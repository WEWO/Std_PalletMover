//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define JSONWRITER_MEMMARK 9
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_JSONWriter"
	Revision           = "1.0"
	GUID               = "{AFBA58E4-6445-46DE-A190-124C5222A6FF}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(444,120)"
	Comment            = "This class provides an interface to create and write a JSON String to a file.&#13;&#10;Creation and manipulation of the JSON String is performed using the embedded _cJSON class which ports the cJSON Project to LASAL.&#13;&#10;&#13;&#10;If the requirement is only to parse, manipulate and serialize JSON in the memory (not reading from / writing to the disk) it is recommended that the _cJSON class be used as standalone.&#13;&#10;&#13;&#10;To use the class:&#13;&#10;1. Get a reference to the Main Element by calling the GetMainElement() method.&#13;&#10;2. Manipulate the Main Element using the _cJSON methods that are available on the _JSONWriter class.&#13;&#10;3. Write the JSON to the disk using the WriteFile() method.">
	<Channels>
		<Server Name="ClassSvr" GUID="{E06B1DEA-1BF6-4C80-AF8B-CC2894E31B2F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Object channel"/>
		<Server Name="LibraryVersion" GUID="{60E58376-8B0B-471E-AFD7-EC926BE512EA}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The embeded cJSON Library version is shown on this Server, the value is read and set once during the _firstscan cycle."/>
		<Server Name="WriteFSM" GUID="{4C2F9022-2DA0-4500-A0E6-AE2C22915CE9}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The status of the print and write procedure is shown on the server:&#13;&#10;1. Once the FSM Reaches the WS_WAIT step, the WriteFile() method can be used to write the JSON Structure defined under the Main Element, this element can be read using the GetMainElement() method.&#13;&#10;2. If the FSM reaches the RS_ERROR step, the Error can be inspected using the GetLastError() method and cleared using the ResetError() method. It is also possible to restart the process from this state using the WriteFile() method."/>
		<Client Name="_cJSON" Required="true" Internal="true"/>
		<Client Name="_FileSys" Required="false" Internal="false" Comment="Object channel to the _FileSys OSInterface, the functions in the OSInterface are used to write files to the disk."/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="OSInterface to SigCLib, this is required for the underlying cJSON functions to function properly."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="VelGer"/>
		<Dokumentation Revision="1.0" Date="2021-01-30" Author="VelGer" Company="Sigmatek" Description="Initial Creation."/>
	</RevDoku>
	<Network Name="_JSONWriter">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_cJSON"
				GUID       = "{759A0F94-3E24-455F-AF8D-03264D380AB3}"
				Class      = "_cJSON"
				Position   = "(150,150)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="LibraryVersion"/>
					<Client Name="SigCLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._cJSON" Destination="_cJSON.ClassSvr"/>
			<Connection Source="this.LibraryVersion" Destination="_cJSON.LibraryVersion" Vertices="(782,270),(750,270),(720,270),(690,270),(660,300),(610,300),"/>
			<Connection Source="_cJSON.SigCLib" Destination="this.SigCLib" Vertices="(150,240),(120,240),(90,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_JSONWriter : CLASS
	TYPE
	  t_e_Errors :  //! <Type Public="true" Comment="This enumaeration contains unique values for each of the known errors that can occur in the class.&#13;&#10;For further problem diagnosing information, see the comment of each entry." Name="t_e_Errors"/>
	  (
	    E_NoError:=0,  //! <Type Comment="No Error Occured." Name="t_e_Errors.E_NoError"/>
	    E_FileNameNotSet:=4294967295,  //! <Type Comment="The Filename was not set ( = NIL) in the WriteFile() call." Name="t_e_Errors.E_FileNameNotSet"/>
	    E_ClassState:=4294967294,  //! <Type Comment="The class was not in the correct state to perform the requested operation." Name="t_e_Errors.E_ClassState"/>
	    E_MemFull:=4294967293,  //! <Type Comment="An internal call to Malloc() failed (returned nil), this means that there is not enough memory available to perform the operation or the memory is so fragmented that the OS cannot deliver a single block big enough to server the request." Name="t_e_Errors.E_MemFull"/>
	    E_AsyncIDUnknown:=4294967292,  //! <Type Comment="Whilst querying the status of an async file operation the OS reported that the async ID was not known." Name="t_e_Errors.E_AsyncIDUnknown"/>
	    E_AsyncResultLost:=4294967291,  //! <Type Comment="Whilst querying the status for the async file operation the OS reported that the operation completed (success or failure could have occured) however as only the last 50 operation results are stored and more than 50 operation have been completed after this one, the result has been lost.&#13;&#10;The Application can be inspected to find out if unnecessary async operations are being performed or the interval at which the operation status is queried (the background time of this class) can be increased." Name="t_e_Errors.E_AsyncResultLost"/>
	    E_AsyncOperationResultUnknown:=4294967290,  //! <Type Comment="Whilst querying the status for an asynchronous file access operation the OS reported that the Async Operation Status was unknown." Name="t_e_Errors.E_AsyncOperationResultUnknown"/>
	    E_FileOperationRequestFailed:=4294967289,  //! <Type Comment="Some File Operation request has failed, the Async Handle returned was negative, if the ErrorCode pointer is set the value returned is written, the errors are defined by the FileSys Class as follows:&#13;&#10;LasalOS File Error Return Codes:&#10;&#13;&#10;0  NO_ERROR&#13;&#10;-1  ERROR_RESERVED &#13;&#10;-2  PARAM_ERROR&#13;&#10;-3  INVALID_FILENAME &#13;&#10;-4  DRIVE_NOT_FOUND&#13;&#10;-5  TOO_MANY_FILES &#13;&#10;-6  NO_MORE_FILES&#13;&#10;-7  WRONG_MEDIA &#13;&#10;-8  INVALID_FILE_SYSTEM&#13;&#10;-9  FILE_NOT_FOUND &#13;&#10;-10  INVALID_FILE_HANDLE&#13;&#10;-11  UNSUPPORTED_DEVICE &#13;&#10;-12  UNSUPPORTED_DRIVER_FUNCTION&#13;&#10;-13  CORRUPTED_PARTITION_TABLE &#13;&#10;-14  TOO_MANY_DRIVES&#13;&#10;-15  INVALID_FILE_POS &#13;&#10;-16  ACCESS_DENIED&#13;&#10;-17  STRING_BUFFER_TOO_SMALL &#13;&#10;-18  GENERAL_FAILURE&#13;&#10;-19  PATH_NOT_FOUND &#13;&#10;-20  FAT_ALLOC_ERROR&#13;&#10;-21  ROOT_DIR_FULL &#13;&#10;-22  DISK_FULL&#13;&#10;-23  TIMEOUT &#13;&#10;-24  BAD_SECTOR&#13;&#10;-25  DATA_ERROR &#13;&#10;-26  MEDIA_CHANGED&#13;&#10;-27  SECTOR_NOT_FOUND &#13;&#10;-28  ADDRESS_MARK_NOT_FOUND&#13;&#10;-29  DRIVE_NOT_READY &#13;&#10;-30  WRITE_PROTECTION&#13;&#10;-31  DMA_OVERRUN &#13;&#10;-32  CRC_ERROR&#13;&#10;-33  DEVICE_RESOURCE_ERROR &#13;&#10;-34  INVALID_SECTOR_SIZE&#13;&#10;-35  OUT_OF_BUFFERS &#13;&#10;-36  FILE_EXISTS&#13;&#10;-37  LONG_FILE_POS &#13;&#10;-38  FILE_TOO_LARGE" Name="t_e_Errors.E_FileOperationRequestFailed"/>
	    E_FileWriteError:=4294967288,  //! <Type Comment="An error occurred whilst writing the file, if the ErrorCode pointer is set the delivered error code is written as delivered by the OS File function:&#13;&#10;0  NO_ERROR&#13;&#10;-1  ERROR_RESERVED &#13;&#10;-2  PARAM_ERROR&#13;&#10;-3  INVALID_FILENAME &#13;&#10;-4  DRIVE_NOT_FOUND&#13;&#10;-5  TOO_MANY_FILES &#13;&#10;-6  NO_MORE_FILES&#13;&#10;-7  WRONG_MEDIA &#13;&#10;-8  INVALID_FILE_SYSTEM&#13;&#10;-9  FILE_NOT_FOUND &#13;&#10;-10  INVALID_FILE_HANDLE&#13;&#10;-11  UNSUPPORTED_DEVICE &#13;&#10;-12  UNSUPPORTED_DRIVER_FUNCTION&#13;&#10;-13  CORRUPTED_PARTITION_TABLE &#13;&#10;-14  TOO_MANY_DRIVES&#13;&#10;-15  INVALID_FILE_POS &#13;&#10;-16  ACCESS_DENIED&#13;&#10;-17  STRING_BUFFER_TOO_SMALL &#13;&#10;-18  GENERAL_FAILURE&#13;&#10;-19  PATH_NOT_FOUND &#13;&#10;-20  FAT_ALLOC_ERROR&#13;&#10;-21  ROOT_DIR_FULL &#13;&#10;-22  DISK_FULL&#13;&#10;-23  TIMEOUT &#13;&#10;-24  BAD_SECTOR&#13;&#10;-25  DATA_ERROR &#13;&#10;-26  MEDIA_CHANGED&#13;&#10;-27  SECTOR_NOT_FOUND &#13;&#10;-28  ADDRESS_MARK_NOT_FOUND&#13;&#10;-29  DRIVE_NOT_READY &#13;&#10;-30  WRITE_PROTECTION&#13;&#10;-31  DMA_OVERRUN &#13;&#10;-32  CRC_ERROR&#13;&#10;-33  DEVICE_RESOURCE_ERROR &#13;&#10;-34  INVALID_SECTOR_SIZE&#13;&#10;-35  OUT_OF_BUFFERS &#13;&#10;-36  FILE_EXISTS&#13;&#10;-37  LONG_FILE_POS &#13;&#10;-38  FILE_TOO_LARGE" Name="t_e_Errors.E_FileWriteError"/>
	    E_JSONError:=4294967287  //! <Type Comment="An error occured whilst printing the JSON String, ensure that the JSON structure is configured correctly." Name="t_e_Errors.E_JSONError"/>
	  )$DINT;
	  t_e_WRITESTEPS :  //! <Type Public="true" Comment="This enum describes the steps in the FSM used to write a file to the disk." Name="t_e_WRITESTEPS"/>
	  (
	    WS_WAIT,  //! <Type Comment="No ongoing operation, to start writing a JSON file, call the _JSONReader::WriteFile() method." Name="t_e_WRITESTEPS.WS_WAIT"/>
	    WS_PRINT_TO_STRING:=1,  //! <Type Comment="In this step the FSM converts the MainElement in the JSON Structure to string using the _cJSON class." Name="t_e_WRITESTEPS.WS_PRINT_TO_STRING"/>
	    WS_OPEN_FILE:=2,  //! <Type Comment="The File Open / Create is requested in this step." Name="t_e_WRITESTEPS.WS_OPEN_FILE"/>
	    WS_WAIT_FOR_OPEN:=3,  //! <Type Comment="The FSM waits in this step until the file has been opened." Name="t_e_WRITESTEPS.WS_WAIT_FOR_OPEN"/>
	    WS_WRITE_FILE:=4,  //! <Type Comment="In this step the Write File Command is issued." Name="t_e_WRITESTEPS.WS_WRITE_FILE"/>
	    WS_WAIT_FOR_WRITE:=5,  //! <Type Comment="The FSM waits in this step until the file has been written." Name="t_e_WRITESTEPS.WS_WAIT_FOR_WRITE"/>
	    WS_CLOSE_FILE:=6,  //! <Type Comment="In this step the Close File Command is issued." Name="t_e_WRITESTEPS.WS_CLOSE_FILE"/>
	    WS_WAIT_FOR_CLOSE:=7,  //! <Type Comment="The FSM waits in this step until the file has been closed." Name="t_e_WRITESTEPS.WS_WAIT_FOR_CLOSE"/>
	    WS_ERROR:=11  //! <Type Comment="The FSM stops in this state when an error occurred, to determine which error occurred the GetLastError() method can be called." Name="t_e_WRITESTEPS.WS_ERROR"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_FileAccessStruct : STRUCT  //! <Type Comment="This structure contains the Class Variables for the File Access Functionalities provided by this class." Name="t_s_FileAccessStruct"/>
	    pFileName : ^CHAR;  //! <Type Comment="Name of the File to be written." Name="t_s_FileAccessStruct.pFileName"/>
	    dAsyncID : DINT;  //! <Type Comment="The AsyncID for the current file access operation is stored on this variable." Name="t_s_FileAccessStruct.dAsyncID"/>
	    dFileHandle : DINT;  //! <Type Comment="File Handle for File Operations" Name="t_s_FileAccessStruct.dFileHandle"/>
	    udFileLength : UDINT;  //! <Type Comment="Length of the File to be written." Name="t_s_FileAccessStruct.udFileLength"/>
	    dBytesWritten : DINT;  //! <Type Comment="Number of bytes written to the disk." Name="t_s_FileAccessStruct.dBytesWritten"/>
	    pFileBuffer : ^CHAR;  //! <Type Comment="Buffer containing the data to be written to file." Name="t_s_FileAccessStruct.pFileBuffer"/>
	    bErrorOccurred : BOOL;  //! <Type Comment="This bool is set if an error occured so that the class can swith to the error state after passing through the File Close Operation." Name="t_s_FileAccessStruct.bErrorOccurred"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	LibraryVersion 	: SvrCh_UDINT;
	WriteFSM 	: SvrCh_t_e_WRITESTEPS_PTofCls__JSONWriter;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
	_FileSys 	: CltChCmd__FileSys;
	_cJSON 	: CltChCmd__cJSON;
  //Variables:
		MainElement 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Main JSON Structure element is stored on this variable." Name="MainElement"/>
		FileAccessStruct 	: t_s_FileAccessStruct;			//! <Variable Comment="This Structure is used to store information for writing to the disk." Name="FileAccessStruct"/>
		LastError 	: t_e_Errors;			//! <Variable Comment="The Last Error that occurred." Name="LastError"/>
		LastErrorCode 	: DINT;			//! <Variable Comment="Extra Information regarding the last error that occurred." Name="LastErrorCode"/>
		bWriteFormatted 	: BOOL;			//! <Variable Comment="Internal bool to track whether the JSON String is to be minified or not." Name="bWriteFormatted"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="File Access and JSON Printing calls are performed in the Background Task of the Class." Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="This method initiates a new write cycle, the MainElement will be serialized to string using the options provided and written to the disk at the location specified." Name="WriteFile"/>
	FUNCTION GLOBAL WriteFile
		VAR_INPUT
			FileName 	: ^CHAR;			//! <Variable Comment="The name of the file to be written to, the expected format is a null-terminated ASCII-string.&#13;&#10;If the file already exists it will be overwritten." Name="WriteFile.FileName"/>
			bFormatted 	: BOOL := false;			//! <Variable Comment="Whether the written file should be formatted or not.&#13;&#10;False - This setting saves space by skipping over unnecessary new line and tab characters when writing the file. (Minified).&#13;&#10;True - This setting writes the file with whitespace, this is easier to read but requires more space on the disk." Name="WriteFile.bFormatted"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="Inidicates whether the operation succeeded or not.&#13;&#10;True = The command was accepted.&#13;&#10;False = The command was rejected." Name="WriteFile.bOK"/>
		END_VAR;
				//! <Function Comment="This function returns the main (first) element in the JSON object tree, this element can then be manipulated and written to disk by calling the WriteFile() method." Name="GetMainElement"/>
	FUNCTION GLOBAL GetMainElement
		VAR_OUTPUT
			MainElement 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Main Element in the JSON Structure, this element will be serialized and written to file when the WriteFile() method is called. The MainElement is automatically created during the Init phase." Name="GetMainElement.MainElement"/>
		END_VAR;
				//! <Function Comment="This function clears and reinitializes the MainElement of the JSON Structure, the function does not need to be called at boot time as the MainElement is already initialized in the _FirstScan cycle of the Init calls." Name="ClearMainElement"/>
	FUNCTION GLOBAL ClearMainElement;
				//! <Function Comment="This method can be used to get the last error that occured in the object. &#13;&#10;This method can only be guaranteed to deliver the correct ErrorCode in the case where the class is only accessed from one thread." Name="GetLastError"/>
	FUNCTION GLOBAL GetLastError
		VAR_INPUT
			pErrorCode 	: ^DINT;			//! <Variable Comment="Pointer to a DINT value where extra information, such as the position in the JSON string where a parse error occurred can be stored.&#13;&#10;The Description of the Error delivered states whether this value is used or not, and the purpose thereof in each case." Name="GetLastError.pErrorCode"/>
		END_VAR
		VAR_OUTPUT
			LastError 	: t_e_Errors;			//! <Variable Comment="The Last Error that occurred." Name="GetLastError.LastError"/>
		END_VAR;
				//! <Function Comment="If an error has occurred the JSON String generated as well as Filename are not cleared to allow the opportunity for the Application / User to inspect the error, this method can be used to reset the error and free the memory.&#13;&#10;If an error has occurred and the print / write process is restarted before clearing the error, the old memory will automatically be cleared." Name="ResetError"/>
	FUNCTION GLOBAL ResetError;
				//! <Function Comment="This method is used to clear all operating memory to allow the class to start fresh." Name="ResetMem"/>
	FUNCTION ResetMem;
				//! <Function Comment="This method returns the version of cJSON as a string." Name="Version"/>
	FUNCTION GLOBAL Version
		VAR_OUTPUT
			retString 	: ^CHAR;			//! <Variable Comment="Version String." Name="Version.retString"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON, the method then returns a cJSON object that can be interrogated." Name="Parse"/>
	FUNCTION GLOBAL Parse
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="Parse.value"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="Parse.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with a data length, the method then returns a cJSON object that can be interrogated." Name="ParseWithLength"/>
	FUNCTION GLOBAL ParseWithLength
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithLength.value"/>
			buffer_length 	: UDINT;			//! <Variable Comment="Length of the string to be parsed." Name="ParseWithLength.buffer_length"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithLength.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with a data length and some options to help verify that the JSON string is terminated OK, the method then returns a cJSON object that can be interrogated and in the case of failure the pointer to where the error was found in the JSON string." Name="ParseWithLengthOpts"/>
	FUNCTION GLOBAL ParseWithLengthOpts
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithLengthOpts.value"/>
			buffer_length 	: UDINT;			//! <Variable Comment="Length of the string to be parsed." Name="ParseWithLengthOpts.buffer_length"/>
			return_parse_end 	: ^pChar;			//! <Variable Comment="If the parsing of the JSON string fails, the pointer to where the error was detected in the String is passed back over this pointer.&#13;&#10;This value matches that which is delivered by the GetErrorPtr() method and can be used to ensure that the class remains thread safe." Name="ParseWithLengthOpts.return_parse_end"/>
			require_null_terminated 	: BOOL;			//! <Variable Comment="When set the parser ensures that the string passed to the method was null terminated." Name="ParseWithLengthOpts.require_null_terminated"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithLengthOpts.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with some options to help verify that the JSON string is terminated OK, the method then returns a cJSON object that can be interrogated and in the case of failure the pointer to where the error was found in the JSON string." Name="ParseWithOpts"/>
	FUNCTION GLOBAL ParseWithOpts
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithOpts.value"/>
			return_parse_end 	: ^pChar;			//! <Variable Comment="If the parsing of the JSON string fails, the pointer to where the error was detected in the String is passed back over this pointer.&#13;&#10;This value matches that which is delivered by the GetErrorPtr() method and can be used to ensure that the class remains thread safe." Name="ParseWithOpts.return_parse_end"/>
			require_null_terminated 	: BOOL;			//! <Variable Comment="When set the parser ensures that the string passed to the method was null terminated." Name="ParseWithOpts.require_null_terminated"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithOpts.json"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON entity (see _cJSON::t_s_cJSON) can be rendered to string." Name="Print"/>
	FUNCTION GLOBAL Print
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="Print.item"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="Print.string"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON entity (see _cJSON::t_s_cJSON) can be rendered to string whilst ignoring any formatting." Name="PrintUnformatted"/>
	FUNCTION GLOBAL PrintUnformatted
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintUnformatted.item"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintUnformatted.string"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON entity can be printed to string using a prebuffered strategy, this means that the required memory is allocated beforehand and reallocation is thereby reduced.&#13;&#10;As opposed to the unbuffered strategy the user must supply an initial guess describing how large the JSON string will be, if this is exceeded whilst rendering a reallocation is made." Name="PrintBuffered"/>
	FUNCTION GLOBAL PrintBuffered
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintBuffered.item"/>
			prebuffer 	: INT;			//! <Variable Comment="Size of the buffer memory to be allocated initially. See the method comment for a further description of this functionality." Name="PrintBuffered.prebuffer"/>
			fmt 	: BOOL;			//! <Variable Comment="Whether the string is to be printed formatted or not:&#13;&#10;True = Formatted&#13;&#10;False = Unformatted" Name="PrintBuffered.fmt"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintBuffered.string"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON entity can be printed to string using a preallocated strategy, this means that the required memory is allocated by the user and the location and size provided to the class.&#13;&#10;If rendering the JSON string requires more memory than was initially allocated by the user the process will fail." Name="PrintPreallocated"/>
	FUNCTION GLOBAL PrintPreallocated
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintPreallocated.item"/>
			buffer 	: ^CHAR;			//! <Variable Comment="A pointer to the memory that the user has allocated for the rendering of the string." Name="PrintPreallocated.buffer"/>
			length 	: INT;			//! <Variable Comment="The length of the memory allocated (how far the class is allowed to write)." Name="PrintPreallocated.length"/>
			format 	: BOOL;			//! <Variable Comment="Whether the string is to be printed formatted or not:&#13;&#10;True = Formatted&#13;&#10;False = Unformatted" Name="PrintPreallocated.format"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintPreallocated.string"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Structure (see _cJSON::t_s_cJSON) can be deleted (freed) from memory, all subentities to this structure are also freed." Name="Delete"/>
	FUNCTION GLOBAL Delete
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Structure to free." Name="Delete.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the number of items in a JSON Array or JSON object." Name="GetArraySize"/>
	FUNCTION GLOBAL GetArraySize
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Array or Object of which the item count is to be returned." Name="GetArraySize.item"/>
		END_VAR
		VAR_OUTPUT
			size 	: INT;			//! <Variable Comment="The number of items found." Name="GetArraySize.size"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the pointer to the item at the position and in the JSON Array provided." Name="GetArrayItem"/>
	FUNCTION GLOBAL GetArrayItem
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Array in which the item is to be found." Name="GetArrayItem.item"/>
			index 	: UDINT;			//! <Variable Comment="The zero-indexed index number from which the item is to be found." Name="GetArrayItem.index"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The pointer to the item found at the index position, if an error occurs, null." Name="GetArrayItem.entry"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the pointer to the item of which the key value matches the string provided, the search is case-insensitive." Name="GetObjectItem"/>
	FUNCTION GLOBAL GetObjectItem
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="GetObjectItem.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-insentive string value matching the key to be found." Name="GetObjectItem.string"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON entity of which the key was found in the object provided, if not found, null." Name="GetObjectItem.entry"/>
		END_VAR;
				//! <Function Comment="This method operates in the same way as the _cJSON::GetObjectItem() method, the only difference is that the key search is case-sensitive.&#13;&#10;The user can find the pointer to the item of which the key value matches the string provided." Name="GetObjectItemCaseSensitive"/>
	FUNCTION GLOBAL GetObjectItemCaseSensitive
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="GetObjectItemCaseSensitive.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-sensitive string value matching the key to be found." Name="GetObjectItemCaseSensitive.string"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON entity of which the key was found in the object provided, if not found, null." Name="GetObjectItemCaseSensitive.entry"/>
		END_VAR;
				//! <Function Comment="Using this method the user can search through a JSON object to determine whether the object contains the key value provided." Name="HasObjectItem"/>
	FUNCTION GLOBAL HasObjectItem
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="HasObjectItem.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-insentive string value matching the key to be found." Name="HasObjectItem.string"/>
		END_VAR
		VAR_OUTPUT
			hasItem 	: BOOL;			//! <Variable Comment="A bool indicating whether the item searched for was found.&#13;&#10;True = The object contains an item with the key value as provided.&#13;&#10;False = The object does not contain an item with the key value provided." Name="HasObjectItem.hasItem"/>
		END_VAR;
				//! <Function Comment="Using this method the user can retrieve the pointer to the position where the last error occurred in any JSON operation.&#13;&#10;Special care must be taken as the method does not ensure thread-safety, if multiple threads can call functions in the class, it cannot be ensured that the retrieved pointer points to the expected error.&#13;&#10;As opposed to using this method the user can use the thread-safe _cJSON::ParseWithOpts() / _cJSON::ParseWithLengthOpts() to receive the pointer to where a parsing error occured immediately." Name="GetErrorPtr"/>
	FUNCTION GLOBAL GetErrorPtr
		VAR_OUTPUT
			errPtr 	: ^CHAR;			//! <Variable Comment="Pointer to where the last error occured." Name="GetErrorPtr.errPtr"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the string value of the supplied JSON entity.&#13;&#10;If the entity is not valid or not of type string, null is returned." Name="GetStringValue"/>
	FUNCTION GLOBAL GetStringValue
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON string entity of which the value is to be returned." Name="GetStringValue.item"/>
		END_VAR
		VAR_OUTPUT
			value 	: ^CHAR;			//! <Variable Comment="If the entity is of type JSON String, a pointer to the string, if not, null." Name="GetStringValue.value"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the number (LREAL) value of the supplied JSON entity." Name="GetNumberValue"/>
	FUNCTION GLOBAL GetNumberValue
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON number entity of which the value is to be returned." Name="GetNumberValue.item"/>
		END_VAR
		VAR_OUTPUT
			value 	: LREAL;			//! <Variable Comment="If the provided item is of type JSON number, the value, if not, NAN." Name="GetNumberValue.value"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is invalid." Name="IsInvalid"/>
	FUNCTION GLOBAL IsInvalid
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsInvalid.item"/>
		END_VAR
		VAR_OUTPUT
			isInvalid 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Invalid:&#13;&#10;True = Invalid&#13;&#10;False = Not Invalid" Name="IsInvalid.isInvalid"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is False." Name="IsFalse"/>
	FUNCTION GLOBAL IsFalse
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsFalse.item"/>
		END_VAR
		VAR_OUTPUT
			isFalse 	: BOOL;			//! <Variable Comment="Value indicating whether the type is False.&#13;&#10;True = Value is False&#13;&#10;False = Value is not False" Name="IsFalse.isFalse"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is True." Name="IsTrue"/>
	FUNCTION GLOBAL IsTrue
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsTrue.item"/>
		END_VAR
		VAR_OUTPUT
			isTrue 	: BOOL;			//! <Variable Comment="Value indicating whether the type is True.&#13;&#10;True = Value is True&#13;&#10;False = Value is not True" Name="IsTrue.isTrue"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type bool." Name="IsBool"/>
	FUNCTION GLOBAL IsBool
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsBool.item"/>
		END_VAR
		VAR_OUTPUT
			isBool 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Bool.&#13;&#10;True = Value is of tye Bool&#13;&#10;False = Value is not of type Bool" Name="IsBool.isBool"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is null." Name="IsNull"/>
	FUNCTION GLOBAL IsNull
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsNull.item"/>
		END_VAR
		VAR_OUTPUT
			isNull 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Null.&#13;&#10;True = Value is Null&#13;&#10;False = Value is not Null" Name="IsNull.isNull"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type number." Name="IsNumber"/>
	FUNCTION GLOBAL IsNumber
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsNumber.item"/>
		END_VAR
		VAR_OUTPUT
			isNumber 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Number.&#13;&#10;True = Value is of type Number&#13;&#10;False = Value is not of type Number" Name="IsNumber.isNumber"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type string." Name="IsString"/>
	FUNCTION GLOBAL IsString
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsString.item"/>
		END_VAR
		VAR_OUTPUT
			isString 	: BOOL;			//! <Variable Comment="Value indicating whether the type is String.&#13;&#10;True = Value is of type String&#13;&#10;False = Value is not of type String" Name="IsString.isString"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is a JSON Array." Name="IsArray"/>
	FUNCTION GLOBAL IsArray
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsArray.item"/>
		END_VAR
		VAR_OUTPUT
			isArray 	: BOOL;			//! <Variable Comment="Value indicating whether the type is JSON Array.&#13;&#10;True = Value is a JSON Array&#13;&#10;False = Value is not a JSON Array" Name="IsArray.isArray"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is a JSON Object." Name="IsObject"/>
	FUNCTION GLOBAL IsObject
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsObject.item"/>
		END_VAR
		VAR_OUTPUT
			isObject 	: BOOL;			//! <Variable Comment="Value indicating whether the type is a JSON Object.&#13;&#10;True = Value is a JSON Object&#13;&#10;False = Value is not a JSON Object" Name="IsObject.isObject"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type Raw." Name="IsRaw"/>
	FUNCTION GLOBAL IsRaw
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsRaw.item"/>
		END_VAR
		VAR_OUTPUT
			isRaw 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Raw.&#13;&#10;True = Value is of type Raw&#13;&#10;False = Value is not of type Raw" Name="IsRaw.isRaw"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Null." Name="CreateNull"/>
	FUNCTION GLOBAL CreateNull
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateNull.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type True." Name="CreateTrue"/>
	FUNCTION GLOBAL CreateTrue
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateTrue.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type False." Name="CreateFalse"/>
	FUNCTION GLOBAL CreateFalse
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateFalse.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Bool." Name="CreateBool"/>
	FUNCTION GLOBAL CreateBool
		VAR_INPUT
			value 	: BOOL;			//! <Variable Comment="The value to be set in the created item." Name="CreateBool.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateBool.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Number." Name="CreateNumber"/>
	FUNCTION GLOBAL CreateNumber
		VAR_INPUT
			value 	: LREAL;			//! <Variable Comment="The value to be set in the created item." Name="CreateNumber.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateNumber.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type String." Name="CreateString"/>
	FUNCTION GLOBAL CreateString
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="The value to be set in the created item." Name="CreateString.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateString.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Raw." Name="CreateRaw"/>
	FUNCTION GLOBAL CreateRaw
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="The value to be set in the created item." Name="CreateRaw.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateRaw.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type JSON Array." Name="CreateArray"/>
	FUNCTION GLOBAL CreateArray
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type JSON Object." Name="CreateObject"/>
	FUNCTION GLOBAL CreateObject
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateObject.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON entity (see _cJSON::t_s_cJSON) of type string where the string is referenced, this means that the string will not be freed when the returned item is deleted (freed)." Name="CreateStringReference"/>
	FUNCTION GLOBAL CreateStringReference
		VAR_INPUT
			string 	: ^CHAR;			//! <Variable Comment="The string to be referenced in the newly created JSON entity." Name="CreateStringReference.string"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="CreateStringReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON Object entity (see _cJSON::t_s_cJSON) containing the child entity provided where the child is referenced, this means that the child will not be freed when the returned item is deleted (freed)." Name="CreateObjectReference"/>
	FUNCTION GLOBAL CreateObjectReference
		VAR_INPUT
			child 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Entity to reference in the newly created JSON Object Entity." Name="CreateObjectReference.child"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Object entity." Name="CreateObjectReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON Array entity (see _cJSON::t_s_cJSON) containing the child entity provided where the child is referenced, this means that the child will not be freed when the returned Array item is deleted (freed)." Name="CreateArrayReference"/>
	FUNCTION GLOBAL CreateArrayReference
		VAR_INPUT
			child 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Entity to reference in the newly created JSON Array Entity." Name="CreateArrayReference.child"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array entity." Name="CreateArrayReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type INT can be created containing the provided values." Name="CreateIntArray"/>
	FUNCTION GLOBAL CreateIntArray
		VAR_INPUT
			numbers 	: ^INT;			//! <Variable Comment="Pointer to the first item in the array of integers to be added in the newly created JSON Array item." Name="CreateIntArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateIntArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateIntArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type REAL can be created containing the provided values." Name="CreateFloatArray"/>
	FUNCTION GLOBAL CreateFloatArray
		VAR_INPUT
			numbers 	: ^REAL;			//! <Variable Comment="Pointer to the first item in the array of REALs to be added in the newly created JSON Array item." Name="CreateFloatArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateFloatArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateFloatArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type LREAL can be created containing the provided values." Name="CreateDoubleArray"/>
	FUNCTION GLOBAL CreateDoubleArray
		VAR_INPUT
			numbers 	: ^LREAL;			//! <Variable Comment="Pointer to the first item in the array of LREALs to be added in the newly created JSON Array item." Name="CreateDoubleArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateDoubleArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateDoubleArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type String can be created containing the provided values." Name="CreateStringArray"/>
	FUNCTION GLOBAL CreateStringArray
		VAR_INPUT
			strings 	: ^CHAR;			//! <Variable Comment="Pointer to the first item in the array of Strings to be added in the newly created JSON Array item." Name="CreateStringArray.strings"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateStringArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateStringArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Array Entity." Name="AddItemToArray"/>
	FUNCTION GLOBAL AddItemToArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Array entity to which the provided entity is to be added." Name="AddItemToArray.arr"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Entity to add to the Array Entity." Name="AddItemToArray.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the procedure succeeded or not.&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Object Entity where the key-string provided is defined in user memory and should be freed when the object is deleted (freed).&#13;&#10;Before using this method compare this to and ensure a good understanding of the purpose of the method: _cJSON::AddItemToObjectCS()" Name="AddItemToObject"/>
	FUNCTION GLOBAL AddItemToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Obect entity to which the item is to be added." Name="AddItemToObject.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be stored in the object.&#13;&#10;This key value string will be freed along with the object when it is deleted (freed) - ensure not to pass a constant (#define) string or a string that is to outlive the JSON object to this value." Name="AddItemToObject.string"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to store in the object." Name="AddItemToObject.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Object Entity where the key-string provided is constant and should not be freed when the object is deleted (freed).&#13;&#10;Before using this method compare this to and ensure a good understanding of the purpose of the method: _cJSON::AddItemToObject()" Name="AddItemToObjectCS"/>
	FUNCTION GLOBAL AddItemToObjectCS
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Obect entity to which the item is to be added." Name="AddItemToObjectCS.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be stored in the object.&#13;&#10;This key value string will not be freed along with the object when it is deleted (freed)." Name="AddItemToObjectCS.string"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to store in the object." Name="AddItemToObjectCS.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToObjectCS.result"/>
		END_VAR;
				//! <Function Comment="This method can be used to append a reference to a JSON Entity to a JSON Array, this can be used when the JSON entity should not be modified by the operation." Name="AddItemReferenceToArray"/>
	FUNCTION GLOBAL AddItemReferenceToArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Array to which the reference to the JSON Entity is to be added." Name="AddItemReferenceToArray.arr"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to reference in the JSON Array." Name="AddItemReferenceToArray.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemReferenceToArray.result"/>
		END_VAR;
				//! <Function Comment="This method can be used to add a reference to a JSON Entity to a JSON Object, this can be used when the JSON entity should not be modified by the operation." Name="AddItemReferenceToObject"/>
	FUNCTION GLOBAL AddItemReferenceToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Object to which the reference to the JSON Entity is to be added." Name="AddItemReferenceToObject.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be referenced in the object." Name="AddItemReferenceToObject.string"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to reference in the JSON Object." Name="AddItemReferenceToObject.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemReferenceToObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from another JSON Entity without deleting (freeing) either." Name="DetachItemViaPointer"/>
	FUNCTION GLOBAL DetachItemViaPointer
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The parent item from which the child item is to be detached." Name="DetachItemViaPointer.parent"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Child item which is to be detached from the parent item provided." Name="DetachItemViaPointer.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Pointer to the detached item." Name="DetachItemViaPointer.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from JSON Array without deleting (freeing) either." Name="DetachItemFromArray"/>
	FUNCTION GLOBAL DetachItemFromArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Array from which the item is to be detached." Name="DetachItemFromArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index of the item in the array to be detached." Name="DetachItemFromArray.index"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Pointer to the detached item." Name="DetachItemFromArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be removed and deleted from a JSON Array Entity." Name="DeleteItemFromArray"/>
	FUNCTION GLOBAL DeleteItemFromArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Array from which the item is to be deleted (freed)." Name="DeleteItemFromArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index of the item to be deleted (removed)." Name="DeleteItemFromArray.index"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from a JSON Object without deleting (freeing) either.&#13;&#10;The key value search is non-case-sensitive." Name="DetachItemFromObject"/>
	FUNCTION GLOBAL DetachItemFromObject
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be detached." Name="DetachItemFromObject.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be detached from the parent provided." Name="DetachItemFromObject.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The detached item if the operation succeeded, else null." Name="DetachItemFromObject.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from a JSON Object without deleting (freeing) either.&#13;&#10;The key value search is case-sensitive." Name="DetachItemFromObjectCaseSensitive"/>
	FUNCTION GLOBAL DetachItemFromObjectCaseSensitive
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be detached." Name="DetachItemFromObjectCaseSensitive.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be detached from the parent provided." Name="DetachItemFromObjectCaseSensitive.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The detached item if the operation succeeded, else null." Name="DetachItemFromObjectCaseSensitive.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be deleted (freed) from a JSON Object.&#13;&#10;The key value search is non-case-sensitive." Name="DeleteItemFromObject"/>
	FUNCTION GLOBAL DeleteItemFromObject
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be deleted." Name="DeleteItemFromObject.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be deleted from the parent provided." Name="DeleteItemFromObject.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be deleted (freed) from a JSON Object.&#13;&#10;The key value search is case-sensitive." Name="DeleteItemFromObjectCaseSensitive"/>
	FUNCTION GLOBAL DeleteItemFromObjectCaseSensitive
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be deleted." Name="DeleteItemFromObjectCaseSensitive.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be deleted from the parent provided." Name="DeleteItemFromObjectCaseSensitive.item"/>
		END_VAR;
				//! <Function Comment="Using this method an item can be inserted in a JSON Array at the index provided, the pre-existing items in the array are shifted to the right." Name="InsertItemInArray"/>
	FUNCTION GLOBAL InsertItemInArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Array in which item is to be added." Name="InsertItemInArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index at which the item should be added in the array." Name="InsertItemInArray.index"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be added to the array." Name="InsertItemInArray.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="InsertItemInArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Entity can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation." Name="ReplaceItemViaPointer"/>
	FUNCTION GLOBAL ReplaceItemViaPointer
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Entity in which the item is to be replaced." Name="ReplaceItemViaPointer.parent"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Item to be replaced and deleted (freed)." Name="ReplaceItemViaPointer.item"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Entity (parent)." Name="ReplaceItemViaPointer.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemViaPointer.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Array can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation." Name="ReplaceItemInArray"/>
	FUNCTION GLOBAL ReplaceItemInArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Array in which item is to be replaced." Name="ReplaceItemInArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index at which the item that is to be replaced can be found." Name="ReplaceItemInArray.index"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Array at the index provided." Name="ReplaceItemInArray.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Object can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation.&#13;&#10;The key value search is non-case-sensitive." Name="ReplaceItemInObject"/>
	FUNCTION GLOBAL ReplaceItemInObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Object in which the item is to be replaced." Name="ReplaceItemInObject.object"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be replaced in the parent provided." Name="ReplaceItemInObject.item"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Object under the key provided." Name="ReplaceItemInObject.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Object can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation.&#13;&#10;The key value search is case-sensitive." Name="ReplaceItemInObjectCaseSensitive"/>
	FUNCTION GLOBAL ReplaceItemInObjectCaseSensitive
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Object in which the item is to be replaced." Name="ReplaceItemInObjectCaseSensitive.object"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be replaced in the parent provided." Name="ReplaceItemInObjectCaseSensitive.item"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Object under the key provided." Name="ReplaceItemInObjectCaseSensitive.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInObjectCaseSensitive.result"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON Entity can be duplicated, optionally the children can be copied as well (deep-copy) or the pointers to the original children left in place (shallow-copy)." Name="Duplicate"/>
	FUNCTION GLOBAL Duplicate
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be duplicated." Name="Duplicate.item"/>
			recurse 	: BOOL;			//! <Variable Comment="Value indicating whether to recurse down the tree or not.&#13;&#10;True = Deep-Copy&#13;&#10;False = Shallow-Copy" Name="Duplicate.recurse"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The duplicated JSON Entity." Name="Duplicate.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method two JSON Entities can be compared, the comparison is performed down the entire tree and case-sensitivity can optionally be checked or ignored." Name="Compare"/>
	FUNCTION GLOBAL Compare
		VAR_INPUT
			compareA 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The first JSON Entity to be used for the comparison." Name="Compare.compareA"/>
			compareB 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The second JSON Entity to be used for the comparison." Name="Compare.compareB"/>
			case_sensitive 	: BOOL;			//! <Variable Comment="Whether case-sensitivity should be considered or not.&#13;&#10;True = Character-Case is considered in the comparison.&#13;&#10;False = Character-Case is ignored in the comparison." Name="Compare.case_sensitive"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Result of the operation.&#13;&#10;True = The provided JSON Entities are identical.&#13;&#10;False = The provided JSON Entities differ." Name="Compare.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON String can be minified, this means that all unnecessary whitespace (&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;) is removed." Name="Minify"/>
	FUNCTION GLOBAL Minify
		VAR_INPUT
			json 	: ^CHAR;			//! <Variable Comment="The JSON String to be minified.&#13;&#10;This value cannot point to a constant memory area, this will cause an access error." Name="Minify.json"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Null to the object specified." Name="AddNullToObject"/>
	FUNCTION GLOBAL AddNullToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddNullToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddNullToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddNullToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type True to the object specified." Name="AddTrueToObject"/>
	FUNCTION GLOBAL AddTrueToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddTrueToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddTrueToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddTrueToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type False to the object specified." Name="AddFalseToObject"/>
	FUNCTION GLOBAL AddFalseToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddFalseToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddFalseToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddFalseToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Bool to the object specified." Name="AddBoolToObject"/>
	FUNCTION GLOBAL AddBoolToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddBoolToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddBoolToObject.name"/>
			boolean 	: BOOL;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddBoolToObject.boolean"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddBoolToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Number to the object specified." Name="AddNumberToObject"/>
	FUNCTION GLOBAL AddNumberToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddNumberToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddNumberToObject.name"/>
			number 	: LREAL;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddNumberToObject.number"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddNumberToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type String to the object specified." Name="AddStringToObject"/>
	FUNCTION GLOBAL AddStringToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddStringToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddStringToObject.name"/>
			string 	: ^CHAR;			//! <Variable Comment="The value to assign to the newly created entity. &#13;&#10;This string will be copied from the dereferenced pointer location provided." Name="AddStringToObject.string"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddStringToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Raw to the object specified." Name="AddRawToObject"/>
	FUNCTION GLOBAL AddRawToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddRawToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddRawToObject.name"/>
			raw 	: ^CHAR;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddRawToObject.raw"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddRawToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type JSON Object to the object specified." Name="AddObjectToObject"/>
	FUNCTION GLOBAL AddObjectToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddObjectToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddObjectToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddObjectToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type JSON Array to the object specified." Name="AddArrayToObject"/>
	FUNCTION GLOBAL AddArrayToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddArrayToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddArrayToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddArrayToObject.item"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the number value of an Entity (see _cJSON::t_s_cJSON) to the value provided." Name="SetNumber"/>
	FUNCTION GLOBAL SetNumber
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the value is to be modified." Name="SetNumber.object"/>
			number 	: LREAL;			//! <Variable Comment="The value to set the entity value to." Name="SetNumber.number"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: LREAL;			//! <Variable Comment="The value that the entity was set to." Name="SetNumber.retVal"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the String value of an Entity (see _cJSON::t_s_cJSON) to the string provided." Name="SetValuestring"/>
	FUNCTION GLOBAL SetValuestring
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the string value is to be modified." Name="SetValuestring.object"/>
			valueString 	: ^CHAR;			//! <Variable Comment="The String value to set the entity to, the string will be copied from the dereferenced pointer location provided here." Name="SetValuestring.valueString"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: ^CHAR;			//! <Variable Comment="Pointer to the copied string that was added to the entity." Name="SetValuestring.retVal"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LibraryVersion::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _cJSON
#pragma usingLtd _FileSys
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _JSONWriter::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__JSONWRITER
1$UINT, 0$UINT, (SIZEOF(::_JSONWriter))$UINT, 
3$UINT, 3$UINT, 0$UINT, 
TO_UDINT(1888817686), "_JSONWriter", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_JSONWriter.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_JSONWriter.LibraryVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(115726070), "LibraryVersion", 
(::_JSONWriter.WriteFSM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(711558464), "WriteFSM", 
//Clients:
(::_JSONWriter.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::_JSONWriter._FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(545279513), "_FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_JSONWriter._cJSON.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(798961397), "_cJSON", TO_UDINT(798961397), "_cJSON", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__JSONWriter 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__JSONWriter] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _JSONWriter::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__JSONWriter, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LibraryVersion.pMeth			:= StoreMethod( #LibraryVersion::Read(), #M_NO_F() );
	IF LibraryVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION GLOBAL _JSONWriter::ResetError
    
  if WriteFSM = WS_ERROR then
    
    ResetMem();
    ClearMainElement();
    WriteFSM := WS_WAIT;   
    
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _JSONWriter::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	dAsyncState, dTemp : DINT;
  END_VAR

	state := READY;
  
  //=================================================================
  // File Writing FSM
  //=================================================================
  case WriteFSM of
        
    //-----------------------------------------------
    // Wait for an operation to start.
    //-----------------------------------------------
  	t_e_WRITESTEPS::WS_WAIT:
      
    //-----------------------------------------------
    // Print the JSON Structure to String.
    //-----------------------------------------------
  	t_e_WRITESTEPS::WS_PRINT_TO_STRING:
      
      if bWriteFormatted then
        
        // The file is to be written with formatting
        FileAccessStruct.pFileBuffer := _cJSON.Print(item := MainElement);
        
      else
      
        // The file is to be written without formatting.
        FileAccessStruct.pFileBuffer := _cJSON.PrintUnformatted(item := MainElement);
      
      end_if;
      
      if FileAccessStruct.pFileBuffer <> NIL then
        
        // The string was successfully printed.
        FileAccessStruct.udFileLength := SigCLib.StrLen(str := FileAccessStruct.pFileBuffer);
        WriteFSM := WS_OPEN_FILE;
        
      else
      
        // Printing the file failed.
        LastError := E_JSONError;
        WriteFSM := WS_ERROR;
      
      end_if;

      
    //-----------------------------------------------
    // Request the specified file to be opened.
    //-----------------------------------------------  
    t_e_WRITESTEPS::WS_OPEN_FILE:
          
      FileAccessStruct.dAsyncID := _FileSys.FileOpen_A(Async       :=  1, 
                                                      filename    :=  FileAccessStruct.pFileName, 
                                                      attributes  :=  ATT_CREATE_ALWAYS);      
      
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        WriteFSM := WS_ERROR;
      else
        WriteFSM := WS_WAIT_FOR_OPEN;
      end_if;

    //-----------------------------------------------
    // Wait for the File Open Operation to complete.
    //-----------------------------------------------  
    t_e_WRITESTEPS::WS_WAIT_FOR_OPEN:
          
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                            Erg :=  #FileAccessStruct.dFileHandle);
      
      if dAsyncState = 0 then
        // The Async Operation has completed
        WriteFSM := WS_WRITE_FILE;
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        WriteFSM := WS_ERROR;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        WriteFSM := WS_ERROR;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        WriteFSM := WS_ERROR;
      
      end_if;
    
    //-----------------------------------------------
    // Write the string to the file.
    //-----------------------------------------------  
    t_e_WRITESTEPS::WS_WRITE_FILE:
          
      FileAccessStruct.dAsyncID := _FileSys.FileWrite_AV1( Async  := 1, 
                                                          handle := FileAccessStruct.dFileHandle, 
                                                          buffer := FileAccessStruct.pFileBuffer, 
                                                          length := FileAccessStruct.udFileLength); 
      
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        WriteFSM := WS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      else
        WriteFSM := WS_WAIT_FOR_WRITE;
      end_if;
    
    //-----------------------------------------------
    // Wait for the File Write Operation to complete.
    //-----------------------------------------------  
    t_e_WRITESTEPS::WS_WAIT_FOR_WRITE:
          
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                             Erg :=  #FileAccessStruct.dBytesWritten$DINT);
      
      if dAsyncState = 0 then
        // The Async Operation has completed
        if FileAccessStruct.dBytesWritten < 0 then
          FileAccessStruct.bErrorOccurred;
          LastError := E_FileWriteError;
          LastErrorCode := FileAccessStruct.dBytesWritten;
        end_if;
        
        WriteFSM := WS_CLOSE_FILE;
        
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        WriteFSM := WS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        WriteFSM := WS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        WriteFSM := WS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      
      end_if;  
    
    //-----------------------------------------------
    // Request the File to be closed.
    //----------------------------------------------- 
    t_e_WRITESTEPS::WS_CLOSE_FILE:
    
      FileAccessStruct.dAsyncID := _FileSys.FileClose_A(Async   :=  1, 
                                                        handle  :=  FileAccessStruct.dFileHandle);
      
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        WriteFSM := WS_ERROR;
      else
        WriteFSM := WS_WAIT_FOR_CLOSE;
      end_if;    
    
    //-----------------------------------------------
    // Wait for the File Close to complete.
    //----------------------------------------------- 
    t_e_WRITESTEPS::WS_WAIT_FOR_CLOSE:
        
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                            Erg :=  #dTemp);
      
      if dAsyncState = 0 then      
        // The Async Operation has completed, the return value does not matter
        if FileAccessStruct.bErrorOccurred then
          WriteFSM := WS_ERROR;
        else
          WriteFSM := WS_WAIT;
          ResetMem();
        end_if;        
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        WriteFSM := WS_ERROR;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        WriteFSM := WS_ERROR;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        WriteFSM := WS_ERROR;
      
      end_if; 
      
    //-----------------------------------------------
    // Wait for reset / new operation.
    //----------------------------------------------- 
    t_e_WRITESTEPS::WS_ERROR:   
      
      
  end_case;


END_FUNCTION


FUNCTION GLOBAL _JSONWriter::WriteFile
	VAR_INPUT
		FileName 	: ^CHAR;
		bFormatted 	: BOOL;(* := false *)
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udNameLen   : UDINT;
  END_VAR
  
  bOK := FALSE;
  
  // Test input
  if FileName = NIL then
    LastError := E_FileNameNotSet;
    return;
  end_if;
  
  if (WriteFSM >= WS_PRINT_TO_STRING 
     & WriteFSM <= WS_WAIT_FOR_CLOSE) then
    LastError := E_ClassState;
    return;
  end_if;
  
  // This clears all reserved memory before the operation starts
  ResetMem();
  
  bWriteFormatted := bFormatted;
  
  // Store the FileName
  udNameLen := SigCLib.StrLen(str := FileName);
  FileAccessStruct.pFileName$^VOID := sigclib_mallocV1( size := udNameLen + sizeof(CHAR), 
                                                        id   := JSONWRITER_MEMMARK);
  
  if FileAccessStruct.pFileName <> NIL then
    SigCLib.StrNCpy(dst0  :=  FileAccessStruct.pFileName, 
                    src0  :=  FileName, 
                    count :=  udNameLen);   
    (FileAccessStruct.pFileName$UDINT + udNameLen)$^CHAR^ := 0x00;
  else    
    LastError := E_MemFull;      
  end_if;
  
  // The Write Operation can be started.
  WriteFSM := WS_PRINT_TO_STRING;
  
  bOK := TRUE;

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetMainElement
	VAR_OUTPUT
		MainElement 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  MainElement := _JSONWriter::MainElement;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _JSONWriter::LibraryVersion::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	LibraryVersion := _cJSON.LibraryVersion.Read();
	output := LibraryVersion;

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetLastError
	VAR_INPUT
		pErrorCode 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		LastError 	: t_e_Errors;
	END_VAR
  
  if pErrorCode then
    pErrorCode^ := LastErrorCode;
  end_if;
  
  LastError := _JSONWriter::LastError;
  
END_FUNCTION


FUNCTION _JSONWriter::ResetMem
  
  if FileAccessStruct.pFileName <> NIL then
    sigclib_freeV1(ptr := FileAccessStruct.pFileName);    
  end_if;
  
  if FileAccessStruct.pFileBuffer <> NIL then
    sigclib_freeV1(ptr := FileAccessStruct.pFileBuffer);      
  end_if;
  
  bWriteFormatted                 := FALSE;
  FileAccessStruct.pFileName      := NIL;
  FileAccessStruct.pFileBuffer    := NIL;
  FileAccessStruct.dAsyncID       := 0;
  FileAccessStruct.dFileHandle    := 0;
  FileAccessStruct.udFileLength   := 0;
  FileAccessStruct.bErrorOccurred := FALSE;
  FileAccessStruct.dBytesWritten  := 0;  
  LastError                       := E_NoError;
  LastErrorCode                   := 0;
    
END_FUNCTION

// =============================================================================
// ============================== _cJSON Methods ===============================
// =============================================================================

FUNCTION GLOBAL _JSONWriter::Version
	VAR_OUTPUT
		retString 	: ^CHAR;
	END_VAR
  
  retString := _cJSON.Version();
  
END_FUNCTION

FUNCTION GLOBAL _JSONWriter::Parse
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  json := _cJSON.Parse(value := value);

END_FUNCTION

FUNCTION GLOBAL _JSONWriter::ParseWithOpts
	VAR_INPUT
		value 	: ^CHAR;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: BOOL;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR

  json := _cJSON.ParseWithOpts( value                   :=  value, 
                                return_parse_end        :=  return_parse_end, 
                                require_null_terminated :=  require_null_terminated);

END_FUNCTION

FUNCTION GLOBAL _JSONWriter::ParseWithLength
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR

  json := _cJSON.ParseWithLength(value         :=  value, 
                                buffer_length :=  buffer_length);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::ParseWithLengthOpts
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: BOOL;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  json := _cJSON.ParseWithLengthOpts(value                   :=  value, 
                                    buffer_length           :=  buffer_length, 
                                    return_parse_end        :=  return_parse_end, 
                                    require_null_terminated :=  require_null_terminated);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::Print
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.Print(item := item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::PrintUnformatted
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.PrintUnformatted(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::PrintBuffered
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		prebuffer 	: INT;
		fmt 	: BOOL;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.PrintBuffered(item      :=  item, 
                                prebuffer :=  prebuffer, 
                                fmt       :=  fmt);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::PrintPreallocated
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		buffer 	: ^CHAR;
		length 	: INT;
		format 	: BOOL;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.PrintPreallocated(item    :=  item, 
                                    buffer  :=  buffer, 
                                    length  :=  length, 
                                    format  :=  format);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::Delete
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  _cJSON.Delete(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetArraySize
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		size 	: INT;
	END_VAR

  size := _cJSON.GetArraySize(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetArrayItem
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  entry := _cJSON.GetArrayItem(item  :=  item, 
                              index :=  index);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetObjectItem
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  entry := _cJSON.GetObjectItem( object  :=  object, 
                                string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetObjectItemCaseSensitive
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  entry := _cJSON.GetObjectItemCaseSensitive(object  :=  object, 
                                            string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::HasObjectItem
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		hasItem 	: BOOL;
	END_VAR
  
  hasItem := _cJSON.HasObjectItem( object  :=  object, 
                                  string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetErrorPtr
	VAR_OUTPUT
		errPtr 	: ^CHAR;
	END_VAR
  
  errPtr := _cJSON.GetErrorPtr();
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetStringValue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: ^CHAR;
	END_VAR
  
  value := _cJSON.GetStringValue(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::GetNumberValue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: LREAL;
	END_VAR
  
  value := _cJSON.GetNumberValue(item := item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsInvalid
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isInvalid 	: BOOL;
	END_VAR
  
  isInvalid := _cJSON.IsInvalid(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsFalse
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isFalse 	: BOOL;
	END_VAR
  
  isFalse := _cJSON.IsFalse(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsTrue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isTrue 	: BOOL;
	END_VAR
  
  isTrue := _cJSON.IsTrue(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsBool
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isBool 	: BOOL;
	END_VAR
  
  isBool := _cJSON.IsBool(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsNull
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNull 	: BOOL;
	END_VAR
  
  isNull := _cJSON.IsNull(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsNumber
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNumber 	: BOOL;
	END_VAR
 
  isNumber := _cJSON.IsNumber(item := item);  
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsString
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isString 	: BOOL;
	END_VAR
  
  isString := _cJSON.IsString(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsArray
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isArray 	: BOOL;
	END_VAR
  
  isArray := _cJSON.IsArray(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsObject
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isObject 	: BOOL;
	END_VAR
  
  isObject := _cJSON.IsObject(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::IsRaw
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isRaw 	: BOOL;
	END_VAR
  
  isRaw := _cJSON.IsRaw(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateNull
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateNull();
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateTrue
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateTrue();

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateFalse
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateFalse();

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateBool
	VAR_INPUT
		value 	: BOOL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateBool(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateNumber
	VAR_INPUT
		value 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateNumber(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateString
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateString(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateRaw
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateRaw(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateArray
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateArray();

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateObject
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateObject();

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateStringReference
	VAR_INPUT
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateStringReference(string := string);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateObjectReference
	VAR_INPUT
		child 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateObjectReference(child := child);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateArrayReference
	VAR_INPUT
		child 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateArrayReference(child := child);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateIntArray
	VAR_INPUT
		numbers 	: ^INT;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateIntArray( numbers := numbers, 
                                count   := count);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateFloatArray
	VAR_INPUT
		numbers 	: ^REAL;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateFloatArray( numbers :=  numbers, 
                                  count   :=  count);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateDoubleArray
	VAR_INPUT
		numbers 	: ^LREAL;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateDoubleArray(numbers :=  numbers, 
                                  count   :=  count);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::CreateStringArray
	VAR_INPUT
		strings 	: ^CHAR;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateStringArray(strings :=  strings, 
                                   count   :=  count);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddItemToArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemToArray( arr   :=  arr, 
                                  item  :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddItemToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemToObject(object  :=  object,   
                                  string  :=  string, 
                                  item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddItemToObjectCS
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemToObjectCS(object  :=  object, 
                                    string  :=  string, 
                                    item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddItemReferenceToArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemReferenceToArray(arr   :=  arr, 
                                          item  :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddItemReferenceToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemReferenceToObject( object  :=  object, 
                                            string  :=  string, 
                                            item    :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DetachItemViaPointer
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  retItem := _cJSON.DetachItemViaPointer(parent  :=  parent, 
                                        item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DetachItemFromArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.DetachItemFromArray(arr   :=  arr, 
                                    index :=  index);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DeleteItemFromArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
	END_VAR
  
  _cJSON.DeleteItemFromArray(arr   :=  arr, 
                            index :=  index);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DetachItemFromObject
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  retItem := _cJSON.DetachItemFromObject(parent  :=  parent, 
                                        item    :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DetachItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  retItem := _cJSON.DetachItemFromObjectCaseSensitive(parent  :=  parent, 
                                                     item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DeleteItemFromObject
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
  
  _cJSON.DeleteItemFromObject(parent  :=  parent, 
                             item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::DeleteItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
  
  _cJSON.DeleteItemFromObjectCaseSensitive(parent  :=  parent, 
                                          item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::InsertItemInArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.InsertItemInArray(arr     :=  arr, 
                                    index   :=  index, 
                                    newItem :=  newItem);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::ReplaceItemViaPointer
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemViaPointer(parent  :=  parent, 
                                        item    :=  item, 
                                        newItem :=  newItem);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::ReplaceItemInArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemInArray( arr     :=  arr, 
                                      index   :=  index, 
                                      newItem :=  newItem);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::ReplaceItemInObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemInObject(object  :=  object, 
                                      item    :=  item, 
                                      newItem :=  newItem);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::ReplaceItemInObjectCaseSensitive
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemInObjectCaseSensitive( object  :=  object, 
                                                    item    :=  item, 
                                                    newItem :=  newItem);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::Duplicate
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		recurse 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
    
  retItem := _cJSON.Duplicate( item    :=  item, 
                              recurse :=  recurse);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::Compare
	VAR_INPUT
		compareA 	: ^_cJSON::t_s_cJSON;
		compareB 	: ^_cJSON::t_s_cJSON;
		case_sensitive 	: BOOL;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.Compare(compareA        :=  compareA, 
                          compareB        :=  compareB, 
                          case_sensitive  :=  case_sensitive);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::Minify
	VAR_INPUT
		json 	: ^CHAR;
	END_VAR
  
  _cJSON.Minify(json := json);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddNullToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddNullToObject(object  :=  object, 
                                name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddTrueToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddTrueToObject(object  :=  object, 
                                name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddFalseToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddFalseToObject( object  :=  object, 
                                  name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddBoolToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		boolean 	: BOOL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddBoolToObject(object  :=  object, 
                                name    :=  name, 
                                boolean :=  boolean);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddNumberToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.AddNumberToObject(object  :=  object, 
                                  name    :=  name, 
                                  number  :=  number);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddStringToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddStringToObject(object  :=  object, 
                                  name    :=  name, 
                                  string  :=  string);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddRawToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		raw 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddRawToObject( object  :=  object, 
                                name    :=  name, 
                                raw     :=  raw);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddObjectToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddObjectToObject(object  :=  object, 
                                  name    :=  name);
  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::AddArrayToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddArrayToObject( object  :=  object, 
                                  name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::SetNumber
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		retVal 	: LREAL;
	END_VAR
  
  retVal := _cJSON.SetNumber(object  :=  object, 
                             number  :=  number);

END_FUNCTION


FUNCTION GLOBAL _JSONWriter::SetValuestring
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		valueString 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retVal 	: ^CHAR;
	END_VAR
  
  retVal := _cJSON.SetValuestring( object      :=  object, 
                                  valueString :=  valueString);

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _JSONWriter::Init
  
  if _FirstScan then
    
    ResetMem();
    ClearMainElement();
    
  end_if;

  
END_FUNCTION


FUNCTION GLOBAL _JSONWriter::ClearMainElement
   
  if MainElement <> NIL then
    _cJSON.Delete(item := MainElement);
  end_if;
  MainElement := _cJSON.CreateObject();
  
END_FUNCTION
