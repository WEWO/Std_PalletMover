//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define HMI_ICON_CHARGING 12
#define LOWBATTERYCOMPARE 20
#define BATTERYCHARGINGDELAY 5 SEC
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "HAL_BMS_MasterVolt"
	Revision           = "0.0"
	GUID               = "{C990C64B-0225-4E8B-97CF-7B3CD518EA58}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(840,900)">
	<Channels>
		<Server Name="BatteryAlarms" GUID="{DC5AF2E7-D72E-41CC-9FF8-B7BA836C4B57}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="BatteryCharging" GUID="{B1792309-B36A-45BE-935B-735658489F3D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="BatteryCurrent" GUID="{BFF08EF1-8F18-4061-8B29-C2B127D38067}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="BatteryTemperature" GUID="{8FFA9D8D-FC34-42A8-8A2B-E915DCFB60A2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="BatteryVirtualStateOfCharge" GUID="{9ACE4856-0DE9-42B4-99C2-5FAD8716E361}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="BatteryVoltage" GUID="{F3C33F0E-AB93-4FC7-8312-D8F99EBDE4B6}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="EnergyDraw" GUID="{CA7E031C-F7B9-448C-9904-05B1E621EB2B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="HMIAdditionalIcon" GUID="{52C15628-4C15-44CC-9AB1-4C8F7EEB8EC6}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="HMIIconState" GUID="{86E33F69-D002-4794-A078-6D2944ACF3F3}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="LowBatteryLimit" GUID="{B36C7ED9-6965-4CD7-9B9F-DFB15099E0FE}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File"/>
		<Server Name="NMT" GUID="{7EF7D335-C84B-4AA9-A011-635BA2A713C4}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="StateOfCharge" GUID="{33838AF3-8BEF-4740-A10E-84564B8CFC03}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ToObject" GUID="{294A2006-5F73-4088-9EC4-E1CD95681A4A}" Class="PeripheralsBase" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="ToObject:&#13;&#10;Object channel server.&#13;&#10;Channel to reach the methodes of this object.&#13;&#10;&#13;&#10;In case this object should be Accessible by a pointer&#13;&#10;the variable ToObject is used to handover the address of this object.&#13;&#10;&#13;&#10;This server is never used for anything else!!!&#13;&#10;&#13;&#10;&#13;&#10;"/>
		<Client Name="cNode" Required="true" Internal="false"/>
		<Client Name="Driver" Required="false" Internal="false"/>
		<Client Name="ObjCanOpenBase" Required="true" Internal="true"/>
		<Client Name="ObjPeripheralsBase" Required="true" Internal="true"/>
		<Client Name="op_LogData" Required="false" Internal="false" Comment="Output for logging data to SF_Logger"/>
		<Client Name="p_NextObject" Required="false" Internal="false" Comment="Pointer to next object in linked list"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="10"/>
		</Servers>
	</Separators>
	<Network Name="HAL_BMS_MasterVolt">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{7A69FD96-722C-4ACA-AA19-8ACD17AC21A1}"
				Class      = "HAL_BMS_Base"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "ObjCanOpenBase"
				GUID       = "{E1FD22A8-7DEB-467E-921B-7DE89AFEAD99}"
				Class      = "CanOpenWewoBase"
				Position   = "(270,420)"
				Visualized = "false"
				CyclicTime = "1 ms">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="cNode"/>
					<Client Name="ConfigData"/>
					<Client Name="Driver"/>
				</Channels>
			</Object>
			<Object
				Name       = "ObjPeripheralsBase"
				GUID       = "{4F8789F5-94D7-47D9-B568-23225BA8AFB7}"
				Class      = "PeripheralsBase"
				Position   = "(240,840)"
				Visualized = "false">
				<Channels>
					<Server Name="ToObject"/>
					<Client Name="op_LogData"/>
					<Client Name="p_NextObject"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(998,210),(518,210),"/>
			<Connection Source="this.ObjCanOpenBase" Destination="ObjCanOpenBase.Server0"/>
			<Connection Source="ObjCanOpenBase.Driver" Destination="this.Driver" Vertices="(270,510),(38,270),"/>
			<Connection Source="ObjCanOpenBase.cNode" Destination="this.cNode" Vertices="(270,570),(38,330),"/>
			<Connection Source="this.ObjPeripheralsBase" Destination="ObjPeripheralsBase.ToObject"/>
			<Connection Source="ObjPeripheralsBase.p_NextObject" Destination="this.p_NextObject" Vertices="(240,990),(38,390),"/>
			<Connection Source="ObjPeripheralsBase.op_LogData" Destination="this.op_LogData" Vertices="(240,930),(30,540),(38,450),"/>
			<Connection Source="this.ToObject" Destination="ObjPeripheralsBase.ToObject" Vertices="(998,990),(826,930),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HAL_BMS_Base

HAL_BMS_MasterVolt : CLASS
: HAL_BMS_Base
	TYPE
	  tHMIAdditionalIconBMS :  //! <Type Public="true" Name="tHMIAdditionalIconBMS"/>
	  (
	    HAI_None,
	    HAI_Attention,
	    HAI_Charging
	  )$UDINT;
	END_TYPE
  //Servers:
	NMT 	: SvrCh_CanDeviceState_PTofCls_CanOpenBase;
	StateOfCharge 	: SvrCh_DINT;
	EnergyDraw 	: SvrCh_DINT;
	BatteryVoltage 	: SvrCh_DINT;
	BatteryCurrent 	: SvrCh_DINT;
	BatteryTemperature 	: SvrCh_DINT;
	BatteryAlarms 	: SvrCh_tBMSAlarms_PTofCls_HAL_BMS_Base;
	HMIIconState 	: SvrCh_DINT;
	HMIAdditionalIcon 	: SvrCh_tHMIAdditionalIconBMS_PTofCls_HAL_BMS_MasterVolt;
	BatteryCharging 	: SvrCh_DINT;
	LowBatteryLimit 	: SvrCh_DINT;
	BatteryVirtualStateOfCharge 	: SvrCh_DINT;
	ToObject 	: SvrChCmd_pVoid;
  //Clients:
	Driver 	: CltChCmd_CanDriverBase;
	cNode 	: CltCh_DINT;
	p_NextObject 	: CltChCmd_LinkedObjectBase;
	op_LogData 	: CltCh_gpt_LogData;
	ObjPeripheralsBase 	: CltChCmd_PeripheralsBase;
	ObjCanOpenBase 	: CltChCmd_CanOpenWewoBase;
  //Variables:
		_pdoIn1 	: PDOStr;
		_pdoIn2 	: PDOStr;
		_pdoIn3 	: PDOStr;
		_pdoIn4 	: PDOStr;
		_pdo1rxTime 	: UDINT;
		_pdo2rxTime 	: UDINT;
		_pdo3rxTime 	: UDINT;
		_pdo4rxTime 	: UDINT;
		_pdo1RxInterval 	: UDINT;
		_pdo2RxInterval 	: UDINT;
		_pdo3RxInterval 	: UDINT;
		_startUpDelayPassed 	: BOOL;
		_initCounter 	: DINT;
		_batteryChargingTimer 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetBMSData
		VAR_OUTPUT
			returnValue 	: tBMSData;
		END_VAR;
	
	FUNCTION _receiveData;
	
	FUNCTION _handleAlarms;
	
	FUNCTION _handleAlarmResets;
	
	FUNCTION VIRTUAL GLOBAL ToObject::Read
		VAR_OUTPUT
			output (EAX) 	: pVoid;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using CanOpenWewoBase
#pragma using PeripheralsBase
#pragma usingLtd CanDriverBase
#pragma usingLtd LinkedObjectBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HAL_BMS_MasterVolt::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_HAL_BMS_MASTERVOLT
0$UINT, 0$UINT, (SIZEOF(::HAL_BMS_MasterVolt))$UINT, 
13$UINT, 6$UINT, 0$UINT, 
TO_UDINT(2936894554), "HAL_BMS_MasterVolt", //Class
TO_UDINT(3662255972), "HAL_BMS_Base", 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HAL_BMS_MasterVolt.NMT.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2895437181), "NMT", 
(::HAL_BMS_MasterVolt.StateOfCharge.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1950517256), "StateOfCharge", 
(::HAL_BMS_MasterVolt.EnergyDraw.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(402870489), "EnergyDraw", 
(::HAL_BMS_MasterVolt.BatteryVoltage.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(662848058), "BatteryVoltage", 
(::HAL_BMS_MasterVolt.BatteryCurrent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4142503414), "BatteryCurrent", 
(::HAL_BMS_MasterVolt.BatteryTemperature.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1341853176), "BatteryTemperature", 
(::HAL_BMS_MasterVolt.BatteryAlarms.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2526189567), "BatteryAlarms", 
(::HAL_BMS_MasterVolt.HMIIconState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4062086763), "HMIIconState", 
(::HAL_BMS_MasterVolt.HMIAdditionalIcon.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3689119680), "HMIAdditionalIcon", 
(::HAL_BMS_MasterVolt.BatteryCharging.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4071763180), "BatteryCharging", 
(::HAL_BMS_MasterVolt.LowBatteryLimit.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3749759677), "LowBatteryLimit", 
(::HAL_BMS_MasterVolt.BatteryVirtualStateOfCharge.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(64529072), "BatteryVirtualStateOfCharge", 
(::HAL_BMS_MasterVolt.ToObject.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4019907084), "ToObject", 
//Clients:
(::HAL_BMS_MasterVolt.Driver.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(3785276255), "Driver", TO_UDINT(1472885325), "CanDriverBase", 0$UINT, 7$UINT, 
(::HAL_BMS_MasterVolt.cNode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000110$UINT, TO_UDINT(1272909673), "cNode", 
(::HAL_BMS_MasterVolt.p_NextObject.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(5254340), "p_NextObject", TO_UDINT(1708657366), "LinkedObjectBase", 0$UINT, 10$UINT, 
(::HAL_BMS_MasterVolt.op_LogData.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(1597732449), "op_LogData", 
(::HAL_BMS_MasterVolt.ObjPeripheralsBase.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3005494750), "ObjPeripheralsBase", TO_UDINT(480875673), "PeripheralsBase", 0$UINT, 0$UINT, 
(::HAL_BMS_MasterVolt.ObjCanOpenBase.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1439302300), "ObjCanOpenBase", TO_UDINT(2527060916), "CanOpenWewoBase", 0$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_HAL_BMS_MasterVolt 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HAL_BMS_MasterVolt] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HAL_BMS_MasterVolt::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HAL_BMS_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HAL_BMS_Base::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HAL_BMS_Base::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_HAL_BMS_MasterVolt;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetBMSData();

#pragma warning (default : 74)
	HAL_BMS_Base::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HAL_BMS_Base::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StateOfCharge.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF StateOfCharge.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BatteryVoltage.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF BatteryVoltage.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HMIIconState.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF HMIIconState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HMIAdditionalIcon.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF HMIAdditionalIcon.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LowBatteryLimit.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF LowBatteryLimit.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ToObject.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #ToObject::Read();
	ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL HAL_BMS_MasterVolt::Init
  _initCounter += 1;

 END_FUNCTION



FUNCTION VIRTUAL GLOBAL HAL_BMS_MasterVolt::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR

  _receiveData();

  if ops.tAbsolute > TIMEOUTDELAY then
    _startUpDelayPassed := TRUE;
  end_if;

  if  (_startUpDelayPassed = TRUE) & ( (ops.tAbsolute - _pdo1rxTime) > COMM_TIMEOUT | (ops.tAbsolute - _pdo2rxTime) > COMM_TIMEOUT | (ops.tAbsolute - _pdo3rxTime) > COMM_TIMEOUT ) then
    // Activate timeout alarm if the cyclic messages aren't received or sent in time.
    BatteryAlarms.ba_NoCommunication := TRUE;
  else
    BatteryAlarms.ba_NoCommunication := FALSE;
  end_if;
  

  BatteryVirtualStateOfCharge := 100*(StateOfCharge - LowBatteryLimit)/(100 - LowBatteryLimit);
  HMIIconState := BatteryVirtualStateOfCharge/20;
  BatteryCharging := (BatteryCurrent > 0);
  
  if BatteryCharging = TRUE then
    HMIIconState := HMI_ICON_CHARGING;
  end_if;


END_FUNCTION


FUNCTION VIRTUAL GLOBAL HAL_BMS_MasterVolt::GetBMSData
	VAR_OUTPUT
		returnValue 	: tBMSData;
	END_VAR
  
  returnValue.bd_StateOfCharge := to_uint(StateOfCharge);
  // returnValue.bd_TimeToGo := 
  returnValue.bd_EnergyDraw := to_int(EnergyDraw);
  returnValue.bd_BatteryVoltage := to_uint(BatteryVoltage);
  returnValue.bd_BatteryCurrent := to_int(BatteryCurrent);
  returnValue.bd_BatteryTemperature := to_int(BatteryTemperature);
  returnValue.bd_BatteryCharging := to_bool(BatteryCharging);
  returnValue.bd_BatteryLowIndication := (BatteryVirtualStateOfCharge <= LOWBATTERYCOMPARE);
  returnValue.bd_Alarm := BatteryAlarms;
  
  
END_FUNCTION


FUNCTION HAL_BMS_MasterVolt::_receiveData
  VAR
  	tmpDataReceived : BOOL;
    tmpBMSData      : tBMSData;  
  END_VAR
  
  tmpDataReceived := FALSE;

  //----------------------------------------------------
  // Read out PDO_RX1 with identifier 0x180 + NodeID
  //----------------------------------------------------
  if ObjCanOpenBase.DecoPDO(PdoId:= cPdoRx1, Value1:= #_pdoIn1.Val1, Value2:= #_pdoIn1.Val2, Value3:= #_pdoIn1.Val3, Value4:= #_pdoIn1.Val4) = 0 then
    // Received value     
    _pdo1RxInterval := (ops.tAbsolute - _pdo1rxTime);
    _pdo1rxTime := ops.tAbsolute;    // time the valid response was receive 

    StateOfCharge := to_dint(_pdoIn1.Val1);
    EnergyDraw := to_dint(_pdoIn1.Val2);
    BatteryVoltage := to_dint(_pdoIn1.Val3);
    BatteryCurrent := to_dint(_pdoIn1.Val4);
    tmpDataReceived := TRUE;
    
  end_if;
  
  //----------------------------------------------------
  // Read out PDO_RX2 with identifier 0x280 + NodeID
  //----------------------------------------------------  
  if ObjCanOpenBase.DecoPDO(PdoId:= cPdoRx2, Value1:= #_pdoIn2.Val1, Value2:= #_pdoIn2.Val2, Value3:= #_pdoIn2.Val3, Value4:= #_pdoIn2.Val4) = 0 then
    // Received value     
    _pdo2RxInterval := (ops.tAbsolute - _pdo2rxTime);
    _pdo2rxTime := ops.tAbsolute;    // time the valid response was receive 

    BatteryTemperature := to_dint(_pdoIn2.Val1);
    BatteryAlarms.ba_OverVoltage := _pdoIn2.Val2$BOOL;
    BatteryAlarms.ba_UnderVoltage := _pdoIn2.Val3$BOOL;
    BatteryAlarms.ba_BatteryEmpty := _pdoIn2.Val4$BOOL;
    tmpDataReceived := TRUE;
    
  end_if;  
  
  //----------------------------------------------------
  // Read out PDO_RX3 with identifier 0x380 + NodeID
  //----------------------------------------------------
  if ObjCanOpenBase.DecoPDO(PdoId:= cPdoRx3, Value1:= #_pdoIn3.Val1, Value2:= #_pdoIn3.Val2, Value3:= #_pdoIn3.Val3, Value4:= #_pdoIn3.Val4) = 0 then
    // Received value     
    _pdo3RxInterval := (ops.tAbsolute - _pdo3rxTime);
    _pdo3rxTime := ops.tAbsolute;    // time the valid response was receive 

    BatteryAlarms.ba_InternalDefect := _pdoIn3.Val1$BOOL;
    BatteryAlarms.ba_AlmostUnderVoltage := _pdoIn3.Val2$BOOL;
    BatteryAlarms.ba_BatteryAlmostEmpty := _pdoIn3.Val3$BOOL;
    tmpDataReceived := TRUE;
    
  end_if;  

 // If NMT state is not operational, send it to operational
  if ObjCanOpenBase.DecoNMT(NmtId:=cNmtErr, DeviceState:=#NMT) = 0 then
    if NMT <> CanOpenBase::cds_Operational then
      ObjCanOpenBase.BuildNmt(NmtId:=0, Cmnd:=1, Node:=cNode);
    end_if;
  end_if;


  if tmpDataReceived = TRUE then
    
    tmpBMSData.bd_StateOfCharge := to_uint(BatteryVirtualStateOfCharge);
    //tmpBMSData.bd_TimeToGo := 
    tmpBMSData.bd_EnergyDraw := to_int(EnergyDraw);
    tmpBMSData.bd_BatteryVoltage := to_uint(BatteryVoltage);
    tmpBMSData.bd_BatteryCurrent := to_int(BatteryCurrent);
    tmpBMSData.bd_BatteryTemperature := to_int(BatteryTemperature);
    
    if BatteryCurrent <= 0 then
      _batteryChargingTimer := ops.tAbsolute;
    end_if;
    
    tmpBMSData.bd_BatteryCharging := ((ops.tAbsolute - _batteryChargingTimer) > BATTERYCHARGINGDELAY);
    tmpBMSData.bd_Alarm := BatteryAlarms;
  
    
  end_if;

END_FUNCTION



FUNCTION HAL_BMS_MasterVolt::_handleAlarms
  
  if BatteryAlarms.ba_OverVoltage = TRUE then
 
  end_if;
  
  if BatteryAlarms.ba_UnderVoltage = TRUE then
   
  end_if;
  
  if BatteryAlarms.ba_AlmostUnderVoltage = TRUE then
   
  end_if;
  
  if BatteryAlarms.ba_BatteryEmpty = TRUE then
   
  end_if;
  
  if BatteryAlarms.ba_BatteryAlmostEmpty = TRUE then
   
  end_if;
  
  if BatteryAlarms.ba_InternalDefect = TRUE then
   
  end_if;
  
  if BatteryAlarms.ba_NoCommunication = TRUE then
    
  end_if;

END_FUNCTION


FUNCTION HAL_BMS_MasterVolt::_handleAlarmResets


  
  

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HAL_BMS_MasterVolt::ToObject::Read
	VAR_OUTPUT
		output (EAX) 	: pVoid;
	END_VAR

	ToObject := ObjPeripheralsBase.ToObject.Read();
	output := ToObject;

END_FUNCTION
