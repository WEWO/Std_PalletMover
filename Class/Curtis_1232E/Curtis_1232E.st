//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Curtis_1232E"
	Revision           = "0.0"
	GUID               = "{D69FC2BF-B806-4736-B35F-492D688321D5}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	DefCyclictime      = "5 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(600,2940)">
	<Channels>
	</Channels>
	<Network Name="Curtis_1232E">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{3EFA8AF8-87CD-4782-8B52-FA2C01A73672}"
				Class      = "Curtis_Base"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Active"/>
					<Server Name="AI_BrakePot"/>
					<Server Name="AI_ThrottlePot"/>
					<Server Name="AutoAccelTime" Value="100"/>
					<Server Name="AutoAct"/>
					<Server Name="AutoDecelTime" Value="10"/>
					<Server Name="AutomaticSetpoint"/>
					<Server Name="AutoSetp"/>
					<Server Name="BDI"/>
					<Server Name="BrakePotSigned"/>
					<Server Name="Capacitor_Voltage"/>
					<Server Name="ClassSvr"/>
					<Server Name="CommunicationOk"/>
					<Server Name="DriveMode"/>
					<Server Name="DriveModeRequest"/>
					<Server Name="EmStopOk"/>
					<Server Name="Enabled" Value="1"/>
					<Server Name="I_DigitalOut6"/>
					<Server Name="I_DigitalOut7"/>
					<Server Name="I_Driver1"/>
					<Server Name="I_Driver2"/>
					<Server Name="I_Driver3"/>
					<Server Name="I_Driver4"/>
					<Server Name="I_PropDriver"/>
					<Server Name="I_Switch1"/>
					<Server Name="I_Switch16"/>
					<Server Name="I_Switch2"/>
					<Server Name="I_Switch3"/>
					<Server Name="I_Switch4"/>
					<Server Name="I_Switch5"/>
					<Server Name="I_Switch6"/>
					<Server Name="I_Switch7"/>
					<Server Name="I_Switch8"/>
					<Server Name="InterlockExternal1"/>
					<Server Name="InterlockExternal2"/>
					<Server Name="InterlockFeedback"/>
					<Server Name="MotorCurrent"/>
					<Server Name="MotorRPM"/>
					<Server Name="MotorTemperature"/>
					<Server Name="QD_DigitalOut6"/>
					<Server Name="QD_DigitalOut7"/>
					<Server Name="QD_Driver1"/>
					<Server Name="QD_Driver2"/>
					<Server Name="QD_Driver3"/>
					<Server Name="QD_Driver4"/>
					<Server Name="QD_PropDriver"/>
					<Server Name="Referenced"/>
					<Server Name="ThrottlePotSigned"/>
					<Client Name="AlarmStartId"/>
					<Client Name="NodeId" Value="1"/>
					<Client Name="objDriver"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(916,210),(744,210),"/>
			<Connection Source="this.Active" Destination="_base.Active" Vertices="(916,270),(744,270),"/>
			<Connection Source="this.CommunicationOk" Destination="_base.CommunicationOk" Vertices="(916,330),(744,330),"/>
			<Connection Source="this.DriveMode" Destination="_base.DriveMode" Vertices="(916,390),(744,390),"/>
			<Connection Source="this.EmStopOk" Destination="_base.EmStopOk" Vertices="(916,450),(744,450),"/>
			<Connection Source="this.Referenced" Destination="_base.Referenced" Vertices="(916,510),(744,510),"/>
			<Connection Source="this.InterlockFeedback" Destination="_base.InterlockFeedback" Vertices="(916,570),(744,570),"/>
			<Connection Source="this.InterlockExternal1" Destination="_base.InterlockExternal1" Vertices="(916,630),(744,630),"/>
			<Connection Source="this.InterlockExternal2" Destination="_base.InterlockExternal2" Vertices="(916,690),(744,690),"/>
			<Connection Source="this.AutoAct" Destination="_base.AutoAct" Vertices="(916,750),(744,750),"/>
			<Connection Source="this.AutoSetp" Destination="_base.AutoSetp" Vertices="(916,810),(744,810),"/>
			<Connection Source="this.MotorCurrent" Destination="_base.MotorCurrent" Vertices="(916,870),(744,870),"/>
			<Connection Source="this.BDI" Destination="_base.BDI" Vertices="(916,930),(744,930),"/>
			<Connection Source="this.Capacitor_Voltage" Destination="_base.Capacitor_Voltage" Vertices="(916,990),(744,990),"/>
			<Connection Source="this.MotorTemperature" Destination="_base.MotorTemperature" Vertices="(916,1050),(744,1050),"/>
			<Connection Source="this.AI_ThrottlePot" Destination="_base.AI_ThrottlePot" Vertices="(916,1110),(744,1110),"/>
			<Connection Source="this.AI_BrakePot" Destination="_base.AI_BrakePot" Vertices="(916,1170),(744,1170),"/>
			<Connection Source="this.I_Switch1" Destination="_base.I_Switch1" Vertices="(916,1230),(744,1230),"/>
			<Connection Source="this.I_Switch2" Destination="_base.I_Switch2" Vertices="(916,1290),(744,1290),"/>
			<Connection Source="this.I_Switch3" Destination="_base.I_Switch3" Vertices="(916,1350),(744,1350),"/>
			<Connection Source="this.I_Switch4" Destination="_base.I_Switch4" Vertices="(916,1410),(744,1410),"/>
			<Connection Source="this.I_Switch5" Destination="_base.I_Switch5" Vertices="(916,1470),(744,1470),"/>
			<Connection Source="this.I_Switch6" Destination="_base.I_Switch6" Vertices="(916,1530),(744,1530),"/>
			<Connection Source="this.I_Switch7" Destination="_base.I_Switch7" Vertices="(916,1590),(744,1590),"/>
			<Connection Source="this.I_Switch8" Destination="_base.I_Switch8" Vertices="(916,1650),(744,1650),"/>
			<Connection Source="this.I_Driver1" Destination="_base.I_Driver1" Vertices="(916,1710),(744,1710),"/>
			<Connection Source="this.I_Driver2" Destination="_base.I_Driver2" Vertices="(916,1770),(744,1770),"/>
			<Connection Source="this.I_Driver3" Destination="_base.I_Driver3" Vertices="(916,1830),(744,1830),"/>
			<Connection Source="this.I_Driver4" Destination="_base.I_Driver4" Vertices="(916,1890),(744,1890),"/>
			<Connection Source="this.I_PropDriver" Destination="_base.I_PropDriver" Vertices="(916,1950),(744,1950),"/>
			<Connection Source="this.I_DigitalOut6" Destination="_base.I_DigitalOut6" Vertices="(916,2010),(744,2010),"/>
			<Connection Source="this.I_DigitalOut7" Destination="_base.I_DigitalOut7" Vertices="(916,2070),(744,2070),"/>
			<Connection Source="this.I_Switch16" Destination="_base.I_Switch16" Vertices="(916,2130),(744,2130),"/>
			<Connection Source="this.MotorRPM" Destination="_base.MotorRPM" Vertices="(916,2190),(744,2190),"/>
			<Connection Source="this.Enabled" Destination="_base.Enabled" Vertices="(916,2250),(744,2310),"/>
			<Connection Source="this.ThrottlePotSigned" Destination="_base.ThrottlePotSigned" Vertices="(916,2310),(744,2370),"/>
			<Connection Source="this.BrakePotSigned" Destination="_base.BrakePotSigned" Vertices="(916,2370),(744,2430),"/>
			<Connection Source="this.DriveModeRequest" Destination="_base.DriveModeRequest" Vertices="(916,2430),(744,2550),"/>
			<Connection Source="this.AutomaticSetpoint" Destination="_base.AutomaticSetpoint" Vertices="(916,2490),(744,2610),"/>
			<Connection Source="this.AutoAccelTime" Destination="_base.AutoAccelTime" Vertices="(916,2550),(744,2670),"/>
			<Connection Source="this.AutoDecelTime" Destination="_base.AutoDecelTime" Vertices="(916,2610),(744,2730),"/>
			<Connection Source="this.QD_Driver1" Destination="_base.QD_Driver1" Vertices="(916,2670),(744,2790),"/>
			<Connection Source="this.QD_Driver2" Destination="_base.QD_Driver2" Vertices="(916,2730),(744,2850),"/>
			<Connection Source="this.QD_Driver3" Destination="_base.QD_Driver3" Vertices="(916,2790),(744,2910),"/>
			<Connection Source="this.QD_Driver4" Destination="_base.QD_Driver4" Vertices="(916,2850),(744,2970),"/>
			<Connection Source="this.QD_PropDriver" Destination="_base.QD_PropDriver" Vertices="(916,2910),(744,3030),"/>
			<Connection Source="this.QD_DigitalOut6" Destination="_base.QD_DigitalOut6" Vertices="(916,2970),(744,3090),"/>
			<Connection Source="this.QD_DigitalOut7" Destination="_base.QD_DigitalOut7" Vertices="(916,3030),(744,3150),"/>
			<Connection Source="_base.AlarmStartId" Destination="this.AlarmStartId" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.NodeId" Destination="this.NodeId" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.objDriver" Destination="this.objDriver" Vertices="(218,330),(38,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using Curtis_Base

Curtis_1232E : CLASS
: Curtis_Base
  //Servers:
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL _receiveData;
	
	FUNCTION VIRTUAL _sendData;
	
	FUNCTION VIRTUAL _handleDriveMode;
	
	FUNCTION GLOBAL Worker;
	
	FUNCTION _setNetworkAlarm
		VAR_INPUT
			alarmType 	: DINT;
		END_VAR;
	
	FUNCTION _handleNetworkAlarm;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Curtis_1232E::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CURTIS_1232E
0$UINT, 0$UINT, (SIZEOF(::Curtis_1232E))$UINT, 
0$UINT, 0$UINT, 0$UINT, 
TO_UDINT(1965105011), "Curtis_1232E", //Class
TO_UDINT(3229075938), "Curtis_Base", 0$UINT, 0$UINT, //Baseclass
//Servers:
//Clients:
END_FUNCTION


#define USER_CNT_Curtis_1232E 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Curtis_1232E] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Curtis_1232E::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= Curtis_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= Curtis_Base::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, Curtis_Base::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_Curtis_1232E;
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #_receiveData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #_sendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #_handleDriveMode();

#pragma warning (default : 74)
	Curtis_Base::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Curtis_Base::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL Curtis_1232E::Worker
  if IsClientConnected(input:=#objDriver) = TRUE & Enabled = 1 then
    Active := 1;
    
    _HandleDriveMode();
    
    if _CanOpenBaseRiwo.Server0 >= 0 then
      _receiveData();
      _sendData();  
    end_if;
    
    if (ops.tAbsolute - _timeoutDelayStart) > TIMEOUTDELAY then
      _StartupDelayActive := FALSE;
    end_if;

    // Delay on the timeout check to allow system to establish connection first on startup.   
    if  (_StartupDelayActive = FALSE) & 
        ( (ops.tAbsolute - _pdo1rxTime) > COMM_TIMEOUT | (ops.tAbsolute - _pdo2rxTime) > COMM_TIMEOUT | (ops.tAbsolute - _pdo3rxTime) > COMM_TIMEOUT ) then
      // Activate timeout alarm if the cyclic messages aren't received or sent in time.
      //_setNetworkAlarm(ca_Com_Timeout);
      
      _setNetworkAlarm(ca_Com_Timeout);
      CommunicationOk := FALSE;
    end_if;

  else
    Active := 0;
  end_if;
  
  _handleNetworkAlarm();
  
END_FUNCTION


FUNCTION VIRTUAL Curtis_1232E::_handleDriveMode
  case _DriveModeReqStepper of
   0:
   
      if  ( DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_EmergencyStop | DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_TimeOut)  &
          ( (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Idle & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Idle ) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Manual  & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Manual) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Automatic  & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Auto) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Reference  & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Referencing) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetDrive & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_DriveReset) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetExtInterlock & (DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_ExtInterlockReset ) ) ) then
        
        //act mode differs to requested mode
        _IntDriveModeReq := DriveModeRequest;
        _DriveModeRequestTime := ops.tAbsolute;
        _DriveModeReqStepper := 1;
        
      end_if;
      
    1:
        if (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Idle & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Idle ) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Manual  & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Manual) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Automatic  & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Auto) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Reference  & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Referencing) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetDrive & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_DriveReset) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetExtInterlock & (DriveMode = Curtis_Base::eCurtisDriveMode::cdm_ExtInterlockReset )) then
          //succesfull change of drive mode
          _DriveModeRequestTime := ops.tAbsolute;
          _IntDriveModeReq := Curtis_Base::eCurtisDriveModeRequest::cdmr_NoReq;
          _DriveModeReqStepper := 2;
          
        elsif (ops.tAbsolute - _DriveModeRequestTime > MAX_TIME_DRIVE_MODE_REQ) then
          //not changed mode go for retry
         ////// Curtis F _RIWO_WARNING_MSG1("switching drive mode from:{0} to:{1} not possible", DriveMode$DINT, _IntDriveModeReq$DINT);
          _DriveModeRequestTime := ops.tAbsolute;
          _IntDriveModeReq := Curtis_Base::eCurtisDriveModeRequest::cdmr_NoReq;
          _DriveModeReqStepper := 2;
    
        end_if;
    2:
        //wait for no request command to be send over
        if (ops.tAbsolute - _DriveModeRequestTime > MAX_TIME_DRIVE_MODE_REQ) then
          _DriveModeReqStepper := 0;
        end_if;
      
  end_case;
END_FUNCTION


FUNCTION VIRTUAL Curtis_1232E::_receiveData
VAR
  	i : DINT;
    alarmStatusDword : Dword;
    PDOSplitOut1     : BSINT;
    PDOSplitOut2     : BSINT;
  END_VAR
    
  //----------------------------------------------------
  // Read out PDO_RX1 with identifier 0x180 + NodeID
  //----------------------------------------------------
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx1, Value1:= #_pdoIn1.Val1, Value2:= #_pdoIn1.Val2, Value3:= #_pdoIn1.Val3, Value4:= #_pdoIn1.Val4) = 0 then
    // Received value     
    _pdo1RxInterval := (ops.tAbsolute - _pdo1rxTime);
    _pdo1rxTime := ops.tAbsolute;    // time the valid response was received
    
    _prevReferenced := Referenced;
    
    DriveMode       := to_dint(_pdoIn1.Val1 and 16#00FF)$eCurtisDriveMode;
    
    EmStopOk            := to_bool(_pdoIn1.Val1 and 16#0100);
    CommunicationOk     := to_bool(_pdoIn1.Val1 and 16#0200);
    Referenced          := to_bool(_pdoIn1.Val1 and 16#0400);
    InterlockFeedback   := to_bool(_pdoIn1.Val1 and 16#0800);
    InterlockExternal1  := to_bool(_pdoIn1.Val1 and 16#1000);
    InterlockExternal2  := to_bool(_pdoIn1.Val1 and 16#2000);
    _tempOk             := to_bool(_pdoIn1.Val1 and 16#4000);
    _DriveCycleTimeOk   := to_bool(_pdoIn1.Val1 and 16#8000);
    
    //set temperature alarm
    if _tempOk <> TRUE then
      _setNetworkAlarm(alarmType:= ca_MotorTemp_CutBack);
    end_if;
 
    //set cycle time error
    if _DriveCycleTimeOk <> TRUE then
      _setNetworkAlarm(alarmType:= ca_VC1_RunTime);
    end_if;
    
    AutoAct           := to_dint(_pdoIn1.Val2);
    AutoSetp          := to_dint(_pdoIn1.Val3);
             
    if (_prevReferenced <> Referenced & Referenced = False) | (EmStopOk <> TRUE) then
      _notReferencedStartTime := ops.tAbsolute;
    elsif Referenced = True then
      _notReferencedStartTime := ops.tAbsolute;
    end_if;  
          
    if Referenced = False & _prevReferenced = False & (ops.tAbsolute - _notReferencedStartTime) > REFERENCETIMEOUT then
      _setNetworkAlarm(ca_NotRef);  
    end_if;  
    
  end_if;
  
  //----------------------------------------------------
  // Read out PDO_RX2 with identifier 0x280 + NodeID
  //----------------------------------------------------
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx2, Value1:= #_pdoIn2.Val1, Value2:= #_pdoIn2.Val2, Value3:= #_pdoIn2.Val3, Value4:= #_pdoIn2.Val4) = 0 then // message received
    
    _pdo2rxTime := ops.tAbsolute;    // time the valid response was received
    
    MotorRPM := to_dint(_pdoIn2.Val1);
    
    MotorCurrent := to_dint(_pdoIn2.Val2);
    MotorTemperature := to_dint(_pdoIn2.Val3);
    
    //Todo SVE change controller to add to val2 vcl statu
    BDI := to_dint(_pdoIn2.Val4 AND 16#00FF);
    
    
  end_if; 
    
  //----------------------------------------------------
  // Read out PDO_RX3 with identifier 0x380 + NodeID
  //----------------------------------------------------    
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx3, Value1:= #_pdoIn3.Val1, Value2:= #_pdoIn3.Val2, Value3:= #_pdoIn3.Val3, Value4:= #_pdoIn3.Val4) = 0 then
    
    _pdo3rxTime := ops.tAbsolute;
    
    // Get potentiometer input
    if ThrottlePotSigned = 1 then
      AI_ThrottlePot := to_dint(_pdoIn3.Val1);
    else
      AI_ThrottlePot := to_dint(to_uint(_pdoIn3.Val1));
    end_if;
      
    
    // Get potentiometer input
    if BrakePotSigned = 1 then
      AI_BrakePot := to_dint(_pdoIn3.Val2); 
    else
      AI_BrakePot := to_dint(to_uint(_pdoIn3.Val2));
    end_if;
    
    // Get input switches
    _Split16bit(Input16bit:=_pdoIn3.Val3, #PDOSplitOut1, #PDOSplitOut2); 
    
    I_Switch1     := PDOSplitOut1.1;
    I_Switch2     := PDOSplitOut1.2;
    I_Switch3     := PDOSplitOut1.3;
    I_Switch4     := PDOSplitOut1.4;
    I_Switch5     := PDOSplitOut1.5;
    I_Switch6     := PDOSplitOut1.6;
    I_Switch7     := PDOSplitOut1.7;
    I_Switch8     := PDOSplitOut1.8;
    I_Driver1     := PDOSplitOut2.1;
    I_Driver2     := PDOSplitOut2.2;
    I_Driver3     := PDOSplitOut2.3;
    I_Driver4     := PDOSplitOut2.4;
    I_PropDriver  := PDOSplitOut2.5;
    I_DigitalOut6 := PDOSplitOut2.6;
    I_DigitalOut7 := PDOSplitOut2.7;
    I_Switch16    := PDOSplitOut2.8;
    
    // Getting the voltage on the drive.
    Capacitor_Voltage := to_dint(_pdoIn3.Val4);
    
    if Capacitor_Voltage > 100 | EmStopOk <> TRUE | InterlockFeedback <> TRUE then
      _FuseBadStartTime := ops.tAbsolute;
    end_if;
    
    // Set or reset fuse alarm only when there is communication and voltage is below 10,0V
    if Capacitor_Voltage <= 100 & EmStopOk = TRUE & (ops.tAbsolute - _FuseBadStartTime) > FUSE_BAD_TIME then
      _setNetworkAlarm(ca_FuseBad);
    end_if;
    
  end_if;


    
  //----------------------------------------------------
  // Read out PDO_RX4 with identifier 0x480 + NodeID
  //----------------------------------------------------
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx4, Value1:= #_pdoIn4.Val1, Value2:= #_pdoIn4.Val2, Value3:= #_pdoIn4.Val3, Value4:= #_pdoIn4.Val4) = 0 then                                   
    // alarm message received
   _memcpy(ptr1:=#alarmStatusDword, ptr2:=#_pdoIn4.Val1, cntr:=sizeof(alarmStatusDword));
   
    for i:=0 to 31 by 1 do     
      //check allarm bit and set coresponding alarm active 0 to 32
      if  ((alarmStatusDword shr i)$byte AND 1)  = 1 then  
        _setNetworkAlarm(i+1);
      end_if;
    end_for;
    
    _memcpy(ptr1:=#alarmStatusDword, ptr2:=#_pdoIn4.Val3, cntr:=sizeof(alarmStatusDword));
    for i:=0 to 31 by 1 do     
      //check allarm bit and set coresponding alarm active 32 to 64
      if  ((alarmStatusDword shr i)$byte AND 1)  = 1 then  
        _setNetworkAlarm(i + 33);
      end_if;
    end_for;
  end_if; 

END_FUNCTION

FUNCTION Curtis_1232E::_sendData
VAR
	tmpOutputReq  :BINT;
END_VAR

  //---------------------------------------------
  // Send out PDO_TX1 with identifier 0x200 + NodeID
  //----------------------------------------------------

  if (ops.tAbsolute - _sendPDO1TimeStamp) > PDO1_SEND_INTERVAL then
  
    tmpOutputReq.1 := QD_Driver1$bool;
    tmpOutputReq.2 := QD_Driver2$bool;
    tmpOutputReq.3 := QD_Driver3$bool;
    tmpOutputReq.4 := QD_Driver4$bool;
    tmpOutputReq.5 := QD_PropDriver$bool;
    tmpOutputReq.6 := QD_DigitalOut6$bool;
    tmpOutputReq.7 := QD_DigitalOut7$bool;
    tmpOutputReq.9 := False;
    tmpOutputReq.10 := False;
    tmpOutputReq.11 := False;
    tmpOutputReq.16 := False;
    
    _pdo1Out.Val1 := _IntDriveModeReq$INT;
    
    _pdo1Out.Val2 := tmpOutputReq$INT;
    _pdo1Out.Val3 := AutomaticSetpoint$INT;
    
    _pdo1Out.Val4 := ((AutoDecelTime$INT AND 16#FF) shl 8) or (AutoAccelTime$INT AND 16#FF);
        
    if _CanOpenBaseRiwo.SendPDO(PdoId:=cPdoTx1, Bytes:=8, Value1:=_pdo1Out.Val1, Value2:=_pdo1Out.Val2, Value3:=_pdo1Out.Val3, Value4:=_pdo1Out.Val4) = 0 then
      _sendPDO1TimeStamp := ops.tAbsolute;

      // Received valid response
    end_if;
        
  end_if;
END_FUNCTION

FUNCTION Curtis_1232E::_setNetworkAlarm
	VAR_INPUT
		alarmType 	: DINT;
	END_VAR
  
  if (_pObjCurtis_Universal <> NIL) then

  end_if;

END_FUNCTION

FUNCTION Curtis_1232E::_handleNetworkAlarm
  if (_pObjCurtis_Universal <> NIL) then
 
  end_if;
END_FUNCTION
