//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define SF_FILE_BUFFER_SIZE         1000                        //size of the buffer used to store the 

//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\WewoFileBase\FileDef.h"

(*!
<Class
	Name               = "WewoFileBase"
	Revision           = "0.4"
	GUID               = "{F9FA6EB2-2CEE-4F64-9C4E-750B2BC3258D}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(554,120)">
	<Channels>
		<Client Name="ToFileSys" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\WewoFileBase\FileDef.h" Include="true"/>
			<File Path=".\Class\WewoFileBase\SFN_FileBase.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Safan" Author="HenOdi"/>
		<Dokumentation Revision="0.3" Date="2011-04-12" Author="HenOdi" Company="Safan" Description="Use InitCnt"/>
		<Dokumentation Revision="0.2" Date="2-11-2010" Author="HenOdi" Company="Safan" Description="Add methode FlushFileBuffer()"/>
	</RevDoku>
	<Network Name="WewoFileBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{9DDD7F57-C65C-42C0-AE20-3BAFED4BE68D}"
				Class      = "WewoBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="m_Id"/>
					<Server Name="m_p_Name"/>
					<Server Name="o_ErrorWarningStatus"/>
					<Server Name="ObjectStatus"/>
					<Server Name="ToObject"/>
					<Client Name="c_Group"/>
					<Client Name="op_LogData"/>
					<Client Name="toOsLibTaskObjControl"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ToObject" Destination="_base.ToObject" Vertices="(856,210),(684,210),"/>
			<Connection Source="this.ObjectStatus" Destination="_base.ObjectStatus" Vertices="(856,270),(684,270),"/>
			<Connection Source="this.m_Id" Destination="_base.m_Id" Vertices="(856,390),(684,390),"/>
			<Connection Source="this.m_p_Name" Destination="_base.m_p_Name" Vertices="(856,450),(684,450),"/>
			<Connection Source="_base.op_LogData" Destination="this.op_LogData" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.c_Group" Destination="this.c_Group" Vertices="(218,270),(38,270),"/>
			<Connection Source="this.o_ErrorWarningStatus" Destination="_base.o_ErrorWarningStatus" Vertices="(856,330),(684,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using WewoBase

WewoFileBase : CLASS
: WewoBase
	TYPE
	  t_SF_FileReadResult :
	  (
	    FILE_READ_OK,  //! <Type Comment="Read Ok" Name="t_SF_FileReadResult.FILE_READ_OK"/>
	    FILE_READ_EOL,  //! <Type Comment="Read Ok, EOL detected" Name="t_SF_FileReadResult.FILE_READ_EOL"/>
	    FILE_READ_EOF,  //! <Type Comment="Read Ok, EOF detected" Name="t_SF_FileReadResult.FILE_READ_EOF"/>
	    FILE_READ_FAILED
	  )$UDINT;
	END_TYPE
  //Servers:
  //Clients:
	ToFileSys 	: CltChCmd__FileSys;
  //Variables:
		FileHandle 	: DINT;
		FileBuffer : ARRAY [0..SF_FILE_BUFFER_SIZE] OF CHAR;

		FileBufferHead 	: UINT;
		NrCharsRead 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION OpenFile
		VAR_INPUT
			p_FileName 	: ^CHAR;
			FileMode 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Result 	: BOOL;
		END_VAR;
	
	FUNCTION ClearFileBuffer;
	
	FUNCTION CloseFile;
				//! <Function Comment="Write content filebuffer to file" Name="FlushFileBuffer"/>
	FUNCTION FlushFileBuffer
		VAR_OUTPUT
			Result 	: BOOL;
		END_VAR;
				//! <Function Comment="Removes specified file" Name="RemoveFile"/>
	FUNCTION RemoveFile
		VAR_INPUT
			p_FileName 	: ^CHAR;
		END_VAR;
	
	FUNCTION WriteChar
		VAR_INPUT
			c 	: CHAR;
			Flush 	: BOOL;
		END_VAR
		VAR_OUTPUT
			Result 	: BOOL;
		END_VAR;
	
	FUNCTION WriteString
		VAR_INPUT
			p_String 	: ^CHAR;
			Flush 	: BOOL;
		END_VAR
		VAR_OUTPUT
			Result 	: BOOL;
		END_VAR;
	
	FUNCTION GetChar
		VAR_INPUT
			p_DestChar 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Result 	: t_SF_FileReadResult;
		END_VAR;
	
	FUNCTION GetLine
		VAR_INPUT
			p_LineBuffer 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Result 	: t_SF_FileReadResult;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _FileSys


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB WewoFileBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_WEWOFILEBASE
0$UINT, 4$UINT, (SIZEOF(::WewoFileBase))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(3477584769), "WewoFileBase", //Class
TO_UDINT(817841270), "WewoBase", 0$UINT, 29$UINT, //Baseclass
//Servers:
//Clients:
(::WewoFileBase.ToFileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4037977231), "ToFileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
END_FUNCTION


#define USER_CNT_WewoFileBase 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_WewoFileBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION WewoFileBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= WewoBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= WewoBase::ToObject.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, WewoBase::ToObject.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_WewoFileBase;
	vmt.CmdTable.Init		:= #Init();
	WewoBase::ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF WewoBase::ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// Note Reading and writing file uses the same buffer. 
//      This base class can only be used only for reading a file or only for writing a file

FUNCTION VIRTUAL GLOBAL WewoFileBase::Init

  WewoBase::Init();
  
  if (initCnt >= 12) then
    FileHandle := 0;
    
  end_if;
  
END_FUNCTION


FUNCTION WewoFileBase::OpenFile
	VAR_INPUT
		p_FileName 	: ^CHAR;
		FileMode 	: UDINT;
	END_VAR
	VAR_OUTPUT
		Result 	: BOOL;
	END_VAR

  CloseFile();    // In case a file is opened close it first.

  if(FileMode = ATT_CREATE) then //first delete existing file if present
    ToFileSys.FileDelete(p_FileName);
  end_if;
  
  FileHandle := ToFileSys.FileOpen(p_FileName, FileMode);
  if (FileHandle > 0) then
    ClearFileBuffer();
    Result := PASSED;
  else
    Result := FAILED;
  end_if;

END_FUNCTION


FUNCTION WewoFileBase::CloseFile

  if (FileHandle > 0) then    //only close if a file is opened
    ToFileSys.FileClose(FileHandle);
    FileHandle := 0;
  end_if;
  
END_FUNCTION

FUNCTION WewoFileBase::RemoveFile
	VAR_INPUT
		p_FileName 	: ^CHAR;
	END_VAR
  
  
  CloseFile();

  ToFileSys.FileDelete(filename:=p_FileName);
  
END_FUNCTION


FUNCTION WewoFileBase::ClearFileBuffer
VAR
	cnt : UINT;
END_VAR

  FileBufferHead := 0;

  for cnt:=0 to SF_FILE_BUFFER_SIZE do
    FileBuffer[cnt]:=0;
  end_for;

END_FUNCTION


FUNCTION WewoFileBase::FlushFileBuffer
	VAR_OUTPUT
		Result 	: BOOL;
	END_VAR
  
  if(ToFileSys.FileWrite(handle:=FileHandle, buffer:=#FileBuffer[0], length:=FileBufferHead) > 0) then
    FileBufferHead := 0;
    Result := PASSED;
  else
    Result := FAILED;
  end_if;

END_FUNCTION


FUNCTION WewoFileBase::WriteChar
	VAR_INPUT
		c 	: CHAR;
		Flush 	: BOOL;
	END_VAR
	VAR_OUTPUT
		Result 	: BOOL;
	END_VAR
  
  Result := PASSED;

  FileBuffer[FileBufferHead] := c;
  FileBufferHead += 1;
  
  if((FileBufferHead = SF_FILE_BUFFER_SIZE) | Flush) then //buffer full or flush to file immediately
    Result := FlushFileBuffer();
  end_if;
  
END_FUNCTION


FUNCTION WewoFileBase::WriteString
	VAR_INPUT
		p_String 	: ^CHAR;
		Flush 	: BOOL;
	END_VAR
	VAR_OUTPUT
		Result 	: BOOL;
	END_VAR
  
  Result := PASSED;
  while ((p_String^ <> 0) & (Result = PASSED)) do
    Result := WriteChar(c:=p_String^, Flush:=Flush);
    p_String += 1;
  end_while;

END_FUNCTION


FUNCTION WewoFileBase::GetChar
	VAR_INPUT
		p_DestChar 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Result 	: t_SF_FileReadResult;
	END_VAR
  
  if (FileBufferHead = NrCharsRead) then    //buffer is empty, so first fill it
    FileBufferHead  := 0;
    //NrCharsRead     := ToFileSys.FileRead(FileHandle, #FileBuffer[0], SF_FILE_BUFFER_SIZE);
    NrCharsRead     := ToFileSys.FileReadV1(handle:=FileHandle, buffer:=#FileBuffer[0], length:=SF_FILE_BUFFER_SIZE);
  end_if;
  
  if NrCharsRead > 0 then

    p_DestChar^     := FileBuffer[FileBufferHead];
    FileBufferHead  += 1;                              // Set header to next index
    Result := FILE_READ_OK;
  else
    Result := FILE_READ_EOF;
  end_if;

END_FUNCTION


// Gets a line from file that is closed by a <CR>, <LF> or <CR LF>
// CR, is replaced by 0-character. LF is skipped.
FUNCTION WewoFileBase::GetLine
	VAR_INPUT
		p_LineBuffer 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Result 	: t_SF_FileReadResult;
	END_VAR

	VAR
		p_Buf 	: ^CHAR;
	END_VAR

  Result  := FILE_READ_OK;                            // Default return OK
  
  p_Buf   := p_LineBuffer;                  // Set to start of destination buffer
  
  while (Result = FILE_READ_OK) do
    // In loop until EOL/EOF found
    
    Result := GetChar(p_DestChar:=p_Buf);
    
    if (Result = FILE_READ_OK) then
     
      if (p_Buf^ = cCR) then
        // Skip CR, return EOL
        p_Buf^  := 0;                       // replace by close string character
        p_Buf   += 1;                       // Next character
        Result  := FILE_READ_EOL;
        
      elsif (p_Buf^ = cLF) then
        // Skip LF
        p_Buf^ := 0;                        // replace by close string character
        
      else
        p_Buf   += 1;                       // Next character

      end_if;
      
    elsif (Result = FILE_READ_EOF) then
      // No more data in buffer
      p_Buf^ := 0;                          // Close string
      p_Buf += 1;                           // Next character
    
    end_if;
    
  end_while;
  
END_FUNCTION

