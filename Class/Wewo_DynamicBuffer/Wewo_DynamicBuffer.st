//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "Wewo_DynamicBuffer"
	Revision           = "0.5"
	GUID               = "{13462C99-DA1D-4DB0-84C5-0E83AF7DA396}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(660,480)"
	Comment            = "Dynamic Memory access&#13;&#10;&#13;&#10;Allocate and free memory in runtime.&#13;&#10;BufferSize can be configured runtime. The size is not limited by OS. (standard Lasal Objects normally can not exceed 64K)&#13;&#10;It is recommended to Allocate buffers during initialsation only!&#13;&#10;&#13;&#10;if buffermode ONCE is used it is possible to link segment buffers together to get a segmentedbuffer.&#13;&#10;&#13;&#10;Usage of dynamic memory:&#13;&#10;- Memory can be accessed as FiFo buffer&#13;&#10;- Memory can be accessed via index&#13;&#10;- Memory can be accessed directly the bufferpointer. &#13;&#10;&#13;&#10;The first two access methodes will check the boundary limits&#13;&#10;For the pointer methode the object which allocates memeory is responsible for checking the boundaries.&#13;&#10;&#13;&#10;It is recommended not to mix up access methodes.&#13;&#10;">
	<Channels>
		<Server Name="BufferSize" GUID="{485BA9B8-B6BD-46BA-9ED4-FCB7843AA513}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Buffersize reserved for buffer&#13;&#10;"/>
		<Server Name="FiFoBufMode" GUID="{3A2E3365-2D01-4743-8D5F-73BED0F40E91}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Fifo Buffer mode "/>
		<Client Name="toStdLib" Required="false" Internal="false" Comment="Objectchannel to OS stdlib"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\Wewo_DynamicBuffer\SFN_DynamicBuffer.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Safan" Author="HenOdi"/>
		<Dokumentation Revision="0.5" Date="2011-12-07" Author="HenOdi" Company="Safan" Description="Use new version of linked list"/>
		<Dokumentation Revision="0.4" Date="2011-10-11" Author="HenOdi" Company="Safan" Description="Allocate buffer is moved from initCnt= 12  to initCnt =2&#13;&#10;So other classes can use allocated buffer pointer during init()"/>
		<Dokumentation Revision="0.2" Date="2011-04-14" Author="HenOdi" Company="Safan" Description="Use InitCnt"/>
		<Dokumentation Revision="0.1" Date="8-11-2010" Author="HenOdi" Company="Safan" Description="Initial revision"/>
	</RevDoku>
	<Network Name="Wewo_DynamicBuffer">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{16B9DBAB-BC4F-45A3-8541-26301DF85B86}"
				Class      = "Wewo_LinkedObjectBase"
				Position   = "(368,120)"
				Visualized = "false">
				<Channels>
					<Server Name="m_Id"/>
					<Server Name="m_p_Name"/>
					<Server Name="o_ErrorWarningStatus"/>
					<Server Name="ObjectStatus"/>
					<Server Name="ToObject"/>
					<Client Name="c_Group"/>
					<Client Name="op_LogData"/>
					<Client Name="p_NextObject"/>
					<Client Name="p_PreviousObject"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
			<Comment Position="(960,120)" Size="(210,60)" Text="&#13;&#10;"/>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ToObject" Destination="_base.ToObject" Vertices="(1326,210),(1038,210),"/>
			<Connection Source="this.ObjectStatus" Destination="_base.ObjectStatus" Vertices="(1326,270),(1038,270),"/>
			<Connection Source="this.m_Id" Destination="_base.m_Id" Vertices="(1326,390),(1038,390),"/>
			<Connection Source="_base.p_NextObject" Destination="this.p_NextObject" Vertices="(368,390),(270,390),(270,330),(38,330),"/>
			<Connection Source="_base.op_LogData" Destination="this.op_LogData" Vertices="(368,210),(38,210),"/>
			<Connection Source="_base.c_Group" Destination="this.c_Group" Vertices="(368,270),(38,270),"/>
			<Connection Source="this.o_ErrorWarningStatus" Destination="_base.o_ErrorWarningStatus" Vertices="(1326,330),(1038,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using Wewo_LinkedObjectBase

Wewo_DynamicBuffer : CLASS
: Wewo_LinkedObjectBase
  //Servers:
	BufferSize 	: SvrCh_UDINT;
	FiFoBufMode 	: SvrCh_gt_FifoBufMode;
  //Clients:
	toStdLib 	: CltChCmd__StdLib;
  //Variables:
		p_StoreBuf 	: ^CHAR;			//! <Variable Comment="Log buffer = first byte in buffer" Name="p_StoreBuf"/>
		p_EndStoreBuf 	: ^CHAR;			//! <Variable Comment="End of log buffer = last byte in buffer" Name="p_EndStoreBuf"/>
		p_WrFiFoBuf 	: ^CHAR;			//! <Variable Comment="Actual byte in buffer tot Write to" Name="p_WrFiFoBuf"/>
		p_RdFiFoBuf 	: ^CHAR;			//! <Variable Comment="Actual byte in buffer to read from" Name="p_RdFiFoBuf"/>
		FiFoByteCnt 	: UDINT;			//! <Variable Comment="Nr of bytes stored in buffer" Name="FiFoByteCnt"/>
		FiFoByteCntInProgres 	: UDINT;			//! <Variable Comment="Nr of Bytes in progress to administrate  pointers." Name="FiFoByteCntInProgres"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION AllocateBuffer;
	
	FUNCTION FreeBuffer;
	
	FUNCTION VIRTUAL GLOBAL InstallBuffer
		VAR_INPUT
			NrOfBytes 	: UDINT;			//! <Variable Comment="Nr of bytes in Buffer." Name="InstallBuffer.NrOfBytes"/>
		END_VAR
		VAR_OUTPUT
			BufSize 	: UDINT;
		END_VAR;
				//! <Function Comment="Get pointer to buffer.&#13;&#10;&#13;&#10;!!WARNING!!&#13;&#10;If object uses this pointer &#13;&#10;user should check buffer &#13;&#10;boundaries&#13;&#10;!!WARNING!!&#13;&#10;" Name="GetBufferPointer"/>
	FUNCTION GLOBAL GetBufferPointer
		VAR_OUTPUT
			p_BufPointer 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Get the actual buffersize " Name="GetBufferSize"/>
	FUNCTION GLOBAL GetBufferSize
		VAR_OUTPUT
			BufSize 	: UDINT;
		END_VAR;
				//! <Function Comment="Read from this buffer segment" Name="ReadFromBuffer"/>
	FUNCTION GLOBAL ReadFromBuffer
		VAR_INPUT
			Idx 	: UDINT;
			p_RdValue 	: pVoid;
			NrOfBytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			NrOfRdBytes 	: UDINT;
		END_VAR;
				//! <Function Comment="Read from selected buffer segment" Name="ReadFromBufferSegment"/>
	FUNCTION GLOBAL ReadFromBufferSegment
		VAR_INPUT
			Segment 	: UDINT;
			Idx 	: UDINT;
			p_RdValue 	: pVoid;
			NrOfBytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			NrOfRdBytes 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL ReadFromFifoBuffer
		VAR_INPUT
			p_RdData 	: ^CHAR;			//! <Variable Comment="&#13;&#10;" Name="ReadFromFifoBuffer.p_RdData"/>
			NrOfBytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			RdCnt 	: UDINT;
		END_VAR;
				//! <Function Comment="Clear buffer and restart all pointers" Name="ResetBuffer"/>
	FUNCTION GLOBAL ResetBuffer;
				//! <Function Comment="Write to this buffer segment" Name="WriteToBuffer"/>
	FUNCTION GLOBAL WriteToBuffer
		VAR_INPUT
			Idx 	: UDINT;
			p_WrValue 	: pVoid;
			NrOfBytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			NrOfWrBytes 	: UDINT;
		END_VAR;
				//! <Function Comment="Write to selected buffer segment" Name="WriteToBufferSegment"/>
	FUNCTION GLOBAL WriteToBufferSegment
		VAR_INPUT
			Segment 	: UDINT;
			Idx 	: UDINT;
			p_WrValue 	: pVoid;
			NrOfBytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			NrOfWrBytes 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL WriteToFifoBuffer
		VAR_INPUT
			p_WrData 	: ^CHAR;
			NrOfBytes 	: UDINT;
		END_VAR
		VAR_OUTPUT
			NrOfWrBytes 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Wewo_DynamicBuffer::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_WEWO_DYNAMICBUFFER
0$UINT, 5$UINT, (SIZEOF(::Wewo_DynamicBuffer))$UINT, 
2$UINT, 1$UINT, 0$UINT, 
TO_UDINT(1418958529), "Wewo_DynamicBuffer", //Class
TO_UDINT(3571739257), "Wewo_LinkedObjectBase", 0$UINT, 10$UINT, //Baseclass
//Servers:
(::Wewo_DynamicBuffer.BufferSize.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1954423117), "BufferSize", 
(::Wewo_DynamicBuffer.FiFoBufMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2996814104), "FiFoBufMode", 
//Clients:
(::Wewo_DynamicBuffer.toStdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2501598121), "toStdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_Wewo_DynamicBuffer 16

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Wewo_DynamicBuffer] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Wewo_DynamicBuffer::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= Wewo_LinkedObjectBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= WewoBase::ToObject.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, WewoBase::ToObject.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_Wewo_DynamicBuffer;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #InstallBuffer();

#pragma warning (default : 74)
	WewoBase::ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF WewoBase::ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BufferSize.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF BufferSize.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	FiFoBufMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF FiFoBufMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

#define MSG_ERROR_BUFFER_ALLOC "Wewo_DynamicBuffer::Init: Memory allocation"
//****************************************************************************************************************
//**
//**  Buffer used as FiFo (using WriteToFifoBuffer and ReadFromFifoBuffer)
//**  
//**  p_WrStoreBuf = p_RdStoreBuf         -> Fifo is empty
//**  p_WrStoreBuf = p_RdStoreBuf - 1     -> Fifo is Full
//**  p_WrStoreBuf <> p_RdStoreBuf        -> Fifo is filled
//**
//****************************************************************************************************************


FUNCTION VIRTUAL GLOBAL Wewo_DynamicBuffer::Init

  VAR
  	AllocSize : UDINT;
  END_VAR

  Wewo_LinkedObjectBase::Init();
  
  if (initCnt = 2) then

    FiFoBufMode := FiFoBufMode.Read();
    FiFoBufMode.Write(input:=FiFoBufMode);
        
    p_StoreBuf  := p_EndStoreBuf := p_WrFiFoBuf := p_RdFiFoBuf := NIL;
    
    BufferSize  := BufferSize.Read();

    BufferSize.Write(input:=BufferSize);
    AllocSize := InstallBuffer(NrOfBytes := BufferSize);
    
    if AllocSize <> BufferSize then
      ObjectStatus.ApplicationError := 1;
      WriteActiveErrorWarning(IntErrorWarningId:= MSGID_MEM_ALLOC,
                              LogLevel         := LL_ERROR_INTERNAL, 
                              p_msg            := MSG_ERROR_BUFFER_ALLOC
                             );
    end_if;

  end_if;

END_FUNCTION


//****************************************************************************************************************
//** Wewo_DynamicBuffer:: InstallBuffer
//** Description:   If buffer was previous allocated, free it.
//**                allocate nr of bytes and return nr of bytes allocated
//**                For BufSize is 0 buffer is freed only.
//**                
//** Paramaters:    Buf
//****************************************************************************************************************
FUNCTION VIRTUAL GLOBAL Wewo_DynamicBuffer::InstallBuffer
	VAR_INPUT
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		BufSize 	: UDINT;
	END_VAR

  BufferSize.Write(input:=NrOfBytes);
       
  FreeBuffer();     // Clean up previous buffer
  
  AllocateBuffer();
  
  if p_StoreBuf <> NIL then
    // Buffer has been created succesfull 
    BufSize   := BufferSize;
  else
    BufSize   := 0;
  end_if;


END_FUNCTION


//****************************************************************************************************************
//** Wewo_DynamicBuffer:: AllocateBuffer
//** Description:   Allocates a buffer using the actual object parameters.
//**                Reset the buffer
//**
//****************************************************************************************************************
FUNCTION Wewo_DynamicBuffer::AllocateBuffer

  if BufferSize > 0 then
    // Allocate memory for Buffer

    p_StoreBuf    := ((toStdLib.Malloc(size:=BufferSize)) $ ^CHAR);
  
  end_if;

  ResetBuffer();

END_FUNCTION


//****************************************************************************************************************
//** Wewo_DynamicBuffer:: FreeBuffer
//** Description:       Free buffer if it was allocated
//**
//****************************************************************************************************************
FUNCTION Wewo_DynamicBuffer::FreeBuffer

  if p_StoreBuf <> NIL then
    toStdLib.Free(mptr := p_StoreBuf);
  end_if;

  p_RdFiFoBuf := p_WrFiFoBuf := p_StoreBuf := p_EndStoreBuf := NIL;
  
END_FUNCTION


//****************************************************************************************************************
//** Wewo_DynamicBuffer:: ResetBuffer
//** Description:       Reset the buffer
//**                        - Clear memory
//**                        - Set pointers based on p_StoreBuf
//****************************************************************************************************************
FUNCTION GLOBAL Wewo_DynamicBuffer::ResetBuffer

  FiFoByteCnt := 0;

  p_RdFiFoBuf  := p_WrFiFoBuf := p_StoreBuf;
  
  if p_StoreBuf <> NIL then
    // Buffer has been created succesfull 
    _memset(dest:=p_StoreBuf , usByte:=0, cntr:=BufferSize);  //  clear buffer
    
    p_EndStoreBuf := p_StoreBuf + BufferSize-1;                       
  else
    p_EndStoreBuf := NIL;
  end_if;

END_FUNCTION


//****************************************************************************************************************
//** Wewo_DynamicBuffer:: WriteToFifoBuffer
//** Description:   Writes Data in (First in First out buffer) and update write pointer
//**
//** Paramaters:    pointer to data
//**                NrOfBytes to write  
//**                
//** Return         Nr of bytes stored in buffer.
//**
//** Note:          In Buffermode ONCE only complete message are stored in fifo buffer
//**                if not all NrOfBytes can be stored in buffer, nothing is stored.
//**                
//****************************************************************************************************************
FUNCTION GLOBAL Wewo_DynamicBuffer::WriteToFifoBuffer
	VAR_INPUT
		p_WrData 	: ^CHAR;
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		NrOfWrBytes 	: UDINT;
	END_VAR
  
  VAR
    p_internalWrStoreBuf : ^CHAR;
    offset               : DINT;      // During wrap around

  END_VAR

  NrOfWrBytes          := 0;                    // Start nr of bytes written
  FiFoByteCntInProgres += NrOfBytes;            // Allocate nr of bytes in this buffer object for actual message data
 
  if (    ( FiFoBufMode = FIFOBUFMODE_CYCLIC )                                // Cyclic mode, Allways write
     L_OR ( (FiFoByteCnt  + FiFoByteCntInProgres) <= BufferSize )             // Once mode, enough room in buffer available
     ) then

    // Access the object global write pointer as short as possible.
    // Therefor we use an internal variable for it
    p_internalWrStoreBuf := p_WrFiFoBuf;        // Take a snapshot of p_WrFiFoBuf
    p_WrFiFoBuf          += NrOfBytes;          // Set writepointer for next datalogging
    if p_WrFiFoBuf > p_EndStoreBuf then
      // Wrap around
      offset      := (p_WrFiFoBuf $ DINT) - (p_EndStoreBuf $ DINT) - 1;
      p_WrFiFoBuf := p_StoreBuf + Offset;
      
    end_if;

    
    FiFoByteCntInProgres -= NrOfBytes;          // Administration handled, In progress is finished
    
    // From here area in buffer is reserved for actual message
    while NrOfBytes > 0 do
      if p_internalWrStoreBuf > p_EndStoreBuf then
        // Wrap around
        p_internalWrStoreBuf := p_StoreBuf;
        
      end_if;
      
      if (FiFoByteCnt < BufferSize) then
        // Buffer not full
        FiFoByteCnt += 1;
        
      else
        // Buffer is full
        // For buffer mode cylic: create room,  
        p_RdFiFoBuf += 1;     // Move readpointer ahead.
        
        if p_RdFiFoBuf > p_EndStoreBuf then
          // Wrap around
          p_RdFiFoBuf := p_EndStoreBuf;
          
        end_if;

      end_if;
      
      p_internalWrStoreBuf^  := p_WrData^;      // Copy byte
      p_internalWrStoreBuf   += 1;              
      p_WrData               += 1;              
      NrOfBytes              -= 1;              // Rest nr of bytes to write
      NrOfWrBytes            += 1;              // Update nr of bytes written
    end_while;

  else
    // Data does not fit in our buffer
    FiFoByteCntInProgres -= NrOfBytes;          // We are finished
    
  end_if;
  
END_FUNCTION



//****************************************************************************************************************
//** Wewo_DynamicBuffer:: ReadFromFifoBuffer
//** Description:   Read Data from (First in First out buffer) and update readpointer.
//**                If no 
//**
//** Paramaters:    pointer to store read data
//**                Nr of bytes to read from Fifo buffer.
//**
//** Return         Nr of bytes read from Fifo buffer
//**
//****************************************************************************************************************
FUNCTION GLOBAL Wewo_DynamicBuffer::ReadFromFifoBuffer
	VAR_INPUT
		p_RdData 	: ^CHAR;
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		RdCnt 	: UDINT;
	END_VAR

  RdCnt := 0;
  
  while (     (NrOfBytes   > 0)     // Nr of bytes left to read
        L_AND (FiFoByteCnt > 0)     // Nr of bytes left in our buffer
        )do
    if p_RdFiFoBuf > p_EndStoreBuf then
      // Wrap around
      p_RdFiFoBuf := p_StoreBuf;
      
    end_if;

    p_RdData^   := p_RdFiFoBuf^;  // Copy byte
    p_RdData    += 1;             // Next destination
    p_RdFiFoBuf += 1;             // Next src 
    NrOfBytes   -= 1;             // Nr of bytes left to read
    FiFoByteCnt -= 1;             // Nr of bytes left in buffer
    
    RdCnt       += 1;             // Update return value: Nr of bytes read from buffer 
  end_while;
   
END_FUNCTION


FUNCTION GLOBAL Wewo_DynamicBuffer::GetBufferPointer
	VAR_OUTPUT
		p_BufPointer 	: ^CHAR;
	END_VAR

  p_BufPointer := p_StoreBuf;
  
END_FUNCTION


FUNCTION GLOBAL Wewo_DynamicBuffer::GetBufferSize
	VAR_OUTPUT
		BufSize 	: UDINT;
	END_VAR

  BufSize := BufferSize;
  
END_FUNCTION


FUNCTION GLOBAL Wewo_DynamicBuffer::WriteToBuffer
	VAR_INPUT
		Idx 	: UDINT;
		p_WrValue 	: pVoid;
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		NrOfWrBytes 	: UDINT;
	END_VAR
  
	VAR
		p_Buf : ^CHAR;
	END_VAR

  NrOfWrBytes := 0;
  
  p_Buf := p_StoreBuf;
  p_Buf += Idx;                 // Set first destinition byte 

  while (NrOfBytes > 0) do

    if p_Buf > p_EndStoreBuf then
      Exit;     // End of buffer reached
      
    end_if;
    
    p_Buf^      := (p_WrValue^ $ CHAR);   // Copy byte
    p_Buf       += 1;                     // Next Destination byte
    p_WrValue   += 1;                     // Next src byte
    NrOfBytes   -= 1;                     // Nr of byte left
    NrOfWrBytes += 1;                     // Update return value
  end_while;

END_FUNCTION


FUNCTION GLOBAL Wewo_DynamicBuffer::ReadFromBuffer
	VAR_INPUT
		Idx 	: UDINT;
		p_RdValue 	: pVoid;
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		NrOfRdBytes 	: UDINT;
	END_VAR

	VAR
		p_Buf : ^CHAR;
	END_VAR

  NrOfRdBytes := 0;
  
  p_Buf := p_StoreBuf;
  p_Buf += Idx;                   // Set first source byte 

  while (NrOfBytes > 0) do

    if p_Buf > p_EndStoreBuf then
      Exit;     // End of buffer reached
      
    end_if;
    
    p_RdValue^ $ CHAR := p_Buf^;  // Copy byte
    p_Buf             += 1;       // Next Destination byte
    p_RdValue         += 1;       // Next src byte
    NrOfBytes         -= 1;       // Nr of byte left
    NrOfRdBytes       += 1;       // Update return value
  end_while;

END_FUNCTION


FUNCTION GLOBAL Wewo_DynamicBuffer::WriteToBufferSegment
	VAR_INPUT
		Segment 	: UDINT;
		Idx 	: UDINT;
		p_WrValue 	: pVoid;
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		NrOfWrBytes 	: UDINT;
	END_VAR
  
	VAR
		p_Object : pVoid;
	END_VAR

  NrOfWrBytes := 0;
  
  // Get buffersegment
  p_Object := This;
  while (Segment > 0) do
    p_Object := p_Object^ $ Wewo_DynamicBuffer.GetNextObjectPtr();
    Segment -= 1;
  end_while;
  
  if p_Object <> NIL then
    // Segment found
    NrOfWrBytes := p_Object^ $ Wewo_DynamicBuffer.WriteToBuffer(Idx:=Idx, p_WrValue:=p_WrValue, NrOfBytes:=NrOfBytes);
  end_if;

END_FUNCTION


FUNCTION GLOBAL Wewo_DynamicBuffer::ReadFromBufferSegment
	VAR_INPUT
		Segment 	: UDINT;
		Idx 	: UDINT;
		p_RdValue 	: pVoid;
		NrOfBytes 	: UDINT;
	END_VAR
	VAR_OUTPUT
		NrOfRdBytes 	: UDINT;
	END_VAR

	VAR
		p_Object : pVoid;
	END_VAR

  NrOfRdBytes := 0;
  
  // Get buffersegment
  p_Object := This;
  while (Segment > 0) do
    p_Object := p_Object^ $ Wewo_DynamicBuffer.GetNextObjectPtr();
    Segment -= 1;
  end_while;
  
  if p_Object <> NIL then
    // Segment found
    NrOfRdBytes := p_Object^ $ Wewo_DynamicBuffer.ReadFromBuffer(Idx:=Idx, p_RdValue:=p_RdValue, NrOfBytes:=NrOfBytes);
  end_if;

END_FUNCTION




