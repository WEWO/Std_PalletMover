//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define AUTOTIMERLIMIT 3 SEC
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "Curtis_AC2F"
	Revision           = "0.0"
	GUID               = "{03258014-E247-4D6F-A4A8-AA28ED8603DA}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "5 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(750,3540)">
	<Channels>
		<Server Name="BusyReferencing" GUID="{2EE50B83-12D4-4D3C-AEDF-CC06F3E81169}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="EMStop_DiagCode" GUID="{6AFA29CD-1642-4544-8E1C-710FA8AB0337}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="EncoderValue" GUID="{1E46EEDA-E204-4044-A290-1D3B25BE1B8E}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Eq_DiagCode" GUID="{D9BBB2F3-CAC3-4F8C-B6B4-E5DF276C0BD5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Fault" GUID="{4031A4E2-4F39-4A93-ABC7-E014D3C8C796}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="FaultCode" GUID="{1EF1E369-B6F9-4554-93FC-A27D135A0CCC}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="MonitorValue" GUID="{1FE3B08A-C12A-4385-8DE5-2275280904ED}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ParameterMonitorCase" GUID="{AD8DD23A-C457-4EAF-AC9D-ADB9923671EC}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ParameterValue" GUID="{CA330E8F-019D-4C90-89D6-D30B28FFB92D}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="ReleaseBrake" GUID="{FDA3F17D-EF76-4386-A16F-66E5DAB7F45B}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="Interlock" Required="true" Internal="false"/>
		<Client Name="objCurtis_AC2F_IO" Required="true" Internal="false"/>
		<Client Name="ReleaseBrakesRequest" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="0"/>
			<SepChn Position="5"/>
			<SepChn Position="7"/>
		</Servers>
	</Separators>
	<Network Name="Curtis_AC2F">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{F7739DEC-F633-4991-870C-340ADB08B953}"
				Class      = "Curtis_Base"
				Position   = "(218,120)"
				Visualized = "true">
				<Channels>
					<Server Name="Active"/>
					<Server Name="AI_BrakePot"/>
					<Server Name="AI_ThrottlePot"/>
					<Server Name="AutoAccelTime" Value="100"/>
					<Server Name="AutoAct"/>
					<Server Name="AutoDecelTime" Value="10"/>
					<Server Name="AutomaticSetpoint"/>
					<Server Name="AutoSetp"/>
					<Server Name="BDI"/>
					<Server Name="BrakePotSigned"/>
					<Server Name="Capacitor_Voltage"/>
					<Server Name="ClassSvr"/>
					<Server Name="CommunicationOk"/>
					<Server Name="DriveMode"/>
					<Server Name="DriveModeRequest"/>
					<Server Name="EmStopOk"/>
					<Server Name="Enabled" Value="1"/>
					<Server Name="I_DigitalOut6"/>
					<Server Name="I_DigitalOut7"/>
					<Server Name="I_Driver1"/>
					<Server Name="I_Driver2"/>
					<Server Name="I_Driver3"/>
					<Server Name="I_Driver4"/>
					<Server Name="I_PropDriver"/>
					<Server Name="I_Switch1"/>
					<Server Name="I_Switch16"/>
					<Server Name="I_Switch2"/>
					<Server Name="I_Switch3"/>
					<Server Name="I_Switch4"/>
					<Server Name="I_Switch5"/>
					<Server Name="I_Switch6"/>
					<Server Name="I_Switch7"/>
					<Server Name="I_Switch8"/>
					<Server Name="InterlockExternal1"/>
					<Server Name="InterlockExternal2"/>
					<Server Name="InterlockFeedback"/>
					<Server Name="MotorCurrent"/>
					<Server Name="MotorRPM"/>
					<Server Name="MotorTemperature"/>
					<Server Name="QD_DigitalOut6"/>
					<Server Name="QD_DigitalOut7"/>
					<Server Name="QD_Driver1"/>
					<Server Name="QD_Driver2"/>
					<Server Name="QD_Driver3"/>
					<Server Name="QD_Driver4"/>
					<Server Name="QD_PropDriver"/>
					<Server Name="Referenced"/>
					<Server Name="ThrottlePotSigned"/>
					<Client Name="AlarmStartId"/>
					<Client Name="NodeId" Value="1"/>
					<Client Name="objDriver"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(916,210),(744,210),"/>
			<Connection Source="this.Active" Destination="_base.Active" Vertices="(916,270),(744,270),"/>
			<Connection Source="this.CommunicationOk" Destination="_base.CommunicationOk" Vertices="(916,330),(744,330),"/>
			<Connection Source="this.DriveMode" Destination="_base.DriveMode" Vertices="(916,390),(744,390),"/>
			<Connection Source="this.EmStopOk" Destination="_base.EmStopOk" Vertices="(916,450),(744,450),"/>
			<Connection Source="this.Referenced" Destination="_base.Referenced" Vertices="(916,510),(744,510),"/>
			<Connection Source="this.InterlockFeedback" Destination="_base.InterlockFeedback" Vertices="(916,570),(744,570),"/>
			<Connection Source="this.InterlockExternal1" Destination="_base.InterlockExternal1" Vertices="(916,630),(744,630),"/>
			<Connection Source="this.InterlockExternal2" Destination="_base.InterlockExternal2" Vertices="(916,690),(744,690),"/>
			<Connection Source="this.AutoAct" Destination="_base.AutoAct" Vertices="(916,750),(744,750),"/>
			<Connection Source="this.AutoSetp" Destination="_base.AutoSetp" Vertices="(916,810),(744,810),"/>
			<Connection Source="this.MotorCurrent" Destination="_base.MotorCurrent" Vertices="(916,870),(744,870),"/>
			<Connection Source="this.BDI" Destination="_base.BDI" Vertices="(916,930),(744,930),"/>
			<Connection Source="this.Capacitor_Voltage" Destination="_base.Capacitor_Voltage" Vertices="(916,990),(744,990),"/>
			<Connection Source="this.MotorTemperature" Destination="_base.MotorTemperature" Vertices="(916,1050),(744,1050),"/>
			<Connection Source="this.AI_ThrottlePot" Destination="_base.AI_ThrottlePot" Vertices="(916,1110),(744,1110),"/>
			<Connection Source="this.AI_BrakePot" Destination="_base.AI_BrakePot" Vertices="(916,1170),(744,1170),"/>
			<Connection Source="this.I_Switch1" Destination="_base.I_Switch1" Vertices="(916,1230),(744,1230),"/>
			<Connection Source="this.I_Switch2" Destination="_base.I_Switch2" Vertices="(916,1290),(744,1290),"/>
			<Connection Source="this.I_Switch3" Destination="_base.I_Switch3" Vertices="(916,1350),(744,1350),"/>
			<Connection Source="this.I_Switch4" Destination="_base.I_Switch4" Vertices="(916,1410),(744,1410),"/>
			<Connection Source="this.I_Switch5" Destination="_base.I_Switch5" Vertices="(916,1470),(744,1470),"/>
			<Connection Source="this.I_Switch6" Destination="_base.I_Switch6" Vertices="(916,1530),(744,1530),"/>
			<Connection Source="this.I_Switch7" Destination="_base.I_Switch7" Vertices="(916,1590),(744,1590),"/>
			<Connection Source="this.I_Switch8" Destination="_base.I_Switch8" Vertices="(916,1650),(744,1650),"/>
			<Connection Source="this.I_Driver1" Destination="_base.I_Driver1" Vertices="(916,1710),(744,1710),"/>
			<Connection Source="this.I_Driver2" Destination="_base.I_Driver2" Vertices="(916,1770),(744,1770),"/>
			<Connection Source="this.I_Driver3" Destination="_base.I_Driver3" Vertices="(916,1830),(744,1830),"/>
			<Connection Source="this.I_Driver4" Destination="_base.I_Driver4" Vertices="(916,1890),(744,1890),"/>
			<Connection Source="this.I_PropDriver" Destination="_base.I_PropDriver" Vertices="(916,1950),(744,1950),"/>
			<Connection Source="this.I_DigitalOut6" Destination="_base.I_DigitalOut6" Vertices="(916,2010),(744,2010),"/>
			<Connection Source="this.I_DigitalOut7" Destination="_base.I_DigitalOut7" Vertices="(916,2070),(744,2070),"/>
			<Connection Source="this.I_Switch16" Destination="_base.I_Switch16" Vertices="(916,2130),(744,2130),"/>
			<Connection Source="this.MotorRPM" Destination="_base.MotorRPM" Vertices="(916,2190),(744,2190),"/>
			<Connection Source="this.Enabled" Destination="_base.Enabled" Vertices="(916,2250),(744,2310),"/>
			<Connection Source="this.ThrottlePotSigned" Destination="_base.ThrottlePotSigned" Vertices="(916,2310),(744,2370),"/>
			<Connection Source="this.BrakePotSigned" Destination="_base.BrakePotSigned" Vertices="(916,2370),(744,2430),"/>
			<Connection Source="this.DriveModeRequest" Destination="_base.DriveModeRequest" Vertices="(916,2430),(744,2550),"/>
			<Connection Source="this.AutomaticSetpoint" Destination="_base.AutomaticSetpoint" Vertices="(916,2490),(744,2610),"/>
			<Connection Source="this.AutoAccelTime" Destination="_base.AutoAccelTime" Vertices="(916,2550),(744,2670),"/>
			<Connection Source="this.AutoDecelTime" Destination="_base.AutoDecelTime" Vertices="(916,2610),(744,2730),"/>
			<Connection Source="this.QD_Driver1" Destination="_base.QD_Driver1" Vertices="(916,2670),(744,2790),"/>
			<Connection Source="this.QD_Driver2" Destination="_base.QD_Driver2" Vertices="(916,2730),(744,2850),"/>
			<Connection Source="this.QD_Driver3" Destination="_base.QD_Driver3" Vertices="(916,2790),(744,2910),"/>
			<Connection Source="this.QD_Driver4" Destination="_base.QD_Driver4" Vertices="(916,2850),(744,2970),"/>
			<Connection Source="this.QD_PropDriver" Destination="_base.QD_PropDriver" Vertices="(916,2910),(744,3030),"/>
			<Connection Source="this.QD_DigitalOut6" Destination="_base.QD_DigitalOut6" Vertices="(916,2970),(744,3090),"/>
			<Connection Source="this.QD_DigitalOut7" Destination="_base.QD_DigitalOut7" Vertices="(916,3030),(744,3150),"/>
			<Connection Source="_base.AlarmStartId" Destination="this.AlarmStartId" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.NodeId" Destination="this.NodeId" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.objDriver" Destination="this.objDriver" Vertices="(218,330),(38,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using Curtis_Base

Curtis_AC2F : CLASS
: Curtis_Base
	TYPE
	  tCurtisFault :  //! <Type Public="true" Name="tCurtisFault"/>
	  (
	    cf_NoFault:=0,
	    cf_ControllerOvercurrent:=18,
	    cf_CurrentSensorFault:=19,
	    cf_PrechargeFailed:=20,
	    cf_ControllerSevereUndertemp:=21,
	    cf_ControllerSevereOvertemp:=22,
	    cf_SevereBPlusUndervoltage:=23,
	    cf_SevereBPlusOvervoltage:=24,
	    cf_ControllerOvertempCutback:=34,
	    cf_BPlusUndervoltageCutback:=35,
	    cf_BPlusOvervoltageCutback:=36,
	    cf_5VSupplyFailure:=37,
	    cf_DigitalOut6OpenShort:=38,
	    cf_DigitalOut7OpenShort:=39,
	    cf_MotorTempHotCutback:=40,
	    cf_MotorTempSensorFault:=41,
	    cf_Coil1DriverOpenShort:=49,
	    cf_Coil2DriverOpenShort:=50,
	    cf_Coil3OpenShort:=51,
	    cf_Coil4OpenShort:=52,
	    cf_PDOpenShort:=53,
	    cf_EncoderFault:=54,
	    cf_MotorOpen:=55,
	    cf_MainContactorWelded:=56,
	    cf_MainContactorDidNotClose:=57,
	    cf_ThrottleWiperHigh:=64,
	    cf_ThrottleWiperLow:=65,
	    cf_Pot2WiperHigh:=66,
	    cf_Pot2WiperLow:=68,
	    cf_PotLowOvercurrent:=69,
	    cf_EEPROMFailure:=70,
	    cf_HPDSequencingFault:=71,
	    cf_EmerRevHPD:=72,
	    cf_ParameterChangeFault:=73,
	    cf_ExternalSupplyOutOfRange:=105,
	    cf_OSGeneral:=113,
	    cf_PDOTimeout:=114,
	    cf_StallDetected:=115,
	    cf_FaultOnOtherTractionController:=116,
	    cf_DualSevereFault:=117,
	    cf_SupervisorFault:=119,
	    cf_SupervisorIncompatible:=120,
	    cf_BadCalibrations:=130,
	    cf_DriverSupply:=131,
	    cf_MotorCharacterizationFault:=135,
	    cf_EncoderPulseCountFault:=136,
	    cf_MotorTypeFault:=137,
	    cf_VCLOSMismatch:=145,
	    cf_EMBrakeFailedToSet:=146,
	    cf_EncoderLOS:=147,
	    cf_EMRRevTimeout:=148,
	    cf_IllegalModelNumber:=152,
	    cf_DualmotorParameterMismatch:=153,
	    cf_VCLRuntimeError:=201
	  )$UDINT;
	END_TYPE
  //Servers:
	EMStop_DiagCode 	: SvrCh_DINT;
	Eq_DiagCode 	: SvrCh_DINT;
	FaultCode 	: SvrCh_DINT;
	Fault 	: SvrCh_tCurtisFault_PTofCls_Curtis_AC2F;
	EncoderValue 	: SvrCh_DINT;
	ParameterMonitorCase 	: SvrCh_DINT;
	ParameterValue 	: SvrCh_DINT;
	MonitorValue 	: SvrCh_REAL;
	BusyReferencing 	: SvrCh_DINT;
	ReleaseBrake 	: SvrCh_DINT;
  //Clients:
	objCurtis_AC2F_IO 	: CltChCmd_Curtis_AC2F_IO;
	ReleaseBrakesRequest 	: CltCh_DINT;
	Interlock 	: CltCh_DINT;
  //Variables:
		_initCounter 	: DINT;
		autoTimer 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION VIRTUAL _receiveData;
	
	FUNCTION VIRTUAL _sendData;
	
	FUNCTION VIRTUAL _handleDriveMode;
	
	FUNCTION GLOBAL StartReferencing;
	
	FUNCTION GLOBAL StopReferencing;
	
	FUNCTION _setAlarms;
	
	FUNCTION _handleAlarmStates;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd Curtis_AC2F_IO


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB Curtis_AC2F::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CURTIS_AC2F
0$UINT, 0$UINT, (SIZEOF(::Curtis_AC2F))$UINT, 
10$UINT, 3$UINT, 0$UINT, 
TO_UDINT(883538238), "Curtis_AC2F", //Class
TO_UDINT(3229075938), "Curtis_Base", 0$UINT, 0$UINT, //Baseclass
//Servers:
(::Curtis_AC2F.EMStop_DiagCode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(818494892), "EMStop_DiagCode", 
(::Curtis_AC2F.Eq_DiagCode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(99796109), "Eq_DiagCode", 
(::Curtis_AC2F.FaultCode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(177654636), "FaultCode", 
(::Curtis_AC2F.Fault.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1753488403), "Fault", 
(::Curtis_AC2F.EncoderValue.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4113438399), "EncoderValue", 
(::Curtis_AC2F.ParameterMonitorCase.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3446115830), "ParameterMonitorCase", 
(::Curtis_AC2F.ParameterValue.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(74731799), "ParameterValue", 
(::Curtis_AC2F.MonitorValue.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1820533726), "MonitorValue", 
(::Curtis_AC2F.BusyReferencing.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3952360337), "BusyReferencing", 
(::Curtis_AC2F.ReleaseBrake.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2479010967), "ReleaseBrake", 
//Clients:
(::Curtis_AC2F.objCurtis_AC2F_IO.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1815860584), "objCurtis_AC2F_IO", TO_UDINT(3951156929), "Curtis_AC2F_IO", 0$UINT, 0$UINT, 
(::Curtis_AC2F.ReleaseBrakesRequest.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(483176851), "ReleaseBrakesRequest", 
(::Curtis_AC2F.Interlock.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4071428699), "Interlock", 
END_FUNCTION


#define USER_CNT_Curtis_AC2F 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_Curtis_AC2F] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION Curtis_AC2F::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= Curtis_Base::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= Curtis_Base::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, Curtis_Base::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_Curtis_AC2F;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #_receiveData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #_sendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #_handleDriveMode();

#pragma warning (default : 74)
	Curtis_Base::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Curtis_Base::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParameterMonitorCase.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParameterMonitorCase.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ParameterValue.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ParameterValue.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	BusyReferencing.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF BusyReferencing.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ReleaseBrake.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ReleaseBrake.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL Curtis_AC2F::Init
  _initCounter += 1;


  
END_FUNCTION


FUNCTION VIRTUAL Curtis_AC2F::_HandleDriveMode
     
  if (_prevReferenced <> Referenced & Referenced = False) | (EmStopOk <> TRUE) then
    _notReferencedStartTime := ops.tAbsolute;
  elsif Referenced = True then
    _notReferencedStartTime := ops.tAbsolute;
  end_if;  
        
  if Referenced = False & _prevReferenced = False & (ops.tAbsolute - _notReferencedStartTime) > REFERENCETIMEOUT then
    //_setAlarm(ca_NotRef);  
  end_if;  
 
  case _DriveModeReqStepper of
   0:
   
      if  ( DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_EmergencyStop | DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_TimeOut)  &
          ( (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Idle & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Idle ) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Manual  & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Manual) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Automatic  & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Auto) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_Reference  & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_Referencing) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetDrive & DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_DriveReset) |
            (DriveModeRequest = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetExtInterlock & (DriveMode <> Curtis_Base::eCurtisDriveMode::cdm_ExtInterlockReset ) ) ) then
        
        //act mode differs to requested mode
        _IntDriveModeReq := DriveModeRequest;
        _DriveModeRequestTime := ops.tAbsolute;
        _DriveModeReqStepper := 1;
        
      end_if;
      
    1:
        if (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Idle & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Idle ) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Manual  & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Manual) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Automatic  & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Auto) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_Reference  & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_Referencing) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetDrive & DriveMode = Curtis_Base::eCurtisDriveMode::cdm_DriveReset) |
          (_IntDriveModeReq = Curtis_Base::eCurtisDriveModeRequest::cdmr_ResetExtInterlock & (DriveMode = Curtis_Base::eCurtisDriveMode::cdm_ExtInterlockReset )) then
          //succesfull change of drive mode
          _DriveModeRequestTime := ops.tAbsolute;
          _IntDriveModeReq := Curtis_Base::eCurtisDriveModeRequest::cdmr_NoReq;
          _DriveModeReqStepper := 2;
          
        elsif (ops.tAbsolute - _DriveModeRequestTime > MAX_TIME_DRIVE_MODE_REQ) then
          //not changed mode go for retry
         ////// Curtis F _RIWO_WARNING_MSG1("switching drive mode from:{0} to:{1} not possible", DriveMode$DINT, _IntDriveModeReq$DINT);
          _DriveModeRequestTime := ops.tAbsolute;
          _IntDriveModeReq := Curtis_Base::eCurtisDriveModeRequest::cdmr_NoReq;
          _DriveModeReqStepper := 2;
    
        end_if;
    2:
        //wait for no request command to be send over
        if (ops.tAbsolute - _DriveModeRequestTime > MAX_TIME_DRIVE_MODE_REQ) then
          _DriveModeReqStepper := 0;
        end_if;
      
  end_case;

END_FUNCTION

FUNCTION VIRTUAL Curtis_AC2F::_receiveData    
  VAR
    PDOSplitOut1     : BSINT;
    PDOSplitOut2     : BSINT;
  END_VAR
    
  //----------------------------------------------------
  // Read out PDO_RX1 with identifier 0x180 + NodeID
  //----------------------------------------------------
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx1, Value1:= #_pdoIn1.Val1, Value2:= #_pdoIn1.Val2, Value3:= #_pdoIn1.Val3, Value4:= #_pdoIn1.Val4) = 0 then
    // Received value     
    _pdo1RxInterval := (ops.tAbsolute - _pdo1rxTime);
    _pdo1rxTime := ops.tAbsolute;    // time the valid response was receive
    _prevReferenced := Referenced;
    
    DriveMode           := to_dint(_pdoIn1.Val1 and 16#00FF)$eCurtisDriveMode;
    EmStopOk            := to_bool(_pdoIn1.Val1 and 16#0100);
    CommunicationOk     := to_bool(_pdoIn1.Val1 and 16#0200); //online
    Referenced          := to_bool(_pdoIn1.Val1 and 16#0400);
    InterlockFeedback   := to_bool(_pdoIn1.Val1 and 16#0800);
    _tempOk             := to_bool(_pdoIn1.Val1 and 16#4000);
    _DriveCycleTimeOk   := to_bool(_pdoIn1.Val1 and 16#8000);
    EMStop_DiagCode := to_dint(_pdoIn1.Val2 and 16#00FF);   
    Eq_DiagCode   := ((_pdoIn1.Val2 and 16#FF00)shr 8)$hsint; 
    AutoSetp := to_dint(_pdoIn1.Val3);
  end_if;
  
  //----------------------------------------------------
  // Read out PDO_RX2 with identifier 0x280 + NodeID
  //----------------------------------------------------
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx2, Value1:= #_pdoIn2.Val1, Value2:= #_pdoIn2.Val2, Value3:= #_pdoIn2.Val3, Value4:= #_pdoIn2.Val4) = 0 then // message received
    
    _pdo2rxTime             := ops.tAbsolute;    // time the valid response was received
    
    MotorRPM                := to_dint(_pdoIn2.Val1);
    MotorCurrent            := to_dint(_pdoIn2.Val2);
    EncoderValue            := to_dint(_pdoIn2.Val3);
    MotorTemperature        := to_dint(_pdoIn2.Val4);
    
  end_if; 
    
  //----------------------------------------------------
  // Read out PDO_RX3 with identifier 0x380 + NodeID
  //---------------------------------------------------- 
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx3, Value1:= #_pdoIn3.Val1, Value2:= #_pdoIn3.Val2, Value3:= #_pdoIn3.Val3, Value4:= #_pdoIn3.Val4) = 0 then
    
    _pdo3rxTime := ops.tAbsolute;
    
    // Get potentiometer input
    if ThrottlePotSigned = 1 then
      AI_ThrottlePot := to_dint(_pdoIn3.Val1);
    else
      AI_ThrottlePot := to_dint(to_uint(_pdoIn3.Val1));
    end_if;
    
    // Get potentiometer input
    if BrakePotSigned = 1 then
      AI_BrakePot := to_dint(_pdoIn3.Val2); 
    else
      AI_BrakePot := to_dint(to_uint(_pdoIn3.Val2));
    end_if;
    
    // Get input switches 32 bit
    _Split16bit(Input16bit:=_pdoIn3.Val3, #PDOSplitOut1, #PDOSplitOut2); 
    
    objCurtis_AC2F_IO.UpdateInput(PDOSplitOut1, PDOSplitOut2);
    
    // Getting the voltage on the drive.
    Capacitor_Voltage := to_dint(_pdoIn3.Val4);
    
    if Capacitor_Voltage > 100 | EmStopOk <> TRUE then
      _FuseBadStartTime := ops.tAbsolute;
    end_if;
    
    // Set or reset fuse alarm only when there is communication and voltage is below 10,0V
    if Capacitor_Voltage <= 100 & EmStopOk = TRUE & (ops.tAbsolute - _FuseBadStartTime) > FUSE_BAD_TIME then
      //_setAlarm(ca_FuseBad);
    end_if;
    
  end_if;

  //----------------------------------------------------
  // Read out PDO_RX4 with identifier 0x480 + NodeID
  //----------------------------------------------------
  if _CanOpenBaseRiwo.DecoPDO(PdoId:= cPdoRx4, Value1:= #_pdoIn4.Val1, Value2:= #_pdoIn4.Val2, Value3:= #_pdoIn4.Val3, Value4:= #_pdoIn4.Val4) = 0 then   
  
    if to_dint(_pdoIn4.Val1) = 1 then
      BDI := to_dint(_pdoIn4.Val2);
    end_if;
    
    FaultCode := to_dint(_pdoIn4.Val4);
    Fault := to_udint(FaultCode)$tCurtisFault;
    if FaultCode <> 0 then
      _setAlarms();
    end_if;

  end_if; 

END_FUNCTION

FUNCTION VIRTUAL Curtis_AC2F::_sendData
VAR
	tmpOutputReq  :BINT;
  Message2      :BOOL;
END_VAR

  //---------------------------------------------
  // Send out PDO_TX1 with identifier 0x200 + NodeID
  //----------------------------------------------------

  if (ops.tAbsolute - _sendPDO1TimeStamp) > PDO1_SEND_INTERVAL then
    
    _pdo1Out.Val1 := _IntDriveModeReq$INT;
    
    tmpOutputReq :=     objCurtis_AC2F_IO.UpdateOutput(); 
     
    ReleaseBrake := ReleaseBrakesRequest;
    tmpOutputReq += ReleaseBrake shl 6;    
       
    _pdo1Out.Val2 := tmpOutputReq$INT;
    _pdo1Out.Val3 := AutomaticSetpoint$INT;
    _pdo1Out.Val4 := ((AutoDecelTime$INT AND 16#FF) shl 8) or (AutoAccelTime$INT AND 16#FF);
    
    if _CanOpenBaseRiwo.SendPDO(PdoId:=cPdoTx1, Bytes:=8, Value1:=_pdo1Out.Val1, Value2:=_pdo1Out.Val2, Value3:=_pdo1Out.Val3, Value4:=_pdo1Out.Val4) = 0 then
      _sendPDO1TimeStamp := ops.tAbsolute;

    // Received valid response

    end_if;
    
    if _CanOpenBaseRiwo.SendPDO(PdoId:=cPdoTx2, Bytes:=8, Value1:=ParameterMonitorCase$INT, Value2:=1, Value3:=2, Value4:=3) = 0 then
      Message2 := TRUE ;
    // Received valid response

    end_if;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL Curtis_AC2F::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR

  if IsClientConnected(input:=#objDriver) = TRUE & Enabled = 1 then
  
    Interlock := Interlock.Read();
    
    if Referenced = false | DriveMode = Curtis_Base::cdm_EmergencyStop then
      autoTimer := ops.tAbsolute;
    end_if;
    if ((ops.tAbsolute - autoTimer) > AUTOTIMERLIMIT & DriveMode <> Curtis_Base::cdm_Auto) & Interlock = FALSE then
      DriveModeRequest := Curtis_Base::cdmr_Automatic;
    end_if;
    
    if Interlock = TRUE & DriveMode <> Curtis_Base::cdm_EmergencyStop then
      DriveModeRequest := cdmr_Idle;
    end_if;
    
    _HandleDriveMode();
    
    if IsClientConnected(#ReleaseBrakesRequest) then
      ReleaseBrakesRequest := ReleaseBrakesRequest.Read();
    end_if;
    
    if _CanOpenBaseRiwo.Server0 >= 0 then
      _receiveData();
      _sendData();  
    end_if;
    
    if (ops.tAbsolute - _timeoutDelayStart) > TIMEOUTDELAY then
      _StartupDelayActive := FALSE;
    end_if;
    
    // Delay on the timeout check to allow system to establish connection first on startup.
    
    if  (_StartupDelayActive = FALSE) & 
        ( (ops.tAbsolute - _pdo1rxTime) > COMM_TIMEOUT | (ops.tAbsolute - _pdo2rxTime) > COMM_TIMEOUT | (ops.tAbsolute - _pdo3rxTime) > COMM_TIMEOUT ) then
      // Activate timeout alarm if the cyclic messages aren't received or sent in time.
    
  
      CommunicationOk := FALSE ;
    end_if;
  end_if;
  
  
  _handleAlarmStates();

END_FUNCTION


FUNCTION GLOBAL Curtis_AC2F::StartReferencing

  BusyReferencing := 1;
  DriveModeRequest := cdmr_Reference;

END_FUNCTION


FUNCTION GLOBAL Curtis_AC2F::StopReferencing

  BusyReferencing := 0;
  DriveModeRequest := cdmr_NoReq;
  
END_FUNCTION


FUNCTION Curtis_AC2F::_setAlarms

  
END_FUNCTION



FUNCTION Curtis_AC2F::_handleAlarmStates
  
  
END_FUNCTION
