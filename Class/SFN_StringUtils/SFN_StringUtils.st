//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "SFN_StringUtils"
	Revision           = "0.10"
	GUID               = "{8F999CF9-2D58-48B1-889B-DA64F287B46C}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(660,120)"
	Comment            = "String utilities.&#13;&#10;&#13;&#10;Note: Lasal OS supports now also direct access to string functions.&#13;&#10;(see _memset() and &#13;&#10;">
	<Channels>
		<Server Name="ToObject" GUID="{F1A26105-F750-432C-9382-46CDE636176F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\SFN_StringUtils\SFN_StringUtils.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Safan" Author="HenOdi"/>
		<Dokumentation Revision="0.10" Date="2012-10-05" Author="HenOdi" Company="Safan" Description="Check for valid pointer parameters"/>
		<Dokumentation Revision="0.8" Date="3-11-2010" Author="HenOdi" Company="Safan" Description="Add StringCatLimited"/>
	</RevDoku>
</Class>
*)
SFN_StringUtils : CLASS
  //Servers:
	ToObject 	: SvrChCmd_DINT;
  //Clients:
  //Variables:
  //Functions:
	
	FUNCTION GLOBAL GetNextDelimiter
		VAR_INPUT
			p_Buf 	: ^CHAR;
			p_Delimiters 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			p_DelimiterChar 	: ^CHAR;
		END_VAR;
				//! <Function Comment="This method returns a zero-terminated substring.&#13;&#10;Parameters:&#13;&#10;-Delimiters       : a string containing the delimiters.&#13;&#10;-nrDelimiters     : the number of delimiters in the delimiter string.&#13;&#10;-InputBufferSize  : The size of the imput buffer&#13;&#10;-p_InputBuffer    : pointer to the input buffer&#13;&#10;-p_Substring      : pointer to the string the result wwill be stored in&#13;&#10;Returns:&#13;&#10;-If the substring is parsed successfully: the size of the returned substring&#13;&#10;-No delimiter is found: -1 " Name="GetSubString"/>
	FUNCTION GLOBAL GetSubString
		VAR_INPUT
			Delimiters 	: ^CHAR;
			NrDelimiters 	: BYTE;
			InputBufferSize 	: INT;
			p_InputBuffer 	: ^CHAR;
			p_Substring 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			NrCharsParsed 	: INT;
		END_VAR;
				//! <Function Comment="This method determines if a character is of type numeric.&#13;&#10;Parameters:&#13;&#10;-c    : character to be analyzed&#13;&#10;Returns:&#13;&#10;-true : character is numeric.&#13;&#10;-false: character is not numeric." Name="IsNumChar"/>
	FUNCTION GLOBAL IsNumChar
		VAR_INPUT
			c 	: CHAR;
		END_VAR
		VAR_OUTPUT
			RetVal 	: BOOL;
		END_VAR;
				//! <Function Comment="This method determines if a character is of type alpha.&#13;&#10;Parameters:&#13;&#10;-c    : character to be analyzed&#13;&#10;Returns:&#13;&#10;-true : character is alpha.&#13;&#10;-false: character is not alpha." Name="IsAlphaChar"/>
	FUNCTION GLOBAL IsAlphaChar
		VAR_INPUT
			c 	: CHAR;
		END_VAR
		VAR_OUTPUT
			RetVal 	: BOOL;
		END_VAR;
				//! <Function Comment="This method determines if a character is alphanumeric.&#13;&#10;Parameters:&#13;&#10;-c    : character to be analyzed&#13;&#10;Returns:&#13;&#10;-true : character is alphanumeric.&#13;&#10;-false: character is not alphanumeric." Name="IsAlphaNumChar"/>
	FUNCTION GLOBAL IsAlphaNumChar
		VAR_INPUT
			c 	: CHAR;
		END_VAR
		VAR_OUTPUT
			RetVal 	: BOOL;
		END_VAR;
	
	FUNCTION AddCharInString
		VAR_INPUT
			p_string 	: pChar;
			charValue 	: CHAR;
		END_VAR;
	
	FUNCTION GLOBAL ConvertUdintToAsciiHex
		VAR_INPUT
			p_string 	: ^CHAR;
			Value 	: UDINT;
			valueSize 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvertUdintToAsciiDec
		VAR_INPUT
			p_string 	: ^CHAR;
			Value 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvertDintToAsciiHex
		VAR_INPUT
			p_string 	: ^CHAR;
			Value 	: DINT;
			valueSize 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvertDintToAsciiDec
		VAR_INPUT
			p_string 	: ^CHAR;
			Value 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvertAsciiToDint
		VAR_INPUT
			p_string 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Output 	: DINT;
		END_VAR;
	
	FUNCTION ConvertAsciiHexToDint
		VAR_INPUT
			p_string 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Output 	: DINT;
		END_VAR;
	
	FUNCTION ConvertAsciiDecToDint
		VAR_INPUT
			p_string 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Output 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ConvertAsciiToUdint
		VAR_INPUT
			p_string 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Output 	: UDINT;
		END_VAR;
	
	FUNCTION ConvertAsciiHexToUdint
		VAR_INPUT
			p_string 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Output 	: UDINT;
		END_VAR;
	
	FUNCTION ConvertAsciiDecToUdint
		VAR_INPUT
			p_string 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Output 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL StringCat
		VAR_INPUT
			p_Dest 	: ^CHAR;
			p_Add 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL StringCatLimited
		VAR_INPUT
			p_Dest 	: ^CHAR;
			p_Add 	: ^CHAR;
			DestSize 	: UDINT;
		END_VAR;
				//! <Function Comment="This method compares 2 zero-terminated strings. The caller has to make sure both strings are zero-terminated.&#13;&#10;Parameters:&#13;&#10;-string1: A pointer to the first string&#13;&#10;-string2: A pointer to the second string&#13;&#10;Returns:&#13;&#10;-true   : if string2 and string2 are equal&#13;&#10;-false  : if string1 and string2 are not equal.  " Name="StringCompare"/>
	FUNCTION GLOBAL StringCompare
		VAR_INPUT
			p_String1 	: ^CHAR;
			p_String2 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			RetVal 	: BOOL;
		END_VAR;
				//! <Function Comment="Description:&#13;&#10;Copies a zero-terminated string from source to destination.&#13;&#10;Parameters:&#13;&#10;-p_Src    : pointer to the source string&#13;&#10;-p_Dest   : pointer to the destination string&#13;&#10;Returns   : nothing" Name="StringCopy"/>
	FUNCTION GLOBAL StringCopy
		VAR_INPUT
			p_Src 	: ^CHAR;
			p_Dest 	: ^CHAR;
		END_VAR;
				//! <Function Comment="This method determined the length of a given zero-terminated string. The user has to make sure the supplied &#13;&#10;string is zero-terminated.&#13;&#10;Parameters:&#13;&#10;-p_String : Pointer to the string.&#13;&#10;Returns   : The length of the given string including the zero-terminator" Name="StringLength"/>
	FUNCTION GLOBAL StringLength
		VAR_INPUT
			p_String 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Length 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL StringNCopy
		VAR_INPUT
			p_Src 	: ^CHAR;
			p_Dest 	: ^CHAR;
			size 	: UDINT;
		END_VAR;
				//! <Function Comment="Searches a (sub)string in a string" Name="StrStr"/>
	FUNCTION GLOBAL StrStr
		VAR_INPUT
			p_searchStr 	: ^CHAR;			//! <Variable Comment="string to search in" Name="StrStr.p_searchStr"/>
			p_lookforStr 	: ^CHAR;			//! <Variable Comment="String to look for in search string" Name="StrStr.p_lookforStr"/>
		END_VAR
		VAR_OUTPUT
			p_ReturnStr 	: ^CHAR;			//! <Variable Comment="Return the position in search string &#13;&#10;where the lookfor string is found.&#13;&#10;&#13;&#10;If lookfor string is not found &#13;&#10;or wrong parameters where used &#13;&#10;(NIL pointers) a NIL is returned" Name="StrStr.p_ReturnStr"/>
		END_VAR;
	
	FUNCTION GLOBAL Debug
		VAR_INPUT
			Msg 	: ^CHAR;
			Value_1 	: DINT;
			Value_2 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB SFN_StringUtils::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_SFN_STRINGUTILS
0$UINT, 10$UINT, (SIZEOF(::SFN_StringUtils))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(2685214234), "SFN_StringUtils", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::SFN_StringUtils.ToObject.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(4019907084), "ToObject", 
//Clients:
END_FUNCTION


#define USER_CNT_SFN_StringUtils 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_SFN_StringUtils] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION SFN_StringUtils::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
(********************************************************************************************
 ** SFN_StringUtils
 **
 ** T
 **
 ********************************************************************************************)


// Take over defines from SF_Base so we do not need Sf_Base in this class
#ifndef L_AND
  #define L_OR      |        // Logic OR
  #define L_AND     &        // Logic AND

#endif


(********************************************************************************************

This method merges two strings together. Nr of bytes in destination will never exceed the nr 
of bytes specified in DestSize.
string is zero-terminated.
Parameters:
-p_Dest   : Pointer to Destination string. This string contains the first part of the string.
            Second string is added in this string.
-P_Add    : Pointer to added string.
-DestSize : Maximum nr of bytes in destination
Returns   : The length of the given string including the zero-terminator
********************************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::StringCatLimited
	VAR_INPUT
		p_Dest 	: ^CHAR;
		p_Add 	: ^CHAR;
		DestSize 	: UDINT;
	END_VAR
  
  if (     (p_Dest <> NIL)
     L_AND (p_Add  <> NIL)
     ) then

    // Find end of first string
    while ( DestSize > 1 L_AND (p_Dest^ <> 0)) do
      p_Dest   += 1;
      DestSize -= 1;      // Nr of bytes left
    end_while;
    
    // Add string
    while ((DestSize > 1) L_AND (p_Add^ <> 0)) do
      p_Dest^ := p_Add^;
      p_Add   += 1;
      p_Dest  += 1;
      DestSize -= 1;      // Nr of bytes left in destination
    end_while;
    
    // Close string
    p_Dest^ := 0;       

  else
    TRACE("ERROR SFN_StringUtils::StringCatLimited: parameter NIL");
  end_if;
END_FUNCTION



(********************************************************************************************

This method merges two strings together
string is zero-terminated.
Parameters:
-p_Dest : Pointer to Destination string. This string contains the first part of the string.
          Second string is added in this string.
-P_Add  : Pointer to added string.
Returns : The length of the given string including the zero-terminator
********************************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::StringCat
	VAR_INPUT
		p_Dest 	: ^CHAR;
		p_Add 	: ^CHAR;
	END_VAR
  
  if (     (p_Dest <> NIL)
     L_AND (p_Add  <> NIL)
     ) then
    // Find end of first string
    while (p_Dest^ <> 0) do
      p_Dest +=1;
    end_while;
    
    // Add string
    while (p_Add^ <> 0) do
      p_Dest^ := p_Add^;
      p_Add   += 1;
      p_Dest  += 1;
    end_while;
    
    // Close string
    p_Dest^ := 0;       

  else
    TRACE("ERROR SFN_StringUtils::StringCat: parameter NIL");
  end_if;
END_FUNCTION


(********************************************************************************************

This method determined the length of a given zero-terminated string. 
The user has to make sure the supplied string is zero-terminated.
Parameters:
-p_String : Pointer to the string.
Returns   : The length of the given string excluding the zero-terminator
********************************************************************************************)

FUNCTION GLOBAL SFN_StringUtils::StringLength
	VAR_INPUT
		p_String 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Length 	: UINT;
	END_VAR
  
  Length := 0;

  if (p_String <> NIL) then
    while (p_String^ <> 0) do
      Length +=1;
      p_String +=1;
    end_while;
    
  else
    TRACE("ERROR SFN_StringUtils::StringLength: parameter NIL");
  end_if;
END_FUNCTION

(********************************************************************************************

Description:
Copies a zero-terminated string from source to destination.
Parameters:
-p_Src    : pointer to the source string
-p_Dest   : pointer to the destination string
Returns   : nothing
********************************************************************************************)

FUNCTION GLOBAL SFN_StringUtils::StringCopy
	VAR_INPUT
		p_Src 	: ^CHAR;
		p_Dest 	: ^CHAR;
	END_VAR

  if (     (p_Src <> NIL)
     L_AND (p_Dest  <> NIL)
     ) then
    repeat
      p_Dest^:= p_Src^;
      p_Src+=1;
      p_Dest+=1;
    until (p_Src^ = 0) end_repeat;
    p_Dest^ := p_Src^; //also copy zero terminator 
  
  else
    TRACE("ERROR SFN_StringUtils::StringCopy: parameter NIL");
  
  end_if;    
END_FUNCTION


(********************************************************************************
Description:
Copies a zero-terminated string from source to destination 
with a maximum of n-bytes. 

Parameters:
-p_Src    : pointer to the source string
-p_Dest   : pointer to the destination string
-size     : maximum number of bytes to copy (including zero-terminator)
Returns   : nothing
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::StringNCopy
	VAR_INPUT
		p_Src 	: ^CHAR;
		p_Dest 	: ^CHAR;
		size 	: UDINT;
	END_VAR
  
  VAR
  	nrOfBytes : udint;
  END_VAR

  if (     (p_Dest <> NIL)
     L_AND (p_Src  <> NIL)
     ) then

    nrOfBytes := 0;
    if size > 0 then
      size -= 1;   // keep space for zero terminator
      
      while ((nrOfBytes < size) | (p_Src^ = 0)) do
        p_Dest^   := p_Src^;
        p_Src     += 1;
        p_Dest    += 1;
        nrOfBytes += 1;
      end_while;
    
      p_Dest^ := p_Src^; //also copy zero terminator 
    
    end_if;

  else
    TRACE("ERROR SFN_StringUtils::StringNCopy: parameter NIL");
  end_if;
  
END_FUNCTION


(********************************************************************************
This method compares 2 zero-terminated strings. The caller has to make sure both strings are zero-terminated.
Parameters:
-string1: A pointer to the first string
-string2: A pointer to the second string
Returns:
-true   : if string2 and string2 are equal
-false  : if string1 and string2 are not equal.  
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::StringCompare
	VAR_INPUT
		p_String1 	: ^CHAR;
		p_String2 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		RetVal 	: BOOL;
	END_VAR
  VAR
  	c1,c2   : CHAR;
    idx     : BYTE;
    CompareDone :  BOOL;
  END_VAR

  if (     (p_String1 <> NIL)
     L_AND (p_String2 <> NIL)
     ) then
    RetVal := true;
    CompareDone := false;
    idx := 0;
    
    repeat
      c1 := (p_String1+idx)^;
      c2 := (p_String2+idx)^;
      if ((c1 = 0) & (c2 = 0))  then //reached the end of both strings simultaneously?
        CompareDone := true;  //strings are equal
      else
        if ((c1 = 0) | (c2 = 0)) then //reached end of one of the two strings?
          RetVal := false; //strings not equal
          CompareDone := true;
        else 
          if (c1 <> c2) then //chars not equal?
            RetVal := false; //strings are not equal
            CompareDone := true;
          end_if;
        end_if;
        idx+=1;
      end_if;
    until CompareDone end_repeat;

  else
    TRACE("ERROR SFN_StringUtils::StringCompare: parameter NIL");
    RetVal := FALSE;

  end_if;
END_FUNCTION

(********************************************************************************
This method returns a zero-terminated substring.
Parameters:
-Delimiters       : a string containing the delimiters.
-nrDelimiters     : the number of delimiters in the delimiter string.
-InputBufferSize  : The size of the imput buffer
-p_InputBuffer    : pointer to the input buffer
-p_Substring      : pointer to the string the result wwill be stored in
Returns:
-If the substring is parsed successfully: the size of the returned substring
-No delimiter is found: -1 
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::GetSubString
	VAR_INPUT
		Delimiters 	: ^CHAR;
		NrDelimiters 	: BYTE;
		InputBufferSize 	: INT;
		p_InputBuffer 	: ^CHAR;
		p_Substring 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		NrCharsParsed 	: INT;
	END_VAR
  VAR
    currChar : CHAR;
    cnt : BYTE;
    DelimiterFound : BOOL;
  END_VAR

  NrCharsParsed := -1;
  if (     (Delimiters <> NIL)
     L_AND (p_InputBuffer <> NIL)
     L_AND (p_Substring <> NIL)
     ) then
    
    DelimiterFound := false;
    
    //continue until delimiter found or end of input buffer reaches
    while ((!!DelimiterFound) & (NrCharsParsed < InputBufferSize)) do
      cnt := 0;
      DelimiterFound := false;

      NrCharsParsed += 1;
      currChar := (p_InputBuffer+NrCharsParsed)^;

      repeat
        if (currChar = (Delimiters+cnt)^) then 
          DelimiterFound := true;
        else
          cnt+=1;
        end_if;
      until DelimiterFound | (cnt = nrDelimiters) end_repeat;
      
      if (!!DelimiterFound) then
        (p_Substring+NrCharsParsed)^ := currChar;
      end_if;
    
    end_while;
    
    if (!!DelimiterFound) then
      NrCharsParsed := -1;
    else
      (p_Substring+NrCharsParsed)^ := 0;//zero terminator
      NrCharsParsed += 1;
    end_if;
  else
    TRACE("ERROR SFN_StringUtils::GetSubString: parameter NIL");
  end_if;

END_FUNCTION

(********************************************************************************
FUNCTION SFN_StringUtils::GetNextDelimiter
Search in string for specified delimters.
.
Parameters:
- p_buf        : Pointer to start of buffer. String is Zero-terminated
- p_Delimiters : Pointer to a string of delimter characters. String is Zero-terminated

Returns:
- Pointer in buffer containg a delimitter specified in delimiter string is found
  NIL if no delimiter is found
*********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::GetNextDelimiter
	VAR_INPUT
		p_Buf 	: ^CHAR;
		p_Delimiters 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		p_DelimiterChar 	: ^CHAR;
	END_VAR

  VAR
  	Found : BOOL;
  END_VAR


  p_DelimiterChar := NIL;
  if (     (p_Delimiters <> NIL)
     L_AND (p_Buf <> NIL)
     ) then
    
    Found           := FALSE;
    
    while (p_Buf^ <> 0)  do
    
      p_DelimiterChar := p_Delimiters;
      while p_DelimiterChar^ <> 0 do
        // check all delimiters
        Found := p_Buf^ =  p_DelimiterChar^;
        if Found then
          exit;       // Exit p_DelChar loop
        end_if;
        p_DelimiterChar += 1;

      end_while;
      
      if Found then
        exit;         // Exit p_Buf loop
      end_if;
      
      p_Buf += 1;     // Next 
      
    end_while;
    
    if (p_Buf^ <> 0) then
      p_DelimiterChar := p_Buf;
    else
      p_DelimiterChar := NIL;
    end_if;
  else
    TRACE("ERROR SFN_StringUtils::GetNextDelimiter: parameter NIL");
  end_if;

  
END_FUNCTION


(********************************************************************************
This method determines if a character is alphanumeric.
Parameters:
-c    : character to be analyzed
Returns:
-true : character is alphanumeric.
-false: character is not alphanumeric.
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::IsAlphaNumChar
	VAR_INPUT
		c 	: CHAR;
	END_VAR
	VAR_OUTPUT
		RetVal 	: BOOL;
	END_VAR
  
  if (IsAlphaChar(c) | IsNumChar(c) )then
    RetVal := true;
  else
    RetVal := false;
  end_if;
END_FUNCTION

(********************************************************************************
This method determines if a character is of type alpha.
Parameters:
-c    : character to be analyzed
Returns:
-true : character is alpha.
-false: character is not alpha.
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::IsAlphaChar
	VAR_INPUT
		c 	: CHAR;
	END_VAR
	VAR_OUTPUT
		RetVal 	: BOOL;
	END_VAR

  if ( ((c >= 'a') & (c <= 'z')) | ((c >= 'A') & (c <= 'Z')) ) then
    RetVal := true;
  else
    RetVal := false;
  end_if;

END_FUNCTION

(********************************************************************************
This method determines if a character is of type numeric.
Parameters:
-c    : character to be analyzed
Returns:
-true : character is numeric.
-false: character is not numeric.
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::IsNumChar
	VAR_INPUT
		c 	: CHAR;
	END_VAR
	VAR_OUTPUT
		RetVal 	: BOOL;
	END_VAR

  if (((c >= '0') & (c <= '9')) | c = '-') then
    RetVal := true;
  else
    RetVal := false;
  end_if;

END_FUNCTION

(***************************************************
  ConvertDintToAsciiDec

  Note: No floating points supported !!!
****************************************************)

FUNCTION GLOBAL SFN_StringUtils::ConvertDintToAsciiDec
	VAR_INPUT
		p_string 	: ^CHAR;
		Value 	: DINT;
	END_VAR
  
	VAR
		restValue : DINT;
    digit     : DINT;
    negValue  : BOOL;
	END_VAR

  negValue  := FALSE;

  if p_string <> NIL then
    // Storage location available
    if Value = 0 then
      p_string^     := '0';
      (p_string+1)^ := 0;  // Close string
    else
      p_string^ := 0;  // Be sure string is closed
      
      if Value < 0 then
        negValue  := TRUE;
        Value     := Value * -1;
      end_if;
      
      while Value > 0 do
        restValue := Value/10;
        digit := (Value - (restValue*10)) ;
        digit := digit + '0';                 // convert value to character
        AddCharInString(p_string:= p_string, charValue:= digit$CHAR);

        Value := restValue;
        
      end_while;

      // Add sign if requiered
      if negValue = TRUE then
        AddCharInString(p_string:= p_string, charValue:= '-');
      end_if;
      
    end_if;

  else
    TRACE("ERROR SFN_StringUtils::ConvertDintToAsciiDec: parameter NIL");
  end_if;

END_FUNCTION


(***************************************************
  ConvertDintToAsciiHex

  Note: No floating points supported !!!
****************************************************)

FUNCTION GLOBAL SFN_StringUtils::ConvertDintToAsciiHex
	VAR_INPUT
		p_string 	: ^CHAR;
		Value 	: DINT;
		valueSize 	: UDINT;
	END_VAR
  
	VAR
		restValue : DINT;
    digit     : DINT;
	END_VAR

  if p_string <> NIL then
    // Storage location available
    if Value = 0 then
      p_string^     := '0';
      (p_string+1)^ := 0;  // Close string
    else
      p_string^ := 0;                   // Be sure string is closed
      
      valueSize := valueSize * 2;       // Convert nr of bytes to nr of nibbles
      while (ValueSize > 0) do
        restValue := Value/16;
        
        digit := (Value - (restValue*16));
        
        if digit < 0 then
          
          digit := digit * -1;
        end_if;
        
        if digit > 9 then
          // Digits A .. F
           digit := digit-10 + 'A';                 
        else
          // Digits 0 .. 9
           digit := digit + '0';                 
        end_if;
        
        AddCharInString(p_string:= p_string, charValue:= digit$CHAR);

        Value := restValue;
        
        ValueSize := ValueSize - 1;
      end_while;
      
    end_if;

    // Add "0x" to indicate it is a hexadecimal value
    AddCharInString(p_string:= p_string, charValue:= 'x');
    AddCharInString(p_string:= p_string, charValue:= '0');

  else
    TRACE("ERROR SFN_StringUtils::ConvertDintToAsciiHex: parameter NIL");
    
  end_if;

END_FUNCTION


(***************************************************
  ConvertUdintToAsciiDec

  Note: No floating points supported !!!
****************************************************)

FUNCTION GLOBAL SFN_StringUtils::ConvertUdintToAsciiDec
	VAR_INPUT
		p_string 	: ^CHAR;
		Value 	: UDINT;
	END_VAR
  
	VAR
		restValue : UDINT;
    digit     : UDINT;
	END_VAR

  if p_string <> NIL then
    // Storage location available
    if Value = 0 then
      p_string^     := '0';
      (p_string+1)^ := 0;  // Close string
    else
      p_string^ := 0;  // Be sure string is closed
      
      while Value > 0 do
        restValue := Value/10;
        digit := (Value - (restValue*10)) ;
        digit := digit + '0';                 // convert value to character
        AddCharInString(p_string:= p_string, charValue:= digit$CHAR);

        Value := restValue;
        
      end_while;
    
    end_if;
  else
    TRACE("ERROR SFN_StringUtils::ConvertUdintToAsciiDec: parameter NIL");
    
  end_if;

END_FUNCTION

(***************************************************
  ConvertUdintToAsciiHex

  Note: No floating points supported !!!
****************************************************)

FUNCTION GLOBAL SFN_StringUtils::ConvertUdintToAsciiHex
	VAR_INPUT
		p_string 	: ^CHAR;
		Value 	: UDINT;
		valueSize 	: UDINT;
	END_VAR
  
	VAR
		restValue   : UDINT;
    digit       : UDINT;
	END_VAR

  if p_string <> NIL then
    // Storage location available
    if Value = 0 then
      p_string^     := '0';
      (p_string+1)^ := 0;  // Close string
    else
      p_string^ := 0;                   // Be sure string is closed
      
      valueSize := valueSize * 2;       // Convert nr of bytes to nr of nibbles
      while (ValueSize > 0) do
        restValue := Value/16;
        
        digit := (Value - (restValue*16));
        
        if digit > 9 then
          // Digits A .. F
           digit := digit-10 + 'A';                 
        else
          // Digits 0 .. 9
           digit := digit + '0';                 
        end_if;
        
        AddCharInString(p_string:= p_string, charValue:= digit$CHAR);

        Value     := restValue;
        
        ValueSize := ValueSize - 1;
      end_while;
      
    end_if;
    // Add "0x" to indicate it is a hexadecimal value
    AddCharInString(p_string:= p_string, charValue:= 'x');
    AddCharInString(p_string:= p_string, charValue:= '0');

  else
    TRACE("ERROR SFN_StringUtils::ConvertUdintToAsciiHex: parameter NIL");
  end_if;

END_FUNCTION

FUNCTION SFN_StringUtils::AddCharInString
	VAR_INPUT
		p_string 	: pChar;
		charValue 	: CHAR;
	END_VAR

  VAR
  	tempChar  : CHAR;
  END_VAR

  // Shift all characters one byte deeper in string and add charValue at start of string.
  if p_string <> NIL then
    while p_string^ <> 0 do
      // In loop until end of string found.
        tempChar  := p_string^;
        p_string^ := charValue;
        charValue := tempChar;
        
        p_string  := p_string + 1;  // next position in string
    end_while;
    
    p_string^ := charValue;         // Last character in string
    p_string  := p_string + 1;      // next position in string
    p_string^ := 0;                 // close string 

  else
    TRACE("ERROR SFN_StringUtils::AddCharInString: parameter NIL");
  end_if;
  
END_FUNCTION

(********************************************************************************
  ConvertAsciiToDint
  Convert an ASCII string to a DINT value.


  Starting with 0x or 0X is interpreted as a hexadecimal value
  Valid characters for hexadcemal  0 - 9, a - f and A - F
  
  Valid digits for decimal 0 - 9, - (minus),  
  
  Note: No floating points supported !!!
                        
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::ConvertAsciiToDint
	VAR_INPUT
		p_string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Output 	: DINT;
	END_VAR

	VAR
		negValue 	: BOOL;
		hexValue 	: BOOL;
	END_VAR

  negValue  := FALSE;
  hexValue  := FALSE;
  Output    := 0;

  if p_string <> NIL then
    
    while p_string^ <> 0 do
      // in loop until end of string found
      
      if p_string^ = '-' then
        negValue  := TRUE;
        
      elsif p_string^ = '0' & ((p_string+1)^ = 'x') | ((p_string+1)^ = 'X') then 
      // 0x.... or 0X..... indicates a hex value
        p_string := p_string + 2;         // Set to start location hexadecimal value
        hexValue := TRUE;
        exit;                             // exit loop
        
      elsif (p_string^ >= '0') & (p_string^ <= '9') then
        exit;                             // Start location found for a decimal value.
                                          // exit loop
      end_if;
      
      p_string := p_string + 1;
    
    end_while;
  
    if p_string^ <> 0 then
      // Data in string available to Convert.
      if hexValue = TRUE then
        Output := ConvertAsciiHexToDint(p_string:= p_string);
      else
        Output := ConvertAsciiDecToDint(p_string:= p_string);
      end_if;
     
     if negValue = TRUE then
        Output := Output * -1;
     end_if;
    end_if;
  else
    TRACE("ERROR SFN_StringUtils::ConvertAsciiToDint: parameter NIL");
  end_if;
END_FUNCTION

FUNCTION SFN_StringUtils::ConvertAsciiHexToDint
	VAR_INPUT
		p_string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Output 	: DINT;
	END_VAR
  
  Output := 0;
  if p_string <> NIL then
    while p_string^ <> 0 do
      // in loop until end of string found
   
      Output := Output ROL 4;                     // multiply 16
      if (p_string^ >= 'a') & (p_string^ <= 'f')  then
        // Digit a..f 
        Output := Output + ( (p_string^ - 'a' + 10) and 16#0f);
        
      elsif (p_string^ >= 'A') & (p_string^ <= 'F') then
        // Digit A..F 
        Output := Output + ( (p_string^ - 'A' + 10) and 16#0f);
        
      elsif (p_string^ >= '0') & (p_string^ <= '9') then
        // Digit 0..9 
        Output := Output + ( (p_string^ - '0') and 16#0f);
        
      else
        // Illegal character. exit loop
        Output := 0;
        exit; 
      end_if;
      p_string := p_string + 1;
      
    end_while;
    
  else
    TRACE("ERROR SFN_StringUtils::ConvertAsciiHexToDint: parameter NIL");
  end_if;

END_FUNCTION


FUNCTION SFN_StringUtils::ConvertAsciiDecToDint
	VAR_INPUT
		p_string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Output 	: DINT;
	END_VAR
  

  Output   := 0;

  if p_string <> NIL then
    while p_string^ <> 0 do
      // in loop until end of string found
   
      Output := Output * 10;
      if p_string^ >= '0' & p_string^ <= '9' then
        // a digit 0..9 
        Output := Output + ( (p_string^ - '0') and 16#0f);
      else
        // Illegal character. exit loop
        Output := 0;
        exit; 
      end_if;
      p_string := p_string + 1;
      
    end_while;
    
  else
    TRACE("ERROR SFN_StringUtils::ConvertAsciiDecToDint: parameter NIL");
  end_if;

END_FUNCTION



(********************************************************************************
  ConvertAsciiToUdint
  Convert an ASCII string to a UDINT value.

  Starting with 0x or 0X is interpreted as a hexadecimal value
  Valid characters for hexadcemal  0 - 9, a - f and A - F
  
  Valid digits for decimal 0 - 9

  Note: No floating points supported !!!
                        
********************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::ConvertAsciiToUdint
	VAR_INPUT
		p_string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Output 	: UDINT;
	END_VAR

	VAR
		negValue 	: BOOL;
		hexValue 	: BOOL;
	END_VAR


  if p_string <> NIL then

    negValue  := FALSE;
    hexValue  := FALSE;
    Output    := 0;
    
    while p_string^ <> 0 do
      // in loop until end of string found
      
     if p_string^ = '0' & ((p_string+1)^ = 'x') | ((p_string+1)^ = 'X') then 
      // 0x.... or 0X..... indicates a hex value
        p_string := p_string + 2;         // Set to start location hexadecimal value
        hexValue := TRUE;
        exit;                             // exit loop
        
      elsif (p_string^ >= '0') & (p_string^ <= '9') then
        exit;                             // Start location found for a decimal value.
                                          // exit loop
      end_if;
      
      p_string := p_string + 1;
    
    end_while;
  
    if p_string^ <> 0 then
      // Data in string available to Convert.
      if hexValue = TRUE then
        Output := ConvertAsciiHexToUdint(p_string:= p_string);
      else
        Output := ConvertAsciiDecToUdint(p_string:= p_string);
      end_if;
     
    end_if;
  else
    TRACE("ERROR SFN_StringUtils::ConvertAsciiToUdint: parameter NIL");
  end_if;
  
END_FUNCTION

FUNCTION SFN_StringUtils::ConvertAsciiHexToUdint
	VAR_INPUT
		p_string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Output 	: UDINT;
	END_VAR
  

  Output := 0;
  if p_string <> NIL then
    while p_string^ <> 0 do
      // in loop until end of string found
   
      Output := Output ROL 4;                     // multiply 16
      if (p_string^ >= 'a') & (p_string^ <= 'f')  then
        // Digit a..f 
        Output := Output + ( (p_string^ - 'a' + 10) and 16#0f);
        
      elsif (p_string^ >= 'A') & (p_string^ <= 'F') then
        // Digit A..F 
        Output := Output + ( (p_string^ - 'A' + 10) and 16#0f);
        
      elsif (p_string^ >= '0') & (p_string^ <= '9') then
        // Digit 0..9 
        Output := Output + ( (p_string^ - '0') and 16#0f);
        
      else
        // Illegal character. exit loop
        Output := 0;
        exit; 
      end_if;
      p_string := p_string + 1;
      
    end_while;
  
  else
    TRACE("ERROR SFN_StringUtils::ConvertAsciiHexToUdint: parameter NIL");
  end_if;
  
END_FUNCTION


FUNCTION SFN_StringUtils::ConvertAsciiDecToUdint
	VAR_INPUT
		p_string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Output 	: UDINT;
	END_VAR
  

  Output   := 0;

  if p_string <> NIL then
    while p_string^ <> 0 do
      // in loop until end of string found
   
      Output := Output * 10;
      if p_string^ >= '0' & p_string^ <= '9' then
        // a digit 0..9 
        Output := Output + ( (p_string^ - '0') and 16#0f);
      else
        // Illegal character. exit loop
        Output := 0;
        exit; 
      end_if;
      p_string := p_string + 1;
      
    end_while;

  else
    TRACE("ERROR SFN_StringUtils::ConvertAsciiDecToUdint: parameter NIL");
    
  end_if;
  
END_FUNCTION


(*******************************************************************************************
FUNCTION GLOBAL SFN_StringUtils::StrStr
This method searches in searchstring for a "look for" string
all strings must be zero-terminated.

Parameters:
-p_searchStr :  Pointer to string to search in.
-p_lookforStr:  Pointer to String to look for 

Returns : 
-p_ReturnStr    Return the position in search string 
                where the lookfor string is found.

                If lookfor string is not found 
                or wrong parameters where used 
                (NIL pointers) a NIL is returned
********************************************************************************************)
FUNCTION GLOBAL SFN_StringUtils::StrStr
	VAR_INPUT
		p_searchStr 	: ^CHAR;
		p_lookforStr 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		p_ReturnStr 	: ^CHAR;
	END_VAR
  
  VAR
  	idx           : UDINT;      // index to select character in strings to search lookforStr in serachStr.
    p_lfStr       : ^CHAR;      // points to character in lookforStr
    p_sStr        : ^CHAR;      // points to character in searchStr
    exitLoop      : BOOL;       // stop searching
  END_VAR

  
  p_ReturnStr := NIL;           // default return NIL to indicate nothing found
  
  if ( (p_searchStr <> NIL) & (p_lookforStr <> NIL) ) then
    // Valid parameters
    
    exitLoop := FALSE;
    
    while ( ( p_searchStr^ <> 0 )     // Check end of "Search string"
          & exitLoop = FALSE          // Check end of "look for string"
          ) do
          
      idx := 0;                       // (re)start comparing strings

      while (1) do
        p_lfStr := p_lookforStr + idx;
        p_sStr  := p_searchStr  + idx;
        if (p_lfStr^ = 0) then
          // end of look for string found.
          p_ReturnStr := p_searchStr;    // Return location in string where "look for" string is found
          exitLoop    := TRUE;        // Exit loop
          
          exit;                       // stop comparing strings (exit endless loop)
        end_if;

        if (p_lfStr^ <> p_sStr^) then
          exit;                       // stop comparing strings (exit endless loop)
          
        end_if;
        
        idx += 1;                     // Next character in search- and "look for" strings to check
      end_while;
      
      p_searchStr += 1;               // Start comparing strings from next character in searchstring
      
    end_while;
  else
    TRACE("ERROR SFN_StringUtils::StrStr: parameter NIL");
    
  end_if;
 
END_FUNCTION




FUNCTION GLOBAL SFN_StringUtils::Debug
	VAR_INPUT
		Msg 	: ^CHAR;
		Value_1 	: DINT;
		Value_2 	: DINT;
	END_VAR
  
  Var
    strValue_01        : array [0..10] of char;
    strValue_02        : array [0..10] of char;
  END_VAR
    
    ConvertDintToAsciiDec(p_string:=#strValue_01[0], Value:= Value_1);
    ConvertDintToAsciiDec(p_string:=#strValue_02[0], Value:= Value_2);
    TRACE1 (Msg,#strValue_01[0],#strValue_02[0]);

END_FUNCTION
