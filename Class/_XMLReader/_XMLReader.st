//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define XMLReader_TaskName          "XML-Read_"
#define XMLReader_TaskPrio          10
#define XMLReader_StackSize         (16#F000 OR 16#80000000)     // 30000 Byte
#define XMLReader_TaskDelay         1                            // delay for the parallel task
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_XMLReader"
	Revision           = "2.3"
	GUID               = "{CB730E08-556E-4C07-8D84-44A3FA315253}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(300,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{38E686B7-9F96-41CE-8A86-FCAAD365815F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server to call global methods"/>
		<Server Name="DoConvert" GUID="{34AD64BF-05C3-4D5B-B7FB-85DE9BAFBF17}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="used to activate convertion of special characters&#13;&#10;= 0 ... no convertion will be done&#13;&#10;&lt;&gt; 0 ... special characters will be converted automatically"/>
		<Server Name="ErrorLine" GUID="{893F9669-D799-4587-852F-3B0AD2CF71C4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows in which line of the parsed xml file the error occured"/>
		<Server Name="ErrorSign" GUID="{2DD88F4F-2369-4734-8061-F600527C3373}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows at which sign of line the parsing error occured"/>
		<Server Name="ErrorState" GUID="{C380F29C-105B-4B30-B9E6-A040861CE8AC}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows the actual error state"/>
		<Server Name="XmlState" GUID="{1B1887A5-4F51-48EB-BFB9-0AB8E9415368}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="State of the _XMLReader"/>
		<Client Name="CheckSum" Required="true" Internal="true"/>
		<Client Name="CreateTask" Required="true" Internal="false" DefValue="0"/>
		<Client Name="FileSys" Required="false" Internal="false"/>
		<Client Name="MultiTask" Required="false" Internal="false"/>
		<Client Name="SigCLib" Required="false" Internal="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
		<Client Name="StructCreator" Required="true" Internal="true"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek " Author="sprdie"/>
		<Dokumentation Revision="2.3" Date="2021-01-13" Author="ludben" Company="Sigmatek " Description="Fixed loading successfully a file with only a header. If only a header is found in the file, the error code _PARSE_ERR_NO_ROOT_ELEMENT is issued."/>
		<Dokumentation Revision="2.2" Date="2020-02-24" Author="HubChr" Company="Sigmatek " Description="Fixed possible memory leak when calling ReadFile() twice before actual reading has started."/>
		<Dokumentation Revision="2.1" Date="2020-02-11" Author="sprdie" Company="Sigmatek " Description="1. fixed bug of deleting elements where an AccessException could occure&#13;&#10;2. added Method ResetSearch to start with Get-Functions at the beginning of the struct&#13;&#10;3. special characters (&amp;  &lt;  &gt;  &apos;  &quot;) can now be converted automatically when parsing the file&#13;&#10;    (for example &quot;&amp;amp;&quot; will be converted to &quot;&amp;&quot;)"/>
		<Dokumentation Revision="2.0" Date="2019-11-19" Author="sprdie" Company="Sigmatek " Description="1. changed memory-management so the number of needed Malloc()- and Free()-Calls is reduced (better performance)&#13;&#10;2. free memory for search criteria if FreeReader() is called&#13;&#10;3. deleting last attribute is now handled correctly"/>
		<Dokumentation Revision="1.6" Date="2018-12-13" Author="sprdie" Company="Sigmatek " Description="corrected skipping of comments in xml-file &amp; creating of user-task"/>
		<Dokumentation Revision="1.5" Date="2018-07-23" Author="sprdie" Company="Sigmatek " Description="1. added treatment for utf8-BOM at beginning of the file&#13;&#10;2. user can now decide if Create &amp; Free-Struct will be done in Background or UserTask&#13;&#10;   (FileBuffer, FileName and Variables will always be resetted in Background)&#13;&#10;3. fixed some errors at parsing the xml:&#13;&#10;    - MajorElement can now start directly after the header&#13;&#10;    - if an element is closed directly after an attribute and there is a space between &#13;&#10;      the reader won&apos;t go into an parse-error anymore"/>
		<Dokumentation Revision="1.4" Date="2017-09-18" Author="sprdie" Company="Sigmatek " Description="new Methods:&#13;&#10;GetAttribValueByName() - returns the value string of an attribute with given name&#13;&#10;GetChildByName() - returns the child of an element with given name&#13;&#10;ParseXML() - starts parsing an xml string&#13;&#10;GetXmlState() - returns the state of the reader&#13;&#10;GetErrorState() - returns the error state of the reader&#13;&#10;&#13;&#10;changes:&#13;&#10;when reading a file it now will be checked if an element has the same attribute (name) twice&#13;&#10;Method AddAttribute() checks if name is already used in the element&#13;&#10;variable bRdIsUnicode changed from DINT to BOOL "/>
		<Dokumentation Revision="1.3" Date="2017-07-31" Author="sprdie" Company="Sigmatek " Description="added more information in case of error while parsing the file&#13;&#10;(line &amp; sign where the error occured)"/>
		<Dokumentation Revision="1.2" Date="2017-07-17" Author="sprdie" Company="Sigmatek " Description="added Support for Space-Sign between Element-Name &amp; Closing-Tag of an directly closed element&#13;&#10;for example: &lt;Name /&gt; (without Space: &lt;Name/&gt;)&#13;&#10;(spelling with the space between name &amp; tag caused an Error at parsing the file)"/>
		<Dokumentation Revision="1.1" Date="2017-05-10" Author="sprdie" Company="Sigmatek " Description="Class is now able to handle Unicode Files."/>
		<Dokumentation Revision="1.0" Date="2017-02-10" Author="sprdie" Company="Sigmatek " Description="Class created"/>
	</RevDoku>
	<Network Name="_XMLReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "CheckSum"
				GUID       = "{3DF55598-7D87-45C2-A1A2-3DF03DE3208E}"
				Class      = "_CheckSum"
				Position   = "(300,690)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "StructCreator"
				GUID       = "{C9859CE4-F42E-44D1-8B76-B688C45358A2}"
				Class      = "_XMLStructCreator"
				Position   = "(270,390)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.StructCreator" Destination="StructCreator.ClassSvr"/>
			<Connection Source="this.CheckSum" Destination="CheckSum.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_XMLReader : CLASS
	TYPE
	  _XML_GET_FCT :
	  (
	    _NONE:=0,
	    _BY_NAME:=1,
	    _BY_ATTRIB:=2,
	    _BY_ATTRIB_NAME:=3,
	    _BY_TEXT:=4
	  )$UDINT;
	  _XML_PARSE_ERROR :  //! <Type Public="true" Name="_XML_PARSE_ERROR"/>
	  (
	    _PARSE_ERR_NONE,
	    _PARSE_ERR_NO_HEADER,
	    _PARSE_ERR_UNEXPECTED_SIGN,
	    _PARSE_ERR_WRONG_SEQUENCE,
	    _PARSE_ERR_ATTRIBUTE_TWICE,
	    _PARSE_ERR_NO_TASK,
	    _PARSE_ERR_MEMORY,
	    _PARSE_ERR_NO_ROOT_ELEMENT
	  )$UDINT;
	  _XML_SEARCH_STATE :
	  (
	    _SEARCH_ELEMENT,
	    _SEARCH_ATTRIB,
	    _SEARCH_TEXT
	  )$UDINT;
	  XML_READ_STATE :  //! <Type Public="true" Name="XML_READ_STATE"/>
	  (
	    _READY,  //! <Type Comment="Class is ready to be used" Name="XML_READ_STATE._READY"/>
	    _FILE_OPENING,  //! <Type Comment="File is being opened" Name="XML_READ_STATE._FILE_OPENING"/>
	    _FILE_OPENED,  //! <Type Comment="File was successfully opened" Name="XML_READ_STATE._FILE_OPENED"/>
	    _FILE_GET_LENGTH,  //! <Type Comment="File lenght is being calculated" Name="XML_READ_STATE._FILE_GET_LENGTH"/>
	    _FILE_GOT_LENGTH,  //! <Type Comment="File length was successfully calculated" Name="XML_READ_STATE._FILE_GOT_LENGTH"/>
	    _FILE_READING,  //! <Type Comment="File is being read" Name="XML_READ_STATE._FILE_READING"/>
	    _FILE_READ,  //! <Type Comment="File was successfully read" Name="XML_READ_STATE._FILE_READ"/>
	    _FILE_CLOSING,  //! <Type Comment="File is being closed" Name="XML_READ_STATE._FILE_CLOSING"/>
	    _FILE_CLOSED,  //! <Type Comment="File was successfully closed" Name="XML_READ_STATE._FILE_CLOSED"/>
	    _STRUCT_CREATING,  //! <Type Comment="XML-Structure is being created" Name="XML_READ_STATE._STRUCT_CREATING"/>
	    _STRUCT_CREATED,  //! <Type Comment="XML-Structure was successfully created" Name="XML_READ_STATE._STRUCT_CREATED"/>
	    _ERROR,  //! <Type Comment="An error occured" Name="XML_READ_STATE._ERROR"/>
	    _PARSE_STREAM,
	    _STRUCT_FREE
	  )$UDINT;
	  XML_READ_STEPS :
	  (
	    _WAIT,
	    _OPEN_FILE,
	    _GET_LENGTH_FILE,
	    _READ_FILE,
	    _CLOSE_FILE,
	    _CREATE_STRUCT,
	    _FREE_STRUCT
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	XmlState 	: SvrCh_XML_READ_STATE_PTofCls__XMLReader;
	ErrorState 	: SvrCh__XML_PARSE_ERROR_PTofCls__XMLReader;
	ErrorLine 	: SvrCh_DINT;
	ErrorSign 	: SvrCh_DINT;
	DoConvert 	: SvrCh_DINT;
  //Clients:
	FileSys 	: CltChCmd__FileSys;
	StdLib 	: CltChCmd__StdLib;
	StructCreator 	: CltChCmd__XMLStructCreator;
	SigCLib 	: CltChCmd_SigCLib;
	MultiTask 	: CltChCmd__MultiTask;
	CreateTask 	: CltCh_DINT;
	CheckSum 	: CltChCmd__CheckSum;
  //Variables:
		startReading 	: BOOL;			//! <Variable Comment="true -&gt; class starts reading File" Name="startReading"/>
		asyncID 	: UDINT;			//! <Variable Comment="ID of Async File-Function" Name="asyncID"/>
		asyncState 	: DINT;			//! <Variable Comment="state of async function" Name="asyncState"/>
		fctRetval 	: DINT;			//! <Variable Comment="return-value of file-function" Name="fctRetval"/>
		FileHandle 	: DINT;			//! <Variable Comment="handle of the file" Name="FileHandle"/>
		fileLength 	: UDINT;			//! <Variable Comment="length of the file" Name="fileLength"/>
		pFileName 	: ^CHAR;			//! <Variable Comment="pointer to stored FileName" Name="pFileName"/>
		pFileBuffer 	: ^USINT;			//! <Variable Comment="pointer to Buffer where file-content will be saved" Name="pFileBuffer"/>
		readSSW 	: XML_READ_STEPS;			//! <Variable Comment="steps of reading" Name="readSSW"/>
		xmlStruct 	: _XML_FILE;			//! <Variable Comment="created struct" Name="xmlStruct"/>
		searchFor 	: _XML_SEARCH_STATE;			//! <Variable Comment="defines what we actually search in Buffer" Name="searchFor"/>
		gotFirst 	: BOOL;			//! <Variable Comment="true -&gt; GetFirstElement was called once" Name="gotFirst"/>
		gotAll 	: BOOL;			//! <Variable Comment="true -&gt; no element left (GetNextElement will return NIL)" Name="gotAll"/>
		getPtr 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to go through the struct" Name="getPtr"/>
		lastCriteria 	: ^USINT;
		lastLen 	: UDINT;
		lastCriteriaValue 	: ^USINT;
		lastLenValue 	: UDINT;
		searchPtr 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer used to search an element in our struct" Name="searchPtr"/>
		bQuot 	: BOOL;
		bTextSearched 	: BOOL;
		retClose 	: DINT;
		lastSearch 	: _XML_GET_FCT;
		bRdIsUnicode 	: BOOL;
		lastCriteriaUni 	: ^UINT;
		lastCriteriaValueUni 	: ^UINT;
		taskHandle 	: MT_TASKHANDLE;
		isTaskCreated 	: BOOL;
		szTaskName : ARRAY [0..30] OF CHAR;

		isCreated 	: BOOL;
		doCreate 	: BOOL;
		isFree 	: BOOL;
		doFree 	: BOOL;
		elementCount 	: UDINT;
		attribCount 	: UDINT;
		strUniAmp : ARRAY [0..9] OF UINT;

		strUniApos : ARRAY [0..9] OF UINT;

		strUniGreater : ARRAY [0..9] OF UINT;

		strUniLess : ARRAY [0..9] OF UINT;

		strUniQuot : ARRAY [0..9] OF UINT;

  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="starts reading the File" Name="ReadFile"/>
	FUNCTION GLOBAL ReadFile
		VAR_INPUT
			FileName 	: ^CHAR;			//! <Variable Comment="Name of file" Name="ReadFile.FileName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="ReadFile.retcode"/>
		END_VAR;
				//! <Function Comment="frees all memory allocated during the process of reading" Name="FreeReader"/>
	FUNCTION GLOBAL FreeReader;
				//! <Function Comment="returns pointer to the header-string" Name="GetHeader"/>
	FUNCTION GLOBAL GetHeader
		VAR_OUTPUT
			pHeader 	: ^USINT;			//! <Variable Comment="pointer to the header" Name="GetHeader.pHeader"/>
		END_VAR;
				//! <Function Comment="returns the encoding type of the file" Name="GetEncoding"/>
	FUNCTION GLOBAL GetEncoding
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="Type of encoding (see defines)&#13;&#10;&gt; 0 .. Success&#13;&#10;-1 ... Commando Failed" Name="GetEncoding.retcode"/>
		END_VAR;
				//! <Function Comment="returns pointer to the Major-Element" Name="GetFirstElement"/>
	FUNCTION GLOBAL GetFirstElement
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to major-element" Name="GetFirstElement.pElement"/>
		END_VAR;
				//! <Function Comment="returns pointer to the next element&#13;&#10;NIL -&gt; no Element left" Name="GetNextElement"/>
	FUNCTION GLOBAL GetNextElement
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to next element" Name="GetNextElement.pElement"/>
		END_VAR;
				//! <Function Comment="returns the first element we find with equal name.&#13;&#10;if method is called again with same input we search for the next one.&#13;&#10;&#13;&#10;NIL -&gt; no element with equal name left&#13;&#10;&#13;&#10;another call after return-value was NIL (and same parameter) will cause a new search from beginning" Name="GetElementByName"/>
	FUNCTION GLOBAL GetElementByName
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Name of Element" Name="GetElementByName.pName"/>
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to element" Name="GetElementByName.pElement"/>
		END_VAR;
				//! <Function Comment="returns the first element we find with equal attributes.&#13;&#10;if method is called again with same input we search for the next one.&#13;&#10;&#13;&#10;NIL -&gt; no element with equal attribute left&#13;&#10;&#13;&#10;another call after return-value was NIL (and same parameter) will cause a new search from beginning" Name="GetElementByAttrib"/>
	FUNCTION GLOBAL GetElementByAttrib
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Name of Attribute" Name="GetElementByAttrib.pName"/>
			pValue 	: ^USINT;			//! <Variable Comment="Attribute-Value" Name="GetElementByAttrib.pValue"/>
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to the element" Name="GetElementByAttrib.pElement"/>
		END_VAR;
				//! <Function Comment="returns the first element we find with equal attribute-name.&#13;&#10;if method is called again with same input we search for the next one.&#13;&#10;&#13;&#10;NIL -&gt; no element with equal attribute-name left&#13;&#10;&#13;&#10;another call after return-value was NIL (and same parameter) will cause a new search from beginning" Name="GetElementByAttribName"/>
	FUNCTION GLOBAL GetElementByAttribName
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Name of attribute" Name="GetElementByAttribName.pName"/>
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to the element" Name="GetElementByAttribName.pElement"/>
		END_VAR;
				//! <Function Comment="returns the first element we find with equal text.&#13;&#10;if method is called again with same input we search for the next one.&#13;&#10;&#13;&#10;NIL -&gt; no element with equal text left&#13;&#10;&#13;&#10;another call after return-value was NIL (and same parameter) will cause a new search from beginning" Name="GetElementByText"/>
	FUNCTION GLOBAL GetElementByText
		VAR_INPUT
			pText 	: ^USINT;			//! <Variable Comment="searched text" Name="GetElementByText.pText"/>
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to the element" Name="GetElementByText.pElement"/>
		END_VAR;
				//! <Function Comment="returns the pointer to the child element which has the given name" Name="GetChildByName"/>
	FUNCTION GLOBAL GetChildByName
		VAR_INPUT
			pParent 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to the XML-Element from where the children should be searched" Name="GetChildByName.pParent"/>
			pName 	: ^USINT;			//! <Variable Comment="name of the child-element" Name="GetChildByName.pName"/>
			number 	: UDINT := 1;			//! <Variable Comment="optional parameter&#13;&#10;if parameter is not set the then the method will always return the first match&#13;&#10;&#13;&#10;if parameter is set method will return the x match&#13;&#10;&#13;&#10;for example name = &quot;ChildElement&quot; number = 2 then the method will return the second child with name &quot;ChildElement&quot; " Name="GetChildByName.number"/>
		END_VAR
		VAR_OUTPUT
			pChild 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to the child element&#13;&#10;if pointer = NIL the child could not be found" Name="GetChildByName.pChild"/>
		END_VAR;
				//! <Function Comment="returns the index of the attribute with given name in given element&#13;&#10;&#13;&#10;retcode -1: there is no attribute with this name&#13;&#10;retcode &gt;= 0: attribute found - retcode equals index " Name="GetAttribIndex"/>
	FUNCTION GLOBAL GetAttribIndex
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="GetAttribIndex.pElement"/>
			pName 	: ^USINT;			//! <Variable Comment="Name of the attribute" Name="GetAttribIndex.pName"/>
		END_VAR
		VAR_OUTPUT
			Index 	: DINT;			//! <Variable Comment="Index of the attribute&#13;&#10;-1 ... Search failed" Name="GetAttribIndex.Index"/>
		END_VAR;
				//! <Function Comment="returns the name of the attrib in dependence of element and index&#13;&#10;returns NIL is not successfull" Name="GetAttribNameByIndex"/>
	FUNCTION GLOBAL GetAttribNameByIndex
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="GetAttribNameByIndex.pElement"/>
			Index 	: UDINT;			//! <Variable Comment="Index of the attribute" Name="GetAttribNameByIndex.Index"/>
		END_VAR
		VAR_OUTPUT
			pName 	: ^USINT;			//! <Variable Comment="Name of the attribute" Name="GetAttribNameByIndex.pName"/>
		END_VAR;
				//! <Function Comment="returns the value of the attrib in dependence of element and index&#13;&#10;returns NIL is not successfull" Name="GetAttribValueByIndex"/>
	FUNCTION GLOBAL GetAttribValueByIndex
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="GetAttribValueByIndex.pElement"/>
			Index 	: UDINT;			//! <Variable Comment="Index of the attribute" Name="GetAttribValueByIndex.Index"/>
		END_VAR
		VAR_OUTPUT
			pValue 	: ^USINT;			//! <Variable Comment="Pointer to the value of the attribute" Name="GetAttribValueByIndex.pValue"/>
		END_VAR;
				//! <Function Comment="returns the value of the attribute with given name" Name="GetAttribValueByName"/>
	FUNCTION GLOBAL GetAttribValueByName
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="pointer to the element where the attribute should be searched" Name="GetAttribValueByName.pElement"/>
			pName 	: ^USINT;			//! <Variable Comment="pointer to the attribute name" Name="GetAttribValueByName.pName"/>
		END_VAR
		VAR_OUTPUT
			pValue 	: ^USINT;			//! <Variable Comment="pointer to the value&#13;&#10;NIL = not found" Name="GetAttribValueByName.pValue"/>
		END_VAR;
				//! <Function Comment="edits the name of destination-element" Name="EditName"/>
	FUNCTION GLOBAL EditName
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="EditName.pElement"/>
			pName 	: ^USINT;			//! <Variable Comment="New name of the element" Name="EditName.pName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="EditName.retcode"/>
		END_VAR;
				//! <Function Comment="edits the name of the attribute which is placed in the Destination-Element on the given Index&#13;&#10;" Name="EditAttribName"/>
	FUNCTION GLOBAL EditAttribName
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="EditAttribName.pElement"/>
			index 	: UDINT;			//! <Variable Comment="Index of the attribute" Name="EditAttribName.index"/>
			pName 	: ^USINT;			//! <Variable Comment="New name of the attribute" Name="EditAttribName.pName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="EditAttribName.retcode"/>
		END_VAR;
				//! <Function Comment="edits the value of the attribute which is placed in the Destination-Element on the given Index&#13;&#10;" Name="EditAttribValue"/>
	FUNCTION GLOBAL EditAttribValue
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="EditAttribValue.pElement"/>
			index 	: UDINT;			//! <Variable Comment="Index of the attribute" Name="EditAttribValue.index"/>
			pValue 	: ^USINT;			//! <Variable Comment="New value" Name="EditAttribValue.pValue"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="EditAttribValue.retcode"/>
		END_VAR;
				//! <Function Comment="edits the text of the destination-element" Name="EditText"/>
	FUNCTION GLOBAL EditText
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="EditText.pElement"/>
			pText 	: ^USINT;			//! <Variable Comment="Pointer to the text to replace the current text in element" Name="EditText.pText"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="EditText.retcode"/>
		END_VAR;
				//! <Function Comment="this method will insert a new child-element to the destination-element&#13;&#10;&#13;&#10;if destination already has children then the new child will be inserted behind them" Name="AddChildElement"/>
	FUNCTION GLOBAL AddChildElement
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the destination (Father) element" Name="AddChildElement.pDest"/>
			pName 	: ^USINT;			//! <Variable Comment="Name of the element to be added" Name="AddChildElement.pName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the added element" Name="AddChildElement.retcode"/>
		END_VAR;
				//! <Function Comment="adds a brother-element to the destination element&#13;&#10;&#13;&#10;this method will insert the element right after the destination-element on the same level&#13;&#10;this means if destination element has children it will look like this:&#13;&#10;&#13;&#10;&lt;Destination&gt;&#13;&#10; &lt;Child/&gt;&#13;&#10; &lt;Child/&gt;&#13;&#10; &lt;Child/&gt;&#13;&#10;&lt;NewBrother&gt; &lt;!--New Brother will be inserted here--&gt;" Name="AddBrotherElement"/>
	FUNCTION GLOBAL AddBrotherElement
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the destination element" Name="AddBrotherElement.pDest"/>
			pName 	: ^USINT;			//! <Variable Comment="Name of the element to be added" Name="AddBrotherElement.pName"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the added element" Name="AddBrotherElement.retcode"/>
		END_VAR;
				//! <Function Comment="adds an attribute to the destination-element" Name="AddAttribute"/>
	FUNCTION GLOBAL AddAttribute
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the destination element" Name="AddAttribute.pDest"/>
			pName 	: ^USINT;			//! <Variable Comment="Name of the attribute" Name="AddAttribute.pName"/>
			pValue 	: ^USINT;			//! <Variable Comment="Value of the attribute" Name="AddAttribute.pValue"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed" Name="AddAttribute.retcode"/>
		END_VAR;
				//! <Function Comment="adds a Text to the destination-element&#13;&#10;&#13;&#10;if destination element already has children we are not allowed to add the text so retcode will be -1&#13;&#10;" Name="AddText"/>
	FUNCTION GLOBAL AddText
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the destination element" Name="AddText.pDest"/>
			pText 	: ^USINT;			//! <Variable Comment="Text to be added" Name="AddText.pText"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed" Name="AddText.retcode"/>
		END_VAR;
				//! <Function Comment="deletes the destination element&#13;&#10;&#13;&#10;if this element has children we either delete the children or they will get 1 level higher" Name="DeleteElement"/>
	FUNCTION GLOBAL DeleteElement
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element to be removed" Name="DeleteElement.pElement"/>
			bDeleteChildren 	: BOOL;			//! <Variable Comment="TRUE ... Delete the children of the element as well&#13;&#10;FALSE .. Do not delete the children of the element" Name="DeleteElement.bDeleteChildren"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="DeleteElement.retcode"/>
		END_VAR;
				//! <Function Comment="deletes an attribute of the destination element which is placed on given index" Name="DeleteAttribute"/>
	FUNCTION GLOBAL DeleteAttribute
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="DeleteAttribute.pElement"/>
			Index 	: UDINT;			//! <Variable Comment="Index of the attribute to be deleted" Name="DeleteAttribute.Index"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="DeleteAttribute.retcode"/>
		END_VAR;
				//! <Function Comment="deletes the text of the destination element" Name="DeleteText"/>
	FUNCTION GLOBAL DeleteText
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;			//! <Variable Comment="Pointer to the element" Name="DeleteText.pElement"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="DeleteText.retcode"/>
		END_VAR;
				//! <Function Comment="in case of error-state this method can be used to reset the Reader&#13;&#10;&#13;&#10;in this function every memory will be freed and state will go back to ready" Name="Reset"/>
	FUNCTION GLOBAL Reset;
				//! <Function Comment="creates the struct out of the string we read from the file" Name="CreateStruct"/>
	FUNCTION CreateStruct
		VAR_INPUT
			parsedBytes 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION FileIsUnicode
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GetElementByNameAscii
		VAR_INPUT
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByNameUni
		VAR_INPUT
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByAttribAscii
		VAR_INPUT
			pName 	: ^USINT;
			pValue 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByAttribUni
		VAR_INPUT
			pName 	: ^UINT;
			pValue 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByAttribNameAscii
		VAR_INPUT
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByAttribNameUni
		VAR_INPUT
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByTextAscii
		VAR_INPUT
			pText 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetElementByTextUni
		VAR_INPUT
			pText 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetChildByNameAscii
		VAR_INPUT
			pParent 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
			number 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pChild 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetChildByNameUni
		VAR_INPUT
			pParent 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
			number 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pChild 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GetAttribIndexAscii
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			Index 	: DINT;
		END_VAR;
	
	FUNCTION GetAttribIndexUni
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			Index 	: DINT;
		END_VAR;
	
	FUNCTION GetAttribValueByNameAscii
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			pValue 	: ^USINT;
		END_VAR;
	
	FUNCTION GetAttribValueByNameUni
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			pValue 	: ^USINT;
		END_VAR;
	
	FUNCTION EditNameAscii
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditNameUni
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditAttribNameAscii
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			index 	: UDINT;
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditAttribNameUni
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			index 	: UDINT;
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditAttribValueAscii
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			index 	: UDINT;
			pValue 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditAttribValueUni
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			index 	: UDINT;
			pValue 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditTextAscii
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pText 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION EditTextUni
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pText 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION AddChildElementAscii
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION AddChildElementUni
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION AddBrotherElementAscii
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION AddBrotherElementUni
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION AddAttributeAscii
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
			pValue 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddAttributeUni
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pName 	: ^UINT;
			pValue 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddTextAscii
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pText 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddTextUni
		VAR_INPUT
			pDest 	: ^_XML_ELEMENT;
			pText 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION CreateStructAscii
		VAR_INPUT
			parsedBytes 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION CreateStructUni
		VAR_INPUT
			parsedBytes 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION FindError
		VAR_INPUT
			bytesParsed 	: UDINT;
		END_VAR;
	
	FUNCTION CreateTaskName
		VAR_INPUT
			pName 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION XmlReadTask;
	
	FUNCTION FetchElementsAndAttribsAscii
		VAR_INPUT
			pElementCount 	: ^UDINT;
			pAttribCount 	: ^UDINT;
		END_VAR;
				//! <Function Comment="starts parsing a xml string&#13;&#10;used if xml-code is not available as a file" Name="ParseXML"/>
	FUNCTION GLOBAL ParseXML
		VAR_INPUT
			pData 	: ^USINT;			//! <Variable Comment="pointer to the xml-string" Name="ParseXML.pData"/>
			length 	: UDINT;			//! <Variable Comment="length of the string (in bytes)" Name="ParseXML.length"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="TRUE = copied string into buffer and started parsing&#13;&#10;FALSE = could not copy the string, length is 0 or Reader is not ready" Name="ParseXML.retcode"/>
		END_VAR;
				//! <Function Comment="method to get the state of the xml-reader class" Name="GetXmlState"/>
	FUNCTION GLOBAL GetXmlState
		VAR_OUTPUT
			state 	: XML_READ_STATE;			//! <Variable Comment="state of the xml-reader" Name="GetXmlState.state"/>
		END_VAR;
				//! <Function Comment="method to get the error state of the xml-reader class" Name="GetErrorState"/>
	FUNCTION GLOBAL GetErrorState
		VAR_OUTPUT
			state 	: _XML_PARSE_ERROR;			//! <Variable Comment="error state of the xml-reader" Name="GetErrorState.state"/>
		END_VAR;
				//! <Function Comment="Converts notation of special characters in XML to normal characters&#13;&#10;(for example &quot;&amp;amp;&quot; will be converted to &apos;&amp;&apos;)&#13;&#10;output-string will be shorter than source-string, source and destination can be the same buffer" Name="ConvertXmlToText"/>
	FUNCTION GLOBAL ConvertXmlToText
		VAR_INPUT
			pDest 	: ^void;			//! <Variable Comment="pointer to destination where the converted string should be stored" Name="ConvertXmlToText.pDest"/>
			pSrc 	: ^void;			//! <Variable Comment="pointer to the string which should be converted" Name="ConvertXmlToText.pSrc"/>
			size 	: UINT;			//! <Variable Comment="size of one character&#13;&#10;1...ASCII&#13;&#10;2...UNICODE" Name="ConvertXmlToText.size"/>
		END_VAR
		VAR_OUTPUT
			length 	: DINT;			//! <Variable Comment="length of the converted string" Name="ConvertXmlToText.length"/>
		END_VAR;
	
	FUNCTION FetchElementsAndAttribsUni
		VAR_INPUT
			pElementCount 	: ^UDINT;
			pAttribCount 	: ^UDINT;
		END_VAR;
	
	FUNCTION ConvertXmlToTextAscii
		VAR_INPUT
			pDest 	: ^CHAR;
			pSrc 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			length 	: DINT;
		END_VAR;
	
	FUNCTION ConvertXmlToTextUni
		VAR_INPUT
			pDest 	: ^UINT;
			pSrc 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			length 	: DINT;
		END_VAR;
				//! <Function Comment="method to start with Get-Functions at the beginning of the struct again" Name="ResetSearch"/>
	FUNCTION GLOBAL ResetSearch;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CheckSum
#pragma using _XMLStructCreator
#pragma usingLtd _FileSys
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _XMLReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__XMLREADER
2$UINT, 3$UINT, (SIZEOF(::_XMLReader))$UINT, 
6$UINT, 7$UINT, 0$UINT, 
TO_UDINT(3727258101), "_XMLReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_XMLReader.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_XMLReader.XmlState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(742526690), "XmlState", 
(::_XMLReader.ErrorState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2975757027), "ErrorState", 
(::_XMLReader.ErrorLine.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2875063439), "ErrorLine", 
(::_XMLReader.ErrorSign.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3845642631), "ErrorSign", 
(::_XMLReader.DoConvert.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2237141759), "DoConvert", 
//Clients:
(::_XMLReader.FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1422438244), "FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_XMLReader.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_XMLReader.StructCreator.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3556400222), "StructCreator", TO_UDINT(2131172539), "_XMLStructCreator", 2$UINT, 0$UINT, 
(::_XMLReader.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::_XMLReader.MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3505031941), "MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::_XMLReader.CreateTask.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(184646452), "CreateTask", 
(::_XMLReader.CheckSum.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(408699862), "CheckSum", TO_UDINT(916194998), "_CheckSum", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT__XMLReader 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__XMLReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _XMLReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__XMLReader, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	DoConvert.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF DoConvert.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL _XMLReader::Init
  
  if _FirstScan then
    
    readSSW := _WAIT;
    XmlState := _READY;
    
    if CreateTask = 1 then // sprdie - v1.6 do not create task if client is not set!
      if CreateTaskName(#szTaskName[0]) then
          
          taskHandle := MultiTask.CREATETHREAD( #XmlReadTask(), 
                                                XMLREADER_TASKPRIO, 
                                                XMLREADER_STACKSIZE, 
                                                MT_TASK_SAVETHIS, 
                                                this, 
                                                #szTaskName[0]);
          if taskHandle = NIL then
            XmlState := _ERROR;
            ErrorState := _PARSE_ERR_NO_TASK;
          end_if;
          
          isTaskCreated := TRUE;
        
        else
          
          XmlState := _ERROR;
          ErrorState := _PARSE_ERR_NO_TASK;
          
        end_if;
    end_if;
    
    // sprdie v2.1 - prepare unicode strings -----------------
    SigCLib.ToStr16(#strUniAmp[0], XML_CONVERT_AMPERSAND);
    SigCLib.ToStr16(#strUniApos[0], XML_CONVERT_APOS);
    SigCLib.ToStr16(#strUniGreater[0], XML_CONVERT_GREATER);
    SigCLib.ToStr16(#strUniLess[0], XML_CONVERT_LESS);
    SigCLib.ToStr16(#strUniQuot[0], XML_CONVERT_QUOT);
    // -------------------------------------------------------
    
  end_if;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL _XMLReader::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		State (EAX) 	: UDINT;
	END_VAR
  VAR
  	bytesParsed : UDINT;
  END_VAR

	State := READY;
  
  // when mark is set start reading file async
  case readSSW of
  	
    _WAIT:
  	  if startReading then
        
        startReading := FALSE;
        if XmlState = _READY then
          readSSW := _OPEN_FILE;
        end_if;

      end_if;
    
    _OPEN_FILE:
  	  if XmlState = _READY then       
        asyncID$DINT := FileSys.FileOpen_A(1, pFileName, ATT_READ_ONLY);
        XmlState := _FILE_OPENING;
      end_if;
      
      if XmlState = _FILE_OPENING then
        
        asyncState := FileSys.GetAsyncState(asyncID, #fctRetval);        
        if asyncState = 0 then
          FileHandle := fctRetval;
          
          //sprdie - set error state if we get an invalid file-handle!
          if FileHandle < 0 then
            XmlState := _ERROR;
            return;
          end_if;

          XmlState := _FILE_OPENED;
          readSSW := _GET_LENGTH_FILE;
        end_if;
        
      end_if;
    
    _GET_LENGTH_FILE:
      if XmlState = _FILE_OPENED then
        asyncID$DINT := FileSys.FileLength_A(1, FileHandle);
        XmlState := _FILE_GET_LENGTH;
      end_if;
      
      if XmlState = _FILE_GET_LENGTH then
        
        asyncState := FileSys.GetAsyncState(asyncID, #fctRetval);
        if asyncState = 0 then
          fileLength := fctRetval$UDINT;
          pFileBuffer$^void := StdLib.Malloc(fileLength);
          if (pFileBuffer = NIL) then
            XmlState := _ERROR;
          else
            StructCreator.SetFileBufferInfo(pFileBuffer, fileLength);
            XmlState := _FILE_GOT_LENGTH;
            readSSW := _READ_FILE;
          end_if;
          
        end_if;

      end_if;
      
    _READ_FILE:
  	  if XmlState = _FILE_GOT_LENGTH then
        asyncID := FileSys.FileRead_A(1, FileHandle, pFileBuffer, fileLength$UDINT);
        XmlState := _FILE_READING;
      end_if;
      
      if XmlState = _FILE_READING then
        
        asyncState := FileSys.GetAsyncState(asyncID, #fctRetval);
        if asyncState = 0 then 
          XmlState := _FILE_READ;
          readSSW := _CLOSE_FILE;
        end_if;

      end_if;
    
    _CLOSE_FILE:
      if XmlState = _FILE_READ then
        asyncID$DINT := FileSys.FileClose_A(1, FileHandle);
        XmlState := _FILE_CLOSING;
      end_if;
      
      if XmlState = _FILE_CLOSING then
        
        asyncState := FileSys.GetAsyncState(asyncID, #fctRetval);
        if asyncState = 0 then
          
          XmlState := _FILE_CLOSED;
          readSSW := _CREATE_STRUCT;
          
        end_if;

      end_if;
    
    _CREATE_STRUCT:
      
      if XmlState = _FILE_CLOSED | XmlState = _PARSE_STREAM then
        XmlState := _STRUCT_CREATING;
        if isTaskCreated = FALSE then
          // no Task created -> Background
          if CreateStruct(#bytesParsed) then
            XmlState := _STRUCT_CREATED;
            readSSW := _WAIT;
          else
            FindError(bytesParsed);
            XmlState := _ERROR;
          end_if;
        
        else
          // Task created -> start work
          isCreated := FALSE;
          doCreate := TRUE;
        end_if;
        
      end_if;
      
      if XmlState = _STRUCT_CREATING then
        // parsing will be done in user-task => check if task finished!
        if isCreated = TRUE then
          XmlState := _STRUCT_CREATED;
          readSSW := _WAIT;
        end_if;

      end_if;
    
    _FREE_STRUCT: 
      if XmlState = _STRUCT_FREE then
        
        if isFree = TRUE then
          XmlState := _READY;
          readSSW := _WAIT;
          ErrorState := _PARSE_ERR_NONE;
          ErrorLine := 0;
          ErrorSign := 0;
        end_if;

      end_if;
      
  end_case;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::ReadFile
	VAR_INPUT
		FileName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	nameLen   : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  if FileName = NIL then
    return;
  end_if;
  
  // HubChr v2.2 check if there is memory we have to free first
  if pFileName <> NIL then
    StdLib.Free(pFileName);
  end_if;

  // save FileName and set mark so we start reading the file async
  nameLen := _strlen(FileName) + 1;
  pFileName$^void := StdLib.Malloc(nameLen);
  
  if (pFileName = NIL) then
    XmlState := _ERROR;
    return;
  end_if;
  
  _strcpy(pFileName, FileName);
 
  startReading := TRUE;
  
  // HubChr v2.2: if the state is ready, we can directly switch to the next step
  // this saves 1 BG cycle.
  if (readSSW = _WAIT) & (XmlState = _READY) then
    startReading := FALSE;
    readSSW := _OPEN_FILE;
  end_if;
  
  
  gotFirst := FALSE;
  retcode := TRUE;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::FreeReader
  
  // used to free the allocated memory and set state to ready
  // so only when user finished handling a file he is able to read a new one
  
  // if no user task has been created, call free-method of StructCreator
  // otherwise we start the work of the user-task
  
  // but first free memory for FileBuffer and FileName and reset variables
  if (pFileBuffer <> NIL) then 
    StdLib.Free(pFileBuffer);
    pFileBuffer := NIL;
  end_if;
  
  if (pFileName <> NIL) then
    StdLib.Free(pFileName); 
    pFileName := NIL;
  end_if;
  
  lastSearch := _NONE;
  pFileBuffer := NIL;
  pFileName := NIL;
  searchPtr := NIL;
  
  // sprdie v2.0 - free last search criteria ---
  if (lastCriteria <> NIL) then
    StdLib.Free(lastCriteria);
    lastCriteria := NIL;
  end_if;
  if (lastCriteriaValue <> NIL) then
    StdLib.Free(lastCriteriaValue);
    lastCriteriaValue := NIL;
  end_if;
  if (lastCriteriaUni <> NIL) then
    StdLib.Free(lastCriteriaUni);
    lastCriteriaUni := NIL;
  end_if;
  if (lastCriteriaValueUni <> NIL) then
    StdLib.Free(lastCriteriaValueUni);
    lastCriteriaValueUni := NIL;
  end_if;
  // sprdie v2.0 -------------------------------
  
  getPtr := NIL;
  lastLen := 0;
  lastLenValue := 0;
  gotfirst := 0;
  gotAll := 0;
  bQuot := 0;
  bTextSearched := 0;
  fileLength := 0;
  asyncID := 0;
  FileHandle := 0;
  
  if isTaskCreated = FALSE then
    
    StructCreator.FreeStruct();
    XmlState := _READY;
    readSSW := _WAIT;
    ErrorState := _PARSE_ERR_NONE;
    ErrorLine := 0;
    ErrorSign := 0;

  else
    
    doFree := TRUE;
    isFree := FALSE;
    XmlState := _STRUCT_FREE;
    readSSW := _FREE_STRUCT;
    
  end_if;
  
END_FUNCTION


FUNCTION _XMLReader::CreateStruct
	VAR_INPUT
		parsedBytes 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  bRdIsUnicode := FileIsUnicode();
  
  if bRdIsUnicode = TRUE then
    retcode := CreateStructUni(parsedBytes);
  else
    retcode := CreateStructAscii(parsedBytes);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetHeader
	VAR_OUTPUT
		pHeader 	: ^USINT;
	END_VAR

  pHeader := xmlStruct.Header$^USINT;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetFirstElement
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR

  getPtr := xmlStruct.MajorElement;
  gotFirst := TRUE;
  gotAll := FALSE;
  
  pElement := getPtr;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetNextElement
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  
  pElement := NIL;
  
  if gotAll then
    return;
  end_if;
  
  if getPtr = NIL then
    return; //Readfile not successfully called
  end_if;

  
  if gotFirst then
    
    if getPtr^.pChildren <> NIL then
      
      getPtr := getPtr^.pChildren;
      pElement := getPtr;
      
    elsif getPtr^.pNext <> NIL then
      
      getPtr := getPtr^.pNext;
      pElement := getPtr;
      
    else
      
      while getPtr <> xmlStruct.MajorElement do
        
        if getPtr^.pPrevious <> NIL then
          getPtr := getPtr^.pPrevious;
        else
          getPtr := getPtr^.pFather;
          
          if getPtr^.pNext <> NIL then
            
            getPtr := getPtr^.pNext;
            pElement := getPtr;
            
            return;
            
          end_if;

        end_if;
        
      end_while;
      
      gotAll := TRUE;
      
    end_if;

  end_if;

END_FUNCTION



FUNCTION GLOBAL _XMLReader::GetElementByName
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR

  if bRdIsUnicode = TRUE then
    pElement := GetElementByNameUni(pName$^UINT);
  else
    pElement := GetElementByNameAscii(pName);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetElementByAttrib
	VAR_INPUT
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR

  if bRdIsUnicode = TRUE then
    pElement := GetElementByAttribUni(pName$^UINT, pValue$^UINT);
  else
    pElement := GetElementByAttribAscii(pName, pValue);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetElementByAttribName
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR

  if bRdIsUnicode = TRUE then
    pElement := GetElementByAttribNameUni(pName$^UINT);
  else
    pElement := GetElementByAttribNameAscii(pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetElementByText
	VAR_INPUT
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR

  if bRdIsUnicode = TRUE then
    pElement := GetElementByTextUni(pText$^UINT);
  else
    pElement := GetElementByTextAscii(pText);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::EditName
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  if bRdIsUnicode = TRUE then
    retcode := EditNameUni(pElement, pName$^UINT);
  else
    retcode := EditNameAscii(pElement, pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::EditAttribName
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		index 	: UDINT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  if bRdIsUnicode = TRUE then
    retcode := EditAttribNameUni(pElement, index, pName$^UINT);
  else
    retcode := EditAttribNameAscii(pElement, index, pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::EditAttribValue
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		index 	: UDINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR

  if bRdIsUnicode = TRUE then
    retcode := EditAttribValueUni(pElement, index, pValue$^UINT);
  else
    retcode := EditAttribValueAscii(pElement, index, pValue);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::EditText
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  if bRdIsUnicode = TRUE then
    retcode := EditTextUni(pElement, pText$^UINT);
  else
    retcode := EditTextAscii(pElement, pText);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::DeleteElement
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		bDeleteChildren 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pFather   : ^_XML_ELEMENT;
    pPrevious : ^_XML_ELEMENT;
    pNext     : ^_XML_ELEMENT;
    pChildren : ^_XML_ELEMENT;
    pTmp      : ^_XML_ELEMENT;
    pFree     : ^_XML_ELEMENT;
    i         : UDINT;
    pAtt      : ^_XML_ATTRIBUTE;
  END_VAR

  retcode := FALSE;
  
  if pElement = NIL then
    return;
  end_if;

  
  if pElement = xmlStruct.MajorElement then
    // deleting Major Element is not allowed!!!
    return;
  end_if;
  
  pFather   := pElement^.pFather;
  pChildren := pElement^.pChildren;
  pPrevious := pElement^.pPrevious;
  pNext     := pElement^.pNext;
  
  if pChildren <> NIL then
    // special treatment if we have children
    if bDeleteChildren = TRUE then
      // also delete the children!
      // this part will get a little bit confusing because we also have to delete children of children, and children of those children and so on...
      
      pTmp := pChildren;
      while pTmp^.pNext <> NIL do
        pTmp := pTmp^.pNext;
      end_while;
      
      while pTmp <> pElement do
      
        if pTmp^.pChildren <> NIL then
          
          pTmp := pTmp^.pChildren;
          while pTmp^.pNext <> NIL do
            pTmp := pTmp^.pNext;
          end_while;
               
        else
          
          pFree := pTmp;
          
          if pTmp^.pPrevious <> NIL then
            pTmp := pTmp^.pPrevious;
          elsif pTmp^.pFather <> NIL then
            pTmp := pTmp^.pFather;
            pTmp^.pChildren := NIL;
          end_if;
          
          // free Text
          if pFree^.pText <> NIL then
            StructCreator.FreePointer(pFree^.pText, _XML_FREE_TEXT);
          end_if;

          // free Attributes
          if pFree^.Attributes.no > 0 then
            pAtt := pFree^.Attributes.pList;
            for i := 1 to pFree^.Attributes.no do
              StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
              StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
              
              pAtt += sizeof(_XML_ATTRIBUTE);
            end_for;
            
            StructCreator.FreePointer(pFree^.Attributes.pList, _XML_FREE_ATTRIBUTE);
          end_if;
          
          // free Name
          StructCreator.FreePointer(pFree^.Name, _XML_FREE_TEXT);
          
          // free Element
          StructCreator.FreePointer(pFree, _XML_FREE_ELEMENT);
          
        end_if;
     
      end_while;
      
      // at this point we deleted all children -> so lets free the root-element
      // now lets do the same code as we wouldn't have children!
      // first IF is for all elements which are not at the beginning of the list
      // second IF is for our first element of the list
      if pPrevious <> NIL then
        
        // next element of our previous is now our next element -> linking jumps over us
        pPrevious^.pNext := pNext;
        // if we have a next-element finish the double-linking
        if pNext <> NIL then
          // this means the back-linking goes to our previous element -> back-linking also jumps over us
          pNext^.pPrevious := pPrevious;
        end_if;

      end_if;
      
      if pFather <> NIL then
        // lets point the father to our next element
        pFather^.pChildren := pNext;
        
        if pNext <> NIL then
          // and the backwards-connection
          pNext^.pFather := pFather;
          // and now our next element has no previous because now it is at the beginning of the list
          pNext^.pPrevious := NIL;
        end_if;
      
      end_if;    
      // now we cann free our Element
      // free Text
      if pElement^.pText <> NIL then
        StructCreator.FreePointer(pElement^.pText, _XML_FREE_TEXT);
      end_if;

      // free Attributes
      if pElement^.Attributes.no > 0 then
        pAtt := pElement^.Attributes.pList;
        for i := 1 to pElement^.Attributes.no do
          StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
          StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
          
          pAtt += sizeof(_XML_ATTRIBUTE);
        end_for;
        
        StructCreator.FreePointer(pElement^.Attributes.pList, _XML_FREE_ATTRIBUTE);
      end_if;
      
      // free Name
      StructCreator.FreePointer(pElement^.Name, _XML_FREE_TEXT);
      
      // free Element
      StructCreator.FreePointer(pElement, _XML_FREE_ELEMENT);
      retcode := TRUE;
      
    else
      // do not delete children -> move them one level higher (same level as pPrevious of Element to delete)
      // this is easier because we just have to insert the children to the linked list at the place of the element to delete!
      
      pChildren^.pFather := pFather;
      pChildren^.pPrevious := pPrevious;
      
      // only one of the following 2 IF can be true
      if pFather <> NIL then
        pFather^.pChildren := pChildren;
      end_if;
      if pPrevious <> NIL then
        pPrevious^.pNext := pChildren;
      end_if;
      
      // now go to the last element with same level as our child and set the next ptr
      pTmp := pChildren;
      while pTmp^.pNext <> NIL do
        pTmp := pTmp^.pNext;
      end_while;
      
      pTmp^.pNext := pNext;
      if pNext <> NIL then
        pNext^.pPrevious := pTmp;      
      end_if;
      
      // now everything should be fine and we can delete(free) the element
      // free Text
      if pElement^.pText <> NIL then
        StructCreator.FreePointer(pElement^.pText, _XML_FREE_TEXT);
      end_if;

      // free Attributes
      if pElement^.Attributes.no > 0 then
        pAtt := pElement^.Attributes.pList;
        for i := 1 to pElement^.Attributes.no do
          StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
          StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
          
          pAtt += sizeof(_XML_ATTRIBUTE);
        end_for;
        
        StructCreator.FreePointer(pElement^.Attributes.pList, _XML_FREE_ATTRIBUTE);
      end_if;
      
      // free Name
      StructCreator.FreePointer(pElement^.Name, _XML_FREE_TEXT);
      
      // free Element
      StructCreator.FreePointer(pElement, _XML_FREE_ELEMENT);
      retcode := TRUE;
      
    end_if;
  
  else
    // we do not have children...this is the easiest part
    // just delete one entry of a double-linked-list
    // first IF is for all elements which are not at the beginning of the list
    // second IF is for our first element of the list
    if pPrevious <> NIL then
      
      // next element of our previous is now our next element -> linking jumps over us
      pPrevious^.pNext := pNext;
      // if we have a next-element finish the double-linking
      if pNext <> NIL then
        // this means the back-linking goes to our previous element -> back-linking also jumps over us
        pNext^.pPrevious := pPrevious;
      end_if;

    end_if;
    
    if pFather <> NIL then
      // lets point the father to our next element
      pFather^.pChildren := pNext;
      //sprdie v2.1 - added correction 4 deleting elements -----
      if pNext <> NIL then
        // and the backwards-connection (only if there is a child left) --- SPRDIE - CORRECTION!!!
        pNext^.pFather := pFather;
        // and now our next element has no previous because now it is at the beginning of the list
        pNext^.pPrevious := NIL;
      end_if;
      //--------------------------------------------------------
    end_if;
    
    // now we can free our Element
    // free Text
    if pElement^.pText <> NIL then
      StructCreator.FreePointer(pElement^.pText, _XML_FREE_TEXT);
    end_if;

    // free Attributes
    if pElement^.Attributes.no > 0 then
      pAtt := pElement^.Attributes.pList;
      for i := 1 to pElement^.Attributes.no do
        StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
        StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
        
        pAtt += sizeof(_XML_ATTRIBUTE);
      end_for;
      
      StructCreator.FreePointer(pElement^.Attributes.pList, _XML_FREE_ATTRIBUTE);
    end_if;
    
    // free Name
    StructCreator.FreePointer(pElement^.Name, _XML_FREE_TEXT);
    
    // free Element
    StructCreator.FreePointer(pElement, _XML_FREE_ELEMENT);
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::DeleteAttribute
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		Index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pAtt      : ^_XML_ATTRIBUTE;
    pNew      : ^_XML_ATTRIBUTE;
    newList   : _XML_ATTRIBUTE_LIST;
    i         : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  if pElement = NIL then
    return;
  end_if;

  
  if Index < pElement^.Attributes.no then
    // valid index
    // we are going to create a new List and copy all atributes except of the one we want to delete
    newList.no := pElement^.Attributes.no - 1;
    if (newList.no = 0) then
      // special treatment if we delete the last attribute
      // just free the last entry and set pointer to NIL
      StructCreator.FreePointer(pElement^.Attributes.pList^.Name, _XML_FREE_TEXT);
      StructCreator.FreePointer(pElement^.Attributes.pList^.Value, _XML_FREE_TEXT);
      
      StructCreator.FreePointer(pElement^.Attributes.pList, _XML_FREE_ATTRIBUTE);
      pElement^.Attributes.no := 0;
      pElement^.Attributes.pList := NIL;
      retcode := TRUE;
      return;
    end_if;

    newList.pList$^void := StdLib.Malloc(newList.no*sizeof(_XML_ATTRIBUTE));
    
    if newList.pList = NIL then
      XmlState := _ERROR;
      return;
    end_if; 
    pAtt := pElement^.Attributes.pList;
    pNew := newList.pList;
    
    for i := 0 to pElement^.Attributes.no - 1 do
      
      if i <> Index then
        _memcpy(pNew, pAtt, sizeof(_XML_ATTRIBUTE));
        pNew += sizeof(_XML_ATTRIBUTE);
      else
        // we reached the index to delete -> free name & value
        StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
        StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
      end_if;
      
      pAtt += sizeof(_XML_ATTRIBUTE);
      
    end_for;
    
    StructCreator.FreePointer(pElement^.Attributes.pList, _XML_FREE_ATTRIBUTE);
    pElement^.Attributes.no := newList.no;
    pElement^.Attributes.pList := newList.pList;
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::DeleteText
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := FALSE;
  
  if pElement = NIL then
    return;
  end_if;

  if pElement^.pText <> NIL then
    
    // we have a text -> delete it
    StructCreator.FreePointer(pElement^.pText, _XML_FREE_TEXT);
    pElement^.pText := NIL;
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetAttribIndex
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		Index 	: DINT;
	END_VAR
  
  if bRdIsUnicode = TRUE then
    Index := GetAttribIndexUni(pElement, pName$^UINT);
  else
    Index := GetAttribIndexAscii(pElement, pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::Reset
  
  if XmlState = _ERROR then 
    
    FreeReader();
    
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::AddChildElement
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_XML_ELEMENT;
	END_VAR

  if bRdIsUnicode = TRUE then
    retcode := AddChildElementUni(pDest, pName$^UINT);
  else
    retcode := AddChildElementAscii(pDest, pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::AddBrotherElement
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_XML_ELEMENT;
	END_VAR

  if bRdIsUnicode = TRUE then
    retcode := AddBrotherElementUni(pDest, pName$^UINT);
  else
    retcode := AddBrotherElementAscii(pDest, pName);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLReader::AddAttribute
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  // check if name already exists!
  if StructCreator.CheckAddAttribute(pDest, pName, bRdIsUnicode$BOOL) = FALSE then
    retcode := -3;
    return;
  end_if;
  
  if bRdIsUnicode = TRUE then
    retcode := AddAttributeUni(pDest, pName$^UINT, pValue$^UINT);
  else
    retcode := AddAttributeAscii(pDest, pName, pValue);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::AddText
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  if bRdIsUnicode = TRUE then
    retcode := AddTextUni(pDest, pText$^UINT);
  else
    retcode := AddTextAscii(pDest, pText);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetAttribNameByIndex
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		Index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pName 	: ^USINT;
	END_VAR
  VAR
  	pAtt  : ^_XML_ATTRIBUTE;
  END_VAR

  pName := NIL;
  
  if pElement = NIL then
    return;
  end_if;

  
  if (pElement^.Attributes.no = 0) | (Index > (pElement^.Attributes.no - 1)) then
    // no attributes or Index out of range
    return;
  end_if;

  pAtt := pElement^.Attributes.pList + (Index * sizeof(_XML_ATTRIBUTE));
  
  pName := pAtt^.Name;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetAttribValueByIndex
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		Index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pValue 	: ^USINT;
	END_VAR
  VAR
  	pAtt  : ^_XML_ATTRIBUTE;
  END_VAR
  
  pValue := NIL;
  
  if pElement = NIL then
    return;
  end_if;

  
  if (pElement^.Attributes.no = 0) | (Index > (pElement^.Attributes.no - 1)) then
    // no attributes or Index out of range
    return;
  end_if;

  pAtt := pElement^.Attributes.pList + (Index * sizeof(_XML_ATTRIBUTE));
  
  pValue := pAtt^.Value;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetEncoding
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	pHead     : ^USINT;
    HeaderLen : DINT;
    foundEnc  : BOOL;
    i         : DINT;
    pTmp      : ^USINT;
    pStart    : ^USINT;
    signCount : UDINT;
    aString   : ARRAY[0..19] of USINT;
  END_VAR
  
  retcode := -1;
  
  _memset(#aString, 0, 20);

  foundEnc := FALSE;
  signCount := 0;
  
  pHead := GetHeader();
  
  if pHEad = NIL then
    return;
  end_if;
  
  if bRdIsUnicode = TRUE then
    retcode := ENCODING_UTF16; 
    return;
  end_if;
  
  HeaderLen$UDINT := _strlen(pHead); 
  if HeaderLen = 0 then
    return;
  end_if;

  
  pTmp := pHead;
  
  for i := 0 to HeaderLen - 8 do
    
    if _memcmp(pTmp, "encoding", 8) = 0 then
      foundEnc := TRUE;
      exit;
    end_if;
    
    pTmp += 1;
    
  end_for;
  
  if foundEnc then
    pTmp += 10; //skip encoding + ="
    
    pStart := pTmp;
    
    while pTmp^ <> XML_QUOTMARK do
      signCount += 1;
      pTmp += 1;
    end_while;
    
    _memcpy(#aString[0], pStart, signCount);
    
    if _stricmp(#aString[0], STRING_UTF8) = 0 then
      retcode := ENCODING_UTF8;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_1) = 0 then
      retcode := ENCODING_ISO8859_1;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_2) = 0 then
      retcode := ENCODING_ISO8859_2;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_3) = 0 then
      retcode := ENCODING_ISO8859_3;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_4) = 0 then
      retcode := ENCODING_ISO8859_4;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_5) = 0 then
      retcode := ENCODING_ISO8859_5;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_6) = 0 then
      retcode := ENCODING_ISO8859_6;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_7) = 0 then
      retcode := ENCODING_ISO8859_7;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_8) = 0 then
      retcode := ENCODING_ISO8859_8;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_9) = 0 then
      retcode := ENCODING_ISO8859_9;
      return;
    end_if;
    
    if _stricmp(#aString[0], STRING_ISO8859_10) = 0 then
      retcode := ENCODING_ISO8859_10;
      return;
    end_if;
  
  else
    retcode := ENCODING_UTF8;
  end_if;
  
END_FUNCTION


FUNCTION _XMLReader::FileIsUnicode
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
//returns true if encoding is unicode (ff fe in the beginning)
  if (pFileBuffer^ = 16#FF) & ((pFileBuffer+1)^ = 16#FE) then
    retcode := TRUE; 
  else
    retcode := FALSE;
  end_if;

END_FUNCTION


FUNCTION _XMLReader::GetElementByNameAscii
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound    : BOOL;
    NameLen   : UDINT;
  END_VAR

  pElement := NIL;
  bFound := FALSE;
  
  if pName = NIL then
    return;
  end_if;
  
  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := _strlen(pName) + 1;
  if NameLen <> lastLen then
    if lastCriteria <> NIL then
      StdLib.Free(lastCriteria);
    end_if;
    
    lastCriteria$^void := StdLib.Malloc(NameLen);

    if (lastCriteria = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(lastCriteria, 0, NameLen);
    
    lastLen := NameLen;
  end_if;
  
  if (_strcmp(lastCriteria, pName) <> 0) | (lastSearch <> _BY_NAME) then
    
    lastSearch := _BY_NAME;
    
    // new input -> start from beginning
    _strcpy(lastCriteria, pName);
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if _strcmp(searchPtr^.Name, lastCriteria) = 0 then
      
      pElement := searchPtr;
      bFound := TRUE;
      
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on
  end_if;

  while searchPtr <> xmlStruct.MajorElement do
    
    if _strcmp(searchPtr^.Name, lastCriteria) = 0 then
      pElement := searchPtr;
      bFound := TRUE;
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
  end_if;
  
END_FUNCTION //GetElementByNameAscii


FUNCTION _XMLReader::GetElementByNameUni
	VAR_INPUT
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound    : BOOL;
    NameLen   : UDINT;
  END_VAR

  pElement := NIL;
  bFound := FALSE;
  
  if pName = NIL then
    return;
  end_if;
  
  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := SigCLib.StrLen16(pName)*2 + 2; 
  if NameLen <> lastLen then
    if lastCriteriaUni <> NIL then
      StdLib.Free(lastCriteriaUni);
    end_if;
    
    lastCriteriaUni$^void := StdLib.Malloc(NameLen);

    if (lastCriteriaUni = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(lastCriteriaUni, 0, NameLen);
    
    lastLen := NameLen;
  end_if;
  
 
  if (SigCLib.StrCmp16(lastCriteriaUni, pName) <> 0) | (lastSearch <> _BY_NAME) then
    
    lastSearch := _BY_NAME;
    
    // new input -> start from beginning
    SigCLib.StrCpy16(lastCriteriaUni, pName);    
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if SigCLib.StrCmp16(searchPtr^.Name$^UINT, lastCriteriaUni) = 0 then
      
      pElement := searchPtr;
      bFound := TRUE;
      
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on
  end_if;

  while searchPtr <> xmlStruct.MajorElement do
    
    if SigCLib.StrCmp16(searchPtr^.Name$^UINT, lastCriteriaUni) = 0 then
      pElement := searchPtr;
      bFound := TRUE;
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
  end_if;

  
END_FUNCTION //GetElementByNameUni


FUNCTION _XMLReader::GetElementByAttribAscii
	VAR_INPUT
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound    : BOOL;
    pAtt      : ^_XML_ATTRIBUTE;
    i         : UDINT;
    NameLen   : UDINT;
    ValueLen  : UDINT;
  END_VAR

  pElement := NIL;
  bFound := FALSE;
  
  if (pName = NIL) | (pValue = NIL) then
    return;
  end_if;
  
  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := _strlen(pName) + 1;
  ValueLen := _strlen(pValue) + 1;
  
  if (NameLen <> lastLen) | (ValueLen <> lastLenValue) then
    
    if lastCriteria <> NIL then
      StdLib.Free(lastCriteria);
    end_if;
    if lastCriteriaValue <> NIL then
      StdLib.Free(lastCriteriaValue);
    end_if;
    
    lastCriteria$^void := StdLib.Malloc(NameLen);
    lastCriteriaValue$^void := StdLib.Malloc(ValueLen);
    
    if (lastCriteria = NIL) | (lastCriteriaValue = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    
    _memset(lastCriteria, 0, NameLen);
    _memset(lastCriteriaValue, 0, ValueLen);   
    
    lastLen := NameLen;
    lastLenValue := ValueLen;
    
  end_if;
  
  if (_strcmp(lastCriteria, pName) <> 0) | (_strcmp(lastCriteriaValue, pValue) <> 0) | (lastSearch <> _BY_ATTRIB) then
    
    lastSearch := _BY_ATTRIB;
    
    // new input -> start from beginning
    _strcpy(lastCriteria, pName);
    _strcpy(lastCriteriaValue, pValue);
    
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (_strcmp(pAtt^.Name, lastCriteria) = 0) & (_strcmp(pAtt^.Value, lastCriteriaValue) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on
  end_if;

  while searchPtr <> xmlStruct.MajorElement do
    
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (_strcmp(pAtt^.Name, lastCriteria) = 0) & (_strcmp(pAtt^.Value, lastCriteriaValue) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
    lastLenValue := 0;
  end_if;
  
END_FUNCTION //GetElementByAttribAscii


FUNCTION _XMLReader::GetElementByAttribUni
	VAR_INPUT
		pName 	: ^UINT;
		pValue 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound    : BOOL;
    pAtt      : ^_XML_ATTRIBUTE;
    i         : UDINT;
    NameLen   : UDINT;
    ValueLen  : UDINT;
  END_VAR

  pElement := NIL;
  bFound := FALSE;
  
  if (pName = NIL) | (pValue = NIL) then
    return;
  end_if;
  
  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := SigCLib.StrLen16(pName)*2 + 2;
  ValueLen := SigCLib.StrLen16(pValue)*2 + 2;
  
  if (NameLen <> lastLen) | (ValueLen <> lastLenValue) then
    
    if lastCriteriaUni <> NIL then
      StdLib.Free(lastCriteriaUni);
    end_if;
    if lastCriteriaValueUni <> NIL then
      StdLib.Free(lastCriteriaValueUni);
    end_if;
    
    lastCriteriaUni$^void := StdLib.Malloc(NameLen);
    lastCriteriaValueUni$^void := StdLib.Malloc(ValueLen);
    
    if (lastCriteriaUni = NIL) | (lastCriteriaValueUni = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    
    _memset(lastCriteriaUni, 0, NameLen);
    _memset(lastCriteriaValueUni, 0, ValueLen);   
    
    lastLen := NameLen;
    lastLenValue := ValueLen;
    
  end_if;
  
  if (SigCLib.StrCmp16(lastCriteriaUni, pName) <> 0) | (SigCLib.StrCmp16(lastCriteriaValueUni, pValue) <> 0) | (lastSearch <> _BY_ATTRIB) then
    
    lastSearch := _BY_ATTRIB;
    
    // new input -> start from beginning
    SigCLib.StrCpy16(lastCriteriaUni, pName);
    SigCLib.StrCpy16(lastCriteriaValueUni, pValue);
    
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (SigCLib.StrCmp16(pAtt^.Name$^UINT, lastCriteriaUni) = 0) & (SigCLib.StrCmp16(pAtt^.Value$^UINT, lastCriteriaValueUni) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on
  end_if;

  while searchPtr <> xmlStruct.MajorElement do
    
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (SigCLib.StrCmp16(pAtt^.Name$^UINT, lastCriteriaUni) = 0) & (SigCLib.StrCmp16(pAtt^.Value$^UINT, lastCriteriaValueUni) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
    lastLenValue := 0;
  end_if;
  
END_FUNCTION //GetElementByAttribUni


FUNCTION _XMLReader::GetElementByAttribNameAscii
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound  : BOOL;
    pAtt    : ^_XML_ATTRIBUTE;
    i       : UDINT;
    NameLen   : UDINT;
  END_VAR
  
  pElement := NIL;
  bFound := FALSE;
  
  if pName = NIL then
    return;
  end_if;

  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := _strlen(pName) + 1;
  if NameLen <> lastLen then
    if lastCriteria <> NIL then
      StdLib.Free(lastCriteria);
    end_if;
    
    lastCriteria$^void := StdLib.Malloc(NameLen);
    if lastCriteria = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(lastCriteria, 0, NameLen);
    lastLen := NameLen;
  end_if;
  
  if (_strcmp(lastCriteria, pName) <> 0) | lastSearch <> _BY_ATTRIB_NAME then
    
    lastSearch := _BY_ATTRIB_NAME;
    // new input
    _strcpy(lastCriteria, pName);
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (_strcmp(pAtt^.Name, lastCriteria) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on  
  end_if;
  
  while searchPtr <> xmlStruct.MajorElement do
    
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (_strcmp(pAtt^.Name, lastCriteria) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
  end_if;
  
END_FUNCTION //GetElementByAttribNameAscii


FUNCTION _XMLReader::GetElementByAttribNameUni
	VAR_INPUT
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound  : BOOL;
    pAtt    : ^_XML_ATTRIBUTE;
    i       : UDINT;
    NameLen   : UDINT;
  END_VAR
  
  pElement := NIL;
  bFound := FALSE;
  
  if pName = NIL then
    return;
  end_if;

  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := SigCLib.StrLen16(pName)*2 + 2;
  if NameLen <> lastLen then
    if lastCriteriaUni <> NIL then
      StdLib.Free(lastCriteriaUni);
    end_if;
    
    lastCriteriaUni$^void := StdLib.Malloc(NameLen);
    if lastCriteriaUni = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(lastCriteriaUni, 0, NameLen);
    lastLen := NameLen;
  end_if;
  
  if (SigCLib.StrCmp16(lastCriteriaUni, pName) <> 0) | lastSearch <> _BY_ATTRIB_NAME then
    
    lastSearch := _BY_ATTRIB_NAME;
    // new input
    SigCLib.StrCpy16(lastCriteriaUni, pName);
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (SigCLib.StrCmp16(pAtt^.Name$^UINT, lastCriteriaUni) = 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on  
  end_if;
  
  while searchPtr <> xmlStruct.MajorElement do
    
    if searchPtr^.Attributes.no > 0 then
      
      pAtt := searchPtr^.Attributes.pList;
      for i := 1 to searchPtr^.Attributes.no do
        
        if (SigCLib.StrCmp16(pAtt^.Name$^UINT, lastCriteriaUni)= 0) then
          bFound := TRUE;
          pElement := searchPtr;
          exit;
        end_if;
        
        pAtt += sizeof(_XML_ATTRIBUTE);
        
      end_for;

    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
  end_if;
  
END_FUNCTION //GetElementByAttribNameUni


FUNCTION _XMLReader::GetElementByTextAscii
	VAR_INPUT
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound    : BOOL;
    NameLen   : UDINT;
  END_VAR

  pElement := NIL;
  bFound := FALSE;
  
  if pText = NIL then
    return;
  end_if;

  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := _strlen(pText) + 1;
  if NameLen <> lastLen then
    if lastCriteria <> NIL then
      StdLib.Free(lastCriteria);
    end_if;
    
    lastCriteria$^void := StdLib.Malloc(NameLen);

    if lastCriteria = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    
    _memset(lastCriteria, 0, NameLen);
        
    lastLen := NameLen;   

  end_if;
  
  if (_strcmp(lastCriteria, pText) <> 0) | (lastSearch <> _BY_TEXT) then
    
    lastSearch := _BY_TEXT;
    
    // new input -> start from beginning
    _strcpy(lastCriteria, pText);
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if searchPtr^.pText <> NIL then
      if _strcmp(searchPtr^.pText, lastCriteria) = 0 then
        
        pElement := searchPtr;
        bFound := TRUE;
        
      end_if;
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on
  end_if;

  while searchPtr <> xmlStruct.MajorElement do
    
    if searchPtr^.pText <> NIL then
      if _strcmp(searchPtr^.pText, lastCriteria) = 0 then
        pElement := searchPtr;
        bFound := TRUE;
      end_if;
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
  end_if;
  
END_FUNCTION //GetElementByTextAscii


FUNCTION _XMLReader::GetElementByTextUni
	VAR_INPUT
		pText 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	bFound    : BOOL;
    NameLen   : UDINT;
  END_VAR

  pElement := NIL;
  bFound := FALSE;
  
  if pText = NIL then
    return;
  end_if;

  if xmlStruct.MajorElement = NIL then //no readfile was successfully made
    return;
  end_if;
  
  NameLen := SigCLib.StrLen16(pText)*2 + 2;
  if NameLen <> lastLen then
    if lastCriteriaUni <> NIL then
      StdLib.Free(lastCriteriaUni);
    end_if;
    
    lastCriteriaUni$^void := StdLib.Malloc(NameLen);

    if lastCriteriaUni = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    
    _memset(lastCriteriaUni, 0, NameLen);
        
    lastLen := NameLen;   

  end_if;
  
  if (SigCLib.StrCmp16(lastCriteriaUni, pText) <> 0) | (lastSearch <> _BY_TEXT) then
    
    lastSearch := _BY_TEXT;
    
    // new input -> start from beginning
    SigCLib.StrCpy16(lastCriteriaUni, pText);
    searchPtr := xmlStruct.MajorElement;
    
    // start with major-element
    if searchPtr^.pText <> NIL then
      if SigCLib.StrCmp16(searchPtr^.pText$^UINT, lastCriteriaUni) = 0 then
        
        pElement := searchPtr;
        bFound := TRUE;
        
      end_if;
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      searchPtr := searchPtr^.pChildren;
    end_if;
    
    if bFound = TRUE then
      return;
    end_if;
 
  //else - same input -> go on
  end_if;

  while searchPtr <> xmlStruct.MajorElement do
    
    if searchPtr^.pText <> NIL then
      if SigCLib.StrCmp16(searchPtr^.pText$^UINT, lastCriteriaUni) = 0 then
        pElement := searchPtr;
        bFound := TRUE;
      end_if;
    end_if;
    
    if searchPtr^.pChildren <> NIL then
      // go to children  
      searchPtr := searchPtr^.pChildren;
      
    elsif searchPtr^.pNext <> NIL then
      // go to brother
      searchPtr := searchPtr^.pNext;
      
    else
      // go back to father and check 4 brother
      while true do
        
        if searchPtr^.pPrevious <> NIL then
          searchPtr := searchPtr^.pPrevious;
        elsif searchPtr^.pFather <> NIL then
          searchPtr := searchPtr^.pFather;
          
          if searchPtr^.pNext <> NIL then
            searchPtr := searchPtr^.pNext;
            exit;
          elsif searchPtr = xmlStruct.MajorElement then
            exit;
          end_if;
          
        end_if;
        
      end_while;
      
    end_if;
    
    if bFound then
      return;
    end_if;
    
  end_while;
  
  if pElement = NIL then
    lastLen := 0;
  end_if;
  
END_FUNCTION //GetElementByTextUni


FUNCTION _XMLReader::GetAttribIndexAscii
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		Index 	: DINT;
	END_VAR
  VAR
    pAtt    : ^_XML_ATTRIBUTE;  	
    i       : UDINT;
  END_VAR

  Index := -1;
  
  if (pElement = NIL) | (pName = NIL) then
    return;
  end_if;

  
  if pElement^.Attributes.no > 0 then
    
    pAtt := pElement^.Attributes.pList;
    
    for i := 0 to pElement^.Attributes.no - 1 do
      
      if _strcmp(pAtt^.Name, pName) = 0 then
        // found the attribute        
        Index := i$DINT;
        exit;
        
      end_if;
      
      pAtt += sizeof(_XML_ATTRIBUTE);
      
    end_for;
  end_if;
  
END_FUNCTION //GetAttribIndexAscii


FUNCTION _XMLReader::GetAttribIndexUni
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		Index 	: DINT;
	END_VAR
  VAR
    pAtt    : ^_XML_ATTRIBUTE;  	
    i       : UDINT;
  END_VAR

  Index := -1;
  
  if (pElement = NIL) | (pName = NIL) then
    return;
  end_if;

  
  if pElement^.Attributes.no > 0 then
    
    pAtt := pElement^.Attributes.pList;
    
    for i := 0 to pElement^.Attributes.no - 1 do
      
      if SigCLib.StrCmp16(pAtt^.Name$^UINT, pName) = 0 then
        // found the attribute        
        Index := i$DINT;
        exit;
        
      end_if;
      
      pAtt += sizeof(_XML_ATTRIBUTE);
      
    end_for;
  end_if;
  
END_FUNCTION //GetAttribIndexUni


FUNCTION _XMLReader::EditNameAscii
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  if (pElement = NIL) | (pName = NIL) then
    return;
  end_if;

  
  newLen := _strlen(pName) + 1;
  oldLen := _strlen(pElement^.Name) + 1;
  
  if newLen > oldLen then
    // free element-name and then get more memory
    StructCreator.FreePointer(pElement^.Name, _XML_FREE_TEXT);
    pElement^.Name$^void := StdLib.Malloc(newLen);
    
    if pElement^.Name = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    
  end_if;
  
  _strcpy(pElement^.Name, pName);
  retcode := TRUE;
  
END_FUNCTION //EditNameAscii


FUNCTION _XMLReader::EditNameUni
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  if (pElement = NIL) | (pName = NIL) then
    return;
  end_if;

  
  newLen := SigCLib.StrLen16(pName)*2 + 2;
  oldLen := SigCLib.StrLen16(pElement^.Name$^UINT)*2 + 2;
  
  if newLen > oldLen then
    // free element-name and then get more memory
    StructCreator.FreePointer(pElement^.Name, _XML_FREE_TEXT);
    pElement^.Name$^void := StdLib.Malloc(newLen);
    
    if pElement^.Name = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    
  end_if;
  
  SigCLib.StrCpy16(pElement^.Name$^UINT, pName);
  retcode := TRUE;
  
END_FUNCTION //EditNameUni


FUNCTION _XMLReader::EditAttribNameAscii
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		index 	: UDINT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pAtt    : ^_XML_ATTRIBUTE;
    newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR

  retcode := FALSE;
  
  if (pElement = NIL) | (pName = NIL) then
    return;
  end_if;

  
  if index < pElement^.Attributes.no then
    
    // valid Index -> set tmp-ptr to the entry of our Attribute-List
    pAtt := pElement^.Attributes.pList + (index*sizeof(_XML_ATTRIBUTE));
    
    newLen := _strlen(pName) + 1;
    oldLen := _strlen(pAtt^.Name) + 1;
    
    if newLen > oldLen then
      StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
      pAtt^.Name$^void := StdLib.Malloc(newLen);
      
      if pAtt^.Name = NIL then
        XmlState := _ERROR;
        return;
      end_if;
      
    end_if;
    
    _strcpy(pAtt^.Name, pName);
    
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION //EditAttribNameAscii


FUNCTION _XMLReader::EditAttribNameUni
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		index 	: UDINT;
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pAtt    : ^_XML_ATTRIBUTE;
    newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR

  retcode := FALSE;
  
  if (pElement = NIL) | (pName = NIL) then
    return;
  end_if;

  
  if index < pElement^.Attributes.no then
    
    // valid Index -> set tmp-ptr to the entry of our Attribute-List
    pAtt := pElement^.Attributes.pList + (index*sizeof(_XML_ATTRIBUTE));
    
    newLen := SigCLib.StrLen16(pName)*2 + 2;
    oldLen := SigCLib.StrLen16(pAtt^.Name$^UINT)*2 + 2;
    
    if newLen > oldLen then
      StructCreator.FreePointer(pAtt^.Name, _XML_FREE_TEXT);
      pAtt^.Name$^void := StdLib.Malloc(newLen);
      
      if pAtt^.Name = NIL then
        XmlState := _ERROR;
        return;
      end_if;
      
    end_if;
    
    SigCLib.StrCpy16(pAtt^.Name$^UINT, pName);
    
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION //EditAttribNameUni


FUNCTION _XMLReader::EditAttribValueAscii
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		index 	: UDINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pAtt    : ^_XML_ATTRIBUTE;
    newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR

  retcode := FALSE;  
  
  if (pElement = NIL) | (pValue = NIL) then
    return;
  end_if;

  if index < pElement^.Attributes.no then
    // valid Index -> set tmp-ptr to the entry of our Attribute-List
    pAtt := pElement^.Attributes.pList + (index*sizeof(_XML_ATTRIBUTE));
    
    newLen := _strlen(pValue) + 1;
    oldLen := _strlen(pAtt^.Value) + 1;
    
    if newLen > oldLen then
      StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
      pAtt^.Value$^void := StdLib.Malloc(newLen);
      
      if pAtt^.Value = NIL then
        XmlState := _ERROR;
        return;
      end_if;

    end_if;
    
    _strcpy(pAtt^.Value, pValue);
    
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION //EditAttribValueAscii


FUNCTION _XMLReader::EditAttribValueUni
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		index 	: UDINT;
		pValue 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pAtt    : ^_XML_ATTRIBUTE;
    newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR

  retcode := FALSE;  
  
  if (pElement = NIL) | (pValue = NIL) then
    return;
  end_if;

  if index < pElement^.Attributes.no then
    // valid Index -> set tmp-ptr to the entry of our Attribute-List
    pAtt := pElement^.Attributes.pList + (index*sizeof(_XML_ATTRIBUTE));
    
    newLen := SigCLib.StrLen16(pValue)*2 + 2;
    oldLen := SigCLib.StrLen16(pAtt^.Value$^UINT)*2 + 2;
    
    if newLen > oldLen then
      StructCreator.FreePointer(pAtt^.Value, _XML_FREE_TEXT);
      pAtt^.Value$^void := StdLib.Malloc(newLen);
      
      if pAtt^.Value = NIL then
        XmlState := _ERROR;
        return;
      end_if;

    end_if;
    
    SigCLib.StrCpy16(pAtt^.Value$^UINT, pValue);
    
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION //EditAttribValueUni


FUNCTION _XMLReader::EditTextAscii
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  if (pElement = NIL) | (pText = NIL) then
    return;
  end_if;
  
  
  if pElement^.pChildren = NIL then
    // Element is no Root-Element (has no Children) -> Text is allowed!
    
    newLen := _strlen(pText) + 1;
    oldLen := _strlen(pElement^.pText) + 1;
    
    // now check if there is already a text or not!
    if pElement^.pText <> NIL then
      
      if newLen > oldLen then
        // Text already exists and new one is bigger -> first free!
        StructCreator.FreePointer(pElement^.pText, _XML_FREE_TEXT);
        pElement^.pText$^void := StdLib.Malloc(newLen);
      end_if;
      
    else
      pElement^.pText$^void := StdLib.Malloc(newLen);
    end_if;
    
    if pElement^.pText = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    
    _strcpy(pElement^.pText, pText);
    
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION //EditTextAscii


FUNCTION _XMLReader::EditTextUni
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pText 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	newLen  : UDINT;
    oldLen  : UDINT;
  END_VAR
  
  retcode := FALSE;
  
  if (pElement = NIL) | (pText = NIL) then
    return;
  end_if;
  
  
  if pElement^.pChildren = NIL then
    // Element is no Root-Element (has no Children) -> Text is allowed!
    
    newLen := SigCLib.StrLen16(pText)*2 + 2;
    oldLen := SigCLib.StrLen16(pElement^.pText$^UINT)*2 + 2;
    
    // now check if there is already a text or not!
    if pElement^.pText <> NIL then
      
      if newLen > oldLen then
        // Text already exists and new one is bigger -> first free!
        StructCreator.FreePointer(pElement^.pText, _XML_FREE_TEXT);
        pElement^.pText$^void := StdLib.Malloc(newLen);
      end_if;
      
    else
      pElement^.pText$^void := StdLib.Malloc(newLen);
    end_if;
    
    if pElement^.pText = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    
    SigCLib.StrCpy16(pElement^.pText$^UINT, pText);
    
    retcode := TRUE;
    
  end_if;
  
END_FUNCTION //EditTextUni


FUNCTION _XMLReader::AddChildElementAscii
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	hptr    : ^_XML_ELEMENT;
    NameLen : UDINT;
  END_VAR

  retcode := NIL;
  
  if (pDest = NIL) | (pName = NIL) then
    return;
  end_if;

  if pDest^.pText = NIL then 
    if pDest^.pChildren <> NIL then
      // we go to the last child of our destination-element and will insert a new element with given name
      hptr := pDest^.pChildren;
      
      while hptr^.pNext <> NIL do
        hptr := hptr^.pNext;
      end_while;
      
      hptr^.pNext$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
      if hptr^.pNext = NIL then
        XmlState := _ERROR;
        return;
      end_if;
      _memset(hptr^.pNext, 0, sizeof(_XML_ELEMENT));
      
      NameLen := _strlen(pName) + 1;
      hptr^.pNext^.Name$^void := StdLib.Malloc(NameLen);

      if (hptr^.pNext^.Name = NIL) then
        XmlState := _ERROR;
        return;
      end_if;  
      
      _strcpy(hptr^.pNext^.Name, pName);
      hptr^.pNext^.pPrevious := hptr;
      hptr^.pNext^.isClosed := TRUE;
      
      retcode := hptr^.pNext;
      
    else
      // destination-element has no child -> just add
      hptr := pDest;
      
      hptr^.pChildren$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
      if hptr^.pChildren = NIL then
        XmlState := _ERROR;
        return;
      end_if;
      _memset(hptr^.pChildren, 0, sizeof(_XML_ELEMENT));
      
      NameLen := _strlen(pName) + 1;
      hptr^.pChildren^.Name$^void := StdLib.Malloc(NameLen);
  
      if (hptr^.pChildren^.Name = NIL) then
        XmlState := _ERROR;
        return;
      end_if;      
      _strcpy(hptr^.pChildren^.Name, pName);
      hptr^.pChildren^.pFather := hptr;
      hptr^.pChildren^.isClosed := TRUE;
      
      retcode := hptr^.pChildren;
      
    end_if;
  end_if;
  
END_FUNCTION //AddChildElementAscii


FUNCTION _XMLReader::AddChildElementUni
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	hptr    : ^_XML_ELEMENT;
    NameLen : UDINT;
  END_VAR

  retcode := NIL;
  
  if (pDest = NIL) | (pName = NIL) then
    return;
  end_if;

  if pDest^.pText = NIL then 
    if pDest^.pChildren <> NIL then
      // we go to the last child of our destination-element and will insert a new element with given name
      hptr := pDest^.pChildren;
      
      while hptr^.pNext <> NIL do
        hptr := hptr^.pNext;
      end_while;
      
      hptr^.pNext$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
      if hptr^.pNext = NIL then
        XmlState := _ERROR;
        return;
      end_if;
      _memset(hptr^.pNext, 0, sizeof(_XML_ELEMENT));
      
      NameLen := SigCLib.StrLen16(pName)*2 + 2;
      hptr^.pNext^.Name$^void := StdLib.Malloc(NameLen);

      if (hptr^.pNext^.Name = NIL) then
        XmlState := _ERROR;
        return;
      end_if;  
      
      SigCLib.StrCpy16(hptr^.pNext^.Name$^UINT, pName);
      hptr^.pNext^.pPrevious := hptr;
      hptr^.pNext^.isClosed := TRUE;
      
      retcode := hptr^.pNext;
      
    else
      // destination-element has no child -> just add
      hptr := pDest;
      
      hptr^.pChildren$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
      if hptr^.pChildren = NIL then
        XmlState := _ERROR;
        return;
      end_if;
      _memset(hptr^.pChildren, 0, sizeof(_XML_ELEMENT));
      
      NameLen := SigCLib.StrLen16(pName)*2 + 2;
      hptr^.pChildren^.Name$^void := StdLib.Malloc(NameLen);
  
      if (hptr^.pChildren^.Name = NIL) then
        XmlState := _ERROR;
        return;
      end_if;      
      SigCLib.StrCpy16(hptr^.pChildren^.Name$^UINT, pName);
      hptr^.pChildren^.pFather := hptr;
      hptr^.pChildren^.isClosed := TRUE;
      
      retcode := hptr^.pChildren;
      
    end_if;
  end_if;
  
END_FUNCTION //AddChildElementUni


FUNCTION _XMLReader::AddBrotherElementAscii
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	hptr    : ^_XML_ELEMENT;
    pSave   : ^_XML_ELEMENT;
    NameLen : UDINT;
  END_VAR

  retcode := NIL;
  
  if (pDest = NIL) | (pName = NIL) | (pDest = xmlStruct.MajorElement) then
    // NIL-pointer or Major Element is not able to have a Brother!
    return;
  end_if;

  if pDest^.pNext <> NIL then
    
    pSave := pDest^.pNext;
    
    hptr$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
    if hptr = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(hptr, 0, sizeof(_XML_ELEMENT));

    pDest^.pNext := hptr;
    hptr^.pPrevious := pDest;
    
    hptr^.pNext := pSave;
    pSave^.pPrevious := hptr;
    
    NameLen := _strlen(pName) + 1;
    hptr^.Name$^void := StdLib.Malloc(NameLen);
    
    if (hptr^.Name = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    
    _strcpy(hptr^.Name, pName);
    hptr^.isClosed := TRUE;
    
    retcode := hptr;
    
  else
    
    hptr$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
    if hptr = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(hptr, 0, sizeof(_XML_ELEMENT));
    
    pDest^.pNext := hptr;
    hptr^.pPrevious := pDest;
    
    NameLen := _strlen(pName) + 1;
    hptr^.Name$^void := StdLib.Malloc(NameLen);

    if (hptr^.Name = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    
    _strcpy(hptr^.Name, pName);
    hptr^.isClosed := TRUE;
    
    retcode := hptr;
    
  end_if;
  
END_FUNCTION //AddBrotherElementAscii


FUNCTION _XMLReader::AddBrotherElementUni
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	hptr    : ^_XML_ELEMENT;
    pSave   : ^_XML_ELEMENT;
    NameLen : UDINT;
  END_VAR

  retcode := NIL;
  
  if (pDest = NIL) | (pName = NIL) | (pDest = xmlStruct.MajorElement) then
    // NIL-pointer or Major Element is not able to have a Brother!
    return;
  end_if;

  if pDest^.pNext <> NIL then
    
    pSave := pDest^.pNext;
    
    hptr$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
    if hptr = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(hptr, 0, sizeof(_XML_ELEMENT));

    pDest^.pNext := hptr;
    hptr^.pPrevious := pDest;
    
    hptr^.pNext := pSave;
    pSave^.pPrevious := hptr;
    
    NameLen := SigCLib.StrLen16(pName)*2 + 2;
    hptr^.Name$^void := StdLib.Malloc(NameLen);
    
    if (hptr^.Name = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    
    SigCLib.StrCpy16(hptr^.Name$^UINT, pName);
    hptr^.isClosed := TRUE;
    
    retcode := hptr;
    
  else
    
    hptr$^void := StdLib.Malloc(sizeof(_XML_ELEMENT));
    if hptr = NIL then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(hptr, 0, sizeof(_XML_ELEMENT));
    
    pDest^.pNext := hptr;
    hptr^.pPrevious := pDest;
    
    NameLen := SigCLib.StrLen16(pName)*2 + 2;
    hptr^.Name$^void := StdLib.Malloc(NameLen);

    if (hptr^.Name = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    
    SigCLib.StrCpy16(hptr^.Name$^UINT, pName);
    hptr^.isClosed := TRUE;
    
    retcode := hptr;
    
  end_if;
  
END_FUNCTION //AddBrotherElementUni


FUNCTION _XMLReader::AddAttributeAscii
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	oldSize   : UDINT;
    newSize   : UDINT;
    hptr      : ^_XML_ATTRIBUTE;
    NameLen   : UDINT;
    ValueLen  : UDINT;
  END_VAR
  
  retcode := -1;
  
  if (pDest = NIL) | (pName = NIL) | (pValue = NIL) then
    return;
  end_if;

  
  if pDest^.Attributes.no = 0 then
    // no attribute until now
    pDest^.Attributes.pList$^void := StdLib.Malloc(sizeof(_XML_ATTRIBUTE));
    if pDest^.Attributes.pList = NIL then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;
    
    hptr := pDest^.Attributes.pList;
    
    NameLen := _strlen(pName) + 1;
    ValueLen := _strlen(pValue) + 1;
    
    hptr^.Name$^void := StdLib.Malloc(NameLen);
    hptr^.Value$^void := StdLib.Malloc(ValueLen);
    
    if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;
    
    _strcpy(hptr^.Name, pName);
    _strcpy(hptr^.Value, pValue);
    
    pDest^.Attributes.no := 1;
    
  else
    // we already have at least 1 attribute -> make new attrib-list
    oldSize := pDest^.Attributes.no;
    newSize := oldSize + 1;
    
    hptr$^void := StdLib.Malloc(newSize * sizeof(_XML_ATTRIBUTE));
    if hptr = NIL then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;
    
    _memcpy(hptr, pDest^.Attributes.pList, oldSize * sizeof(_XML_ATTRIBUTE));
    StructCreator.FreePointer(pDest^.Attributes.pList, _XML_FREE_ATTRIBUTE);
    
    pDest^.Attributes.pList := hptr;
    
    hptr += oldSize * sizeof(_XML_ATTRIBUTE);
    
    NameLen := _strlen(pName) + 1;
    ValueLen := _strlen(pValue) + 1;
    
    hptr^.Name$^void := StdLib.Malloc(NameLen);
    hptr^.Value$^void := StdLib.Malloc(ValueLen);
    
    if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;

    _strcpy(hptr^.Name, pName);
    _strcpy(hptr^.Value, pValue);
    
    pDest^.Attributes.no += 1;
    
  end_if;
  
  retcode := 0;
  
END_FUNCTION //AddAttributeAscii


FUNCTION _XMLReader::AddAttributeUni
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
		pValue 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	oldSize   : UDINT;
    newSize   : UDINT;
    hptr      : ^_XML_ATTRIBUTE;
    NameLen   : UDINT;
    ValueLen  : UDINT;
  END_VAR
  
  retcode := -1;
  
  if (pDest = NIL) | (pName = NIL) | (pValue = NIL) then
    return;
  end_if;

  
  if pDest^.Attributes.no = 0 then
    // no attribute until now
    pDest^.Attributes.pList$^void := StdLib.Malloc(sizeof(_XML_ATTRIBUTE));
    if pDest^.Attributes.pList = NIL then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;
    
    hptr := pDest^.Attributes.pList;
    
    NameLen := SigCLib.StrLen16(pName)*2 + 2;
    ValueLen := SigCLib.StrLen16(pValue)*2 + 2;
    
    hptr^.Name$^void := StdLib.Malloc(NameLen);
    hptr^.Value$^void := StdLib.Malloc(ValueLen);
    
    if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;
    
    SigCLib.StrCpy16(hptr^.Name$^UINT, pName);
    SigCLib.StrCpy16(hptr^.Value$^UINT, pValue);
    
    pDest^.Attributes.no := 1;
    
  else
    // we already have at least 1 attribute -> make new attrib-list
    oldSize := pDest^.Attributes.no;
    newSize := oldSize + 1;
    
    hptr$^void := StdLib.Malloc(newSize * sizeof(_XML_ATTRIBUTE));
    if hptr = NIL then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;
    
    _memcpy(hptr, pDest^.Attributes.pList, oldSize * sizeof(_XML_ATTRIBUTE));
    StructCreator.FreePointer(pDest^.Attributes.pList, _XML_FREE_ATTRIBUTE);
    
    pDest^.Attributes.pList := hptr;
    
    hptr += oldSize * sizeof(_XML_ATTRIBUTE);
    
    NameLen := SigCLib.StrLen16(pName)*2 + 2;
    ValueLen := SigCLib.StrLen16(pValue)*2 + 2;
    
    hptr^.Name$^void := StdLib.Malloc(NameLen);
    hptr^.Value$^void := StdLib.Malloc(ValueLen);
    
    if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
      XmlState := _ERROR;
      retcode := -2;
      return;
    end_if;

    SigCLib.StrCpy16(hptr^.Name$^UINT, pName);
    SigCLib.StrCpy16(hptr^.Value$^UINT, pValue);
    
    pDest^.Attributes.no += 1;
    
  end_if;
  
  retcode := 0;
  
END_FUNCTION //AddAttributeUni


FUNCTION _XMLReader::AddTextAscii
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	TextLen   : UDINT;
  END_VAR
  
  retcode := -1;
  
  if (pDest = NIL) | (pText = NIL) then
    return;
  end_if;

  
  // only allowed to add text when element has no children or already has a text
  if (pDest^.pText <> NIL) | (pDest^.pChildren <> NIL) then
    return;
  end_if;

  TextLen := _strlen(pText);
  TextLen += 1; // zero termination
  
  pDest^.pText$^void := StdLib.Malloc(TextLen);
  if pDest^.pText = NIL then
    XmlState := _ERROR;
    retcode := -2;
    return;
  end_if;

  _strcpy(pDest^.pText, pText);
  
  retcode := 0;
  
END_FUNCTION //AddTextAscii


FUNCTION _XMLReader::AddTextUni
	VAR_INPUT
		pDest 	: ^_XML_ELEMENT;
		pText 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	TextLen   : UDINT;
  END_VAR
  
  retcode := -1;
  
  if (pDest = NIL) | (pText = NIL) then
    return;
  end_if;

  
  // only allowed to add text when element has no children or already has a text
  if (pDest^.pText <> NIL) | (pDest^.pChildren <> NIL) then
    return;
  end_if;

  TextLen := SigCLib.StrLen16(pText)*2;
  TextLen += 2; // zero termination
  
  pDest^.pText$^void := StdLib.Malloc(TextLen);
  if pDest^.pText = NIL then
    XmlState := _ERROR;
    retcode := -2;
    return;
  end_if;

  SigCLib.StrCpy16(pDest^.pText$^UINT, pText);
  
  retcode := 0;
  
END_FUNCTION //AddTextUni


FUNCTION _XMLReader::CreateStructAscii
	VAR_INPUT
		parsedBytes 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
VAR
  pRun            : ^USINT;   // pointer to go through the information we read
  pStart          : ^USINT;   // points to the start of an element-name, atrib-name, attrib-value and so on...
  signCount       : UDINT;    // counts how much signs a string has
  counter         : UDINT;    // counter how far we passed through the information
  detectedBOM     : BOOL; 
  allocRet        : DINT;
  nextSign        : USINT;
  pAttribName     : ^USINT;
  pAttribValue    : ^USINT;
  bStartReplaced  : BOOL;
END_VAR
  
  retcode := FALSE;
  
  // sprdie v2.0 - get number of elements and attributes first, afterwards get memory
  FetchElementsAndAttribsAscii(#elementCount, #attribCount);
  allocRet := StructCreator.AllocPredefinedHeap(elementCount, attribCount);
  if allocRet < 0 then
    XmlState := _ERROR;
    ErrorState := _PARSE_ERR_MEMORY;
    return;
  end_if;
  
  // biggest work will be here
  // we have to go through the buffer and create our XML_STRUCT out of the information
  pRun := pFileBuffer;
    
  counter := 1;
  bStartReplaced := FALSE;
  
  //sprdie v1.5 - special treatment for UTF8-BOM -----
  detectedBOM := FALSE;
  if (pRun^ = 16#EF) & ((pRun+1)^ = 16#BB) & ((pRun+2)^ = 16#BF) then
    counter += 3;
    pRun += 3;
    detectedBOM := TRUE;
  end_if;
  //--------------------------------------------------
  
  // first handle the header
  if (pRun^ = XML_START) & ((pRun+1)^ = '?') then
    
    pStart := pRun;
    signCount := 0;
    
    while pRun^ <> XML_END do
      signCount += 1;
      
      counter += 1;      
      pRun += 1;
    end_while;
    
    // now we are pointing at the end-mark, this also has to be in the header -> increase counters
    counter += 1;
    signCount += 1;
    
    if signCount > XML_MAX_HEADER_LENGTH then
      return;
    end_if;
    
    if detectedBOM = FALSE then
      xmlStruct.Header$^void := StdLib.Malloc(signCount+1);
      _memset(xmlStruct.Header, 0, signCount+1);
      _memcpy(xmlStruct.Header, pStart, signCount);
    else
      xmlStruct.Header$^void := StdLib.Malloc(signCount+1+3); //+3 because we are going to insert the BOM to the header
      _memset(xmlStruct.Header, 0, signCount+1+3);            //   so if file is edited and written we do not lose the BOM
      _memcpy(xmlStruct.Header, pFileBuffer, signCount+3);    
    end_if;
    
    // get memory for first element and set struct for creator
    xmlStruct.MajorElement := StructCreator.GetElementMemory(); //sprdie v2.0 - no alloc needed, get memory from struct-creator
    if (xmlStruct.MajorElement = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    _memset(xmlStruct.MajorElement, 0, sizeof(_XML_ELEMENT));
    StructCreator.SetStructPtr(#xmlStruct);
  
  else
    // xml does not start with the header
    ErrorState := _PARSE_ERR_NO_HEADER;
    parsedBytes^ := counter;
    return;
  end_if;
  
  // now lets see if we find a CR or LF and no signs between except of SPACE
  counter += 1;
  pRun += 1;
  while (pRun^ <> XML_CR) & (pRun^ <> XML_LF) & (pRun^ <> XML_START) do
    
    if pRun^ <> XML_SPACE then
      ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
      parsedBytes^ := counter;
      return; //wrong sign
    end_if;
    
    counter += 1;
    pRun += 1;
  end_while;
  
  // Header finished -> now lets start with looking for an Element
  searchFor := _SEARCH_ELEMENT;  
  
  // ludben v2.3: there could only be a header in the file
  if counter = fileLength then
    ErrorState := _PARSE_ERR_NO_ROOT_ELEMENT;
    parsedBytes^ := counter;
    return;
  end_if;    
  
  while counter < fileLength do
    
    case searchFor of
    
    	_SEARCH_ELEMENT:
    	  // look for '<'
        while (pRun^ <> XML_START) & (bStartReplaced = FALSE) do
        
          if (pRun^ <> XML_CR) & (pRun^ <> XML_LF) & (pRun^ <> XML_SPACE) & (pRun^ <> XML_TABULATOR) then
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return; //wrong sign
          end_if;

          pRun += 1;
          counter += 1;
        end_while;
        
        bStartReplaced := FALSE;
        
        // now we are pointing at start-mark, but we need one increase more
        pRun += 1;
        counter += 1;
        
        if (pRun^ <> XML_SLASH) & (pRun^ <> XML_EXCLAMATION) then
          //START Element
          if bTextSearched = TRUE then
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return; //wrong sign
          end_if;
          
          pStart := pRun;
          signCount := 0;
          
          // next step is to look for Space or End-Mark
          // counter are always one behind the pointer so we do not need to decrease afterwards
          while (pRun^ <> XML_END) & (pRun^ <> XML_SPACE) & (pRun^ <> XML_SLASH) do
            signCount += 1;
            
            counter += 1;
            pRun += 1;
          end_while;
          
          // at this point we found an element,        
          nextSign := pRun^;
          pRun^ := 0; // add zero termination to file
          StructCreator.AddElement(pStart, FALSE, FALSE);
          
          // lets see what we have to do next
          if nextSign = XML_END then
            
            pRun += 1;    
            counter += 1;
            
            if (pRun^ = XML_CR) | (pRun^ = XML_LF) | (pRun^ = XML_START) | (pRun^ = XML_SPACE) then
              searchFor := _SEARCH_ELEMENT;
            else
              searchFor := _SEARCH_TEXT;
            end_if;
          
          elsif nextSign = XML_SLASH then
            StructCreator.CloseElement(NIL,FALSE);
            
            // element is closed directly -> check if next sign is END-Tag
            pRun += 1;
            counter += 1;
            
            if pRun^ <> XML_END then
              // no end-tag after slash -> error
              ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
              parsedBytes^ := counter;
              return; //wrong sign
            end_if;
            
            // set to next sign
            pRun += 1;
            counter += 1;
            
            searchFor := _SEARCH_ELEMENT;
            
          elsif nextSign = XML_SPACE then
            // in this case there can also be a closing-tag if element ist closed directly
            if (pRun+1)^ = XML_SLASH then
              
              StructCreator.CloseElement(NIL, FALSE);
              
              //                      <Element />
              //we point now to the space-----^---
              //but we need to be after end------^
              //this means +3 signs
              pRun += 3;
              counter += 3;
              
              searchFor := _SEARCH_ELEMENT;
            else
              searchFor := _SEARCH_ATTRIB;
            end_if;
          
          end_if;
        
        else
          if pRun^ = XML_SLASH then
            
            bTextSearched := FALSE;
            // CLOSE Element
            // so just go to the end of the close-element-tag and then close
            pRun += 1;
            counter += 1;
            
            pStart := pRun;
            signCount := 0;
            
            while pRun^ <> XML_END do
              signCount += 1;
              
              counter += 1;
              pRun += 1;
            end_while;
            
            pRun^ := 0;            
            pRun += 1;
            counter += 1;
            
            retClose := StructCreator.CloseElement(pStart, FALSE);
            if retClose <> 0 then
              ErrorState := _PARSE_ERR_WRONG_SEQUENCE;
              parsedBytes^ := counter - signCount - 1;
              return; //wrong sequence of elements
            end_if;
            
            searchFor := _SEARCH_ELEMENT;
            
          else
            // check 4 comment
            if bTextSearched = TRUE then
              ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
              parsedBytes^ := counter;
              return; //wrong sign
            end_if;
            
            pRun += 1;
            counter += 1;
            if (pRun^ = XML_HYPHEN) & ((pRun+1)^ = XML_HYPHEN) then
              // we found '<!--' this means comment -> skip
              pRun += 2;
              counter += 2;
              
              while !!((pRun^ = XML_HYPHEN) & ((pRun+1)^ = XML_HYPHEN) & ((pRun+2)^ = XML_END)) do
                
                pRun += 1;
                counter += 1;
                
              end_while;
              pRun += 3; // set ptr to one ofter end-tag
              counter += 3;
              // we found the end '-->'
              // go on with searching for an element
              searchFor := _SEARCH_ELEMENT;
              
            end_if;
            
          end_if;
          
        end_if;
        
      _SEARCH_ATTRIB:
      
        bTextSearched := FALSE;
    	  // when we have to search 4 an attribute we know that pRun points to a Space
        // so the next sign is the start 
        pRun += 1;
        counter += 1;
        
        pStart := pRun;
        signCount := 0;
        
        while pRun^ <> XML_EQUAL do
          
          if (pRun^ = XML_SPACE) | (pRun^ = XML_LF) | (pRun^ = XML_CR) then
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return; //wrong sign
          end_if;
          
          signCount += 1; 
          counter += 1;
          pRun += 1;
        end_while;
        
        pAttribName := pStart;
        pRun^ := 0;
        
        // we got the name of the attribute now lets get the value
        if ((pRun+1)^ <> XML_QUOTMARK) & ((pRun+1)^ <> XML_APOSTROPHE) then
          ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
          parsedBytes^ := counter;
          return; // wrong sign
        end_if;
        
        if ((pRun+1)^ = XML_QUOTMARK) then
          bQuot := TRUE;
        else
          bQuot := FALSE;
        end_if;
        
        pRun += 2; // set to one after quotation-mark
        counter += 2;
        
        pStart := pRun;
        signCount := 0;
        
        while ((pRun^ <> XML_QUOTMARK) & (bQuot = TRUE)) | ((pRun^ <> XML_APOSTROPHE) & (bQuot = FALSE)) do 
          signCount += 1;
          
          counter += 1;
          pRun += 1;
        end_while;
        
        pAttribValue := pStart;
        pRun^ := 0;
        
        // sprdie v2.1 - convert special characters ---------------
        if (DoConvert = TRUE) then
          // convert XML notation of special characters (for example &amp; -> &)
          if ConvertXmlToText(pAttribValue, pAttribValue, sizeof(CHAR)) < 0 then // use same memory because text will be less
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;
        end_if;
        // --------------------------------------------------------
        
        if StructCreator.AddAttribute(pAttribName, pAttribValue, FALSE, FALSE) = -1 then
          ErrorState := _PARSE_ERR_ATTRIBUTE_TWICE;
          parsedBytes^ := counter - signCount - 1;
          return; // attribute already exists
        end_if;
        
        // lets see what we have to do next
        pRun += 1;
        counter += 1;
        
        if pRun^ = XML_END then
          // so in this case we can have Text afterwards or next thing is an element
          pRun += 1;
          counter += 1;
          
          if (pRun^ = XML_CR) | (pRun^ = XML_LF) | (pRun^ = XML_START) then
            searchFor := _SEARCH_ELEMENT;
          else
            searchFor := _SEARCH_TEXT;
          end_if;
          
        elsif pRun^ = XML_SLASH then
            StructCreator.CloseElement(NIL, FALSE);
            
            // jump one sign after "/>"
            pRun += 2;
            counter += 2;
            searchFor := _SEARCH_ELEMENT;
            
        elsif pRun^ = XML_SPACE then
          // in this case there can also be a closing-tag if element ist closed directly
          if (pRun+1)^ = XML_SLASH then
              
            StructCreator.CloseElement(NIL, FALSE);
            
            //                      <Element />
            //we point now to the space-----^---
            //but we need to be after end------^
            //this means +3 signs
            pRun += 3;
            counter += 3;
            
            searchFor := _SEARCH_ELEMENT;
          else
            searchFor := _SEARCH_ATTRIB;
          end_if;

        end_if;
        
      _SEARCH_TEXT:
        // we already point to the start of the text
        pStart := pRun;
        signCount := 0;
        
        while pRun^ <> XML_START do
          signCount += 1;
          
          counter += 1;
          pRun += 1;
        end_while;
                
        // kick off text & add to actual element  
        pRun^ := 0;
        bStartReplaced := TRUE;
        
        // sprdie v2.1 - convert special characters ---------------
        if (DoConvert = TRUE) then
          // convert XML notation of special characters (for example &amp; -> &)
          if ConvertXmlToText(pStart, pStart, sizeof(CHAR)) < 0 then // use same memory because text will be less
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;
        end_if;
        // --------------------------------------------------------
        
        StructCreator.AddText(pStart, FALSE, FALSE);
        
        //next step has to be looking for an element
        bTextSearched := TRUE;
        searchFor := _SEARCH_ELEMENT;
        
    end_case;
    
  end_while;
  
  retcode := TRUE;
  
END_FUNCTION //CreateStructAscii


FUNCTION _XMLReader::CreateStructUni
	VAR_INPUT
		parsedBytes 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
    pRun            : ^USINT;   // pointer to go through the information we read
    pStart          : ^USINT;   // points to the start of an element-name, atrib-name, attrib-value and so on...
    signCount       : UDINT;    // counts how much signs a string has
    counter         : UDINT;    // counter how far we passed through the information
    allocRet        : DINT;
    nextSign        : UINT;
    pAttribName     : ^USINT;
    pAttribValue    : ^USINT;
    bStartReplaced  : BOOL;
  END_VAR
  
  retcode := FALSE;
  
  // sprdie v2.0 - get number of elements and attributes first, afterwards get memory
  FetchElementsAndAttribsUni(#elementCount, #attribCount);
  allocRet := StructCreator.AllocPredefinedHeap(elementCount, attribCount);
  if allocRet < 0 then
    XmlState := _ERROR;
    ErrorState := _PARSE_ERR_MEMORY;
    return;
  end_if;
  
  // biggest work will be here
  // we have to go through the buffer and create our XML_STRUCT out of the information
  pRun := pFileBuffer + 2;
  
  counter := 2; 
  bStartReplaced := FALSE;
  
  // first handle the header
  if (pRun^$UINT = XML_START_UNI) & ((pRun+2)^$UINT = 16#003F) then 
    
    pStart := pRun;
    signCount := 0;
    
    while pRun^$UINT <> XML_END_UNI do
      signCount += 2;
      
      counter += 2;      
      pRun += 2;
    end_while;
    
    // now we are pointing at the end-mark, this also has to be in the header -> increase counters
    counter += 2;
    signCount += 2;
    
    if signCount > XML_MAX_HEADER_LENGTH then
      return;
    end_if;

    xmlStruct.Header$^void := StdLib.Malloc(signCount+2);
    _memset(xmlStruct.Header, 0, signCount+2);
    _memcpy(xmlStruct.Header, pStart, signCount);  
    
    // alloc memory for first element and set struct for creator
    xmlStruct.MajorElement$^void := StructCreator.GetElementMemory();
    if (xmlStruct.MajorElement = NIL) then
      XmlState := _ERROR;
      return;
    end_if;
    StructCreator.SetStructPtr(#xmlStruct);
  
  else
    // xml does not start with the header
    ErrorState := _PARSE_ERR_NO_HEADER;
    parsedBytes^ := counter;
    return;
  end_if;
  
  // now lets see if we find a CR or LF and no signs between except of SPACE
  counter += 2;
  pRun += 2;
  while (pRun^$UINT <> XML_CR_UNI) & (pRun^$UINT <> XML_LF_UNI) & (pRun^$UINT <> XML_START_UNI) do
    
    if pRun^$UINT <> XML_SPACE_UNI then
      ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
      parsedBytes^ := counter;
      return;
    end_if;
    
    counter += 2;
    pRun += 2;
  end_while;
  
  // Header finished -> now lets start with looking for an Element
  searchFor := _SEARCH_ELEMENT;
  
  // ludben v2.3: there could only be a header in the file
  if counter = fileLength then
    ErrorState := _PARSE_ERR_NO_ROOT_ELEMENT;
    parsedBytes^ := counter;
    return;
  end_if;
  
  while counter < fileLength do
    
    case searchFor of
    
    	_SEARCH_ELEMENT:
    	  // look for '<'
        while (pRun^$UINT <> XML_START_UNI) & (bStartReplaced = FALSE) do
        
          if (pRun^$UINT <> XML_CR_UNI) & (pRun^$UINT <> XML_LF_UNI) & (pRun^$UINT <> XML_SPACE_UNI) & (pRun^$UINT <> XML_TABULATOR_UNI) then
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;

          pRun += 2;
          counter += 2;
        end_while;
        
        bStartReplaced := FALSE;
        
        // now we are pointing at start-mark, but we need one increase more
        pRun += 2;
        counter += 2;
        
        if (pRun^$UINT <> XML_SLASH_UNI) & (pRun^$UINT <> XML_EXCLAMATION_UNI) then
          //START Element
          if bTextSearched = TRUE then
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;
          
          pStart := pRun;
          signCount := 0;
          
          // next step is to look for Space or End-Mark
          // counter are always one behind the pointer so we do not need to decrease afterwards
          while (pRun^$UINT <> XML_END_UNI) & (pRun^$UINT <> XML_SPACE_UNI) & (pRun^$UINT <> XML_SLASH_UNI) do
            signCount += 2;
            
            counter += 2;
            pRun += 2;
          end_while;
          
          // at this point we found an element and we can get the name, so kick off name and add element to struct
          nextSign := pRun^$UINT;
          pRun^ := 0;
          StructCreator.AddElement(pStart, TRUE, FALSE);
          
          // lets see what we have to do next
          if nextSign = XML_END_UNI then
            
            pRun += 2;    
            counter += 2;
            
            if (pRun^$UINT = XML_CR_UNI) | (pRun^$UINT = XML_LF_UNI) | (pRun^$UINT = XML_START_UNI) | (pRun^$UINT = XML_SPACE_UNI) then
              searchFor := _SEARCH_ELEMENT;
            else
              searchFor := _SEARCH_TEXT;
            end_if;
          
          elsif nextSign = XML_SLASH_UNI then
            StructCreator.CloseElement(NIL, TRUE);
            
            // element is closed directly -> check if next sign is END-Tag
            pRun += 2;
            counter += 2;
            
            if pRun^ <> XML_END_UNI then
              // no end-tag after slash -> error
              ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
              parsedBytes^ := counter;
              return;
            end_if;
            
            // set to next sign
            pRun += 2;
            counter += 2;
            
            searchFor := _SEARCH_ELEMENT;
            
          elsif nextSign = XML_SPACE_UNI then
            // in this case there can also be a closing-tag if element ist closed directly
            if (pRun+2)^ = XML_SLASH_UNI then
              
              StructCreator.CloseElement(NIL, TRUE);
              
              //                      <Element />
              //we point now to the space-----^---
              //but we need to be after end------^
              //this means +3 signs (in case of unicode 6Bytes)
              pRun += 6;
              counter += 6;
              
              searchFor := _SEARCH_ELEMENT;
            else
              searchFor := _SEARCH_ATTRIB;
            end_if;
          end_if;
        
        else
          if pRun^$UINT = XML_SLASH_UNI then
            
            bTextSearched := FALSE;
            // CLOSE Element
            // so just go to the end of the close-element-tag and then close
            pRun += 2;
            counter += 2;
            
            pStart := pRun;
            signCount := 0;
            
            while pRun^$UINT <> XML_END_UNI do
              signCount += 2;
              
              counter += 2;
              pRun += 2;
            end_while;
            
            pRun^ := 0;
            pRun += 2;
            counter += 2;
            
            retClose := StructCreator.CloseElement(pStart, TRUE);
            if retClose <> 0 then
              ErrorState := _PARSE_ERR_WRONG_SEQUENCE;
              parsedBytes^ := counter - signCount - 2;
              return;
            end_if;
            
            searchFor := _SEARCH_ELEMENT;
            
          else
            // check 4 comment
            if bTextSearched = TRUE then
              ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
              parsedBytes^ := counter;
              return;
            end_if;
            
            pRun += 2;
            counter += 2;
            if (pRun^$UINT = XML_HYPHEN_UNI) & ((pRun+2)^$UINT = XML_HYPHEN_UNI) then
              // we found '<!--' this means comment -> skip
              pRun += 4;
              counter += 4;
              
              while !!((pRun^$UINT = XML_HYPHEN_UNI) & ((pRun+2)^$UINT = XML_HYPHEN_UNI) & ((pRun+4)^$UINT = XML_END_UNI)) do
                
                pRun += 2;
                counter += 2;
                
              end_while;
              pRun += 6; // set ptr to one ofter end-tag
              counter += 6;
              // we found the end '-->'
              // go on with searching for an element
              searchFor := _SEARCH_ELEMENT;
              
            end_if;
            
          end_if;
          
        end_if;
        
      _SEARCH_ATTRIB:
      
        bTextSearched := FALSE;
    	  // when we have to search 4 an attribute we know that pRun points to a Space
        // so the next sign is the start 
        pRun += 2;
        counter += 2;
        
        pStart := pRun;
        signCount := 0;
        
        while pRun^$UINT <> XML_EQUAL_UNI do
          
          if (pRun^$UINT = XML_SPACE_UNI) | (pRun^$UINT = XML_LF_UNI) | (pRun^$UINT = XML_CR_UNI) then
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;
          
          signCount += 2; 
          counter += 2;
          pRun += 2;
        end_while;
        
        pAttribName := pStart;
        pRun^ := 0;
        
        // we got the name of the attribute now lets get the value
        if ((pRun+2)^$UINT <> XML_QUOTMARK_UNI) & ((pRun+2)^$UINT <> XML_APOSTROPHE_UNI) then
          ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
          parsedBytes^ := counter;
          return;
        end_if;
        
        if ((pRun+2)^$UINT = XML_QUOTMARK_UNI) then
          bQuot := TRUE;
        else
          bQuot := FALSE;
        end_if;
        
        pRun += 4; // set to one after quotation-mark
        counter += 4;
        
        pStart := pRun;
        signCount := 0;
        
        while ((pRun^$UINT <> XML_QUOTMARK_UNI) & (bQuot = TRUE)) | ((pRun^$UINT <> XML_APOSTROPHE_UNI) & (bQuot = FALSE)) do 
          signCount += 2;
          
          counter += 2;
          pRun += 2;
        end_while;
        
        pAttribValue := pStart;
        pRun^ := 0;
        
        // sprdie v2.1 - convert special characters ---------------
        if (DoConvert = TRUE) then
          // convert XML notation of special characters (for example &amp; -> &)
          if ConvertXmlToText(pAttribValue, pAttribValue, sizeof(UINT)) < 0 then // use same memory because text will be less
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;
        end_if;
        // --------------------------------------------------------
        
        if StructCreator.AddAttribute(pAttribName, pAttribValue, TRUE, FALSE) = -1 then
          ErrorState := _PARSE_ERR_ATTRIBUTE_TWICE;
          parsedBytes^ := counter - signCount - 2;
          return; // attribute already exists
        end_if;
        
        // lets see what we have to do next
        pRun += 2;
        counter += 2;
        
        if pRun^$UINT = XML_END_UNI then
          // so in this case we can have Text afterwards or next thing is an element
          pRun += 2;
          counter += 2;
          
          if (pRun^$UINT = XML_CR_UNI) | (pRun^$UINT = XML_LF_UNI) | (pRun^$UINT = XML_START_UNI) then
            searchFor := _SEARCH_ELEMENT;
          else
            searchFor := _SEARCH_TEXT;
          end_if;
          
        elsif pRun^$UINT = XML_SLASH_UNI then
            StructCreator.CloseElement(NIL, TRUE);
            
            // jump one sign after "/>"
            pRun += 4;
            counter += 4;
            searchFor := _SEARCH_ELEMENT;
            
        elsif pRun^$UINT = XML_SPACE_UNI then
          // in this case there can also be a closing-tag if element ist closed directly
          if (pRun+2)^ = XML_SLASH_UNI then
            
            StructCreator.CloseElement(NIL, TRUE);
            
            //                      <Element />
            //we point now to the space-----^---
            //but we need to be after end------^
            //this means +3 signs (in case of unicode 6Bytes)
            pRun += 6;
            counter += 6;
            
            searchFor := _SEARCH_ELEMENT;
          else
            searchFor := _SEARCH_ATTRIB;
          end_if;
          
        end_if;
        
      _SEARCH_TEXT:
        // we already point to the start of the text
        pStart := pRun;
        signCount := 0;
        
        while pRun^$UINT <> XML_START_UNI do
          signCount += 2;
          
          counter += 2;
          pRun += 2;
        end_while;
                
        // kick off text & add to actual element
        pRun^ := 0;
        bStartReplaced := TRUE;
        
        // sprdie v2.1 - convert special characters ---------------
        if (DoConvert = TRUE) then
          // convert XML notation of special characters (for example &amp; -> &)
          if ConvertXmlToText(pStart, pStart, sizeof(UINT)) < 0 then // use same memory because text will be less
            ErrorState := _PARSE_ERR_UNEXPECTED_SIGN;
            parsedBytes^ := counter;
            return;
          end_if;
        end_if;
        // --------------------------------------------------------
        
        StructCreator.AddText(pStart, TRUE, FALSE);
        
        //next step hast to be looking for an element
        bTextSearched := TRUE;
        searchFor := _SEARCH_ELEMENT;
        
    end_case;
    
  end_while;
  
  retcode := TRUE;
  
END_FUNCTION //CreateStructUni


FUNCTION _XMLReader::FindError
	VAR_INPUT
		bytesParsed 	: UDINT;
	END_VAR
  VAR
  	count : UDINT;
    linecount : UDINT;
    signsUntilCRLF : UDINT;
    pTmp  : ^USINT;
  END_VAR
  
  lineCount := 1;
  signsUntilCRLF := 0;
  
  pTmp := pFileBuffer;
  
  if bRdIsUnicode = TRUE then
    pTmp += sizeof(UINT);
    
    bytesParsed := bytesParsed / 2;
  end_if;
  
  for count := 1 to bytesParsed - 1 do
    
    if pTmp^ = XML_LF | pTmp^ = XML_CR then
      linecount += 1;
      signsUntilCRLF := 0;
      
      while pTmp^ = XML_CR | pTmp^ = XML_LF do
        if bRdIsUnicode = TRUE then
          pTmp += sizeof(UINT);
        else
          pTmp += sizeof(USINT);
        end_if;
      end_while;
    
    else
      signsUntilCRLF += 1;
      
      if bRdIsUnicode = TRUE then
        pTmp += sizeof(UINT);
      else
        pTmp += sizeof(USINT);
      end_if;
    end_if;  
    
  end_for;

  ErrorLine := TO_DINT(linecount);
  ErrorSign := TO_DINT(signsUntilCRLF);
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetAttribValueByName
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pValue 	: ^USINT;
	END_VAR
  
  if pElement = NIL | pName = NIL then
    pValue := NIL;
    return;
  end_if;
  
  // look if we have tu use unicode functions or not
  if bRdIsUnicode = TRUE then
    pValue := GetAttribValueByNameUni(pElement, pName$^UINT);
  else
    pValue := GetAttribValueByNameAscii(pElement, pName);
  end_if;
  
END_FUNCTION


FUNCTION _XMLReader::GetAttribValueByNameAscii
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		pValue 	: ^USINT;
	END_VAR
  VAR
  	i : UDINT;
    pAttrib : ^_XML_ATTRIBUTE;
  END_VAR
  
  pValue := NIL;
  
  // go through whole attribute list and check names
  pAttrib := pElement^.Attributes.pList;
  for i := 1 to pElement^.Attributes.no do
    
    if SigCLib.StrCmp(pName, pAttrib^.Name) = 0 then
      pValue := pAttrib^.Value;
      return;
    end_if;
    
    pAttrib += sizeof(_XML_ATTRIBUTE);
  end_for;

END_FUNCTION


FUNCTION _XMLReader::GetAttribValueByNameUni
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		pValue 	: ^USINT;
	END_VAR
  VAR
  	i : UDINT;
    pAttrib : ^_XML_ATTRIBUTE;
  END_VAR
  
  pValue := NIL;
  
  // go through whole attribute list and check names
  pAttrib := pElement^.Attributes.pList;
  for i := 1 to pElement^.Attributes.no do
    
    if SigCLib.StrCmp16(pName, pAttrib^.Name$^UINT) = 0 then
      pValue := pAttrib^.Value;
      return;
    end_if;
    
    pAttrib += sizeof(_XML_ATTRIBUTE);
  end_for;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetChildByName
	VAR_INPUT
		pParent 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
		number 	: UDINT;(* := 1 *)
	END_VAR
	VAR_OUTPUT
		pChild 	: ^_XML_ELEMENT;
	END_VAR
  
  // number = 1 means first child; number = 2 means second child and so on...
  if number = 0 then
    pChild := NIL;
    return;
  end_if;
  
  if pParent = NIL | pName = NIL then
    pChild := NIL;
    return;
  end_if;
  
  if bRdIsUnicode = TRUE then
    pChild := GetChildByNameUni(pParent, pName$^UINT, number);
  else
    pChild := GetChildByNameAscii(pParent, pName, number);
  end_if;

END_FUNCTION


FUNCTION _XMLReader::GetChildByNameAscii
	VAR_INPUT
		pParent 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
		number 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pChild 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	pTmp : ^_XML_ELEMENT;
    tmpNr : UDINT;
  END_VAR
 
  pChild := NIL;
  
  // set temp-pointer to first child
  pTmp := pParent^.pChildren;
  tmpNr := number;
  
  while pTmp <> NIL do
    // go through childs and compare names
    if SigCLib.StrCmp(pTmp^.Name, pName) = 0 then
      
      tmpNr -= 1;
      if tmpNr = 0 then
        pChild := pTmp;
        return;
      end_if;
      
    end_if;

    pTmp := pTmp^.pNext;
  end_while;
  
END_FUNCTION


FUNCTION _XMLReader::GetChildByNameUni
	VAR_INPUT
		pParent 	: ^_XML_ELEMENT;
		pName 	: ^UINT;
		number 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pChild 	: ^_XML_ELEMENT;
	END_VAR
  VAR
  	pTmp : ^_XML_ELEMENT;
    tmpNr : UDINT;
  END_VAR
  
  pChild := NIL;
  
  // set temp-pointer to first child
  pTmp := pParent^.pChildren;
  tmpNr := number;
  
  while pTmp <> NIL do
    // go through childs and compare names
    if SigCLib.StrCmp16(pTmp^.Name$^UINT, pName) = 0 then
      
      tmpNr -= 1;
      if tmpNr = 0 then
        pChild := pTmp;
        return;
      end_if;
      
    end_if;

    pTmp := pTmp^.pNext;
  end_while;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::ParseXML
	VAR_INPUT
		pData 	: ^USINT;
		length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  retcode := FALSE;
  
  if XmlState = _READY then // check if reader is ready
    
    if length > 0 then // check given length
      
      pFileBuffer$^void := StdLib.Malloc(length);
      if pFileBuffer <> NIL then
        
        StructCreator.SetFileBufferInfo(pFileBuffer, length);
        
        // alloc memory was successfull - copy data
        _memcpy(pFileBuffer, pData, length);
        
        fileLength := length;
        
        XmlState := _PARSE_STREAM;
        readSSW := _CREATE_STRUCT;
        
        retcode := TRUE;
      end_if;

    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetXmlState
	VAR_OUTPUT
		state 	: XML_READ_STATE;
	END_VAR
  
  state := XmlState;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::GetErrorState
	VAR_OUTPUT
		state 	: _XML_PARSE_ERROR;
	END_VAR
  
  state := ErrorState;
  
END_FUNCTION


FUNCTION _XMLReader::CreateTaskName
	VAR_INPUT
		pName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	udCRC32       : UDINT;
    udStrLen      : UDINT;
    szObjectName  : ARRAY [0..255] OF CHAR;
    szCRC32       : ARRAY [0..15]  OF CHAR;
  END_VAR

  retcode := FALSE;
  
  if pName = NIL then
    return;
  end_if;
  
  SigCLib.StrCpy(dst0 := pName,
                 src0 := XMLREADER_TASKNAME);

  _GetObjName(pThis := this,
              pName := #szObjectName[0]);

  udStrLen := SigCLib.StrLen(str := #szObjectName[0]);

  udCRC32  := CheckSum.CRC32(pBuffer  := #szObjectName[0],
                             len      := udStrLen,
                             CrcStart := 0);

  SigCLib.IToA(val  := udCRC32$DINT,
                 dst  := #szCRC32[0],
                 base := 0x10);

  SigCLib.StrCat(ps1 := pName,
                   ps2 := #szCRC32[0]);
  
  retcode := TRUE;
  
END_FUNCTION


FUNCTION _XMLReader::XmlReadTask
  VAR
    bytesParsed : UDINT;
  END_VAR

  while 1 do
  
    if doCreate = TRUE then
      
      doCreate := FALSE;
      if CreateStruct(#bytesParsed) then
        isCreated := TRUE;
      else
        FindError(bytesParsed);
        XmlState := _ERROR;
      end_if;
      
    end_if;

    if doFree = TRUE then
      doFree := FALSE;
      StructCreator.FreeStruct();
      isFree := TRUE;
    end_if;
    
    MultiTask.TASKDELAY(XMLREADER_TASKDELAY);
    
  end_while;

END_FUNCTION


FUNCTION _XMLReader::FetchElementsAndAttribsAscii
	VAR_INPUT
		pElementCount 	: ^UDINT;
		pAttribCount 	: ^UDINT;
	END_VAR
  VAR
  	pSearch         : ^CHAR;
    bytesRead       : UDINT;
    tmpElemCount    : UDINT;
    tmpAttribCount  : UDINT;
  END_VAR
  
  pSearch := pFileBuffer;
  bytesRead := 0;
  
  tmpElemCount := 0;
  tmpAttribCount := 0;
  
  while bytesRead < fileLength do
      
      // looking for start of Element - for example `<x`
      if (pSearch^ = XML_START) then
        bytesRead += 1;
        pSearch += 1;
        
        if (pSearch^ <> XML_SLASH) then
          tmpElemCount += 1;
        end_if;
      
      elsif (pSearch^ = XML_EQUAL) then
        bytesRead += 1;
        pSearch += 1;
        
        if ((pSearch^ = XML_APOSTROPHE) | (pSearch^ = XML_QUOTMARK)) then
          tmpAttribCount += 1;
        end_if;
      end_if;
      
      bytesRead += 1;
      pSearch += 1;
  end_while;
  
  pElementCount^ := tmpElemCount;
  pAttribCount^ := tmpAttribCount;
  
END_FUNCTION

FUNCTION _XMLReader::FetchElementsAndAttribsUni
	VAR_INPUT
		pElementCount 	: ^UDINT;
		pAttribCount 	: ^UDINT;
	END_VAR
  VAR
  	pSearch         : ^UINT;
    bytesRead       : UDINT;
    tmpElemCount    : UDINT;
    tmpAttribCount  : UDINT;
  END_VAR
  
  pSearch := pFileBuffer$^UINT;
  bytesRead := 0;
  
  tmpElemCount := 0;
  tmpAttribCount := 0;
  
  while bytesRead < fileLength do
      
      // looking for start of Element - for example `<x`
      if (pSearch^ = XML_START_UNI) then
        bytesRead += 2;
        pSearch += 2;
        
        if (pSearch^ <> XML_SLASH_UNI) then
          tmpElemCount += 2;
        end_if;
      
      elsif (pSearch^ = XML_EQUAL_UNI) then
        bytesRead += 2;
        pSearch += 2;
        
        if ((pSearch^ = XML_APOSTROPHE_UNI) | (pSearch^ = XML_QUOTMARK_UNI)) then
          tmpAttribCount += 2;
        end_if;
      end_if;
      
      bytesRead += 2;
      pSearch += 2;
  end_while;
  
  pElementCount^ := tmpElemCount;
  pAttribCount^ := tmpAttribCount;
  
END_FUNCTION


FUNCTION GLOBAL _XMLReader::ConvertXmlToText
	VAR_INPUT
		pDest 	: ^void;
		pSrc 	: ^void;
		size 	: UINT;
	END_VAR
	VAR_OUTPUT
		length 	: DINT;
	END_VAR
  
  if ((pDest = NIL) | (pSrc = NIL)) then
    length := -1;
    return;
  end_if;
  
  // initialise retcode with -2 (not supported char size)
  length := -2;
  
  if (size = 1) then
    length := ConvertXmlToTextAscii(pDest$^CHAR, pSrc$^CHAR);
  elsif (size = 2) then
    length := ConvertXmlToTextUni(pDest$^UINT, pSrc$^UINT);
  end_if;
  
END_FUNCTION

FUNCTION _XMLReader::ConvertXmlToTextAscii
	VAR_INPUT
		pDest 	: ^CHAR;
		pSrc 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		length 	: DINT;
	END_VAR
  VAR
  	pSearch   : ^CHAR;
    scIndex   : UDINT;
    pNewDest  : ^CHAR;
    pNewSrc   : ^CHAR;
    pInsert   : ^CHAR;
    tmpLength : DINT;
  END_VAR

  length := 0;
  
  // go through whole string and replace first sign we find
  // afterwards call method again with changed pSrc and pDest
  scIndex := 0;
  pSearch := pSrc;
  while ((pSearch^ <> 0) 
       & (pSearch^ <> XML_AMPERSAND)) do
    
    scIndex += 1;
    pSearch += sizeof(CHAR);
  end_while; 
  
  // copy part where no special characters have been found
  if (scIndex > 0) then
    SigCLib.MemMove(pDest, pSrc, scIndex);
  end_if;
  
  pInsert := pDest + scIndex;
  length += scIndex$DINT;
  
  if (pSearch^ = 0) then
    pInsert^ := 0;
    return; // end of string reached -> leave method
    
  elsif (_memcmp(pSearch, XML_CONVERT_AMPERSAND, XML_LENGTH_AMPERSAND) = 0) then
    // from &amp; to & ---------------------------------------
    pInsert^ := XML_AMPERSAND;
    
    pNewDest := pInsert + sizeof(CHAR);
    pNewSrc := pSearch + XML_LENGTH_AMPERSAND;
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, XML_CONVERT_APOS, XML_LENGTH_APOS) = 0) then
    // from &apos; to ' --------------------------------------
    pInsert^ := XML_APOSTROPHE;
    
    pNewDest := pInsert + sizeof(CHAR);
    pNewSrc := pSearch + XML_LENGTH_APOS;
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, XML_CONVERT_GREATER, XML_LENGTH_GREATER) = 0) then
    // from &gt; to > ----------------------------------------
    pInsert^ := XML_END;
    
    pNewDest := pInsert + sizeof(CHAR);
    pNewSrc := pSearch + XML_LENGTH_GREATER;
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, XML_CONVERT_LESS, XML_LENGTH_LESS) = 0) then
    // from &lt; to < ----------------------------------------
    pInsert^ := XML_START;
    
    pNewDest := pInsert + sizeof(CHAR);
    pNewSrc := pSearch + XML_LENGTH_LESS;
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, XML_CONVERT_QUOT, XML_LENGTH_QUOT) = 0) then
    // from &quot; to " --------------------------------------
    pInsert^ := XML_QUOTMARK;
    
    pNewDest := pInsert + sizeof(CHAR);
    pNewSrc := pSearch + XML_LENGTH_QUOT;
    // -------------------------------------------------------
    
  else
    // nothing matched -> return with error!
    length := -3;
    return;
    
  end_if;
  
  // when we reached this point, we have been able to insert the special character -> therefore increment length of String
  length += 1;
  
  tmpLength := ConvertXmlToTextAscii(pNewDest, pNewSrc);
  if (tmpLength < 0) then
    length := tmpLength;
    return;
  end_if;
  
  length += tmpLength;
  
END_FUNCTION

FUNCTION _XMLReader::ConvertXmlToTextUni
	VAR_INPUT
		pDest 	: ^UINT;
		pSrc 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		length 	: DINT;
	END_VAR
  VAR
  	pSearch       : ^UINT;
    scIndex       : UDINT;
    pNewDest      : ^UINT;
    pNewSrc       : ^UINT;
    pInsert       : ^UINT;
    tmpLength     : DINT;
  END_VAR
  
  length := 0;
  
  // go through whole string and replace first sign we find
  // afterwards call method again with changed pSrc and pDest
  scIndex := 0;
  pSearch := pSrc;
  while ((pSearch^ <> 0) 
       & (pSearch^ <> XML_AMPERSAND)) do
    
    scIndex += 1;
    pSearch += sizeof(UINT);
  end_while; 
  
  // copy part where no special characters have been found
  if (scIndex > 0) then
    SigCLib.MemMove(pDest, pSrc, scIndex*sizeof(UINT));
  end_if;
  
  pInsert := pDest + (scIndex * sizeof(UINT));
  length += scIndex$DINT;
  
  if (pSearch^ = 0) then
    pInsert^ := 0;
    return; // end of string reached -> leave method
    
  elsif (_memcmp(pSearch, #strUniAmp[0], (XML_LENGTH_AMPERSAND*sizeof(UINT))) = 0) then
    // from &amp; to & ---------------------------------------
    pInsert^ := XML_AMPERSAND_UNI;
    
    pNewDest := pInsert + sizeof(UINT);
    pNewSrc := pSearch + (XML_LENGTH_AMPERSAND*sizeof(UINT));
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, #strUniApos[0], (XML_LENGTH_APOS*sizeof(UINT))) = 0) then
    // from &apos; to ' --------------------------------------
    pInsert^ := XML_APOSTROPHE_UNI;
    
    pNewDest := pInsert + sizeof(UINT);
    pNewSrc := pSearch + (XML_LENGTH_APOS*sizeof(UINT));
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, #strUniGreater[0], (XML_LENGTH_GREATER*sizeof(UINT))) = 0) then
    // from &gt; to > ----------------------------------------
    pInsert^ := XML_END_UNI;
    
    pNewDest := pInsert + sizeof(UINT);
    pNewSrc := pSearch + (XML_LENGTH_GREATER*sizeof(UINT));
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, #strUniLess[0], (XML_LENGTH_LESS*sizeof(UINT))) = 0) then
    // from &lt; to < ----------------------------------------
    pInsert^ := XML_START_UNI;
    
    pNewDest := pInsert + sizeof(UINT);
    pNewSrc := pSearch + (XML_LENGTH_LESS*sizeof(UINT));
    // -------------------------------------------------------
    
  elsif (_memcmp(pSearch, #strUniQuot[0], (XML_LENGTH_QUOT*sizeof(UINT))) = 0) then
    // from &quot; to " --------------------------------------
    pInsert^ := XML_QUOTMARK_UNI;
    
    pNewDest := pInsert + sizeof(UINT);
    pNewSrc := pSearch + (XML_LENGTH_QUOT*sizeof(UINT));
    // -------------------------------------------------------
    
  else
    // nothing matched -> return with error!
    length := -3;
    return;
    
  end_if;
  
  // when we reached this point, we have been able to insert the special character -> therefore increment length of String
  length += 1;
  
  tmpLength := ConvertXmlToTextUni(pNewDest, pNewSrc);
  if (tmpLength < 0) then
    length := tmpLength;
    return;
  end_if;
  
  length += tmpLength;
  
END_FUNCTION

FUNCTION GLOBAL _XMLReader::ResetSearch
  
  //sprdie v2.1 - set length to 0 so next search-method starts from beginning
  lastLen := 0;
  lastLenValue := 0;
  
END_FUNCTION
