//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

  #define MB_CL_SEND_DATA_OK      0
  #define MB_CL_NOT_READY         -1
  #define MB_CL_WAIT_4_RESPONSE   -2
  #define MB_CL_SEND_DATA_FAILED  -3
  
//  #define MAX_CONNECTIONS         16
  
  #define TCPCLT_ERROR_NO            0
  #define TCPCLT_ERROR_INVALID_SOCK  -1
  #define TCPCLT_ERROR_CONNECTION    -2
  #define TCPCLT_ERROR_TIMEOUT       -3

  #define TCP_CLT_SEND_OK               0
  #define TCP_CLT_INVALID_HANDLE        -1
  #define TCP_CLT_NOT_CONNECTED         -2
  #define TCP_CLT_SEND_FAILED           -3
  #define TCP_CLT_SEND_BUFFER_FULL      -4
  #define TCP_CLT_DATA_TO_BIG_FOR_DIRECT_SENDING   -5
  #define TCP_CLT_MAXLEN_SEMANAME     32

  #define TCP_CLT_ERR_SET_PARA_INVALID_CMD     -10
  #define TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD -11

  #define TCP_CLT_ERR_TASK_ALREADY_EXIST       -12

  #define TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED  -13

  #ifndef OS_VERSION_MIN_SALAMANDER
    #define OS_VERSION_MIN_SALAMANDER          0x9000
  #endif

  #define TCP_CLT_NO_ERROR                          0

  // - RETURN VALUES PRIVATE METHOD Read_LSLOBJ_CRC32
  #define TCP_CLT_ERR_GET_LSLOBJ_NAME             -20
  #define TCP_CLT_ERR_INVALID_POINTER             -21

  // - RETURN VALUES PRIVATE METHOD Read_AP_TaskPeriod
  #define TCP_CLT_ERR_TASK_TIME_NO_APP            -31
  #define TCP_CLT_ERR_TASK_TIME_WRONG_TASK_TYPE   -33
  #define TCP_CLT_ERR_TASK_TIME_OBJ_NOT_FOUND     -35

  // - RETURN VALUES PRIVATE METHOD AP_TaskCreate
  #define TCP_CLT_ERR_TASK_CREATE                 -40

  // - RETURN VALUES PRIVATE METHOD AP_SemaCreate
  #define TCP_CLT_ERR_SEMA_CREATE                 -50
  #define TCP_CLT_ERR_SEMA_INVALID_IDX            -51
  #define TCP_CLT_ERR_SEMA_INVALID_NAME           -52

  #define TCP_CLT_SEND_BUFFER_EMPTY                -6
  #define TCP_CLT_ERR_SEND_BUFFER_FATAL_ERROR      -7

  #define TCP_CLT_ERR_NO_SSL_INTERFACE             -8
  #define TCP_CLT_ERR_NO_TCP_INTERFACE             -9

  #define TCP_CLT_ERR_INVALID_PARA_TCP            -60
  #define TCP_CLT_ERR_INVALID_PARA_SSL            -61
  
  #define TCP_CLT_ERR_CONN_MEMORY                 -70
  #define TCP_CLT_ERR_MAX_CONN                    -80
  #define TCP_CLT_ERR_MAIN_INIT                   -90
  
  #define TCP_CLT_ERR_GROUP_OS                      0
  #define TCP_CLT_ERR_GROUP_AP                      1

  #define TCP_CLT_ERR_CODE_AP_TIMEOUT              -1
  
  #ifndef INIT_FIRSTSCAN
    #define INIT_FIRSTSCAN                         12
  #endif

  #ifndef AP_TASK_PRIORITY_DEFAULT
    #define AP_TASK_PRIORITY_DEFAULT               14
  #endif

  #define TCP_CLT_CMD_KEEP_ALIVE_PARA               2
  #define TCP_CLT_SUB_CMD_KEEP_ALIVE_INTERVAL       0
  #define TCP_CLT_SUB_CMD_KEEP_ALIVE_RETRY          1
  #define TCP_CLT_SUB_CMD_KEEP_ALIVE_TIMEOUT        2

  #define TCP_CLT_INFO_DISCONNECT                   0
  #define TCP_CLT_INFO_CONNECT                      1
  #define TCP_CLT_INFO_DELETED                      2
  
  #ifndef KEEPALIVE_INTERVAL_DEFAULT
    #define KEEPALIVE_INTERVAL_DEFAULT           7200
  #endif

  #ifndef KEEPALIVE_RETRYTIME_DEFAULT
    #define KEEPALIVE_RETRYTIME_DEFAULT            75
  #endif

  #ifndef KEEPALIVE_RETRYCNT_DEFUALT
    #define KEEPALIVE_RETRYCNT_DEFUALT             10
  #endif

  #ifndef CLOSE_SOCKET_TYPE_DEFAULT
    #define CLOSE_SOCKET_TYPE_DEFAULT               0
  #endif
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\_TCPIP_CLIENT\SalamanderDelay.h"
#include "..\..\Class\_TCPIP_CLIENT\lsl_st_ssl_user.h"

(*!
<Class
	Name               = "_TCPIP_CLIENT"
	Revision           = "1.17"
	GUID               = "{737E7644-8481-4C04-B98F-BF7D954F6CDD}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	DefBackground      = "always"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(568,120)"
	Comment            = "TCP/IP Client for TCP/IP Communication.&#13;&#10;&#13;&#10;It is recommended to use one object per connection.">
	<Channels>
		<Server Name="Control" GUID="{4A378BA5-C1B5-4DC4-BA64-B864666189FE}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Object Channel&#13;&#10;-) use the channel to call global functions from external&#13;&#10;-) this server shows the TCP client state"/>
		<Server Name="SemaName01" GUID="{4FB8C9CC-C5CF-41F0-A163-453B02A41DE6}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="name of mutex to save the internal connection buffer&#13;&#10;&#13;&#10;This name is also listed in PLCTraceView"/>
		<Server Name="SemaName02" GUID="{D38CF90A-398F-4B98-B132-7EB053555A4E}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="name of mutex to save the internal connection settings (socket options)&#13;&#10;&#13;&#10;This name is also listed in PLCTraceView"/>
		<Server Name="TaskName" GUID="{CB1B4521-82B0-4FF1-89CB-BF6B68BB22B8}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="shows task information&#13;&#10;-) use object in cyclic task&#13;&#10;-) use object in async task&#13;&#10;-) task deactivated&#13;&#10;-) async task error status (error creating async task)&#13;&#10;&#13;&#10;In case of using the object in async task, this name is also listed in PLCTraceView"/>
		<Client Name="cConfig" Required="false" Internal="false" Comment="object configuration&#13;&#10;bit0 ... task configuration&#13;&#10;0 = use object in cyclic task&#13;&#10;1 = use object in async task"/>
		<Client Name="CheckSum" Required="true" Internal="true"/>
		<Client Name="cMaxConnections" Required="true" Internal="false" DefValue="0" Comment="Maximal number of connections. Maximal possible connections are 16.&#13;&#10;&#13;&#10;0 = 16 connections, because of compatibility to older versions."/>
		<Client Name="co_MultiTask" Required="false" Internal="false" Comment="object channel to OS interface class _MultiTask"/>
		<Client Name="co_SigCLib" Required="false" Internal="false" Comment="object channel to OS interface class SigCLib"/>
		<Client Name="co_StdLib" Required="false" Internal="false" Comment="object channel to OS interface class _StdLib"/>
		<Client Name="co_Task" Required="false" Internal="false" Comment="object channel to OS interface class _TaskObjectControl"/>
		<Client Name="cPort" Required="true" Internal="false" DefValue="502" Comment="port number ... must be connected or initialized"/>
		<Client Name="cSizeOfTXBuffer" Required="false" Internal="false" Comment="size of TX buffer [byte]&#13;&#10;if 0 there will be 1024 Byte allocated"/>
		<Client Name="StrSemaName01" Required="true" Internal="true"/>
		<Client Name="StrSemaName02" Required="true" Internal="true"/>
		<Client Name="StrTaskName" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_tcp_user.h" Include="false"/>
			<File Path=".\Class\_TCPIP_CLIENT\_TCPIP_CLIENT.h" Include="true"/>
			<File Path=".\Class\_TCPIP_CLIENT\SalamanderDelay.h" Include="true"/>
			<File Path=".\Class\_TCPIP_CLIENT\lsl_st_ssl_user.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SIGMATEK" Author="SCHMAT"/>
		<Dokumentation Revision="1.17" Date="2018-02-22" Author="SCHMAT" Company="SIGMATEK" Description="- improvement: GetSetting() method to read client settings via object channel&#13;&#10;- bugfix: send more than 5840 byte"/>
		<Dokumentation Revision="1.16" Date="2018-02-05" Author="SCHMAT" Company="SIGMATEK" Description="- corrected defines because of identical redefinition warning by using _TCPIP_CLIENT and _TCPIP_SERVER in same network"/>
		<Dokumentation Revision="1.15" Date="2017-11-02" Author="SCHMAT" Company="SIGMATEK" Description="- improvement: add SSL/TLS connection"/>
		<Dokumentation Revision="1.14" Date="2017-10-25" Author="SCHMAT" Company="SIGMATEK" Description="- bugfix using async task at multi core CPUs&#13;&#10;- run cyclic task also in case of using async communication to do the CyWork of derived classes"/>
		<Dokumentation Revision="1.13" Date="2017-08-17" Author="HubChr, SchMat" Company="SIGMATEK" Description="Type of connection closing can now also be set (graceful close / hard close)"/>
		<Dokumentation Revision="1.12" Date="2017-06-22" Author="SchMat" Company="SIGMATEK" Description="bug fix: semaphore handling&#13;&#10;improvement: possible use of async task for cyclic connection updates&#13;&#10;improved error interfaces"/>
		<Dokumentation Revision="1.11" Date="2017-05-08" Author="SchMat, HubChr" Company="SIGMATEK" Description="New Methods SetMainParameter(), SetConnParameter() to set Socket Options"/>
		<Dokumentation Revision="1.10" Date="2017-05-08" Author="HubChr" Company="SIGMATEK" Description="Bugfix in semaphore handling: calling DelConnection from a task other than CyWork could cause the respective task to stop."/>
		<Dokumentation Revision="1.9" Date="2017-01-31" Author="KaiAnd" Company="SIGMATEK" Description="fixed access-exception bug because of lost pointer pActConnection (V.1.8 didn&apos;t work correct)"/>
		<Dokumentation Revision="1.8" Date="2017-01-27" Author="KaiAnd" Company="SIGMATEK" Description="fixed access-exception bug because of lost pointer pActConnection"/>
		<Dokumentation Revision="1.7" Date="2016-11-21" Author="HubChr" Company="SIGMATEK" Description="-) Fixed error that occurred when an Objectname longer than 32 signs was used&#13;&#10;-) CIL-Pointer is now declared as Member-Variable (was private)"/>
		<Dokumentation Revision="1.6" Date="2016-04-29" Author="HubChr" Company="SIGMATEK" Description="Improved Semaphore Handling"/>
		<Dokumentation Revision="1.5" Date="2015-07-07" Author="hoechr1" Company="SIGMATEK" Description="Methods AddConnection, DelConnection are now threadsave. (SA31299)&#13;&#10;Added support for sending more than 1452 bytes.&#13;&#10;Changed the connection buffer from dynamic to static memory management.&#13;&#10;Added client cMaxConnections for set the number of connections that should be initialized."/>
		<Dokumentation Revision="1.4" Date="2012-05-30" Author="spimar" Company="SIGMATEK" Description="Corrected a comment;"/>
		<Dokumentation Revision="1.3" Date="2012-03-20" Author="spimar&#13;&#10;schmat" Company="SIGMATEK" Description="Now the size of 1kb is allocated if there is no init value set on the client;&#13;&#10;The data buffer is now only cleared (free) if the pointer is valid;&#13;&#10;Now the right pointer is set at closesocket();"/>
		<Dokumentation Revision="1.2" Date="2012-02-03" Author="wentob" Company="SIGMATEK" Description="Reconection timeout to prevent sync-flood. BETA!"/>
		<Dokumentation Revision="1.1" Date="2011-12-13" Author="spimar" Company="SIGMATEK" Description="The global methods are now virtual;"/>
		<Dokumentation Revision="1.0" Date="7.10.2010" Author="SCHMAT" Company="SIGMATEK" Description="TCP/IP Client for TCP/IP Communication"/>
	</RevDoku>
	<Network Name="_TCPIP_CLIENT">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "CheckSum"
				GUID       = "{FC39352F-F797-497F-B594-E820A7A22227}"
				Class      = "_CheckSum"
				Position   = "(360,240)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSemaName01"
				GUID       = "{E85D366E-9709-4F3D-AE62-C1B016CACD7B}"
				Class      = "String"
				Position   = "(360,570)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrSemaName02"
				GUID       = "{10DC5FEF-3685-401A-A366-325AC26C1ADC}"
				Class      = "String"
				Position   = "(360,720)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "StrTaskName"
				GUID       = "{C0143FE0-3A33-4991-A32A-076BDAE27564}"
				Class      = "String"
				Position   = "(360,420)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.CheckSum" Destination="CheckSum.ClassSvr"/>
			<Connection Source="this.StrTaskName" Destination="StrTaskName.Data"/>
			<Connection Source="this.TaskName" Destination="StrTaskName.Data" Vertices="(1268,270),(1096,510),"/>
			<Connection Source="this.StrSemaName01" Destination="StrSemaName01.Data"/>
			<Connection Source="this.SemaName01" Destination="StrSemaName01.Data" Vertices="(1268,330),(1096,660),"/>
			<Connection Source="this.StrSemaName02" Destination="StrSemaName02.Data"/>
			<Connection Source="this.SemaName02" Destination="StrSemaName02.Data" Vertices="(1268,390),(1096,810),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_TCPIP_CLIENT : CLASS
	TYPE
#pragma pack(push, 1)
	  _BUFFER_HEADER : STRUCT
	    DataSize : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _TX_RINGBUFFER : STRUCT  //! <Type Comment="struct to handle a ringbuffer" Name="_TX_RINGBUFFER"/>
	    udSize : UDINT;
	    udUsed : UDINT;
	    pMem : ^void;
	    pRead : ^void;
	    pWrite : ^void;
	  END_STRUCT;
#pragma pack(pop)
	  _SocketOptions : BDINT
	  [
	    1 Nagle,
	    2 KeepAlive,
	    3 DelayedAck,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
#pragma pack(push, 1)
	  _KeepAlivePara : STRUCT
	    keepIDLE : DINT;
	    keepINTVL : DINT;
	    keepCNT : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _CONNECTION : STRUCT
	    bInUse : BOOL;
	    szIPAddress : ARRAY [0..0x10] OF CHAR;
	    bConnected : BOOL;
	    dSocket : DINT;
	    FSM_TCP : _FSM_TCP_USER;
	    udTimeout : UDINT;
	    udTimeStamp : UDINT;
	    pCallbackThis : ^void;
	    pCallbackMeth : ^void;
	    RingbufferForSending : _TX_RINGBUFFER;
	    pSendReceiveBuffer : ^CHAR;
	    pSendReceiveBufferHelp : ^CHAR;
	    BufferHeader : _BUFFER_HEADER;
	    ConnSockOpt : _SocketOptions;
	    bdSettings : BDINT
	    [
	      1 SockOptInit,
	      2 SockOptChanged,
	      3 DelConn,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 Bit8,
	      9 Bit9,
	      10 Bit10,
	      11 Bit11,
	      12 Bit12,
	      13 Bit13,
	      14 Bit14,
	      15 Bit15,
	      16 Bit16,
	      17 ConnSSL,
	      18 Bit18,
	      19 Bit19,
	      20 Bit20,
	      21 Bit21,
	      22 Bit22,
	      23 Bit23,
	      24 Bit24,
	      25 Bit25,
	      26 Bit26,
	      27 Bit27,
	      28 Bit28,
	      29 Bit29,
	      30 Bit30,
	      31 Bit31,
	      32 Bit32,
	    ];
	    szCACertPEMFileName : ARRAY [0..255] OF CHAR;
	    szClientCertChainPEMFileName : ARRAY [0..255] OF CHAR;
	    szClientCertKeyPEMFileName : ARRAY [0..255] OF CHAR;
	    szKeyDecryptPwd : ARRAY [0..1023] OF CHAR;
	    pNextConn : ^_CONNECTION;
	    pErrCallbackThis : ^void;
	    pErrCallbackMeth : ^void;
	    pInfoCallbackThis : ^void;
	    pInfoCallbackMeth : ^void;
	    KeepAlivePara : _KeepAlivePara;
	    CloseSocketType : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  _FSM_CLT_STATE :
	  (
	    _STATE_INIT,
	    _STATE_WORK
	  )$UDINT;
#pragma pack(push, 1)
	  _KeepAliveParaLasalOS : STRUCT
	    interval : UINT;
	    retry : UINT;
	    timeout : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _TCP_CLT_CONNECTS : STRUCT
	    dActConn : DINT;
	    pConnections : ^_CONNECTION;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	Control 	: SvrChCmd__FSM_TCP_USER;
	TaskName 	: SvrCh_UDINT;
	SemaName01 	: SvrCh_UDINT;
	SemaName02 	: SvrCh_UDINT;
  //Clients:
	cPort 	: CltCh_DINT;
	cSizeOfTXBuffer 	: CltCh_UDINT;
	cMaxConnections 	: CltCh_DINT;
	cConfig 	: CltCh_DINT;
	co_StdLib 	: CltChCmd__StdLib;
	co_MultiTask 	: CltChCmd__MultiTask;
	co_SigCLib 	: CltChCmd_SigCLib;
	CheckSum 	: CltChCmd__CheckSum;
	StrTaskName 	: CltChCmd_String;
	co_Task 	: CltChCmd__TaskObjectControl;
	StrSemaName01 	: CltChCmd_String;
	StrSemaName02 	: CltChCmd_String;
  //Variables:
		pActConn 	: ^_CONNECTION;			//! <Variable Comment="includes all Informations to the act Connection" Name="pActConn"/>
		FSMClient 	: _FSM_CLT_STATE;			//! <Variable Comment="SSW for Connection" Name="FSMClient"/>
		udSendError 	: UDINT;			//! <Variable Comment="Counter if sending Data failed" Name="udSendError"/>
		AP_SemaHandle1 	: MT_SEMAHANDLE;			//! <Variable Comment="Handle of the mutex semaphore" Name="AP_SemaHandle1"/>
		pConnectionBuffer 	: ^_CONNECTION;			//! <Variable Comment="Buffer for the informations of all conenctions" Name="pConnectionBuffer"/>
		ActConn 	: DINT;			//! <Variable Comment="Value of actual connected servers" Name="ActConn"/>
		lsl_tcp_user 	: ^LSL_TCP_USER;
		MainSockOpt 	: _SocketOptions;
		usInit 	: USINT;
		bdStatus : BDINT
		[
		  1 SalamanderOS,
		  5 CIL_tcp_user,
		  6 CIL_ssl_user,
		  7 CIL_debug,
		  9 InhibNextConn,
		  13 LSLOBJ_CRC32,
		  14 AP_TaskPeriod,
		  15 CyclicTask,
		  16 AsyncTask,
		  17 Sema01,
		  18 Sema02,
		  25 ErrAsyncTask,
		  26 ErrSema01,
		  27 ErrSema02,
		  28 ErrMem,
		];

		lsl_ssl_user 	: ^LSL_SSL_USER;
		pCIL_DEBUG 	: ^OS_SALAMANDERDEBUG;
		AP_TaskTime 	: UDINT;
		AP_TaskHandle 	: MT_TASKHANDLE;
		MaxConn 	: DINT;
		LastError 	: DINT;
		AP_SemaSockOpt 	: MT_SEMAHANDLE;
		AP_TaskPriority 	: UDINT;			//! <Variable Comment="task priority of async task (in case of using object in async task)" Name="AP_TaskPriority"/>
		KeepAlivePara 	: _KeepAlivePara;
		CloseSocketType 	: UDINT;
  //Functions:
				//! <Function Comment="-) initialize TCP USER pointer to use OS TCP FUNCTIONS&#13;&#10;-) read port number&#13;&#10;-) Allocate Memory for Buffers" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Handles the Connection and Data receiving and sending" Name="CyclicCall"/>
	FUNCTION VIRTUAL GLOBAL CyclicCall;
				//! <Function Comment="Call this Function to add a Object for sending/receiving Data to a TCP/IP Server" Name="AddConnection"/>
	FUNCTION VIRTUAL GLOBAL AddConnection
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnection.pIPAddress"/>
			pCallbackThis 	: ^void;			//! <Variable Comment="This Pointer to Object which should be called" Name="AddConnection.pCallbackThis"/>
			pCallbackMeth 	: ^void;			//! <Variable Comment="Pointer to Method which should be called" Name="AddConnection.pCallbackMeth"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnection.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;			//! <Variable Comment="Save this Handle to call the &quot;IsConnected&quot; and &quot;SendData&quot; Function&#13;&#10;&#13;&#10;0...Error&#13;&#10;&gt;0...OK" Name="AddConnection.dHandle"/>
		END_VAR;
				//! <Function Comment="this function writes data into the TX buffer&#13;&#10;&#13;&#10;the first 4 Bytes are always the size of the following Data" Name="RingbufferWrite"/>
	FUNCTION RingbufferWrite
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="this function reads data from the TX buffer" Name="RingbufferRead"/>
	FUNCTION RingbufferRead
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="Delete one Entry in SendBuffer" Name="FLUSHRingbuffer"/>
	FUNCTION VIRTUAL GLOBAL FLUSHRingbuffer
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle what you get after calling &quot;AddConnection&quot;" Name="FLUSHRingbuffer.dHandle"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Function to send data over TCP/IP&#13;&#10;" Name="SendData"/>
	FUNCTION VIRTUAL GLOBAL SendData
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to Data" Name="SendData.pData"/>
			udSize 	: UDINT;			//! <Variable Comment="Size of Data" Name="SendData.udSize"/>
			dHandle 	: DINT;			//! <Variable Comment="Handle what you get after calling &quot;AddConnection&quot;" Name="SendData.dHandle"/>
			bDirect 	: BOOL;			//! <Variable Comment="0 ... Write it to Send Buffer and send it in next Cyclus&#13;&#10;1 ... Send it imidiatly" Name="SendData.bDirect"/>
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;			//! <Variable Comment="0 ... TCP_CLT_SEND_OK         &#13;&#10;-1... TCP_CLT_INVALID_HANDLE  &#13;&#10;-2... TCP_CLT_NOT_CONNECTED   &#13;&#10;-3... TCP_CLT_SEND_FAILED     &#13;&#10;-4... TCP_CLT_SEND_BUFFER_FULL&#13;&#10;-5... TCP_CLT_DATA_TO_BIG     &#13;&#10;" Name="SendData.dRetcode"/>
		END_VAR;
	
	FUNCTION Callback
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
				//! <Function Comment="initialize connection structure" Name="INITConnection"/>
	FUNCTION INITConnection
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
		END_VAR;
				//! <Function Comment="Call this Function to check if Connection is OK and the Handle will be saved" Name="IsConnected"/>
	FUNCTION VIRTUAL GLOBAL IsConnected
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle from &quot;AddConnection&quot;" Name="IsConnected.dHandle"/>
		END_VAR
		VAR_OUTPUT
			bRetcode 	: BOOL;			//! <Variable Comment="1 ... connected&#13;&#10;0 ... not connected" Name="IsConnected.bRetcode"/>
		END_VAR;
				//! <Function Comment="Delet (shutdown) one Connection" Name="DelConnection"/>
	FUNCTION VIRTUAL GLOBAL DelConnection
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="Handle from &quot;AddConnection&quot;" Name="DelConnection.dHandle"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="checks the Handle for validity" Name="CheckHandleValid"/>
	FUNCTION CheckHandleValid
		VAR_INPUT
			dHandle 	: DINT;
		END_VAR
		VAR_OUTPUT
			bRetcode 	: BOOL;
		END_VAR;
				//! <Function Comment="send Data via OS-Function" Name="SendTCP"/>
	FUNCTION SendTCP
		VAR_INPUT
			pConnection 	: ^_CONNECTION;
			pData 	: ^CHAR;
			udSize 	: UDINT;
			udTimeout 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dRetcode 	: DINT;
		END_VAR;
				//! <Function Comment="Method to set main parameters. Main parameters will be used for every new connection." Name="SetMainParameter"/>
	FUNCTION VIRTUAL GLOBAL SetMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket options&#13;&#10;1 ... task priority of async task (in case of using object in async task)" Name="SetMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... activate/deactivate delayed acknowledge packet&#13;&#10;&#13;&#10;Cmd = 1 (set task priority of async task)&#13;&#10;-) SubCmd = 0: task priority of async task" Name="SetMainParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) 1 ... Activate option&#13;&#10;-) 2 ... Deactivate option&#13;&#10;&#13;&#10;Cmd = 1 (task priority of async task)&#13;&#10;-) task priority 1-14" Name="SetMainParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-12 ... error set task priority - task already created&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="SetMainParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="Sets the socket options of the main socket" Name="SetSocketOptions"/>
	FUNCTION SetSocketOptions
		VAR_INPUT
			dHandle 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method to set parameters of a single connection" Name="SetConnParameter"/>
	FUNCTION VIRTUAL GLOBAL SetConnParameter
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="connection handle" Name="SetConnParameter.dHandle"/>
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket options" Name="SetConnParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... activate/deactivate nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... activate/deactivate keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... activate/deactivate delayed acknowledge packet" Name="SetConnParameter.SubCmd"/>
			ParaValue 	: DINT;			//! <Variable Comment="1.. Activate option&#13;&#10;2.. Deactivate option" Name="SetConnParameter.ParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1.. Invalid Handle&#13;&#10;-10.. Invalid CMD&#13;&#10;-11.. Invalid SubCMD" Name="SetConnParameter.Retcode"/>
		END_VAR;
	
	FUNCTION Read_LSLOBJ_CRC32
		VAR_INPUT
			pCRC32 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION Read_AP_TaskPeriod
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION GetMultiTaskErrorCode
		VAR_INPUT
			pErrTxt 	: ^CHAR;
		END_VAR;
	
	FUNCTION AP_TaskCreate
		VAR_INPUT
			pTaskName 	: ^CHAR;
			pCallback 	: ^void;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION __CDECL AP_TaskCallback
		VAR_INPUT
			Param0 	: ^void;
		END_VAR;
	
	FUNCTION AP_TaskDelay
		VAR_INPUT
			udTaskDelay 	: UDINT;
		END_VAR;
	
	FUNCTION AP_SemaCreate
		VAR_INPUT
			pSemaName 	: ^CHAR;
			Index 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION RingbufferReadEntry
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			pSize 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION RingbufferWriteEntry
		VAR_INPUT
			pBuffer 	: ^_TX_RINGBUFFER;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_SemaWait
		VAR_INPUT
			SemaHandle 	: MT_SEMAHANDLE;
		END_VAR;
	
	FUNCTION AP_SemaSignal
		VAR_INPUT
			SemaHandle 	: MT_SEMAHANDLE;
		END_VAR;
	
	FUNCTION DelConnIntern
		VAR_INPUT
			pDelConn 	: ^_CONNECTION;
		END_VAR;
	
	FUNCTION AddConnIntern
		VAR_INPUT
			pIPAddress 	: ^CHAR;
			pCACertPEMFilename 	: ^CHAR;
			pClientCertChainPEMFilename 	: ^CHAR;
			pClientCertKeyPEMFilename 	: ^CHAR;
			pKeyDecryptPwd 	: ^CHAR;
			pCallbackThis 	: ^void;
			pCallbackMeth 	: ^void;
			udTimeout 	: UDINT;
			ConnSSL 	: BOOL;
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;
		END_VAR;
	
	FUNCTION CheckParaConnSSL
		VAR_INPUT
			pCACertPEMFilename 	: ^CHAR;
			pClientCertChainPEMFilename 	: ^CHAR;
			pClientCertKeyPEMFilename 	: ^CHAR;
			pKeyDecryptPwd 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION FindFirstConn
		VAR_OUTPUT
			pFirstConn 	: ^_CONNECTION;
		END_VAR;
	
	FUNCTION CheckParaConnTCP
		VAR_INPUT
			pIPAddress 	: ^CHAR;
			pCallbackThis 	: ^void;
			pCallbackMeth 	: ^void;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="Read error codes if the result of a global function call was negative&#13;&#10;and the global function returns no specified error code.&#13;&#10;-) AddConnection()" Name="GetLastError"/>
	FUNCTION GLOBAL GetLastError
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="last error code" Name="GetLastError.Retcode"/>
		END_VAR;
				//! <Function Comment="Method to install a callback method for a single connection to get connection error states.&#13;&#10;-) TCP error (callback: ErrorGroup = 0, ErrorCode = TCP error status)&#13;&#10;-) error code definition in lsl_st_tcp_user.h&#13;&#10;&#13;&#10;-)  internal error (callback: ErrorGroup = 1, ErrorCode = internal error status)&#13;&#10;-) -1: receive timeout (in case of timeout is set)&#13;&#10;&#13;&#10;example for callback method definition:&#13;&#10;FUNCTION MyErrorCallback::ErrCallback&#13;&#10;VAR_INPUT&#13;&#10;  FSM_TCP  : _FSM_TCP_USER;&#13;&#10;  ErrGroup  : DINT;&#13;&#10;  ErrCode  : DINT;&#13;&#10;END_VAR&#13;&#10;&#13;&#10;END_FUNCTION&#13;&#10;" Name="InstallConnErrCallback"/>
	FUNCTION GLOBAL InstallConnErrCallback
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="connection handle" Name="InstallConnErrCallback.dHandle"/>
			pCallbackThis 	: ^void;			//! <Variable Comment="pointer to callback method object" Name="InstallConnErrCallback.pCallbackThis"/>
			pCallbackMeth 	: ^void;			//! <Variable Comment="pointer to callback method" Name="InstallConnErrCallback.pCallbackMeth"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="method result&#13;&#10;0 ... install info callback successful&#13;&#10;-1 ... invalid connection handle&#13;&#10;-21 ... invalid pointer (pCallbackThis or pCallbackMeth)" Name="InstallConnErrCallback.Retcode"/>
		END_VAR;
	
	FUNCTION ErrCallback
		VAR_INPUT
			FSM_TCP 	: _FSM_TCP_USER;
			ErrGroup 	: DINT;
			ErrCode 	: DINT;
		END_VAR;
	
	FUNCTION ConnErrCallback
		VAR_INPUT
			pConn 	: ^_CONNECTION;
			ErrGroup 	: DINT;
			ErrCode 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="method to read main parameters" Name="ReadMainParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadMainParameter
		VAR_INPUT
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket options&#13;&#10;1 ... task priority of async task (in case of using object in async task)" Name="ReadMainParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... status option nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... status option keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... status option delayed acknowledge packet&#13;&#10;&#13;&#10;Cmd = 1 (set task priority of async task)&#13;&#10;-) SubCmd = 0: task priority of async task" Name="ReadMainParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadMainParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0 ... success&#13;&#10;-10 ... invalid CMD&#13;&#10;-11 ... invalid SubCMD&#13;&#10;-90 ... object not initialized (initialization in first Init() call)" Name="ReadMainParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="method to set parameters of a single connection" Name="ReadConnParameter"/>
	FUNCTION VIRTUAL GLOBAL ReadConnParameter
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="connection handle" Name="ReadConnParameter.dHandle"/>
			Cmd 	: DINT;			//! <Variable Comment="0 ... socket options" Name="ReadConnParameter.Cmd"/>
			SubCmd 	: DINT;			//! <Variable Comment="Cmd = 0 (socket option)&#13;&#10;-) SubCmd = 0: TCPCLT_SOCKOPT_NAGLE... status option nagle algorithm&#13;&#10;-) SubCmd = 1: TCPCLT_SOCKOPT_KEEPALIVE... status option keepalive message&#13;&#10;-) SubCmd = 2: TCPCLT_SOCKOPT_DELAYEDACK... status option delayed acknowledge packet" Name="ReadConnParameter.SubCmd"/>
			pParaValue 	: ^DINT;			//! <Variable Comment="pointer to target parameter value" Name="ReadConnParameter.pParaValue"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="0.. success&#13;&#10;-1.. Invalid Handle&#13;&#10;-10.. Invalid CMD&#13;&#10;-11.. Invalid SubCMD" Name="ReadConnParameter.Retcode"/>
		END_VAR;
				//! <Function Comment="Method to install a callback method for a single connection to get connection informations.&#13;&#10;-) TCP connected (callback: InfoPara1 = 1)&#13;&#10;-) TCP disconnected (callback InfoPara1 = 0)&#13;&#10;-) connection is deleted (callback InfoPara1 = 2)&#13;&#10;&#13;&#10;example for callback method definition:&#13;&#10;FUNCTION MyInfoCallback::InfoCallback&#13;&#10;VAR_INPUT&#13;&#10;  FSM_TCP  : _FSM_TCP_USER;&#13;&#10;  InfoPara1  : DINT;&#13;&#10;  InfoPara2  : DINT;&#13;&#10;END_VAR&#13;&#10;&#13;&#10;END_FUNCTION&#13;&#10;" Name="InstallConnInfoCallback"/>
	FUNCTION GLOBAL InstallConnInfoCallback
		VAR_INPUT
			dHandle 	: DINT;			//! <Variable Comment="connection handle" Name="InstallConnInfoCallback.dHandle"/>
			pCallbackThis 	: ^void;			//! <Variable Comment="pointer to callback method object" Name="InstallConnInfoCallback.pCallbackThis"/>
			pCallbackMeth 	: ^void;			//! <Variable Comment="pointer to callback method" Name="InstallConnInfoCallback.pCallbackMeth"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="method result&#13;&#10;0 ... install info callback successful&#13;&#10;-1 ... invalid connection handle&#13;&#10;-21 ... invalid pointer (pCallbackThis or pCallbackMeth)" Name="InstallConnInfoCallback.Retcode"/>
		END_VAR;
	
	FUNCTION InfoCallback
		VAR_INPUT
			FSM_TCP 	: _FSM_TCP_USER;
			InfoPara1 	: DINT;
			InfoPara2 	: DINT;
		END_VAR;
	
	FUNCTION ConnInfoCallback
		VAR_INPUT
			pConn 	: ^_CONNECTION;
			InfoPara1 	: DINT;
			InfoPara2 	: DINT;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
	
	FUNCTION AP_NReadAvailable
		VAR_INPUT
			pConn 	: ^_CONNECTION;
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;
		END_VAR;
				//! <Function Comment="create SSL/TLS connection to a server" Name="AddConnectionSSL"/>
	FUNCTION VIRTUAL GLOBAL AddConnectionSSL
		VAR_INPUT
			pIPAddress 	: ^CHAR;			//! <Variable Comment="Pointer to IP-Address&#13;&#10;Needs to be a dotted string!&#13;&#10;&#13;&#10;e.g. &quot;192.168.2.1&quot;" Name="AddConnectionSSL.pIPAddress"/>
			pCACertPEMFilename 	: ^CHAR;
			pClientCertChainPEMFilename 	: ^CHAR;
			pClientCertKeyPEMFilename 	: ^CHAR;
			pKeyDecryptPwd 	: ^CHAR;
			pCallbackThis 	: ^void;			//! <Variable Comment="This Pointer to Object which should be called" Name="AddConnectionSSL.pCallbackThis"/>
			pCallbackMeth 	: ^void;			//! <Variable Comment="Pointer to Method which should be called" Name="AddConnectionSSL.pCallbackMeth"/>
			udTimeout 	: UDINT;			//! <Variable Comment="in [ms]&#13;&#10;Timeout to close Connection when no Data is received or sended&#13;&#10;0 ... No Timeout activated (connection will not be closed)" Name="AddConnectionSSL.udTimeout"/>
		END_VAR
		VAR_OUTPUT
			dHandle 	: DINT;			//! <Variable Comment="Save this Handle to call the &quot;IsConnected&quot; and &quot;SendData&quot; Function&#13;&#10;&#13;&#10;0...Error&#13;&#10;&gt;0...OK" Name="AddConnectionSSL.dHandle"/>
		END_VAR;
				//! <Function Comment="method to read client settings" Name="GetSetting"/>
	FUNCTION VIRTUAL GLOBAL GetSetting
		VAR_INPUT
			Index 	: DINT;			//! <Variable Comment="setting index&#13;&#10;0 (TCPCLT_GET_SETTING_PORT) ... port setting&#13;&#10;1 (TCPCLT_GET_SETTING_BUFSIZE) ... buffer size of send buffer&#13;&#10;2 (TCPCLT_GET_SETTING_MAXCONN) ... max connection&#13;&#10;3 (TCPCLT_GET_SETTING_CONFIG) ... config bitfield" Name="GetSetting.Index"/>
			pSetting 	: ^DINT;			//! <Variable Comment="pointer to destination variable" Name="GetSetting.pSetting"/>
		END_VAR
		VAR_OUTPUT
			Retcode 	: DINT;			//! <Variable Comment="result of method&#13;&#10;0 ... no error&#13;&#10;-1 ... invalid index" Name="GetSetting.Retcode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _CheckSum
#pragma using String
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd _TaskObjectControl
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _TCPIP_CLIENT::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__TCPIP_CLIENT
1$UINT, 17$UINT, (SIZEOF(::_TCPIP_CLIENT))$UINT, 
4$UINT, 12$UINT, 0$UINT, 
TO_UDINT(2629403047), "_TCPIP_CLIENT", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_TCPIP_CLIENT.Control.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3533623889), "Control", 
(::_TCPIP_CLIENT.TaskName.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3136881463), "TaskName", 
(::_TCPIP_CLIENT.SemaName01.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3023984995), "SemaName01", 
(::_TCPIP_CLIENT.SemaName02.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(758581465), "SemaName02", 
//Clients:
(::_TCPIP_CLIENT.cPort.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2368846560), "cPort", 
(::_TCPIP_CLIENT.cSizeOfTXBuffer.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1870367421), "cSizeOfTXBuffer", 
(::_TCPIP_CLIENT.cMaxConnections.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4178062980), "cMaxConnections", 
(::_TCPIP_CLIENT.cConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(2101344707), "cConfig", 
(::_TCPIP_CLIENT.co_StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3072335391), "co_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_TCPIP_CLIENT.co_MultiTask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(123997224), "co_MultiTask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::_TCPIP_CLIENT.co_SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2195423801), "co_SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::_TCPIP_CLIENT.CheckSum.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(408699862), "CheckSum", TO_UDINT(916194998), "_CheckSum", 1$UINT, 0$UINT, 
(::_TCPIP_CLIENT.StrTaskName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3109787989), "StrTaskName", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_TCPIP_CLIENT.co_Task.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3916282292), "co_Task", TO_UDINT(1584830088), "_TaskObjectControl", 1$UINT, 1$UINT, 
(::_TCPIP_CLIENT.StrSemaName01.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4079954366), "StrSemaName01", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_TCPIP_CLIENT.StrSemaName02.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1780905988), "StrSemaName02", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
END_FUNCTION


#define USER_CNT__TCPIP_CLIENT 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__TCPIP_CLIENT] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _TCPIP_CLIENT::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__TCPIP_CLIENT, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #CyclicCall();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #AddConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #FLUSHRingbuffer();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #SendData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #IsConnected();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #DelConnection();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #SetMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #SetConnParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #ReadMainParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReadConnParameter();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #AddConnectionSSL();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #GetSetting();

#pragma warning (default : 74)
	Control.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Control.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::Init
VAR
	pConn                 : ^_CONNECTION;
  i                     : UDINT;
  udStrLen              : UDINT;
  dRet                  : DINT;
  szCRC32               : ARRAY [0..15] OF CHAR;
  szTaskName            : ARRAY [0..63] OF CHAR;
  szErrCode             : ARRAY [0..31] OF CHAR;
  szSemaName            : ARRAY [0..63] OF CHAR;
END_VAR

  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  // - F I R S T   I N I T   R U N   ( M A I N   I N I T )
  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  if (usInit = 0) then

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - SET DEFAULT SETTINGS
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    MainSockOpt.Nagle      := true;
    MainSockOpt.KeepAlive  := false;
    MainSockOpt.DelayedAck := true;

    AP_TaskPriority         := AP_TASK_PRIORITY_DEFAULT;

    KeepAlivePara.keepIDLE  := KEEPALIVE_INTERVAL_DEFAULT;
    KeepAlivePara.keepINTVL := KEEPALIVE_RETRYTIME_DEFAULT;
    KeepAlivePara.keepCNT   := KEEPALIVE_RETRYCNT_DEFUALT;

    CloseSocketType         := CLOSE_SOCKET_TYPE_DEFAULT;

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ CONFIGURATION PARAMETER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    cPort           := cPort.Read();
    cConfig         := cConfig.Read();
    cMaxConnections := cMaxConnections.Read();
    cSizeOfTXBuffer := cSizeOfTXBuffer.Read();


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - CHECK GENERAL PARAMETER CONFIGURATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if cMaxConnections <= 0 then
      cMaxConnections := 16;
    elsif cMaxConnections > 16 then
      cMaxConnections := 16;
    end_if;
    MaxConn := cMaxConnections;

    if (cSizeOfTXBuffer = 0) then
      cSizeOfTXBuffer := 1024;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ OS INFORMATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if (_RtOSVersion >= OS_VERSION_MIN_SALAMANDER) then
      bdStatus.SalamanderOS := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ OS CIL INTERFACE INFORMATION
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    if OS_CILGET("TCP_USER", #lsl_tcp_user) then 
      lsl_tcp_user := NIL;
    else
      bdStatus.CIL_tcp_user := true;
    end_if;

    if OS_CILGET("SSL_USER", #lsl_ssl_user) then 
      lsl_ssl_user := NIL;
    else
      bdStatus.CIL_ssl_user := true;
    end_if;

    if OS_CILGET("SALAMANDERDEBUG", #pCIL_DEBUG) then
      pCIL_DEBUG := NIL;
    else
      bdStatus.CIL_debug := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - ALLOCATE MEMORY FOR CONNECTION STRUCTURE
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    pConnectionBuffer$^void := co_StdLib.Malloc(size:=(sizeof(_CONNECTION) * MaxConn$UDINT));
    if (pConnectionBuffer = NIL) then
      bdStatus.ErrMem := true;
    end_if;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - ALLOCATE MEMORY FOR SEND BUFFER
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    for i := 0 to (MaxConn$USINT-1) do
      pConn := pConnectionBuffer + (i * sizeof(_CONNECTION));

      pConn^.RingbufferForSending.pMem$^void  := co_StdLib.Malloc(size := cSizeOfTXBuffer);        
      if (pConn^.RingbufferForSending.pMem = NIL) then
        bdStatus.ErrMem := true;
        exit;
      else
        //###################################################################################
        //### initialize send buffer (RINGBUFFER)
        //###################################################################################
        pConn^.RingbufferForSending.udSize := to_UDINT(cSizeOfTXBuffer);
        pConn^.RingbufferForSending.udUsed := 0;
        pConn^.RingbufferForSending.pRead  := pConn^.RingbufferForSending.pMem;
        pConn^.RingbufferForSending.pWrite := pConn^.RingbufferForSending.pMem;
        pConn^.pSendReceiveBuffer$^void := co_StdLib.Malloc(size:=cSizeOfTXBuffer);
        if (pConn^.pSendReceiveBuffer = NIL) then
          bdStatus.ErrMem := true;
          exit;
        end_if;
      end_if;

      //##################################################################################
      //### initialize connection structure
      //##################################################################################
      INITConnection(pConn);

    end_for;

  end_if;

  usInit += 1;




  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  // - F I R S T S C A N
  // -------------------------------------------------------------------------------------------------------
  // -------------------------------------------------------------------------------------------------------
  if (_firstscan) then 

    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - READ THE LASAL OBJECT CRC32
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    dRet := Read_LSLOBJ_CRC32(#szCRC32[0]);
    case dRet of
      (*==================================================================*)
      TCP_CLT_NO_ERROR: // - NO ERROR
      (*==================================================================*)
        bdStatus.LSLOBJ_CRC32 := true;
      (*==================================================================*)
      else // - ERROR WHILE READING THE LASAL OBJECT CRC32 (USE THIS PTR)
      (*==================================================================*)
        co_SigCLib.IToA(this$DINT, #szCRC32[0], 0x10);
    end_case;


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - MUTEX CONNECTION INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    co_SigCLib.StrCpy(#szSemaName[0], "USR_SEMA_");
    co_SigCLib.StrCat(#szSemaName[0], #szCRC32[0]);
    co_SigCLib.StrCat(#szSemaName[0], "_01");
    dRet := AP_SemaCreate(#szSemaName[4], 0);
    if (dRet = TCP_CLT_NO_ERROR) then
      bdStatus.Sema01 := true;
    else
      bdStatus.ErrSema01 := true;
      GetMultiTaskErrorCode(#szErrCode[0]);
      co_SigCLib.StrCpy(#szTaskName[0], "SEMA ERR: CREATE SEMA (");
      co_SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
      co_SigCLib.StrCat(#szTaskName[0], ")");
    end_if;

    udStrLen := co_SigCLib.StrLen(#szSemaName[0]);
    StrSemaName01.WriteDataOff(udStrLen, 0, #szSemaName[0]);


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - MUTEX SOCKET OPTION INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    co_SigCLib.StrCpy(#szSemaName[0], "USR_SEMA_");
    co_SigCLib.StrCat(#szSemaName[0], #szCRC32[0]);
    co_SigCLib.StrCat(#szSemaName[0], "_02");
    dRet := AP_SemaCreate(#szSemaName[4], 1);
    if (dRet = TCP_CLT_NO_ERROR) then
      bdStatus.Sema02 := true;
    else
      bdStatus.ErrSema02 := true;
      GetMultiTaskErrorCode(#szErrCode[0]);
      co_SigCLib.StrCpy(#szTaskName[0], "SEMA ERR: CREATE SEMA (");
      co_SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
      co_SigCLib.StrCat(#szTaskName[0], ")");
    end_if;

    udStrLen := co_SigCLib.StrLen(#szSemaName[0]);
    StrSemaName02.WriteDataOff(udStrLen, 0, #szSemaName[0]);


    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    // - TASK INIT
    // -------------------------------------------------------------------------------------
    // -------------------------------------------------------------------------------------
    dRet := Read_AP_TaskPeriod();
    if (dRet = TCP_CLT_NO_ERROR) then
      bdStatus.AP_TaskPeriod := true;
      if (cConfig AND 0x1) then
        // - CYCLIC CALL IN PARALLEL TASK
        co_SigCLib.StrCpy(#szTaskName[0], "USR_TASK_");
        co_SigCLib.StrCat(#szTaskName[0], #szCRC32[0]);
        dRet := AP_TaskCreate(#szTaskName[4], #AP_TaskCallback());
        if (dRet = TCP_CLT_NO_ERROR) then
          bdStatus.AsyncTask := true;
        else
          bdStatus.ErrAsyncTask := true;
          GetMultiTaskErrorCode(#szErrCode[0]);
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: CREATE TASK (");
          co_SigCLib.StrCat(#szTaskName[0], #szErrCode[0]);
          co_SigCLib.StrCat(#szTaskName[0], ")");
        end_if;
      else
        // - CYCLIC CALL IN CYCLIC TASK
        bdStatus.CyclicTask := true;
        co_SigCLib.StrCpy(#szTaskName[0], "CyclicTask");
      end_if;
    else

      case dRet of
        (*==================================================================*)
        TCP_CLT_ERR_TASK_TIME_NO_APP:
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (NO APPLICATION)");
        (*==================================================================*)
        TCP_CLT_ERR_TASK_TIME_WRONG_TASK_TYPE:
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (WRONG TASK TYPE)");
        (*==================================================================*)
        TCP_CLT_ERR_TASK_TIME_OBJ_NOT_FOUND:
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "task deactivated");
        (*==================================================================*)
        else
        (*==================================================================*)
          co_SigCLib.StrCpy(#szTaskName[0], "TASK ERR: LSLOBJ (UNKNOWN ERROR)");
      end_case;

    end_if;

    udStrLen := co_SigCLib.StrLen(#szTaskName[0]);
    StrTaskName.WriteDataOff(udStrLen, 0, #szTaskName[0]);

  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::INITConnection
VAR_INPUT
  pConnection 	: ^_CONNECTION;
END_VAR

  pConnection^.bInUse     := false;
  pConnection^.bConnected := false;
  pConnection^.dSocket    := 0;
  pConnection^.FSM_TCP    := _STATE_IDLE;

  pConnection^.pCallbackMeth := NIL;
  pConnection^.pCallbackThis := NIL;

  pConnection^.udTimeout   := 0;
  pConnection^.udTimeStamp := 0;

  pConnection^.RingbufferForSending.udUsed := 0;
  pConnection^.RingbufferForSending.pRead  := pConnection^.RingbufferForSending.pMem;
  pConnection^.RingbufferForSending.pWrite := pConnection^.RingbufferForSending.pMem;
  pConnection^.BufferHeader.DataSize       := 0;
  pConnection^.pSendReceiveBufferHelp      := pConnection^.pSendReceiveBuffer;

  pConnection^.ConnSockOpt := MainSockOpt;
  pConnection^.pNextConn   := NIL;

  pConnection^.bdSettings.DelConn        := false;
  pConnection^.bdSettings.ConnSSL        := false;
  pConnection^.bdSettings.SockOptChanged := false;

  co_SigCLib.MemSet(#pConnection^.szIPAddress[0], 0x00, 0x10);
  co_SigCLib.MemSet(#pConnection^.szCACertPEMFilename, 0x00, sizeof(_CONNECTION.szCACertPEMFilename));
  co_SigCLib.MemSet(#pConnection^.szClientCertChainPEMFilename, 0x00, sizeof(_CONNECTION.szClientCertChainPEMFilename));
  co_SigCLib.MemSet(#pConnection^.szClientCertKeyPEMFilename, 0x00, sizeof(_CONNECTION.szClientCertKeyPEMFilename));
  co_SigCLib.MemSet(#pConnection^.szKeyDecryptPwd, 0x00, sizeof(_CONNECTION.szKeyDecryptPwd));

  pConnection^.pErrCallbackThis  := NIL;
  pConnection^.pErrCallbackMeth  := NIL;
  pConnection^.pInfoCallbackThis := NIL;
  pConnection^.pInfoCallbackMeth := NIL;

  pConnection^.KeepAlivePara   := KeepAlivePara;
  pConnection^.CloseSocketType := CloseSocketType;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::AddConnection
VAR_INPUT
  pIPAddress 	    : ^CHAR;
  pCallbackThis 	: ^void;
  pCallbackMeth 	: ^void;
  udTimeout 	    : UDINT;
END_VAR
VAR_OUTPUT
  dHandle 	      : DINT;
END_VAR
VAR
	dRet            : DINT;
END_VAR

  dHandle := 0;

  if (usInit > 0) then
    if (bdStatus.CIL_tcp_user = true) then
      if (bdStatus.ErrMem = false) then
        dRet := CheckParaConnTCP(pIPAddress, pCallbackThis, pCallbackMeth);
        if (dRet = TCP_CLT_NO_ERROR) then

          dHandle := AddConnIntern(pIPAddress,
                                   NIL,
                                   NIL,
                                   NIL,
                                   NIL,
                                   pCallbackThis,
                                   pCallbackMeth,
                                   udTimeout,
                                   false);

        else
          LastError := dRet;
        end_if;
      else
        LastError := TCP_CLT_ERR_CONN_MEMORY;
      end_if;
    else
      LastError := TCP_CLT_ERR_NO_TCP_INTERFACE;
    end_if;
  else
    LastError := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::DelConnection
VAR_INPUT
  dHandle 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    if (CheckHandleValid(dHandle := dHandle) = true) then
      dHandle$^_CONNECTION^.bdSettings.DelConn := true;
    else
      Retcode   := TCP_CLT_INVALID_HANDLE;
    end_if;
  else
    Retcode   := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::CyclicCall
VAR
  dRet          : DINT;
  dBytes        : DINT;
  pTmpThis      : ^void;
END_VAR

  case FSMClient of

    //*******************************************************************************************************************************
    _STATE_INIT: //### initialization state
    //*******************************************************************************************************************************
      if (bdStatus.ErrAsyncTask = true) then
        Control := _STATE_ERROR_CREATING_TASK;
      elsif (bdStatus.ErrSema01 = true) | (bdStatus.ErrSema02 = true) then
        Control := _STATE_ERROR_CREATING_MUTEX;
      elsif (bdStatus.ErrMem = true) then
        Control := _STATE_ERROR_ALLOCATING_MEMORY;
      else
        if (lsl_tcp_user <> NIL) then
          if (ActConn) then
            pActConn := FindFirstConn();
            if (pActConn <> NIL) then
              FSMClient := _STATE_WORK;
            end_if;
          else
            pActConn := NIL;
          end_if;
        end_if;
      end_if;


    //*******************************************************************************************************************************
    _STATE_WORK: //### work state
    //*******************************************************************************************************************************

      //############################################################################################
      //##                                                                                        ##
      //##    this finite state machine is used for the main TCP/IP connection:                   ##
      //##                                                                                        ##
      //##    -> allocate sockets                                                                 ##
      //##    -> build a connection to a specified socket                                         ##
      //##    -> receive data from server                                                         ##
      //##    -> disable receives and sends on socket                                             ##
      //##    -> close socket                                                                     ##
      //##                                                                                        ##
      //############################################################################################

        case pActConn^.FSM_TCP of

          //****************************************************************************
          _STATE_IDLE: // idle state
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;
            else
              if (pActConn^.bConnected = false) then
                pActConn^.FSM_TCP := _STATE_MAIN_SOCK;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_MAIN_SOCK: // allocate socket
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;
            else
              if (pActConn^.bdSettings.ConnSSL = false) then
                pActConn^.dSocket := OS_TCP_USER_SOCKET();
              else
                pActConn^.dSocket := OS_SSL_USER_CREATE_CONN_STRUCT(#pActConn^.szCACertPEMFilename[0],
                                                                    #pActConn^.szClientCertChainPEMFilename[0],
                                                                    #pActConn^.szClientCertKeyPEMFilename[0],
                                                                    #pActConn^.szKeyDecryptPwd[0],
                                                                    nil);
              end_if;

              if (pActConn^.dSocket < 0) then
                ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, pActConn^.dSocket);
                pActConn^.FSM_TCP := _STATE_ERROR;
              else
                if (pActConn^.bdSettings.ConnSSL = false) then
                  pActConn^.FSM_TCP := _STATE_MAIN_SOCK_OPT;
                else
                  pActConn^.FSM_TCP := _STATE_CONNECT;
                end_if;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_MAIN_SOCK_OPT: // set socket options
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              dRet := SetSocketOptions((pActConn)$DINT);
              if (dRet = TCPCLT_ERROR_NO) then
                pActConn^.FSM_TCP := _STATE_CONNECT;
              else
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_CONNECT: // connect
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              if (_strlen(#pActConn^.szIPAddress[0])) & ((ops.tAbsolute - pActConn^.udTimeStamp) > pActConn^.udTimeout) then 

                if (pActConn^.bdSettings.ConnSSL = false) then
                  dRet := OS_TCP_USER_CONNECT(pActConn^.dSocket, 0, #pActConn^.szIPAddress[0], TO_UDINT(cPort), 0);
                else
                  dRet := OS_SSL_USER_CONNECT(pActConn^.dSocket, #pActConn^.szIPAddress[0], TO_UDINT(cPort), 0);
                end_if;

                pActConn^.udTimeStamp := 0;

                if (dRet < 0) then
                  if (dRet <> TCP_NOT_READY) then
                    ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dRet);
                    pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
                    pActConn^.udTimeStamp := ops.tAbsolute;
                  end_if;
                elsif (dRet = 0) then
                  pActConn^.FSM_TCP := _STATE_RECV;
                  pActConn^.bConnected := true;
                  ConnInfoCallback(pActConn, TCP_CLT_INFO_CONNECT, 0);
                end_if;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_CONN_SOCK_OPT: // set socket options
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              dRet := SetSocketOptions((pActConn)$DINT);
              if (dRet = TCPCLT_ERROR_NO) then
                pActConn^.FSM_TCP := _STATE_RECV;
              else
                pActConn^.FSM_TCP := _STATE_SHUTDOWN;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_RECV: // receive state
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            elsif (pActConn^.bdSettings.ConnSSL = false) & (pActConn^.bdSettings.SockOptChanged = true) then
              pActConn^.FSM_TCP := _STATE_CONN_SOCK_OPT;
            else
              dBytes := AP_NReadAvailable(pActConn);
              if (dBytes <= 0) then
                if (dBytes <> TCP_NOT_READY) then
                  ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dBytes);
                  pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                else
                  if (pActConn^.udTimeout) & (pActConn^.udTimeStamp) then
                    if ((ops.tAbsolute - pActConn^.udTimeStamp) > pActConn^.udTimeout) then
                      pActConn^.udTimeStamp := 0;
                      ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_AP, TCP_CLT_ERR_CODE_AP_TIMEOUT);
                      pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                    end_if;
                  end_if;
                end_if;
              else
                if (dBytes$UDINT > cSizeOfTXBuffer) then
                  dBytes$UDINT := cSizeOfTXBuffer;
                end_if;

                if (pActConn^.bdSettings.ConnSSL = false) then
                  dRet := OS_TCP_USER_RECV(pActConn^.dSocket, pActConn^.pSendReceiveBuffer, to_UDINT(dBytes), 0, 0);
                else
                  dRet := OS_SSL_USER_READ(pActConn^.dSocket, pActConn^.pSendReceiveBuffer, dBytes, 0);
                  if (dRet > 0) then
                    dBytes := dRet;
                  end_if;
                end_if;

                if (dRet = dBytes) then
                  pTmpThis := this;
                  this$^void := pActConn^.pCallbackThis;
                  #pragma warning(disable: 137);
                  pTmpThis^$_TCPIP_CLIENT.pActConn^.pCallbackMeth$Callback(#pTmpThis^$_TCPIP_CLIENT.pActConn^.pSendReceiveBuffer^, dBytes$UDINT);
                  #pragma warning(default: 137);
                  this$^void := pTmpThis;
                  pActConn^.udTimeStamp := 0;
                else
                  if (dRet <> TCP_NOT_READY) then
                    ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dRet);
                    pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                  end_if;
                end_if;
              end_if;

              if (pActConn^.FSM_TCP = _STATE_RECV) then
                if (pActConn^.RingbufferForSending.udUsed > sizeof(pActConn^.BufferHeader.DataSize)) then
                  pActConn^.FSM_TCP := _STATE_SEND;
                end_if;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_SEND: // send data
          //****************************************************************************
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;
            else
              if (pActConn^.BufferHeader.DataSize = 0) then
                dRet := RingbufferReadEntry(#pActConn^.RingbufferForSending, pActConn^.pSendReceiveBuffer, #pActConn^.BufferHeader.DataSize);
                pActConn^.pSendReceiveBufferHelp := pActConn^.pSendReceiveBuffer;
              end_if;
              if (pActConn^.BufferHeader.DataSize > 0) then
                if (pActConn^.bdSettings.ConnSSL = false) then
                  dRet := OS_TCP_USER_SEND(pActConn^.dSocket, pActConn^.pSendReceiveBufferHelp, pActConn^.BufferHeader.DataSize, 0, 0);
                else
                  dRet := OS_SSL_USER_WRITE(pActConn^.dSocket, pActConn^.pSendReceiveBufferHelp, (pActConn^.BufferHeader.DataSize)$DINT, 0);
                end_if;

                if dRet >= 0 then
                  pActConn^.BufferHeader.DataSize -= dRet$UDINT;
                  pActConn^.pSendReceiveBufferHelp += dRet;
                  pActConn^.udTimeStamp := ops.tAbsolute;
                else
                  if (dRet <> TCP_NOT_READY) then
                    ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_OS, dRet);
                    pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                  else 
                    if (pActConn^.udTimeout) & (pActConn^.udTimeStamp) then
                      if (ops.tAbsolute - pActConn^.udTimeStamp) >= pActConn^.udTimeout then
                        ConnErrCallback(pActConn, TCP_CLT_ERR_GROUP_AP, TCP_CLT_ERR_CODE_AP_TIMEOUT);
                        pActConn^.FSM_TCP := _STATE_SHUTDOWN;
                        pActConn^.udTimeStamp := 0;
                      end_if;
                    end_if;
                  end_if;
                end_if;

                if pActConn^.BufferHeader.DataSize <= 0 then
                  pActConn^.FSM_TCP := _STATE_RECV;
                  pActConn^.pSendReceiveBufferHelp := pActConn^.pSendReceiveBuffer;
                else
                  bdStatus.InhibNextConn := true;
                end_if;
              else
                pActConn^.FSM_TCP := _STATE_RECV;
              end_if;
            end_if;

          //****************************************************************************
          _STATE_SHUTDOWN: // disable receives and sends on socket
          //****************************************************************************
            if (pActConn^.bdSettings.ConnSSL = false) then
              OS_TCP_USER_SHUTDOWN(pActConn^.dSocket, 2);
            end_if;
            pActConn^.FSM_TCP := _STATE_CLOSE_MAIN_SOCK;

          //****************************************************************************
          _STATE_CLOSE_MAIN_SOCK: // close socket
          //****************************************************************************
            if (pActConn^.bdSettings.ConnSSL = false) then
              OS_TCP_USER_CLOSESOCKET(pActConn^.dSocket, pActConn^.CloseSocketType);
            else
              OS_SSL_USER_FREE_CONN(pActConn^.dSocket);
            end_if;
            pActConn^.dSocket := 0;
            pActConn^.bConnected := false;
            ConnInfoCallback(pActConn, TCP_CLT_INFO_DISCONNECT, 0);
            if (pActConn^.bdSettings.DelConn = true) then
              pActConn^.FSM_TCP := _STATE_DEL_CONNECTION;
            else
              pActConn^.FSM_TCP := _STATE_IDLE;
            end_if;

          //****************************************************************************
          _STATE_DEL_CONNECTION: // delete connection
          //****************************************************************************
            DelConnIntern(pActConn);

          //****************************************************************************
          _STATE_ERROR,
          _STATE_ERROR_ALLOCATING_MEMORY,
          _STATE_ERROR_CREATING_MUTEX,
          _STATE_ERROR_CREATING_TASK: 
          //****************************************************************************

          //****************************************************************************
          else // - INVALID STATE
          //****************************************************************************
            TRACE("Fatal Error");
            pActConn^.FSM_TCP := _STATE_ERROR;

        end_case;      

        if (ActConn = 0) then
          pActConn := NIL;
          Control   := _STATE_IDLE;
          FSMClient := _STATE_INIT;
        else
          if (bdStatus.InhibNextConn = false) then
            pActConn := pActConn^.pNextConn;
            Control  := pActConn^.FSM_TCP;
          end_if;
          bdStatus.InhibNextConn := false;
        end_if;

  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::SendData
VAR_INPUT
  pData 	        : ^void;
  udSize 	        : UDINT;
  dHandle 	      : DINT;
  bDirect 	      : BOOL;
END_VAR
VAR_OUTPUT
  dRetcode 	      : DINT;
END_VAR
VAR
  dRet            : DINT;
  pConn           : ^_CONNECTION;
END_VAR  

  dRetcode := TCP_CLT_SEND_FAILED;

  if (CheckHandleValid(dHandle) = true) then
    pConn := dHandle$^_CONNECTION;
    if (pConn^.bConnected = true) then
      if (bDirect = true) then
        if (udSize <= 1452) then
          dRet := SendTCP(pConn, pData$^CHAR, udSize, 0);
          if (dRet = to_DINT(udSize)) then
            dRetcode := TCP_CLT_SEND_OK;
          end_if;
        else
          dRetcode := TCP_CLT_DATA_TO_BIG_FOR_DIRECT_SENDING;
        end_if;
      else
        dRet := RingbufferWriteEntry(#pConn^.RingbufferForSending, pData, udSize);
        if (dRet = TCP_CLT_NO_ERROR) then
          dRetcode := TCP_CLT_SEND_OK;
        else
          dRetcode := dRet;
        end_if;
      end_if;
    else
      dRetcode := TCP_CLT_NOT_CONNECTED;
    end_if;
  else
    dRetcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::RingbufferReadEntry
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  pSize 	: ^UDINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	BufferHeader    : _BUFFER_HEADER;
  dRet            : DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;
  pSize^  := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pSize = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_POINTER;
  else
    if (pBuffer^.udUsed = 0) then
      Retcode := TCP_CLT_SEND_BUFFER_EMPTY;
    else
      AP_SemaWait(AP_SemaHandle1);
      dRet := RingbufferRead(pBuffer, #BufferHeader, sizeof(_BUFFER_HEADER));
      if (dRet = sizeof(_BUFFER_HEADER)) then
        dRet := RingbufferRead(pBuffer, pData, BufferHeader.DataSize);
        if (dRet = BufferHeader.DataSize$DINT) then
          pSize^ := BufferHeader.DataSize;
        else
          Retcode := TCP_CLT_ERR_SEND_BUFFER_FATAL_ERROR;
        end_if;
      else
        Retcode := TCP_CLT_ERR_SEND_BUFFER_FATAL_ERROR;
      end_if;
      AP_SemaSignal(AP_SemaHandle1);
    end_if;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::RingbufferRead
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  udSize 	: UDINT;
END_VAR
VAR_OUTPUT
  dRetcode 	: DINT;
END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  dRetcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pRead$UDINT;

  if (udSize > udBytes2End) then 

    //##########################################################################################
    //### we must read the data in 2 blocks (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytes2End); //### copy the first block
    pData += udBytes2End;
    pBuffer^.pRead := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udBytesTmp); //### copy the second block
    pBuffer^.pRead += udBytesTmp;

  else

    //##########################################################################################
    //### read data in one block
    //##########################################################################################
    _memcpy(ptr1 := pData, ptr2 := pBuffer^.pRead, cntr := udSize);
    pBuffer^.pRead += udSize;
  end_if;

  pBuffer^.udUsed -= udSize; // decrease the number of bytes in ringbuffer
  dRetcode := udSize$DINT;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::RingbufferWriteEntry
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  udSize 	: UDINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	BufferHeader  : _BUFFER_HEADER;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pBuffer = NIL) | (pData = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_POINTER;
  else
    AP_SemaWait(AP_SemaHandle1);
    if ((udSize + sizeof(_BUFFER_HEADER)) > (pBuffer^.udSize - pBuffer^.udUsed)) then
      Retcode := TCP_CLT_SEND_BUFFER_FULL;
    else
      BufferHeader.DataSize := udSize;
      RingbufferWrite(pBuffer, #BufferHeader, sizeof(_BUFFER_HEADER));
      RingbufferWrite(pBuffer, pData, udSize);
    end_if;
    AP_SemaSignal(AP_SemaHandle1);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::RingbufferWrite
VAR_INPUT
  pBuffer 	: ^_TX_RINGBUFFER;
  pData 	: ^void;
  udSize 	: UDINT;
END_VAR
VAR_OUTPUT
  dRetcode 	: DINT;
END_VAR
VAR
	udBytes2End   : UDINT;
  udBytesTmp    : UDINT;
END_VAR

  dRetcode := 0;

  if (pBuffer = NIL) | (pData = NIL) | (pBuffer^.pMem = NIL) then
    return; //### invalid pointer
  end_if;

  if ((udSize) > (pBuffer^.udSize - pBuffer^.udUsed)) then
    return; //### buffer full
  end_if;

  udBytes2End := (pBuffer^.pMem$UDINT + pBuffer^.udSize) - pBuffer^.pWrite$UDINT; // calculate number of bytes till the end of SENDbuffer

  if (udSize > udBytes2End) then
    
    //##########################################################################################
    //### we must write the data in 2 blocks  (|second|...........other data...........|first|)
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytes2End); // copy the first block
    pData += udBytes2End;
    pBuffer^.pWrite := pBuffer^.pMem$^USINT;
    udBytesTmp := udSize - udBytes2End;
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udBytesTmp); // copy the second block
    pBuffer^.pWrite += udBytesTmp;
  else
    
    //##########################################################################################
    //### store data in one block
    //##########################################################################################
    _memcpy(ptr1 := pBuffer^.pWrite, ptr2 := pData, cntr := udSize);
    pBuffer^.pWrite += udSize;
  end_if;
  
  pBuffer^.udUsed += udSize; // increase the number of bytes in ringbuffer
  dRetcode := udSize$DINT;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::FLUSHRingbuffer
VAR_INPUT
  dHandle 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	pBuffer   : ^_TX_RINGBUFFER;
END_VAR

  if (usInit > 0) then
    if (CheckHandleValid(dHandle := dHandle) = true) then
      AP_SemaWait(AP_SemaHandle1);
      pBuffer := #dHandle$^_CONNECTION^.RingbufferForSending;
      pBuffer^.pRead := pBuffer^.pMem;
      pBuffer^.pWrite := pBuffer^.pMem;
      pBuffer^.udUsed := 0;
      AP_SemaSignal(AP_SemaHandle1);
    else
      Retcode := TCP_CLT_INVALID_HANDLE;
    end_if;
  else
    Retcode := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::CyWork
VAR_INPUT
  EAX 	: UDINT;
END_VAR
VAR_OUTPUT
  state (EAX) 	: UDINT;
END_VAR

  if (bdStatus.CyclicTask = true) then
    CyclicCall();
  end_if;

	state := READY;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::IsConnected
VAR_INPUT
  dHandle 	: DINT;
END_VAR
VAR_OUTPUT
  bRetcode 	: BOOL;
END_VAR

  bRetcode := false;

  if (CheckHandleValid(dHandle := dHandle) = true) then
    bRetcode := dHandle$^_CONNECTION^.bConnected;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::CheckHandleValid
VAR_INPUT
  dHandle 	: DINT;
END_VAR
VAR_OUTPUT
  bRetcode 	: BOOL;
END_VAR
VAR
	i         : USINT;
  pConn     : ^_CONNECTION;
END_VAR

  bRetcode := false;

  if (dHandle <> 0) then
    AP_SemaWait(AP_SemaHandle1);
    for i := 0 to (MaxConn-1) do
      pConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
      if (pConn = dHandle$^_CONNECTION) then
        if (pConn^.bInUse = true) & (pConn^.bdSettings.DelConn = false) then
          bRetcode := true;
          exit;
        end_if;
      end_if;
    end_for;
    AP_SemaSignal(AP_SemaHandle1);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::SendTCP
VAR_INPUT
  pConnection 	: ^_CONNECTION;
  pData 	: ^CHAR;
  udSize 	: UDINT;
  udTimeout 	: UDINT;
END_VAR
VAR_OUTPUT
  dRetcode 	: DINT;
END_VAR

  dRetcode := OS_TCP_USER_SEND(pConnection^.dSocket,
                               pData,
                               udSize,
                               0, //### flags ... not used
                               udTimeout
                               );

  if (dRetcode = udSize$DINT) then
    pConnection^.udTimeStamp := ops.tAbsolute;
  else
    udSendError += 1;
    pConnection^.FSM_TCP := _STATE_SHUTDOWN;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::SetMainParameter
VAR_INPUT
  Cmd 	      : DINT;
  SubCmd 	    : DINT;
  ParaValue 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    case Cmd of
      (*================================================================*)
      TCPCLT_CMD_SETSOCKOPT:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_SOCKOPT_NAGLE:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.Nagle := false;
            else
              MainSockOpt.Nagle := true;
            end_if;
          (*==================================================*)
          TCPCLT_SOCKOPT_KEEPALIVE:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.KeepAlive := false;
            else
              MainSockOpt.KeepAlive := true;
            end_if; 
          (*==================================================*)
          TCPCLT_SOCKOPT_DELAYEDACK:
          (*==================================================*)
            if (ParaValue = 0) then
              MainSockOpt.DelayedAck := false;
            else
              MainSockOpt.DelayedAck := true;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPCLT_CMD_TASKPRIO:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_SUB_CMD_TASKPRIO:
          (*==================================================*)
            if (usInit < INIT_FIRSTSCAN) then
              AP_TaskPriority := ParaValue$UDINT;
            else
              Retcode := TCP_CLT_ERR_TASK_ALREADY_EXIST;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPCLT_CMD_KEEPALIVEPARA:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_KEEPALIVE_KEEPIDLE:
          (*==================================================*)
            KeepAlivePara.keepIDLE := ParaValue;
          (*==================================================*)
          TCPCLT_KEEPALIVE_KEEPINTVL:
          (*==================================================*)
            KeepAlivePara.keepINTVL := ParaValue;
          (*==================================================*)
          TCPCLT_KEEPALIVE_KEEPCNT:
          (*==================================================*)
            KeepAlivePara.keepCNT := ParaValue;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPCLT_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_CLOSESOCKETTYPE:
          (*==================================================*)
            CloseSocketType := ParaValue$UDINT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::SetSocketOptions
VAR_INPUT
  dHandle 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	OptionValue       : DINT;
  pConn             : ^_CONNECTION;
  dRet              : DINT;
  KeepAliveLasalOS  : _KeepAliveParaLasalOS;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (CheckHandleValid(dHandle) = true) then

    pConn := dHandle$^_CONNECTION;

    AP_SemaWait(AP_SemaSockOpt);

    // -----------------------------------------------------------
    // - SOCKET OPTION NAGLE
    // -----------------------------------------------------------
    if (pConn^.ConnSockOpt.Nagle = true) then
      OptionValue := 1;
    else
      OptionValue := 0;
    end_if;
    dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_NAGLE, (#OptionValue)$^CHAR, sizeof(DINT));
    if (dRet < 0) then
      Retcode := dRet;
      ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
    end_if;

    // -----------------------------------------------------------
    // - SOCKET OPTION KEEP ALIVE
    // -----------------------------------------------------------
    if (bdStatus.SalamanderOS = false) then
      // --------------------------------------------------------
      // - LASAL OS
      // --------------------------------------------------------
      if (pConn^.ConnSockOpt.KeepAlive = true) then
        KeepAliveLasalOS.interval := to_UINT(pConn^.KeepAlivePara.keepIDLE);
        KeepAliveLasalOS.retry    := to_UINT(pConn^.KeepAlivePara.keepINTVL);
        KeepAliveLasalOS.timeout  := to_UINT(pConn^.KeepAlivePara.keepCNT * pConn^.KeepAlivePara.keepINTVL);
      else
        KeepAliveLasalOS.interval := 0;
        KeepAliveLasalOS.retry    := 0;
        KeepAliveLasalOS.timeout  := 0;
      end_if;
      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, 8, (#KeepAliveLasalOS)$^CHAR, sizeof(_KeepAliveParaLasalOS));
      if (dRet < 0) then
        Retcode := dRet;
        ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
      end_if;
    else
      // --------------------------------------------------------
      // - SALAMANDER OS
      // --------------------------------------------------------
      if (pConn^.ConnSockOpt.KeepAlive = true) then
        OptionValue := 1;
      else
        OptionValue := 0;
      end_if;
      dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, 8, (#OptionValue)$^CHAR, sizeof(DINT));
      if (dRet < 0) then
        Retcode := dRet;
        ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
      end_if;

//      if (pConn^.ConnSockOpt.KeepAlive = true) then
//        OptionValue := KeepAlivePara.keepCNT;
//        dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPCNT, (#OptionValue)$^CHAR, sizeof(DINT));
//        if (dRet < 0) then
//          Retcode := dRet;
//          ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
//        end_if;
//        OptionValue := KeepAlivePara.keepIDLE;
//        dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPIDLE, (#OptionValue)$^CHAR, sizeof(DINT));
//        if (dRet < 0) then
//          Retcode := dRet;
//          ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
//        end_if;
//        OptionValue := KeepAlivePara.keepINTVL;
//        dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_TCP, TCP_KEEPINTVL, (#OptionValue)$^CHAR, sizeof(DINT));
//        if (dRet < 0) then
//          Retcode := dRet;
//          ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
//        end_if;
//      end_if;
    end_if;

    // -----------------------------------------------------------
    // - SOCKET OPTION DELAYED ACK
    // -----------------------------------------------------------
    if (pConn^.ConnSockOpt.DelayedAck = true) then
      OptionValue := 1;
    else
      OptionValue := 0;
    end_if;
    dRet := OS_TCP_USER_SETSOCKOPT(pConn^.dSocket, SOL_SOCKET, SO_DELAYED_ACK, (#OptionValue)$^CHAR, sizeof(DINT));
    if (dRet < 0) then
      Retcode := dRet;
      ConnErrCallback(pConn, TCP_CLT_ERR_GROUP_OS, dRet);
    end_if;

    pConn^.bdSettings.SockOptChanged := false;

    AP_SemaSignal(AP_SemaSockOpt);

  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::SetConnParameter
VAR_INPUT
  dHandle 	      : DINT;
  Cmd 	          : DINT;
  SubCmd 	        : DINT;
  ParaValue 	    : DINT;
END_VAR
VAR_OUTPUT
  Retcode 	      : DINT;
END_VAR
VAR
  pConn           : ^_CONNECTION;
END_VAR

  Retcode := TCPCLT_ERROR_NO;

  if (CheckHandleValid(dHandle) = true) then
    pConn := dHandle$^_CONNECTION;
    case Cmd of
      (*================================================================*)
      TCPCLT_CMD_SETSOCKOPT:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            TCPCLT_SOCKOPT_NAGLE:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.Nagle = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.Nagle := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.Nagle = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.Nagle := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            TCPCLT_SOCKOPT_KEEPALIVE:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.KeepAlive = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.KeepAlive := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.KeepAlive = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.KeepAlive := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            TCPCLT_SOCKOPT_DELAYEDACK:
            (*==================================================*)
              if (ParaValue = 0) then
                if (pConn^.ConnSockOpt.DelayedAck = true) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.DelayedAck := false;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              else
                if (pConn^.ConnSockOpt.DelayedAck = false) then
                  AP_SemaWait(AP_SemaSockOpt);
                  pConn^.ConnSockOpt.DelayedAck := true;
                  pConn^.bdSettings.SockOptChanged := true;
                  AP_SemaSignal(AP_SemaSockOpt);
                end_if;
              end_if;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      TCPCLT_CMD_KEEPALIVEPARA:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            TCPCLT_KEEPALIVE_KEEPIDLE:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepIDLE    := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            TCPCLT_KEEPALIVE_KEEPINTVL:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepINTVL   := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            TCPCLT_KEEPALIVE_KEEPCNT:
            (*==================================================*)
              AP_SemaWait(AP_SemaSockOpt);
              pConn^.KeepAlivePara.keepCNT     := ParaValue;
              pConn^.bdSettings.SockOptChanged := true;
              AP_SemaSignal(AP_SemaSockOpt);
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      TCPCLT_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            TCPCLT_CLOSESOCKETTYPE:
            (*==================================================*)
              pConn^.CloseSocketType := ParaValue$UDINT;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::Read_LSLOBJ_CRC32
VAR_INPUT
  pCRC32 	    : ^CHAR;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
	udStrLen    : UDINT;
  udCRC32     : UDINT;
  szObjName   : ARRAY [0..255] OF CHAR;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pCRC32 <> NIL) then
    pCRC32^ := 0x00;
    udStrLen := _GetObjName(this, #szObjName[0]);
    if (udStrLen > 0) then
      udCRC32 := CheckSum.CRC32(#szObjName[0], udStrLen, 0);
      co_SigCLib.IToA(udCRC32$DINT, pCRC32, 0x10);
    else
      Retcode := TCP_CLT_ERR_GET_LSLOBJ_NAME;
    end_if;
  else
    Retcode := TCP_CLT_ERR_INVALID_POINTER;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::Read_AP_TaskPeriod
VAR_OUTPUT
  Retcode 	    : DINT;
END_VAR
VAR
	dRet          : DINT;
  LSLOBJ_INFO   : LSLOBJ_INFO;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  dRet := co_Task.GetObjectInfo(this, OBJ_CT, #LSLOBJ_INFO);
  case dRet of
    (*=============================================================================*)
    0: // - GET OBJECT INFO OK
    (*=============================================================================*)
      if (bdStatus.SalamanderOS = true) then
        // --------------------------------------------------------
        // - SALAMANDER OS
        // --------------------------------------------------------
        if (LSLOBJ_INFO.orgperiod AND 0x80000000) then
          // -------------------------------------------------------
          // - TASK PERIOD IN [s]
          // -------------------------------------------------------
          AP_TaskTime := LSLOBJ_INFO.orgperiod XOR 0x80000000;
        else
          // -------------------------------------------------------
          // - TASK PERIOD IN [ms]
          // -------------------------------------------------------
          AP_TaskTime := LSLOBJ_INFO.orgperiod * 1000;
        end_if;
      else
        // --------------------------------------------------------
        // - LASAL OS
        // --------------------------------------------------------
        if (LSLOBJ_INFO.orgperiod AND 0x80000000) then
          // -------------------------------------------------------
          // - TASK PERIOD IN [s]
          // -------------------------------------------------------
          AP_TaskTime := (LSLOBJ_INFO.orgperiod XOR 0x80000000) / 1000;
          if (AP_TaskTime = 0) then
            AP_TaskTime := 1;
          end_if;
        else
          // -------------------------------------------------------
          // - TASK PERIOD IN [ms]
          // -------------------------------------------------------
          AP_TaskTime := LSLOBJ_INFO.orgperiod;
        end_if;
      end_if;

    (*=============================================================================*)
    -1: // - ERROR READ OBJECT INFO (NO APPLICATION)
    (*=============================================================================*)
      Retcode     := TCP_CLT_ERR_TASK_TIME_NO_APP;
      AP_TaskTime := 0xFFFFFFFF;

    (*=============================================================================*)
    -3: // - ERROR READ OBJECT INFO (NO APPLICATION)
    (*=============================================================================*)
      Retcode     := TCP_CLT_ERR_TASK_TIME_WRONG_TASK_TYPE;
      AP_TaskTime := 0xFFFFFFFF;

    (*=============================================================================*)
    -5: // - OBJECT NOT FOUND (TASK DEACTIVATED)
    (*=============================================================================*)
      Retcode     := TCP_CLT_ERR_TASK_TIME_OBJ_NOT_FOUND;
      AP_TaskTime := 0xFFFFFFFF;

  end_case;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::GetMultiTaskErrorCode
VAR_INPUT
  pErrTxt 	: ^CHAR;
END_VAR
VAR
	ErrMT     : DINT;
END_VAR

  ErrMT := co_MultiTask.GETLASTERROR();
  case ErrMT of

    (*===============================================================================================*)
    MTERROR_NONE: // - NO ERROR
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NONE");

    (*===============================================================================================*)
    MTERROR_NOMEM: // - NO MORE MEMORY TO RUN THIS FUNCTION, E.G. INTERNAL ALLOC FAILED
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOMEM");

    (*===============================================================================================*)
    MTERROR_NOFCT: // - CREATE TASK NEEDS A VALID TASK FUNCTION
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOFCT");

    (*===============================================================================================*)
    MTERROR_FCTNOTINMEM: // - CREATE TASK NEEDS A TASK FUNCTION PLACED IN LASAL CODE MEMORY
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_FCTNOTINMEM");

    (*===============================================================================================*)
    MTERROR_WRONGPRIOR: // - CREATE TASK ONLY SUPPORTS PRIORS FROM 1 .. 14
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_WRONGPRIOR");

    (*===============================================================================================*)
    MTERROR_STACK: // - CREATE TASK ONLY SUPPORT SATCK SIZE LOWER THAN 0x4000
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_STACK");

    (*===============================================================================================*)
    MTERROR_NAME: // - CREATE TASK, MAILBOX OR SEMAPHORE NEEDS A VALID NAME
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NAME");

    (*===============================================================================================*)
    MTERROR_NAMEUSED: // - CREATE TASK, MAILBOX OR SEMAPHORE NAME ALREADY IN USE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NAMEUSED");

    (*===============================================================================================*)
    MTERROR_HANDLE: // - HANDLE NOT FOUND IN OS-LIST => NOT VALID
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_HANDLE");

    (*===============================================================================================*)
    MTERROR_NOTALLOWED: // - MT-FUNCTION NOT ALLOWED IN THIS TASK CONTEXT
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOTALLOWED");

    (*===============================================================================================*)
    MTERROR_MESSAGESIZE: // - MAILBOX NEED A VALID MESSAGE SIZE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_MESSAGESIZE");

    (*===============================================================================================*)
    MTERROR_DATA: // - POINTER TO DATA IS NOT VALID
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_DATA");

    (*===============================================================================================*)
    MTERROR_PTR: // - INVALID POINTER, PARAMETER OR INTERNAL
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_PTR");

    (*===============================================================================================*)
    MTERROR_TASKID: // - INVALID TASK ID, ID NOT FOUND
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_TASKID");

    (*===============================================================================================*)
    MTERROR_NOTASK: // - TASK DOES NOT EXIST
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOTASK");

    (*===============================================================================================*)
    MTERROR_NOIFFNC: // - INTERFACE FUNCTION IS NOT AVAILABLE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_NOIFFNC");

    (*===============================================================================================*)
    else // - UNKNOWN ERROR CODE
    (*===============================================================================================*)
      co_SigCLib.StrCpy(pErrTxt, "MTERROR_UNKNOWN");

  end_case;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AP_TaskCreate
VAR_INPUT
  pTaskName 	: ^CHAR;
  pCallback 	: ^void;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  AP_TaskHandle := co_MultiTask.CREATETHREAD(pCallback, AP_TaskPriority, 0x4000, MT_TASK_SAVETHIS, this, pTaskName);
  if (AP_TaskHandle = NIL) then
    Retcode := TCP_CLT_ERR_TASK_CREATE;
  end_if;

END_FUNCTION

FUNCTION __CDECL _TCPIP_CLIENT::AP_TaskCallback
VAR_INPUT
#pragma warning (disable: 0073)
  Param0 	: ^void;
#pragma warning (default: 0073)
END_VAR

  while 1 do
    CyclicCall();
    AP_TaskDelay(AP_TaskTime);
  end_while;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AP_TaskDelay
VAR_INPUT
  udTaskDelay 	: UDINT;
END_VAR

  if (bdStatus.SalamanderOS = true) then
    OSSD_DELAY(pCIL_DEBUG, udTaskDelay);
  else
    co_MultiTask.TASKDELAY(udTaskDelay);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AP_SemaCreate
VAR_INPUT
  pSemaName 	: ^CHAR;
  Index 	    : DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pSemaName <> NIL) then
    case Index of
      (*=================================================================================*)
      0:
      (*=================================================================================*)
        AP_SemaHandle1 := co_MultiTask.CREATESEMAPHORE(MTSEMATYPE_MUTEX, 1, 0, pSemaName);
        if (AP_SemaHandle1 = NIL) then
          Retcode := TCP_CLT_ERR_SEMA_CREATE;
        end_if;

      (*=================================================================================*)
      1:
      (*=================================================================================*)
        AP_SemaSockOpt := co_MultiTask.CREATESEMAPHORE(MTSEMATYPE_MUTEX, 1, 0, pSemaName);
        if (AP_SemaSockOpt = NIL) then
          Retcode := TCP_CLT_ERR_SEMA_CREATE;
        end_if;

      (*=================================================================================*)
      else
      (*=================================================================================*)
        Retcode := TCP_CLT_ERR_SEMA_INVALID_IDX;

    end_case;
  else
    Retcode := TCP_CLT_ERR_SEMA_INVALID_NAME;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AP_SemaWait
VAR_INPUT
  SemaHandle 	: MT_SEMAHANDLE;
END_VAR

  if (SemaHandle <> NIL) then
    co_MultiTask.WAIT(SemaHandle);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AP_SemaSignal
VAR_INPUT
  SemaHandle 	: MT_SEMAHANDLE;
END_VAR

  if (SemaHandle <> NIL) then
    co_MultiTask.SIGNAL(SemaHandle);
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::DelConnIntern
VAR_INPUT
  pDelConn 	  : ^_CONNECTION;
END_VAR
VAR
	pSearchConn : ^_CONNECTION;
END_VAR

  if (pDelConn <> NIL) then

    AP_SemaWait(AP_SemaHandle1);

    if (pDelConn^.pNextConn = pDelConn) then
      // - ONE ACTIVE CONNECTION
    else
      pSearchConn := pDelConn;
      while pSearchConn^.pNextConn <> pDelConn do
        pSearchConn := pSearchConn^.pNextConn;
      end_while;
      pSearchConn^.pNextConn := pDelConn^.pNextConn;
      pActConn := pDelConn^.pNextConn;
      bdStatus.InhibNextConn := true;
    end_if;

    ConnInfoCallback(pDelConn, TCP_CLT_INFO_DELETED, 0);
    INITConnection(pDelConn);
    AP_SemaSignal(AP_SemaHandle1);

    ActConn -= 1;

  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::AddConnectionSSL
VAR_INPUT
  pIPAddress 	                  : ^CHAR;
  pCACertPEMFilename 	          : ^CHAR;
  pClientCertChainPEMFilename 	: ^CHAR;
  pClientCertKeyPEMFilename 	  : ^CHAR;
  pKeyDecryptPwd 	              : ^CHAR;
  pCallbackThis 	              : ^void;
  pCallbackMeth 	              : ^void;
  udTimeout 	                  : UDINT;
END_VAR
VAR_OUTPUT
  dHandle 	                    : DINT;
END_VAR
VAR
	dRet                          : DINT;
END_VAR

  dHandle := 0;

  if (usInit > 0) then
    if (bdStatus.CIL_ssl_user = true) then
      if (bdStatus.ErrMem = false) then
        dRet := CheckParaConnSSL(pCACertPEMFilename, pClientCertChainPEMFilename, pClientCertKeyPEMFilename, pKeyDecryptPwd);
        if (dRet = TCP_CLT_NO_ERROR) then
          dRet := CheckParaConnTCP(pIPAddress, pCallbackThis, pCallbackMeth);
          if (dRet = TCP_CLT_NO_ERROR) then

            dHandle := AddConnIntern(pIPAddress,
                                     pCACertPEMFilename,
                                     pClientCertChainPEMFilename,
                                     pClientCertKeyPEMFilename,
                                     pKeyDecryptPwd,
                                     pCallbackThis,
                                     pCallbackMeth,
                                     udTimeout,
                                     true);

          else
            LastError := dRet;
          end_if;
        else
          LastError := dRet;
        end_if;
      else
        LastError := TCP_CLT_ERR_CONN_MEMORY;
      end_if;
    else
      LastError := TCP_CLT_ERR_NO_SSL_INTERFACE;
    end_if;
  else
    LastError := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AddConnIntern
VAR_INPUT
  pIPAddress 	                  : ^CHAR;
  pCACertPEMFilename 	          : ^CHAR;
  pClientCertChainPEMFilename 	: ^CHAR;
  pClientCertKeyPEMFilename 	  : ^CHAR;
  pKeyDecryptPwd 	              : ^CHAR;
  pCallbackThis 	              : ^void;
  pCallbackMeth 	              : ^void;
  udTimeout 	                  : UDINT;
  ConnSSL 	                    : BOOL;
END_VAR
VAR_OUTPUT
  dHandle 	                    : DINT;
END_VAR
VAR
  pFirstConn                    : ^_CONNECTION;
  pNewConn                      : ^_CONNECTION;
  pSearchConn                   : ^_CONNECTION;
  i                             : USINT;
END_VAR

  dHandle := 0;

  if (pIPAddress = NIL) | (pConnectionBuffer = NIL) | (Control = _STATE_ERROR_CREATING_MUTEX) | (Control = _STATE_ERROR_ALLOCATING_MEMORY) then
    return;
  end_if;

  if (ActConn < MaxConn) then

    AP_SemaWait(AP_SemaHandle1);

    for i := 0 to (MaxConn-1) do
      pFirstConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
      if (pFirstConn^.bInUse = true) then
        exit;
      else
        pFirstConn := NIL;
      end_if;
    end_for;


    for i := 0 to (MaxConn-1) do
      pNewConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
      if (pNewConn^.bInUse = false) then
        exit;
      end_if;
    end_for;

    pNewConn^.bInUse          := true;
    pNewConn^.udTimeout       := udTimeout;
    pNewConn^.pCallbackThis   := pCallbackThis;
    pNewConn^.pCallbackMeth   := pCallbackMeth;
    pNewConn^.FSM_TCP         := _STATE_IDLE;
    pNewConn^.ConnSockOpt     := MainSockOpt;
    pNewConn^.KeepAlivePara   := KeepAlivePara;
    pNewConn^.CloseSocketType := CloseSocketType;
    co_SigCLib.StrCpy(#pNewConn^.szIPAddress[0], pIPAddress);
    pNewConn^.bdSettings.SockOptChanged := true;

    if (ConnSSL = true) then
      pNewConn^.bdSettings.ConnSSL := true;
      if (pCACertPEMFilename <> NIL) then
        co_SigCLib.StrCpy(#pNewConn^.szCACertPEMFileName[0], pCACertPEMFilename);
      end_if;
      if (pClientCertChainPEMFilename <> NIL) then
        co_SigCLib.StrCpy(#pNewConn^.szClientCertChainPEMFilename[0], pClientCertChainPEMFilename);
      end_if;
      if (pClientCertKeyPEMFilename <> NIL) then
        co_SigCLib.StrCpy(#pNewConn^.szClientCertKeyPEMFilename[0], pClientCertKeyPEMFilename);
      end_if;
      if (pKeyDecryptPwd <> NIL) then
        co_SigCLib.StrCpy(#pNewConn^.szKeyDecryptPwd[0], pKeyDecryptPwd);
      end_if;
    end_if;

    if (pFirstConn = NIL) then
      pNewConn^.pNextConn := pNewConn;
    else
      pSearchConn := pFirstConn;
      while (pSearchConn^.pNextConn <> pFirstConn) do
        pSearchConn := pSearchConn^.pNextConn;
      end_while;
      pNewConn^.pNextConn    := pFirstConn;
      pSearchConn^.pNextConn := pNewConn;
    end_if;

    dHandle := pNewConn$DINT;
    ActConn += 1;

    AP_SemaSignal(AP_SemaHandle1);

  else
    LastError := TCP_CLT_ERR_MAX_CONN;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::CheckParaConnSSL
VAR_INPUT
  pCACertPEMFilename 	          : ^CHAR;
  pClientCertChainPEMFilename 	: ^CHAR;
  pClientCertKeyPEMFilename 	  : ^CHAR;
  pKeyDecryptPwd 	              : ^CHAR;
END_VAR
VAR_OUTPUT
  Retcode 	                    : DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pClientCertChainPEMFilename <> NIL) then
    if (pClientCertKeyPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
  end_if;

  if (pClientCertKeyPEMFilename <> NIL) then
    if (pClientCertChainPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
  end_if;

  if (pKeyDecryptPwd <> NIL) then
    if (pClientCertChainPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
    if (pClientCertKeyPEMFilename = NIL) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_SSL;
    end_if;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::FindFirstConn
VAR_OUTPUT
  pFirstConn 	: ^_CONNECTION;
END_VAR
VAR
	i           : USINT;
  pSearchConn : ^_CONNECTION;
END_VAR

  pFirstConn := NIL;

  for i := 0 to (MaxConn-1) do
    pSearchConn := pConnectionBuffer + (i * sizeof(_CONNECTION));
    if (pSearchConn^.bInUse = true) then
      pFirstConn := pSearchConn;
    end_if;
  end_for;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::CheckParaConnTCP
VAR_INPUT
  pIPAddress 	    : ^CHAR;
  pCallbackThis 	: ^void;
  pCallbackMeth 	: ^void;
END_VAR
VAR_OUTPUT
  Retcode 	      : DINT;
END_VAR
VAR
	udStrLen        : UDINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pIPAddress = NIL) then
    Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
  else
    udStrLen := co_SigCLib.StrLen(pIPAddress);
    if (udStrLen = 0) then
      Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
    end_if;
  end_if;

//  if (pCallbackThis = NIL) then
//    Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
//  end_if;
//
//  if (pCallbackMeth = NIL) then
//    Retcode := TCP_CLT_ERR_INVALID_PARA_TCP;
//  end_if;

END_FUNCTION

FUNCTION GLOBAL _TCPIP_CLIENT::GetLastError
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := LastError;

END_FUNCTION

FUNCTION GLOBAL _TCPIP_CLIENT::InstallConnErrCallback
VAR_INPUT
  dHandle 	      : DINT;
  pCallbackThis 	: ^void;
  pCallbackMeth 	: ^void;
END_VAR
VAR_OUTPUT
  Retcode 	      : DINT;
END_VAR
VAR
	pConn           : ^_CONNECTION;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (CheckHandleValid(dHandle) = true) then
    if (pCallbackThis <> NIL) & (pCallbackMeth <> NIL) then
      pConn := dHandle$^_CONNECTION;
      pConn^.pErrCallbackThis := pCallbackThis;
      pConn^.pErrCallbackMeth := pCallbackMeth;
    else
      Retcode := TCP_CLT_ERR_INVALID_POINTER;
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::ErrCallback
VAR_INPUT
#pragma warning (disable: 0073)
  FSM_TCP 	: _FSM_TCP_USER;
  ErrGroup 	: DINT;
  ErrCode 	: DINT;
#pragma warning (default: 0073)
END_VAR

END_FUNCTION

FUNCTION _TCPIP_CLIENT::ConnErrCallback
VAR_INPUT
  pConn 	  : ^_CONNECTION;
  ErrGroup 	: DINT;
  ErrCode 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR
VAR
	pTmpThis  : ^void;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pConn <> NIL) then
    if (pConn^.pErrCallbackThis <> NIL) & (pConn^.pErrCallbackMeth <> NIL) then
      pTmpThis := this;
      this$^void := pConn^.pErrCallbackThis;
      #pragma warning(disable: 137);
      pConn^.pErrCallbackMeth$ErrCallback(pConn^.FSM_TCP, ErrGroup, ErrCode);
      #pragma warning(default: 137);
      this$^void := pTmpThis;
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::ReadMainParameter
VAR_INPUT
  Cmd 	      : DINT;
  SubCmd 	    : DINT;
  pParaValue 	: ^DINT;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (usInit > 0) then
    case Cmd of
      (*================================================================*)
      TCPCLT_CMD_SETSOCKOPT:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_SOCKOPT_NAGLE:
          (*==================================================*)
            if (MainSockOpt.Nagle = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          TCPCLT_SOCKOPT_KEEPALIVE:
          (*==================================================*)
            if (MainSockOpt.KeepAlive = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if; 
          (*==================================================*)
          TCPCLT_SOCKOPT_DELAYEDACK:
          (*==================================================*)
            if (MainSockOpt.DelayedAck = false) then
              pParaValue^ := 0;
            else
              pParaValue^ := 1;
            end_if;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPCLT_CMD_TASKPRIO:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_SUB_CMD_TASKPRIO:
          (*==================================================*)
            pParaValue^ := AP_TaskPriority$DINT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPCLT_CMD_KEEPALIVEPARA:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_KEEPALIVE_KEEPIDLE:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepIDLE;
          (*==================================================*)
          TCPCLT_KEEPALIVE_KEEPINTVL:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepINTVL;
          (*==================================================*)
          TCPCLT_KEEPALIVE_KEEPCNT:
          (*==================================================*)
            pParaValue^ := KeepAlivePara.keepCNT;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      TCPCLT_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        case SubCmd of
          (*==================================================*)
          TCPCLT_CLOSESOCKETTYPE:
          (*==================================================*)
            pParaValue^$UDINT := CloseSocketType;
          (*==================================================*)
          else // - INVALID SUB COMMAND
          (*==================================================*)
            Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
        end_case;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_ERR_MAIN_INIT;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::ReadConnParameter
VAR_INPUT
  dHandle 	  : DINT;
  Cmd 	      : DINT;
  SubCmd 	    : DINT;
  pParaValue 	: ^DINT;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
	pConn       : ^_CONNECTION;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (CheckHandleValid(dHandle) = true) then
    pConn := dHandle$^_CONNECTION;
    case Cmd of
      (*================================================================*)
      TCPCLT_CMD_SETSOCKOPT:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            TCPCLT_SOCKOPT_NAGLE:
            (*==================================================*)
              if (pConn^.ConnSockOpt.Nagle = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            TCPCLT_SOCKOPT_KEEPALIVE:
            (*==================================================*)
              if (pConn^.ConnSockOpt.KeepAlive = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            TCPCLT_SOCKOPT_DELAYEDACK:
            (*==================================================*)
              if (pConn^.ConnSockOpt.DelayedAck = false) then
                pParaValue^ := 0;
              else
                pParaValue^ := 1;
              end_if;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      TCPCLT_CMD_KEEPALIVEPARA:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            TCPCLT_KEEPALIVE_KEEPIDLE:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepIDLE;
            (*==================================================*)
            TCPCLT_KEEPALIVE_KEEPINTVL:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepINTVL;
            (*==================================================*)
            TCPCLT_KEEPALIVE_KEEPCNT:
            (*==================================================*)
              pParaValue^ := pConn^.KeepAlivePara.keepCNT;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      TCPCLT_CMD_CLOSESOCKETTYPE:
      (*================================================================*)
        if (pConn^.bdSettings.ConnSSL = true) then
          Retcode := TCP_CLT_ERR_SET_PARA_CMD_NOT_SUPPORTED;
        else
          case SubCmd of
            (*==================================================*)
            TCPCLT_CLOSESOCKETTYPE:
            (*==================================================*)
              pParaValue^$UDINT := pConn^.CloseSocketType;
            (*==================================================*)
            else // - INVALID SUB COMMAND
            (*==================================================*)
              Retcode := TCP_CLT_ERR_SET_PARA_INVALID_SUB_CMD;
          end_case;
        end_if;

      (*================================================================*)
      else // - INVALID COMMAND
      (*================================================================*)
        Retcode := TCP_CLT_ERR_SET_PARA_INVALID_CMD;

    end_case;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION GLOBAL _TCPIP_CLIENT::InstallConnInfoCallback
VAR_INPUT
  dHandle 	      : DINT;
  pCallbackThis 	: ^void;
  pCallbackMeth 	: ^void;
END_VAR
VAR_OUTPUT
  Retcode 	      : DINT;
END_VAR
VAR
	pConn           : ^_CONNECTION;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (CheckHandleValid(dHandle) = true) then
    if (pCallbackThis <> NIL) & (pCallbackMeth <> NIL) then
      pConn := dHandle$^_CONNECTION;
      pConn^.pInfoCallbackThis := pCallbackThis;
      pConn^.pInfoCallbackMeth := pCallbackMeth;
    else
      Retcode := TCP_CLT_ERR_INVALID_POINTER;
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::InfoCallback
VAR_INPUT
#pragma warning (disable: 0073)
  FSM_TCP 	: _FSM_TCP_USER;
  InfoPara1 	: DINT;
  InfoPara2 	: DINT;
#pragma warning (default: 0073)
END_VAR

END_FUNCTION

FUNCTION _TCPIP_CLIENT::ConnInfoCallback
VAR_INPUT
  pConn 	    : ^_CONNECTION;
  InfoPara1 	: DINT;
  InfoPara2 	: DINT;
END_VAR
VAR_OUTPUT
  Retcode 	  : DINT;
END_VAR
VAR
	pTmpThis    : ^void;
END_VAR

  Retcode := TCP_CLT_NO_ERROR;

  if (pConn <> NIL) then
    if (pConn^.pInfoCallbackThis <> NIL) & (pConn^.pInfoCallbackMeth <> NIL) then
      pTmpThis := this;
      this$^void := pConn^.pInfoCallbackThis;
      #pragma warning(disable: 137);
      pConn^.pInfoCallbackMeth$InfoCallback(pConn^.FSM_TCP, InfoPara1, InfoPara2);
      #pragma warning(default: 137);
      this$^void := pTmpThis;
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION _TCPIP_CLIENT::Callback
VAR_INPUT
#pragma warning (disable: 0073)
  pData   : ^void;
  udSize  : UDINT;
#pragma warning (default: 0073)
END_VAR

END_FUNCTION

FUNCTION _TCPIP_CLIENT::AP_NReadAvailable
VAR_INPUT
  pConn 	: ^_CONNECTION;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  if (pConn <> NIL) then
    if (pConn^.bdSettings.ConnSSL = false) then
      Retcode := OS_TCP_USER_NREAD_AVAILABLE(pConn^.dSocket);
    else
      Retcode := cSizeOfTXBuffer$DINT;
    end_if;
  else
    Retcode := TCP_CLT_INVALID_HANDLE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _TCPIP_CLIENT::GetSetting
VAR_INPUT
  Index 	: DINT;
  pSetting 	: ^DINT;
END_VAR
VAR_OUTPUT
  Retcode 	: DINT;
END_VAR

  Retcode := 0;

  case Index of

    (*============================================================================*)
    TCPCLT_GET_SETTING_PORT:
    (*============================================================================*)
      pSetting^ := cPort;

    (*============================================================================*)
    TCPCLT_GET_SETTING_BUFSIZE:
    (*============================================================================*)
      pSetting^ := cSizeOfTXBuffer$DINT;

    (*============================================================================*)
    TCPCLT_GET_SETTING_MAXCONN:
    (*============================================================================*)
      pSetting^ := cMaxConnections;

    (*============================================================================*)
    TCPCLT_GET_SETTING_CONFIG:
    (*============================================================================*)
      pSetting^ := cConfig;

    (*============================================================================*)
    else
    (*============================================================================*)
      Retcode := -1;

  end_case;

END_FUNCTION
