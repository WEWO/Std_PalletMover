//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "RiwoDateTimeLib"
	Revision           = "0.3"
	GUID               = "{721EC39B-0370-41AD-AFB1-D2D3A44570B1}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\RiwoDateTimeLib\RiwoDateTimeLib.ico"
	SharedCommandTable = "true"
	Objectsize         = "(630,120)"
	Singleton          = "true">
	<Channels>
		<Client Name="objSystem" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Riwo Engineering B.V." Author="DN"/>
		<Dokumentation Revision="0.3" Date="2019-01-24" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="- Singleton active"/>
		<Dokumentation Revision="0.2" Date="2017-10-25" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="Added the TimeOverflow function from the RiwoDateTime class, therefore all classes can use this function"/>
		<Dokumentation Revision="0.1" Date="16-06-2009" Author="DN" Company="Riwo Engineering B.V." Description="Initial version"/>
	</RevDoku>
	<Network Name="RiwoDateTimeLib">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5834B6E5-F973-4CB2-86E0-B758D6F9712C}"
				Class      = "TimeDateLib"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(690,210),(518,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using TimeDateLib

RiwoDateTimeLib : CLASS
: TimeDateLib
  //Servers:
  //Clients:
	objSystem 	: CltChCmd_System;
  //Variables:
  //Functions:
	
	FUNCTION GLOBAL TimeToAsciiString
		VAR_INPUT
			pTime 	: ^CHAR;
			tme 	: ^SYSTIME;
		END_VAR
		VAR_OUTPUT
			pRetTime 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL DateToAsciiString
		VAR_INPUT
			pDate 	: ^CHAR;
			dte 	: ^SYSDATE;
		END_VAR
		VAR_OUTPUT
			pRetDate 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL TimeToUnicodeString
		VAR_INPUT
			pTime 	: ^UINT;
			tme 	: ^SYSTIME;
		END_VAR
		VAR_OUTPUT
			pRetTime 	: ^UINT;
		END_VAR;
	
	FUNCTION GLOBAL DateToUnicodeString
		VAR_INPUT
			pDate 	: ^UINT;
			dte 	: ^SYSDATE;
		END_VAR
		VAR_OUTPUT
			pRetDate 	: ^UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetDayOfMonth
		VAR_INPUT
			Month 	: UINT;
			Year 	: UINT;
		END_VAR
		VAR_OUTPUT
			Result 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL GetDayOfWeekSplitsed
		VAR_INPUT
			day 	: UINT;
			month 	: UINT;
			year 	: UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: UINT;
		END_VAR;
	
	FUNCTION GLOBAL CheckIfLeapYear
		VAR_INPUT
			Year 	: UINT;
		END_VAR
		VAR_OUTPUT
			Result 	: BOOL;
		END_VAR;
				//! <Function Comment="Check if datetim is in given range&#13;&#10;InRange := CurrentDatim - Original &lt; Range" Name="DaysFromYear0"/>
	FUNCTION GLOBAL DaysFromYear0
		VAR_INPUT
			ToDate 	: SYSDATE;
		END_VAR
		VAR_OUTPUT
			Days 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL SecondsFromHour0
		VAR_INPUT
			ToTime 	: SYSTIME;
		END_VAR
		VAR_OUTPUT
			Seconds 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL TimeFromSecond0
		VAR_INPUT
			Seconds 	: DINT;
		END_VAR
		VAR_OUTPUT
			ToTime 	: SYSTIME;
		END_VAR;
	
	FUNCTION GLOBAL GetDate
		VAR_INPUT
			pDate 	: ^SYSDATE;
		END_VAR;
	
	FUNCTION GLOBAL GetTime
		VAR_INPUT
			pTime 	: ^SYSTIME;
		END_VAR;
	
	FUNCTION GLOBAL lasal_to_Date
		VAR_INPUT
			pDate 	: ^SYSDATE;
			LasalDate 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL lasal_to_Time
		VAR_INPUT
			pTime 	: ^SYSTIME;
			LasalTime 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetLasalTime
		VAR_OUTPUT
			LasalTime 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL lasal_to_Seconds
		VAR_INPUT
			LasalTime 	: DINT;
			Seconds 	: ^DINT;
		END_VAR;
	
	FUNCTION GLOBAL Seconds_to_Lasal
		VAR_INPUT
			Seconds 	: DINT;
			LasalTime 	: ^DINT;
		END_VAR;
	
	FUNCTION GLOBAL Convert_Date_to_HDINT
		VAR_INPUT
			Date_In 	: SYSDATE;
		END_VAR
		VAR_OUTPUT
			Date_Out 	: HDINT;
		END_VAR;
	
	FUNCTION GLOBAL Convert_Time_to_HDINT
		VAR_INPUT
			Time_in 	: SYSTIME;
		END_VAR
		VAR_OUTPUT
			Time_out 	: HDINT;
		END_VAR;
	
	FUNCTION GLOBAL Convert_HDINT_to_Date
		VAR_INPUT
			Date_in 	: HDINT;
		END_VAR
		VAR_OUTPUT
			Date_out 	: SYSDATE;
		END_VAR;
	
	FUNCTION GLOBAL Convert_HDINT_to_Time
		VAR_INPUT
			Time_in 	: HDINT;
		END_VAR
		VAR_OUTPUT
			Time_out 	: SYSTIME;
		END_VAR;
				//! <Function Comment="use this function to count minutes up with the current datetime" Name="TimeOverflow"/>
	FUNCTION GLOBAL TimeOverflow
		VAR_INPUT
			InputDateTime 	: RiwoDateTime::tDAT_DateAndTime;
			MinutesOverflow 	: DINT;
		END_VAR
		VAR_OUTPUT
			OutputDateTime 	: RiwoDateTime::tDAT_DateAndTime;
		END_VAR;
	
	FUNCTION GLOBAL DDE_Datim_To_Time
		VAR_INPUT
			DDEDatim 	: _DDE_DATIM;
			pTime 	: ^SYSTIME;
		END_VAR;
	
	FUNCTION GLOBAL DDE_Datim_To_Date
		VAR_INPUT
			DDEDatim 	: _DDE_DATIM;
			pDate 	: ^SYSDATE;
		END_VAR;
	
	FUNCTION GLOBAL SysDateDiff
		VAR_INPUT
			dat1 	: SYSDATE;
			dat2 	: SYSDATE;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ShortTimeToAsciiString
		VAR_INPUT
			pTime 	: ^CHAR;
			tme 	: ^SYSTIME;
		END_VAR
		VAR_OUTPUT
			pRetTime 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL ShortDateToAsciiString
		VAR_INPUT
			pDate 	: ^CHAR;
			dte 	: ^SYSDATE;
		END_VAR
		VAR_OUTPUT
			pRetDate 	: ^CHAR;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd System


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB RiwoDateTimeLib::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_RIWODATETIMELIB
0$UINT, 3$UINT, (SIZEOF(::RiwoDateTimeLib))$UINT, 
0$UINT, 1$UINT, 0$UINT, 
TO_UDINT(1116381182), "RiwoDateTimeLib", //Class
TO_UDINT(1512043018), "TimeDateLib", 1$UINT, 1$UINT, //Baseclass
//Servers:
//Clients:
(::RiwoDateTimeLib.objSystem.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3835052145), "objSystem", TO_UDINT(968218125), "System", 0$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_RiwoDateTimeLib 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_RiwoDateTimeLib] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION RiwoDateTimeLib::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code	:= TimeDateLib::@STD();

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION GLOBAL RiwoDateTimeLib::TimeToAsciiString
	VAR_INPUT
		pTime 	: ^char;
		tme 	: ^SYSTIME;
	END_VAR
	VAR_OUTPUT
		pRetTime 	: ^char;
	END_VAR

	(pTime)^ := '0' + (tme^.wHour / 10)$char;
	(pTime+1*sizeof(char))^ := '0' + (tme^.wHour mod 10)$char;
	(pTime+2*sizeof(char))^ := ':';

	(pTime+3*sizeof(char))^ := '0' + (tme^.wMinute / 10)$char;
	(pTime+4*sizeof(char))^ := '0' + (tme^.wMinute mod 10)$char;
	(pTime+5*sizeof(char))^ := ':';

	(pTime+6*sizeof(char))^ := '0' + (tme^.wSecond / 10)$char;
	(pTime+7*sizeof(char))^ := '0' + (tme^.wSecond mod 10)$char;
	(pTime+8*sizeof(char))^ := 0;
	
	pRetTime := pTime;

END_FUNCTION

FUNCTION GLOBAL RiwoDateTimeLib::ShortTimeToAsciiString
	VAR_INPUT
		pTime 	: ^char;
		tme 	: ^SYSTIME;
	END_VAR
	VAR_OUTPUT
		pRetTime 	: ^char;
	END_VAR

	(pTime)^ := '0' + (tme^.wHour / 10)$char;
	(pTime+1*sizeof(char))^ := '0' + (tme^.wHour mod 10)$char;
	(pTime+2*sizeof(char))^ := ':';

	(pTime+3*sizeof(char))^ := '0' + (tme^.wMinute / 10)$char;
	(pTime+4*sizeof(char))^ := '0' + (tme^.wMinute mod 10)$char;
	(pTime+5*sizeof(char))^ := 0;
	
	pRetTime := pTime;

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::DateToAsciiString
	VAR_INPUT
		pDate 	: ^char;
		dte 	: ^SYSDATE;
	END_VAR
	VAR_OUTPUT
		pRetDate 	: ^char;
	END_VAR
  
  (pDate)^ := '0' + ((dte^.wYear / 1000) mod 10)$char;
	(pDate+1*sizeof(char))^ := '0' + ((dte^.wYear / 100) mod 10)$char;
	(pDate+2*sizeof(char))^ := '0' + ((dte^.wYear / 10) mod 10)$char;
	(pDate+3*sizeof(char))^ := '0' + (dte^.wYear mod 10)$char;
  (pDate+4*sizeof(char))^ := '-';

	(pDate+5*sizeof(char))^ := '0' + (dte^.wMonth / 10)$char;
	(pDate+6*sizeof(char))^ := '0' + (dte^.wMonth mod 10)$char;
	(pDate+7*sizeof(char))^ := '-';
  
  (pDate+8*sizeof(char))^ := '0' + (dte^.wDay / 10)$char;
	(pDate+9*sizeof(char))^ := '0' + (dte^.wDay mod 10)$char;
	(pDate+10*sizeof(char))^ := 0;

	pRetDate := pDate;

END_FUNCTION

FUNCTION GLOBAL RiwoDateTimeLib::ShortDateToAsciiString
	VAR_INPUT
		pDate 	: ^char;
		dte 	: ^SYSDATE;
	END_VAR
	VAR_OUTPUT
		pRetDate 	: ^char;
	END_VAR

	(pDate)^ := '0' + (dte^.wDay / 10)$char;
	(pDate+1*sizeof(char))^ := '0' + (dte^.wDay mod 10)$char;
	(pDate+2*sizeof(char))^ := '-';
  
  (pDate+3*sizeof(char))^ := '0' + (dte^.wMonth / 10)$char;
	(pDate+4*sizeof(char))^ := '0' + (dte^.wMonth mod 10)$char;
	(pDate+5*sizeof(char))^ := 0;

	pRetDate := pDate;

END_FUNCTION

FUNCTION GLOBAL RiwoDateTimeLib::TimeToUnicodeString
	VAR_INPUT
		pTime 	: ^UINT;
		tme 	: ^SYSTIME;
	END_VAR
	VAR_OUTPUT
		pRetTime 	: ^UINT;
	END_VAR

	(pTime)^ := '0' + (tme^.wHour / 10)$UINT;
	(pTime+1*sizeof(UINT))^ := '0' + (tme^.wHour mod 10)$UINT;
	(pTime+2*sizeof(UINT))^ := ':';

	(pTime+3*sizeof(UINT))^ := '0' + (tme^.wMinute / 10)$UINT;
	(pTime+4*sizeof(UINT))^ := '0' + (tme^.wMinute mod 10)$UINT;
	(pTime+5*sizeof(UINT))^ := ':';

	(pTime+6*sizeof(UINT))^ := '0' + (tme^.wSecond / 10)$UINT;
	(pTime+7*sizeof(UINT))^ := '0' + (tme^.wSecond mod 10)$UINT;
	(pTime+8*sizeof(UINT))^ := 0;
	
	pRetTime := pTime;

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::DateToUnicodeString
	VAR_INPUT
		pDate 	: ^UINT;
		dte 	: ^SYSDATE;
	END_VAR
	VAR_OUTPUT
		pRetDate 	: ^UINT;
	END_VAR
 
  (pDate)^ := '0' + ((dte^.wYear / 1000) mod 10)$UINT;
	(pDate+1*sizeof(UINT))^ := '0' + ((dte^.wYear / 100) mod 10)$UINT;
	(pDate+2*sizeof(UINT))^ := '0' + ((dte^.wYear / 10) mod 10)$UINT;
	(pDate+3*sizeof(UINT))^ := '0' + (dte^.wYear mod 10)$UINT;
  (pDate+4*sizeof(UINT))^ := '-';
  
	(pDate+5*sizeof(UINT))^ := '0' + (dte^.wMonth / 10)$UINT;
	(pDate+6*sizeof(UINT))^ := '0' + (dte^.wMonth mod 10)$UINT;
	(pDate+7*sizeof(UINT))^ := '-';
  
  (pDate+8*sizeof(UINT))^ := '0' + (dte^.wDay / 10)$UINT;
	(pDate+9*sizeof(UINT))^ := '0' + (dte^.wDay mod 10)$UINT;  
	(pDate+10*sizeof(UINT))^ := 0;

	pRetDate := pDate;

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::GetDayOfMonth
	VAR_INPUT
		Month 	: UINT;
		Year 	: UINT;
	END_VAR
	VAR_OUTPUT
		Result 	: UINT;
	END_VAR

	Result := 30; 

	case Month of
	  1,3,5,7,8,10,12: 
		  Result := 31;

    2: 
      Result := 28;

      if(CheckIfLeapYear(year) = TRUE) then
        Result := 29;
      end_if;             

	end_case;

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::GetDayOfWeekSplitsed
	VAR_INPUT
		day 	: UINT;
		month 	: UINT;
		year 	: UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: UINT;
	END_VAR
  VAR
    days : UDINT; 
    maxs : UINT; 
  END_VAR

  year  -= 1; 
  maxs  := year / 4; 
  maxs  -= year / 100;
  maxs  += year / 400; 
  days  := ((TO_UDINT(year)) * 365) + maxs; 

  while(month > 1) do
	month -= 1; 
    days  += GetDayOfMonth(month, year+1);   
  end_while; 

  days += day;

  retcode := TO_UINT(days mod 7);

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::CheckIfLeapYear
	VAR_INPUT
		Year 	: UINT;
	END_VAR
	VAR_OUTPUT
		Result 	: BOOL;
	END_VAR
  Result := FALSE;

  if((Year mod 4) = 0) then
    Result := TRUE; 

    if((Year mod 100) = 0) then

	    Result := FALSE; 

	    if((Year mod 400) = 0) then
	      Result := TRUE; 
      end_if; 

    end_if; 

  end_if;

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::DaysFromYear0
	VAR_INPUT
		ToDate 	: SYSDATE;
	END_VAR
	VAR_OUTPUT
		Days 	: DINT;
	END_VAR
  VAR
  	Emboly : BOOL;
  END_VAR

  Days := to_dint(ToDate.wYear) * 365;
  Days += to_dint(ToDate.wYear / 4);
  Days -= to_dint(ToDate.wYear / 100);
  Days += to_dint(ToDate.wYear / 400);  

  Emboly := FALSE; 
  // Bereken of schrikkeljaar is
  if((ToDate.wYear mod 4) = 0) then
    Emboly := TRUE; 
    if((ToDate.wYear mod 100) = 0) then
      Emboly := FALSE; 
      if((ToDate.wYear mod 400) = 0) then
        Emboly := TRUE; 
      end_if; 
    end_if; 
  end_if; 
  
  // Aantal dagen er bij op tellen
  while ToDate.wMonth > 1 do
    ToDate.wMonth -= 1;
    case ToDate.wMonth of
      1,3,5,7,8,10,12: Days += 31;
                    2: if(Emboly = true) then
                         Days += 29;
                       else
                         Days += 28;
                       end_if;
      else Days += 30;
    end_case;
  end_while;
  
  Days += ToDate.wDay;
  
END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::SecondsFromHour0
	VAR_INPUT
		ToTime 	: SYSTIME;
	END_VAR
	VAR_OUTPUT
		Seconds 	: DINT;
	END_VAR

  Seconds := to_dint(ToTime.wHour) * 3600;
  Seconds += to_dint(ToTime.wMinute) * 60;
  Seconds += to_dint(ToTime.wSecond);

END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::TimeFromSecond0
	VAR_INPUT
		Seconds 	: DINT;
	END_VAR
	VAR_OUTPUT
		ToTime 	: SYSTIME;
	END_VAR

  ToTime.wHour := to_usint(Seconds / 3600);
  Seconds := Seconds mod 3600;
  ToTime.wMinute := to_usint(Seconds / 60);
  Seconds := Seconds mod 60;
  ToTime.wSecond := to_usint(Seconds);

END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::GetDate
	VAR_INPUT
		pDate 	: ^SYSDATE;
	END_VAR
    
  objSystem.GetSysDate(pDate);

END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::GetTime
	VAR_INPUT
		pTime 	: ^SYSTIME;
	END_VAR
    
  objSystem.GetSysTime(pTime);
  
END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::lasal_to_Date
	VAR_INPUT
		pDate 	: ^SYSDATE;
		LasalDate 	: DINT;
	END_VAR
  
  pDate^.wDayOfWeek  := (LasalDate          AND 0x000F)$UINT;
  pDate^.wDay        := ((LasalDate shr 4)  AND 0x00FF)$UINT;
  pDate^.wMonth      := ((LasalDate shr 12) AND 0x000F)$UINT;
  pDate^.wYear       := ((LasalDate shr 16) AND 0xFFFF)$UINT;

END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::lasal_to_Time
	VAR_INPUT
		pTime 	: ^SYSTIME;
		LasalTime 	: DINT;
	END_VAR
  
  pTime^.wSecond     := ((LasalTime shr 8)  AND 0x00FF)$UINT;
  pTime^.wMinute     := ((LasalTime shr 16) AND 0x00FF)$UINT;
  pTime^.wHour       := ((LasalTime shr 24) AND 0x00FF)$UINT;
END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::lasal_to_Seconds
	VAR_INPUT
		LasalTime 	: DINT;
		Seconds 	: ^DINT;
	END_VAR
  
  Seconds^    := ((LasalTime shr 8)  AND 0x00FF)$DINT;
  Seconds^     += 60 * ((LasalTime shr 16) AND 0x00FF)$DINT;
  Seconds^     += 3600 * ((LasalTime shr 24) AND 0x00FF)$DINT;
  
END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::Seconds_to_Lasal
	VAR_INPUT
		Seconds 	: DINT;
		LasalTime 	: ^DINT;
	END_VAR
  VAR
  	tmp : DINT;
  END_VAR

  
  LasalTime^ := 0;
  IF Seconds >= 3600 THEN
    tmp := (Seconds / 3600);
    Seconds := Seconds - (tmp*3600);
    LasalTime^ := tmp shl 8;
  END_IF;
  
  IF Seconds >= 60 THEN
    tmp := (Seconds / 60);
    Seconds := Seconds - (tmp*60);
    LasalTime^:= (LasalTime^ + tmp) shl 8;
  ELSE
    LasalTime^:= LasalTime^ shl 8;
  END_IF;

  LasalTime^ := (LasalTime^ + Seconds) shl 8;
  
END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::GetLasalTime
	VAR_OUTPUT
		LasalTime 	: DINT;
	END_VAR
  VAR
  	pTime : SYSTIME;
  END_VAR

  
  objSystem.GetSysTime(#pTime);
  
  LasalTime       := pTime.wHour and 16#FF; 
  LasalTime       := (LasalTime shl 8) or (pTime.wMinute and 16#FF); 
  LasalTime       := (LasalTime shl 8) or (pTime.wSecond and 16#FF);
  LasalTime       := (LasalTime shl 8);

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::Convert_Date_to_HDINT
	VAR_INPUT
		Date_In 	: SYSDATE;
	END_VAR
	VAR_OUTPUT
		Date_Out 	: HDINT;
	END_VAR

  Date_Out := 0;

  Date_Out := Date_Out OR ((TO_UINT(Date_In.wYear) SHL 16) AND 16#FFFF0000);           // 16#FFFF0000
  Date_Out := Date_Out OR ((TO_UINT(Date_In.wMonth) SHL 12) AND 16#0000F000);          // 16#0000F000
  Date_Out := Date_Out OR ((TO_UINT(Date_In.wDay) SHL 4) AND 16#00000FF0);             // 16#00000FF0
  Date_Out := Date_Out OR ((TO_UINT(Date_In.wDayOfWeek) SHL 0) AND 16#0000000F);       // 16#0000000F

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::Convert_Time_to_HDINT
	VAR_INPUT
		Time_in 	: SYSTIME;
	END_VAR
	VAR_OUTPUT
		Time_out 	: HDINT;
	END_VAR

  Time_out := 0;

  Time_out := Time_out OR (TO_USINT(Time_in.wHour) SHL 24);           // 16#FF000000
  Time_out := Time_out OR (TO_USINT(Time_in.wMinute) SHL 16);         // 16#00FF0000
  Time_out := Time_out OR (TO_USINT(Time_in.wSecond) SHL 8);          // 16#0000FF00

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::Convert_HDINT_to_Date
	VAR_INPUT
		Date_in 	: HDINT;
	END_VAR
	VAR_OUTPUT
		Date_out 	: SYSDATE;
	END_VAR

  Date_Out.wYear         := TO_UINT((Date_in SHR 16) AND 16#0000FFFF);    // 16#FFFF0000
  Date_Out.wMonth        := TO_USINT((Date_in SHR 12) AND 16#0000000F);   // 16#0000F000
  Date_Out.wDay          := TO_USINT((Date_in SHR 4) AND 16#000000FF);    // 16#00000FF0
  Date_Out.wDayOfWeek    := TO_USINT((Date_in SHR 0) AND 16#0000000F);    // 16#0000000F

END_FUNCTION



FUNCTION GLOBAL RiwoDateTimeLib::Convert_HDINT_to_Time
	VAR_INPUT
		Time_in 	: HDINT;
	END_VAR
	VAR_OUTPUT
		Time_out 	: SYSTIME;
	END_VAR

  Time_out.wHour         := TO_USINT((Time_in SHR 24) AND 16#000000FF);   // 16#FF000000
  Time_out.wMinute       := TO_USINT((Time_in SHR 16) AND 16#000000FF);   // 16#00FF0000
  Time_out.wSecond       := TO_USINT((Time_in SHR 8) AND 16#000000FF);    // 16#0000FF00

END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::TimeOverflow
	VAR_INPUT
		InputDateTime 	: RiwoDateTime::tDAT_DateAndTime;
		MinutesOverflow 	: DINT;
	END_VAR
	VAR_OUTPUT
		OutputDateTime 	: RiwoDateTime::tDAT_DateAndTime;
	END_VAR
  VAR
    day_month         : INT;
    AddHours          : INT;
    AddDays           : INT;
    i1                : INT;
  END_VAR

  // init
  day_month := 0;
  AddHours := 0;
  AddDays := 0;

  // Calculate minute overflow
  IF (MinutesOverflow >= 60) THEN
    AddHours := TO_INT(MinutesOverflow / 60);
    MinutesOverflow := MinutesOverflow - (AddHours * 60);
  ELSIF (MinutesOverflow < 0) THEN
    AddHours := TO_INT(MinutesOverflow / 60);
    MinutesOverflow := MinutesOverflow - (AddHours * 60);
  END_IF;

  IF (MinutesOverflow > 0) & ((MinutesOverflow + InputDateTime.DAT_Time.wMinute) >= 60) THEN
    InputDateTime.DAT_Time.wMinute := InputDateTime.DAT_Time.wMinute + TO_USINT(MinutesOverflow) - 60;
    AddHours += 1;
  ELSIF (MinutesOverflow < 0) & ((MinutesOverflow + InputDateTime.DAT_Time.wMinute) < 0) THEN
    InputDateTime.DAT_Time.wMinute := InputDateTime.DAT_Time.wMinute + TO_USINT(MinutesOverflow) + 60;
    AddHours -= 1;
  ELSIF (MinutesOverflow <> 0) THEN
    InputDateTime.DAT_Time.wMinute := TO_USINT(InputDateTime.DAT_Time.wMinute + MinutesOverflow);
  END_IF;

  // Calculate hour overflow
  if AddHours >= 24 then
    AddDays := AddHours / 24;
    AddHours := AddHours - (AddDays * 24);
  elsif AddHours < 0 then
    AddDays := AddHours / 24;
    AddHours := AddHours - (AddDays * 24);
  end_if;

  if (AddHours > 0) & ((AddHours + InputDateTime.DAT_Time.wHour) >= 24) then
    InputDateTime.DAT_Time.wHour := to_usint(InputDateTime.DAT_Time.wHour + AddHours - 24);
    AddDays += 1;
  elsif (AddHours < 0) & ((AddHours + InputDateTime.DAT_Time.wHour) < 0) then
    InputDateTime.DAT_Time.wHour := to_usint(InputDateTime.DAT_Time.wHour + AddHours + 24);
    AddDays -= 1;
  elsif AddHours <> 0 then
    InputDateTime.DAT_Time.wHour := to_usint(InputDateTime.DAT_Time.wHour + AddHours);
  end_if;

  // Calculate day overflow
  if AddDays < 0 then

    if (InputDateTime.DAT_Date.wDay + AddDays) > 0 then
      InputDateTime.DAT_Date.wDay += to_usint(AddDays);
    else
      AddDays += TO_INT(InputDateTime.DAT_Date.wDay);

      for i1 := -1 to -1000 by -1 do

        InputDateTime.DAT_Date.wMonth -= 1;

        if InputDateTime.DAT_Date.wMonth = 0 then
          InputDateTime.DAT_Date.wMonth := 12;
          InputDateTime.DAT_Date.wYear -= 1;
        end_if;

        day_month := to_int(GetDayOfMonth(InputDateTime.DAT_Date.wMonth,InputDateTime.DAT_Date.wYear));

        if day_month >= (0 - AddDays) then
          i1 := -1001;
          InputDateTime.DAT_Date.wDay := to_usint(day_month + AddDays);
        else
          AddDays += day_month;
        end_if;

      end_for;

    end_if;

  elsif AddDays > 0 then

    day_month := to_int(GetDayOfMonth(InputDateTime.DAT_Date.wMonth,InputDateTime.DAT_Date.wYear));

    if (to_int(InputDateTime.DAT_Date.wDay) + AddDays) <= day_month then
      InputDateTime.DAT_Date.wDay += to_usint(AddDays);
    else

      AddDays -= (day_month - TO_INT(InputDateTime.DAT_Date.wDay));
      for i1 := 1 to 1000 by 1 do
        InputDateTime.DAT_Date.wMonth += 1;

        if InputDateTime.DAT_Date.wMonth = 13 then
          InputDateTime.DAT_Date.wMonth := 1;
          InputDateTime.DAT_Date.wYear += 1;
        end_if;

        day_month := to_int(GetDayOfMonth(InputDateTime.DAT_Date.wMonth,InputDateTime.DAT_Date.wYear));

        if day_month >= AddDays then
          i1 := 1001;
          InputDateTime.DAT_Date.wDay := to_usint(AddDays);
        else
          AddDays -= day_month;
        end_if;

      end_for;

    end_if;

  end_if;

  InputDateTime.DAT_Date.wDayOfWeek := GetDayOfWeekSplitsed(day:=InputDateTime.DAT_Date.wDay, month:=InputDateTime.DAT_Date.wMonth, year:=InputDateTime.DAT_Date.wYear);

  OutputDateTime := InputDateTime;

END_FUNCTION


FUNCTION GLOBAL RiwoDateTimeLib::DDE_Datim_To_Time
	VAR_INPUT
		DDEDatim 	: _DDE_DATIM;
		pTime 	: ^SYSTIME;
	END_VAR
  //  _DDE_DATIM: this structure is bit-masked(!!):
//     first 5 bits: Second
//     next  6 bits: Minute
//     next  5 bits: Hour
//     next  5 bits: Day
//     next  4 bits: Month
//     next  7 bits: Year, counting from 1980

  if pTime <> nil then
    pTime^.wSecond := ((DDEDatim$UDINT shr 0)  AND 0x001F)$UINT;
    pTime^.wMinute := ((DDEDatim$UDINT shr 5)  AND 0x003F)$UINT;
    pTime^.wHour := ((DDEDatim$UDINT shr 11)  AND 0x001F)$UINT;
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL RiwoDateTimeLib::DDE_Datim_To_Date
	VAR_INPUT
		DDEDatim 	: _DDE_DATIM;
		pDate 	: ^SYSDATE;
	END_VAR
  //  _DDE_DATIM: this structure is bit-masked(!!):
//     first 5 bits: Second
//     next  6 bits: Minute
//     next  5 bits: Hour
//     next  5 bits: Day
//     next  4 bits: Month
//     next  7 bits: Year, counting from 1980

  if pDate <> nil then
    pDate^.wDay := ((DDEDatim$UDINT shr 16)  AND 0x001F)$UINT;
    pDate^.wMonth := ((DDEDatim$UDINT shr 21)  AND 0x000F)$UINT;
    pDate^.wYear := ((DDEDatim$UDINT shr 25)  AND 0x007F)$UINT + 1980;
    pDate^.wDayOfWeek := 0; //not implemented
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL RiwoDateTimeLib::SysDateDiff
	VAR_INPUT
		dat1 	: SYSDATE;
		dat2 	: SYSDATE;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	DaysDat1  :DINT;
    DaysDat2  :DINT;
  END_VAR


  DaysDat1 := DaysFromYear0(ToDate:=dat1);
  DaysDat2 := DaysFromYear0(ToDate:=dat2);
  retcode := DaysDat1 - DaysDat2;
END_FUNCTION
