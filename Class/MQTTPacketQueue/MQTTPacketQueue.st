//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define MQTTPACKETQUEUE_QUEUE_FULL    -1
#define MQTTPACKETQUEUE_GROW_FAIL     -2
#define MQTTPACKETQUEUE_INPUT_NOT_OK  -3
#define MQTTPACKETQUEUE_QUEUE_START   1
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "MQTTPacketQueue"
	Revision           = "1.2"
	GUID               = "{BC5B90E3-9606-4C37-8FAF-916FFD77B339}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\MQTTClient\mqtt.ico"
	SharedCommandTable = "true"
	Objectsize         = "(540,180)"
	Comment            = "PacketQueue created for the MQTTClient Class.">
	<Channels>
		<Server Name="ClassSvr" GUID="{070B11A7-B281-42CD-8CB6-2B6F7C52C6C0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="MemoryHeap" Required="true" Internal="false"/>
		<Client Name="SigCLib" Required="false" Internal="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="VelGer"/>
		<Dokumentation Revision="1.2" Date="2020-11-25" Author="MehMar" Company="Sigmatek" Description="1. Bugfix: MQTT is sending invalid values in case of high load of the broker."/>
		<Dokumentation Revision="1.1" Date="2020-02-17" Author="VelGer" Company="Sigmatek" Description="1. BugFix: Class memory handling has been reworked."/>
		<Dokumentation Revision="1.0" Date="2019-04-19" Author="VelGer" Company="Sigmatek" Description="Creation."/>
	</RevDoku>
	<Network Name="MQTTPacketQueue">
		<!-- List of Components in this network -->
		<Components>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
MQTTPacketQueue : CLASS
	TYPE
#pragma pack(push, 1)
	  t_s_Callback : STRUCT
	    pThis : ^void;
	    pMethod : ^void;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Packet : STRUCT  //! <Type Public="true" Name="t_s_Packet"/>
	    pData : ^void;
	    udDataSize : UDINT;
	    pPayload : ^void;
	    udPayloadSize : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PacketEntry : STRUCT  //! <Type Public="true" Name="t_s_PacketEntry"/>
	    udWriteOffset : UDINT;
	    bLocked : BOOL;
	    dID : DINT;
	    PacketData : t_s_Packet;
	    pCBThis : ^void;
	    pCBMeth : ^void;
	    Direction : DINT;
	    MsgType : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
	StdLib 	: CltChCmd__StdLib;
	MemoryHeap 	: CltChCmd__MemoryBubbles;
  //Variables:
		bIntited 	: BOOL;
		aMsgs : ARRAY [0..MQTT_MESSAGEQUEUE_NUM_ITEMS-1] OF t_s_PacketEntry;

		udNumMessages 	: UDINT;
		MQTTClientErrorCallback 	: t_s_Callback;
		dCurrentID 	: DINT;
  //Functions:
	
	FUNCTION InitQueue
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL InsertPacket
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
			pPayload 	: ^void;
			udPayloadSize 	: UDINT;
			udBytesAvailable 	: UDINT;
			pCBThis 	: ^void;
			pCBMeth 	: ^void;
			Direction 	: DINT;
			MsgType 	: MQTTClient::t_e_MQTTControlPackets;
		END_VAR
		VAR_OUTPUT
			dID 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL AppendToPacket
		VAR_INPUT
			dID 	: DINT;
			pData 	: ^void;
			udBytesAvailable 	: UDINT;
			pComplete 	: ^BOOL;
		END_VAR
		VAR_OUTPUT
			udBytesAccepted 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL GetPacket
		VAR_INPUT
			pMessage 	: ^t_s_Packet;
			pCBThis 	: ^void;
			pCBMeth 	: ^void;
			pMsgType 	: ^DINT;
			pDirection 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			dID 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL ClearPacket
		VAR_INPUT
			dID 	: DINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL CyclicWork;
	
	FUNCTION LogError
		VAR_INPUT
			pTxt 	: ^CHAR;
		END_VAR;
	
	FUNCTION GLOBAL LockPacket
		VAR_INPUT
			dID 	: DINT;
			bLock 	: BOOL;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _MemoryBubbles
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MQTTPacketQueue::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MQTTPACKETQUEUE
1$UINT, 2$UINT, (SIZEOF(::MQTTPacketQueue))$UINT, 
1$UINT, 3$UINT, 0$UINT, 
TO_UDINT(4175763163), "MQTTPacketQueue", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MQTTPacketQueue.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::MQTTPacketQueue.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::MQTTPacketQueue.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::MQTTPacketQueue.MemoryHeap.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3266143373), "MemoryHeap", TO_UDINT(217061216), "_MemoryBubbles", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MQTTPacketQueue 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MQTTPacketQueue] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MQTTPacketQueue::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION LogCallback VAR_INPUT pThis : ^void; level : INT; pStr : ^CHAR;  udLen : UDINT;  END_VAR VAR_OUTPUT bOK : BOOL; END_VAR;

FUNCTION MQTTPacketQueue::InitQueue
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR  
  
  //Always OK
  bOK := TRUE;
  
  //If already inited
  if bIntited = FALSE then
        
    //Reset Packet ID, start at 1 so that a test against 0 can be performed.
    dCurrentID  := MQTTPACKETQUEUE_QUEUE_START;
    bIntited    := TRUE;
    
  end_if;
  
END_FUNCTION
  

FUNCTION GLOBAL MQTTPacketQueue::CyclicWork
  
  //If the queue is not inited, Init the Queue
  if bIntited = FALSE then
    InitQueue();
  end_if;
  
END_FUNCTION

FUNCTION MQTTPacketQueue::LogError
	VAR_INPUT
		pTxt 	: ^CHAR;
	END_VAR
  
  //If the error callback is set
  if MQTTClientErrorCallback.pThis    &
     MQTTClientErrorCallback.pMethod  then
    
    MQTTClientErrorCallback.pMethod$LogCallback(pThis :=  MQTTClientErrorCallback.pThis, 
                                                level :=  MQTT_LOG_ERR, 
                                                pStr  :=  pTxt, 
                                                udLen :=  SigCLib.StrLen(str:=pTxt));
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTPacketQueue::InsertPacket
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
		pPayload 	: ^void;
		udPayloadSize 	: UDINT;
		udBytesAvailable 	: UDINT;
		pCBThis 	: ^void;
		pCBMeth 	: ^void;
		Direction 	: DINT;
		MsgType 	: MQTTClient::t_e_MQTTControlPackets;
	END_VAR
	VAR_OUTPUT
		dID 	: DINT;
	END_VAR

  //Incoming Messages: No pPayload, Only pData
  //Outgoing Messages: Payload and Data

  //If the input data is not valid, set return code and end
  
  if pData = NIL  |
     udSize = 0   then
    
    dID := MQTTPACKETQUEUE_INPUT_NOT_OK;
    return;
    
  end_if;
  
  //First section of message (All headers are copied into outgoing packet queue, the payload is left)
  
  //If there is a position available
  if udNumMessages < MQTT_MESSAGEQUEUE_NUM_ITEMS then
    
    //Save pData
    aMsgs[udNumMessages].PacketData.pData := MemoryHeap.MallocV1( size0 :=  udSize, 
                                                                  mark0 :=  MQTTCLIENT_DEFAULT_MALLOC_MARK);
    
    
    //If the malloc is OK, copy the data
    if aMsgs[udNumMessages].PacketData.pData then
      
      aMsgs[udNumMessages].PacketData.udDataSize     := udSize;
      aMsgs[udNumMessages].dID                       := dCurrentID;
      aMsgs[udNumMessages].PacketData.pPayload       := pPayload;
      aMsgs[udNumMessages].PacketData.udPayloadSize  := udPayloadSize;
      aMsgs[udNumMessages].Direction                 := Direction;
      aMsgs[udNumMessages].MsgType                   := MsgType$DINT;
      
      //The exact amount of data required to complete the message is available -> Unlock the message.
      if udSize = udBytesAvailable then
        aMsgs[udNumMessages].bLocked := FALSE;
        
      //We still need to wait for more data to complete the message -> Lock It.      
      elsif udBytesAvailable < udSize then
        aMsgs[udNumMessages].bLocked := TRUE;
        
      //There is more data available for this message than is required, limit the bytes available for the copy below -> Unlock the message.
      elsif udBytesAvailable > udSize then
        udBytesAvailable := udSize;
        aMsgs[udNumMessages].bLocked := FALSE;
        
      end_if;
      
      //Copy message data
      SigCLib.MemCpy(dst0 :=  aMsgs[udNumMessages].PacketData.pData, 
                     src0 :=  pData, 
                     len0 :=  udBytesAvailable);
                                              
      aMsgs[udNumMessages].udWriteOffset := udBytesAvailable;
      dID := aMsgs[udNumMessages].dID;
      
      //Handle the callback data, if set then store for use later
      if pCBThis &
         pCBMeth then
        aMsgs[udNumMessages].pCBThis := pCBThis;
        aMsgs[udNumMessages].pCBMeth := pCBMeth; 
      else
        aMsgs[udNumMessages].pCBThis := NIL;
        aMsgs[udNumMessages].pCBMeth := NIL; 
      end_if;

      udNumMessages += 1;
      
//      if dCurrentID >= MQTT_MESSAGEQUEUE_COUNTER_OVF then
//        dCurrentID := MQTTPACKETQUEUE_QUEUE_START;
//      else
        dCurrentID += 1;
      //end_if;
      
    //Malloc Failed
    else
      dID := MQTTPACKETQUEUE_GROW_FAIL;
      return;
    
    end_if;

  //No sapce in the Queue
  else
    dID := MQTTPACKETQUEUE_QUEUE_FULL;
  
  end_if;    

END_FUNCTION

FUNCTION GLOBAL MQTTPacketQueue::GetPacket
	VAR_INPUT
		pMessage 	: ^t_s_Packet;
		pCBThis 	: ^void;
		pCBMeth 	: ^void;
		pMsgType 	: ^DINT;
		pDirection 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		dID 	: DINT;
	END_VAR
  VAR
  	udCount : UDINT;
  END_VAR

  //Assume no Msg
  pMessage^.pData         := NIL;
  pMessage^.udDataSize    := 0;
  pMessage^.pPayload      := NIL;
  pMessage^.udPayloadSize := 0;
  dID := -1;
  
  //If there are messages, return the first message that is not locked
  if udNumMessages >= 1 then
    
    for udCount := 0 to udNumMessages-1 do
      
      //If the message is not locked then return
      if aMsgs[udCount].bLocked = FALSE then
        
        pMessage^ := aMsgs[udCount].PacketData;
        dID       := aMsgs[udCount].dID;
        if pMsgType then
          pMsgType^ := aMsgs[udCount].MsgType;
        end_if;
        if pDirection then
          pDirection^ := aMsgs[udCount].Direction;
        end_if;
        
        if pCBThis &
           pCBMeth then
           
          if aMsgs[udCount].pCBThis &
             aMsgs[udCount].pCBMeth then
             
            pCBThis$^pVoid^  := aMsgs[udCount].pCBThis;
            pCBMeth$^pVoid^  := aMsgs[udCount].pCBMeth;
            
          else
          
            pCBThis   := NIL;
            pCBMeth   := NIL;
            
          end_if;
          
        end_if;

        return;
        
      end_if;
      
    end_for;
    
  end_if;

END_FUNCTION

FUNCTION GLOBAL MQTTPacketQueue::ClearPacket
	VAR_INPUT
		dID 	: DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udCount, udLen : UDINT;
    pTo, pFrom : ^void;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //Only look for the message to clear if there are any messages
  if udNumMessages >= 1 then
    
    //Find the message to clear, if the message is locked, do not clear it.
    for udCount := 0 to udNumMessages - 1 do

      //If this is the message we are interested in
      if aMsgs[udCount].dID = dID then
                
        //If this message has been locked, skip over
        if aMsgs[udCount].bLocked then
          
          bOK := TRUE;
          return;
          
        end_if;
        
        //Free this message
        MemoryHeap.Free(mptr:=aMsgs[udCount].PacketData.pData);
        
        //If this is not the last message, move the rest of the messages's data up
        if udNumMessages - 1 > udCount then
          
          //Array entries
          pTo   := #aMsgs[udCount];
          pFrom := #aMsgs[udCount+1];
          udLen := (udNumMessages - 1 - udCount) * sizeof(t_s_PacketEntry);
          
          SigCLib.MemCpy( dst0  :=  pTo, 
                          src0  :=  pFrom, 
                          len0  :=  udLen);
          
        end_if;
        
        udNumMessages -= 1;
        
        bOK := TRUE;
        return;
      
      end_if;
      
    end_for;
    
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL MQTTPacketQueue::AppendToPacket
	VAR_INPUT
		dID 	: DINT;
		pData 	: ^void;
		udBytesAvailable 	: UDINT;
    pComplete : ^BOOL;
	END_VAR
	VAR_OUTPUT
		udBytesAccepted 	: UDINT;
	END_VAR
  VAR
  	udCount : UDINT;
  END_VAR

  udBytesAccepted := 0;  
  
  //If the Input values are not OK, stop
  if pData = NIL        |
     udNumMessages = 0  |
     pComplete = NIL    then
    return;
  end_if;
  
  pComplete^ := FALSE;
  
  //Find the MessageData
  for udCount := 0 to udNumMessages - 1 do
    
    //If this is the message we are concerned with
    if aMsgs[udCount].dID = dID then
      
      //If the user writes enough bytes to complete this message
      if aMsgs[udCount].udWriteOffset + udBytesAvailable >= aMsgs[udCount].PacketData.udDataSize then
      
        pComplete^ := TRUE;
        aMsgs[udCount].bLocked := FALSE;  
        
        udBytesAccepted := (aMsgs[udCount].PacketData.udDataSize) - (aMsgs[udCount].udWriteOffset);
      
      //There aren't enough bytes to complete the message, accept all the available bytes
      else
      
        udBytesAccepted := udBytesAvailable;
        
      end_if;

      //Copy the data
      SigCLib.MemCpy(dst0 :=  (aMsgs[udCount].PacketData.pData$UDINT + aMsgs[udCount].udWriteOffset)$^void, 
                     src0 :=  pData,  
                     len0 :=  udBytesAccepted);
            
      //Offset the Write Offset
      aMsgs[udCount].udWriteOffset += udBytesAccepted;
            
      return;
      
    end_if;
    
  end_for;
    
END_FUNCTION

FUNCTION GLOBAL MQTTPacketQueue::LockPacket
	VAR_INPUT
		dID 	: DINT;
    bLock : BOOL;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udCount : UDINT;
    pPacket : ^t_s_PacketEntry;
  END_VAR

  //Find the Packet to lock, and set the lock bit
  bOK := FALSE;
  
  //Only search for the packet if there are any messages
  if udNumMessages > 0 then
    
    pPacket := #aMsgs[0];
  
    //Step over the messages and find the one to clear
    for udCount := 0 to udNumMessages - 1 do
    
      if pPacket^.dID = dID then
        pPacket^.bLocked := bLock;
        bOK := TRUE;
        return;
      end_if;
      
      //Move the pointer for the next entry
      pPacket$UDINT += sizeof(t_s_PacketEntry);
      
    end_for;
  
  end_if;
  
END_FUNCTION
