//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "_XMLStructCreator"
	Revision           = "2.0"
	GUID               = "{5AEDD2F3-E04D-4F1C-9D93-3DBBD33913B9}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(284,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{806E29FD-8223-4442-BB80-49636B8C69B6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server to call global methods"/>
		<Client Name="SigCLib" Required="false" Internal="false"/>
		<Client Name="StdLib" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_XMLStructCreator\XML_Defines.h" Include="true"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="sprdie"/>
		<Dokumentation Revision="2.0" Date="2019-11-19" Author="sprdie" Company="Sigmatek" Description="changed memory-management for _XMLReader so the number of Malloc()- and Free()-Calls is reduced (better performance)"/>
		<Dokumentation Revision="1.3" Date="2018-08-01" Author="sprdie" Company="Sigmatek" Description="fixed an error of Method CheckAddAttribute() where a wrong pointer has been used"/>
		<Dokumentation Revision="1.2" Date="2017-09-18" Author="sprdie" Company="Sigmatek" Description="new method:&#13;&#10;CheckAddAttribute() - checks if we are allowed to add the attribute &#13;&#10;(names of attributes of one element are not allowed to occur twice)"/>
		<Dokumentation Revision="1.1" Date="2017-05-10" Author="sprdie" Company="Sigmatek" Description="Class is now also able to handle Unicode String Inputs."/>
		<Dokumentation Revision="1.0" Date="2017-02-10" Author="sprdie" Company="Sigmatek" Description="Class created"/>
	</RevDoku>
</Class>
*)
_XMLStructCreator : CLASS
	TYPE
	  _XML_FREE_TYPE :  //! <Type Public="true" Name="_XML_FREE_TYPE"/>
	  (
	    _XML_FREE_ELEMENT,
	    _XML_FREE_ATTRIBUTE,
	    _XML_FREE_TEXT
	  )$UDINT;
	  _XML_STRUCT_ERR :  //! <Type Public="true" Name="_XML_STRUCT_ERR"/>
	  (
	    _NO_ERROR,
	    _MEM_ERROR
	  )$UDINT;
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
  //Clients:
	StdLib 	: CltChCmd__StdLib;
	SigCLib 	: CltChCmd_SigCLib;
  //Variables:
		pStruct 	: ^_XML_FILE;
		pAdd 	: ^_XML_ELEMENT;
		pElementBuffer 	: ^_XML_ELEMENT;
		elementsUsed 	: UDINT;
		maxElements 	: UDINT;
		pAttributeBuffer 	: ^_XML_ATTRIBUTE;
		attribsUsed 	: UDINT;
		maxAttributes 	: UDINT;
		pTextBuffer 	: ^USINT;
		textSize 	: UDINT;
		pLastElement 	: ^_XML_ELEMENT;
		pLastAttrib 	: ^_XML_ATTRIBUTE;
		pLastText 	: ^USINT;
  //Functions:
				//! <Function Comment="sets the struct-pointer of this class" Name="SetStructPtr"/>
	FUNCTION GLOBAL SetStructPtr
		VAR_INPUT
			pStructPtr 	: ^_XML_FILE;			//! <Variable Comment="Pointer at the XML-structur" Name="SetStructPtr.pStructPtr"/>
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;			//! <Variable Comment="True ... Success&#13;&#10;False ... Command failed" Name="SetStructPtr.retcode"/>
		END_VAR;
				//! <Function Comment="adds a new element with given name" Name="AddElement"/>
	FUNCTION GLOBAL AddElement
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Pointer at the name of the element" Name="AddElement.pName"/>
			bIsUnicode 	: BOOL;
			allocMem 	: BOOL := TRUE;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed" Name="AddElement.retcode"/>
		END_VAR;
				//! <Function Comment="adds an attribute to the actual opened element" Name="AddAttribute"/>
	FUNCTION GLOBAL AddAttribute
		VAR_INPUT
			pName 	: ^USINT;			//! <Variable Comment="Pointer at the name of the attribute" Name="AddAttribute.pName"/>
			pValue 	: ^USINT;			//! <Variable Comment="Pointer at the value of the attribute" Name="AddAttribute.pValue"/>
			bIsUnicode 	: BOOL;
			allocMem 	: BOOL := TRUE;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed" Name="AddAttribute.retcode"/>
		END_VAR;
				//! <Function Comment="adds a text to the actual opened element" Name="AddText"/>
	FUNCTION GLOBAL AddText
		VAR_INPUT
			pText 	: ^USINT;			//! <Variable Comment="Pointer at the text" Name="AddText.pText"/>
			bIsUnicode 	: BOOL;
			allocMem 	: BOOL := TRUE;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... Input NIL&#13;&#10;-2 ... Memory operation failed" Name="AddText.retcode"/>
		END_VAR;
				//! <Function Comment="closes the actual opened element&#13;&#10;&#13;&#10;if a name is given to this function it also checks the name of the element to close" Name="CloseElement"/>
	FUNCTION GLOBAL CloseElement
		VAR_INPUT
			pName 	: ^USINT := NIL;			//! <Variable Comment="Pointer at the name of the element" Name="CloseElement.pName"/>
			bIsUnicode 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;			//! <Variable Comment="0 ... Success&#13;&#10;-1 ... No Element" Name="CloseElement.retcode"/>
		END_VAR;
				//! <Function Comment="frees the whole memory we allocated during operations with the writer" Name="FreeStruct"/>
	FUNCTION GLOBAL FreeStruct;
	
	FUNCTION AddElementAscii
		VAR_INPUT
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddElementUni
		VAR_INPUT
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddElementToMem
		VAR_INPUT
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddAttributeAscii
		VAR_INPUT
			pName 	: ^USINT;
			pValue 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddAttributeUni
		VAR_INPUT
			pName 	: ^UINT;
			pValue 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddAttributeToMem
		VAR_INPUT
			pName 	: ^USINT;
			pValue 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddTextAscii
		VAR_INPUT
			pText 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddTextUni
		VAR_INPUT
			pText 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION AddTextToMem
		VAR_INPUT
			pText 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION CloseElementAscii
		VAR_INPUT
			pName 	: ^USINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION CloseElementUni
		VAR_INPUT
			pName 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL FreePointer
		VAR_INPUT
			pFree 	: ^void;
			freeType 	: _XML_FREE_TYPE;
		END_VAR;
	
	FUNCTION GLOBAL CheckAddAttribute
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
			pName 	: ^USINT;
			bIsUnicode 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retcode 	: BOOL;
		END_VAR;
	
	FUNCTION GLOBAL AllocPredefinedHeap
		VAR_INPUT
			elementCount 	: UDINT;
			attribCount 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retcode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetElementMemory
		VAR_OUTPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR;
	
	FUNCTION GLOBAL GetAttribMemory
		VAR_OUTPUT
			pAttribute 	: ^_XML_ATTRIBUTE;
		END_VAR;
	
	FUNCTION GLOBAL SetFileBufferInfo
		VAR_INPUT
			pFileBuffer 	: ^USINT;
			fileSize 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _XMLStructCreator::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__XMLSTRUCTCREATOR
2$UINT, 0$UINT, (SIZEOF(::_XMLStructCreator))$UINT, 
1$UINT, 2$UINT, 0$UINT, 
TO_UDINT(2131172539), "_XMLStructCreator", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_XMLStructCreator.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::_XMLStructCreator.StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_XMLStructCreator.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
END_FUNCTION


#define USER_CNT__XMLStructCreator 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__XMLStructCreator] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _XMLStructCreator::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR

	ret_code := C_OK;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION GLOBAL _XMLStructCreator::SetStructPtr
	VAR_INPUT
		pStructPtr 	: ^_XML_FILE;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  
  pStruct := pStructPtr;
  pAdd    := pStruct^.MajorElement; 
  
  retcode := TRUE;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::AddElement
	VAR_INPUT
		pName 	: ^USINT;
		bIsUnicode 	: BOOL;
		allocMem 	: BOOL;(* := TRUE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR   
 
  retcode := -1;

  if (pName = NIL) | (pStruct = NIL) then
    return;
  end_if; 
  
  if allocMem = TRUE then
    if bIsUnicode = TRUE then
      retcode := AddElementUni(pName$^UINT);
    else  
      retcode := AddElementAscii(pName);
    end_if;
  else
    // sprdie v2.0 - if predefined memory is used it doesn't matter if uni or ascii
    retcode := AddElementToMem(pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::AddAttribute
	VAR_INPUT
		pName 	: ^USINT;
		pValue 	: ^USINT;
		bIsUnicode 	: BOOL;
		allocMem 	: BOOL;(* := TRUE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := -1;
  
  if (pName = NIL) | (pValue = NIL) | (pAdd = NIL) then
    return;
  end_if;
  
  // check if attribute-name already exists in this element
  if CheckAddAttribute(pAdd, pName, bIsUnicode) = FALSE then
    return;
  end_if;
  
  if allocMem = TRUE then
    if bIsUnicode = TRUE then
      retcode := AddAttributeUni(pName$^UINT, pValue$^UINT);
    else
      retcode := AddAttributeAscii(pName, pValue);
    end_if;
  else
    retcode := AddAttributeToMem(pName, pValue);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::AddText
	VAR_INPUT
		pText 	: ^USINT;
		bIsUnicode 	: BOOL;
		allocMem 	: BOOL;(* := TRUE *)
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  retcode := -1;
  
  if (pText = NIL) | (padd = NIL) then
    return;
  end_if;
  
  if allocMem = TRUE then
    if bIsUnicode = TRUE then
      retcode := AddTextUni(pText$^UINT);
    else
      retcode := AddTextAscii(pText);
    end_if;
  else
    retcode := AddTextToMem(pText);
  end_if;

END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::CloseElement
	VAR_INPUT
		pName 	: ^USINT;(* := NIL *)
		bIsUnicode 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := -1;
  
  if pAdd = NIL then
    return;
  end_if;
 
  if pAdd = pStruct^.MajorElement then
    if pStruct^.MajorElement^.isClosed then
      retcode := 0;
      return;
    end_if;
  end_if;
  
  if bIsUnicode = TRUE then
    retcode := CloseElementUni(pName$^UINT);
  else
    retcode := CloseElementAscii(pName);
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::FreeStruct
  VAR
	  hptr  : ^_XML_ELEMENT;
    pTmp  : ^_XML_ATTRIBUTE;
    i     : UDINT;
  END_VAR
  
  if pStruct = NIL then
    return;
  end_if;
  
  // to free every memory we used we will go to the "deepest" element and go backwards
  if pStruct^.Header <> NIL then
    StdLib.Free(pStruct^.Header);
    pStruct^.Header := NIL;
  end_if;
  
  hptr := pStruct^.MajorElement;
  if hptr = NIL then
    return;
  end_if;
  
  while 1 do
    
    if hptr^.pChildren <> NIL then
      hptr := hptr^.pChildren;
    end_if;
    
    while hptr^.pNext <> NIL do
      hptr := hptr^.pNext;
    end_while;
    
    if hptr = pStruct^.MajorElement then
      
      //we reached the major Element -> Free the ptr
      if hptr^.Attributes.no > 0 then
        // and Attributes
        pTmp := hptr^.Attributes.pList;
        for i := 1 to hptr^.Attributes.no do
          FreePointer(pTmp^.Name, _XML_FREE_TEXT);
          FreePointer(pTmp^.Value, _XML_FREE_TEXT);
          
          pTmp += sizeof(_XML_ATTRIBUTE);
        end_for;
          
        FreePointer(hptr^.Attributes.pList$^void, _XML_FREE_ATTRIBUTE);
      end_if;
      
      // and the name
      if hptr^.Name <> NIL then
        FreePointer(hptr^.Name, _XML_FREE_TEXT);
      end_if;
      
      FreePointer(pStruct^.MajorElement$^void, _XML_FREE_ELEMENT);
      pStruct^.MajorElement := NIL;
      hptr := NIL;
      exit;
      
    end_if;
    
    if hptr^.pChildren = NIL then
      
      if hptr^.pPrevious <> NIL then
        //Element has no children and is the last one of the brothers -> Free
        if hptr^.pText <> NIL then
          // but first free text
          FreePointer(hptr^.pText, _XML_FREE_TEXT);
        end_if;
        
        if hptr^.Attributes.no > 0 then
          // and Attributes
          // therefore we have to go through the list and free name & value
          pTmp := hptr^.Attributes.pList;
          for i := 1 to hptr^.Attributes.no do
            FreePointer(pTmp^.Name, _XML_FREE_TEXT);
            FreePointer(pTmp^.Value, _XML_FREE_TEXT);
            
            pTmp += sizeof(_XML_ATTRIBUTE);
          end_for;
          
          FreePointer(hptr^.Attributes.pList$^void, _XML_FREE_ATTRIBUTE);
        end_if;
        
        // and the name
        if hptr^.Name <> NIL then
          FreePointer(hptr^.Name, _XML_FREE_TEXT);
        end_if;
        
        hptr := hptr^.pPrevious; 
        if hptr^.pNext <> NIL then
          FreePointer(hptr^.pNext$^void, _XML_FREE_ELEMENT);
        end_if;
        
        hptr^.pNext := NIL;
      else
        //Element has no children and is the last child left -> go to father and free child
        if hptr^.pText <> NIL then
          // but first free text
          FreePointer(hptr^.pText, _XML_FREE_TEXT);
        end_if;
        
        if hptr^.Attributes.no > 0 then
          // and Attributes
          // therefore we have to go through the list and free name & value
          pTmp := hptr^.Attributes.pList;
          for i := 1 to hptr^.Attributes.no do
            FreePointer(pTmp^.Name, _XML_FREE_TEXT);
            FreePointer(pTmp^.Value, _XML_FREE_TEXT);
            
            pTmp += sizeof(_XML_ATTRIBUTE);
          end_for;

          FreePointer(hptr^.Attributes.pList$^void, _XML_FREE_ATTRIBUTE);
        end_if;
        
        // and the name
        if hptr^.Name <> NIL then
          FreePointer(hptr^.Name, _XML_FREE_TEXT);
        end_if;
        
        hptr := hptr^.pFather;
        if hptr <> NIL then
          FreePointer(hptr^.pChildren$^void, _XML_FREE_ELEMENT);
          hptr^.pChildren := NIL;
        end_if;
        
      end_if;
      
    end_if;
    
  end_while;
  
  if pElementBuffer <> NIL then
    StdLib.Free(pElementBuffer);
    pElementBuffer := NIL;
    maxElements := 0;
    elementsUsed := 0;
  end_if;
  
  if pAttributeBuffer <> NIL then
    StdLib.Free(pAttributeBuffer);
    pAttributeBuffer := NIL;
    maxAttributes := 0;
    attribsUsed := 0;
  end_if;
  
END_FUNCTION


FUNCTION _XMLStructCreator::AddElementAscii
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    allocPtr  : ^void;
    NameLen   : UDINT;  
  END_VAR
     
  retcode := -1;
  
  if (pAdd = pStruct^.MajorElement) & (pStruct^.MajorElement^.Name = NIL) then
    
    // add-ptr points to first Element which is empty until now
    NameLen := _strlen(pName);
    NameLen += 1; // zero-termination
    
    pAdd^.Name$^void := StdLib.Malloc(NameLen);
    if pAdd^.Name = NIL then
      retcode := -2;
      return;
    end_if;

    _strcpy(pAdd^.Name, pName);
    
  else

    // we have at least 1 element so lets look if we have to be a child or brother (brother = pNext) 
    if pAdd^.isClosed = FALSE then
      //No children if element has text
      if pAdd^.pText <> NIL then 
        return;
      end_if;
      // Element is open -> we are a child...
      // ...so allocate memory for pChildren
      allocPtr := StdLib.Malloc(sizeof(_XML_ELEMENT));
      pAdd^.pChildren$^void := allocPtr;
      if pAdd^.pChildren = NIL then
        return; // Error at getting memory
      end_if;
      
      // fill child with 0 (just born)
      _memset(pAdd^.pChildren, 0, sizeof(_XML_ELEMENT));
      
      // first born child has backwards-connection to the father
      pAdd^.pChildren^.pFather := pAdd;
      
      // now let us point to the child
      pAdd := pAdd^.pChildren;
      
      // and let's give it a name
      NameLen := _strlen(pName);
      NameLen += 1; // zero-termination
      
      pAdd^.Name$^void := StdLib.Malloc(NameLen);
      if pAdd^.Name = NIL then
        retcode := -2;
        return;
      end_if;

      _strcpy(pAdd^.Name, pName);
      
    else
      // Element ist closed -> we are a brother
      allocPtr := StdLib.Malloc(sizeof(_XML_ELEMENT));
      pAdd^.pNext$^void := allocPtr;
      if pAdd^.pNext = NIL then
        retcode := -2;
        return;
      end_if;

      // fill our brother with 0
      _memset(pAdd^.pNext, 0, sizeof(_XML_ELEMENT));
      
      // brother has a backwards-connection to us
      pAdd^.pNext^.pPrevious := pAdd;
      
      // now let us give some attention to our new brother
      pAdd := pAdd^.pNext;
      
      // and now give him a stupid nickname
      NameLen := _strlen(pName);
      NameLen += 1; // zero-termination
      
      pAdd^.Name$^void := StdLib.Malloc(NameLen);
      if pAdd^.Name = NIL then
        retcode := -2;
        return;
      end_if;

      _strcpy(pAdd^.Name, pName);
      
    end_if;

  end_if;

  retcode := 0;
  
END_FUNCTION //AddElementAscii


FUNCTION _XMLStructCreator::AddElementUni
	VAR_INPUT
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    allocPtr  : ^void;
    NameLen   : UDINT;  
  END_VAR

  retcode := -1;
  
  if (pAdd = pStruct^.MajorElement) & (pStruct^.MajorElement^.Name = NIL) then
    
    // add-ptr points to first Element which is empty until now
    NameLen := SigCLib.StrLen16(pName) * 2;
    NameLen += 2; // zero-termination
    
    pAdd^.Name$^void := StdLib.Malloc(NameLen);
    if pAdd^.Name = NIL then
      retcode := -2;
      return;
    end_if;
    
    SigCLib.StrCpy16(pAdd^.Name$^UINT, pName);
    
  else

    // we have at least 1 element so lets look if we have to be a child or brother (brother = pNext) 
    if pAdd^.isClosed = FALSE then
      //No children if element has text
      if pAdd^.pText <> NIL then 
        return;
      end_if;
      // Element is open -> we are a child...
      // ...so allocate memory for pChildren
      allocPtr := StdLib.Malloc(sizeof(_XML_ELEMENT));
      pAdd^.pChildren$^void := allocPtr;
      if pAdd^.pChildren = NIL then
        return; // Error at getting memory
      end_if;
      
      // fill child with 0 (just born)
      _memset(pAdd^.pChildren, 0, sizeof(_XML_ELEMENT));
      
      // first born child has backwards-connection to the father
      pAdd^.pChildren^.pFather := pAdd;
      
      // now let us point to the child
      pAdd := pAdd^.pChildren;
      
      // and let's give it a name
      NameLen := SigCLib.StrLen16(pName) * 2;
      NameLen += 2; // zero-termination
      
      pAdd^.Name$^void := StdLib.Malloc(NameLen);
      if pAdd^.Name = NIL then
        retcode := -2;
        return;
      end_if;
  
      SigCLib.StrCpy16(pAdd^.Name$^UINT, pName);
      
    else
      // Element ist closed -> we are a brother
      allocPtr := StdLib.Malloc(sizeof(_XML_ELEMENT));
      pAdd^.pNext$^void := allocPtr;
      if pAdd^.pNext = NIL then
        retcode := -2;
        return;
      end_if;

      // fill our brother with 0
      _memset(pAdd^.pNext, 0, sizeof(_XML_ELEMENT));
      
      // brother has a backwards-connection to us
      pAdd^.pNext^.pPrevious := pAdd;
      
      // now let us give some attention to our new brother
      pAdd := pAdd^.pNext;
      
      // and now give him a stupid nickname
      NameLen := SigCLib.StrLen16(pName) * 2;
      NameLen += 2; // zero-termination
      
      pAdd^.Name$^void := StdLib.Malloc(NameLen);
      if pAdd^.Name = NIL then
        retcode := -2;
        return;
      end_if;

      SigCLib.StrCpy16(pAdd^.Name$^UINT, pName);
      
    end_if;

  end_if;

  retcode := 0;
  
END_FUNCTION //AddElementUni


FUNCTION _XMLStructCreator::AddAttributeAscii
	VAR_INPUT
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	allocPtr  : ^void;
    hptr      : ^_XML_ATTRIBUTE;
    newSize   : UDINT;
    oldSize   : UDINT;
    NameLen   : UDINT;
    ValueLen  : UDINT;
  END_VAR

  retcode := -1;
  
  // we only will add an Attribute, if this method is called right after WriteStartElement!!
  if pAdd^.isClosed = FALSE then
  
    if pAdd^.Attributes.no = 0 then
      // no attribute until now -> create new list with 1 entry
      allocPtr := StdLib.Malloc(sizeof(_XML_ATTRIBUTE));
      if allocPtr = NIL then
        retcode := -2;
        return;
      end_if;

      pAdd^.Attributes.pList  := allocPtr$^_XML_ATTRIBUTE;
      pAdd^.Attributes.no     := 1;
      
      // now we just can easily add the name and the value
      hptr := pAdd^.Attributes.pList;

      NameLen   := _strlen(pName) + 1;
      ValueLen  := _strlen(pValue) + 1;
      
      hptr^.Name$^void  := StdLib.Malloc(NameLen);
      hptr^.Value$^void := StdLib.Malloc(ValueLen);
      
      if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
        retcode := -2;
        return;
      end_if;
      
      _strcpy(hptr^.Name, pName);
      _strcpy(hptr^.Value, pValue);

      // success
      retcode := 0;
      
    else
      
      // we already have at least 1 Element, so lets make a new list (with 1 Attrib more)
      oldSize := pAdd^.Attributes.no;
      newSize := oldSize + 1;
      allocPtr := StdLib.Malloc(newSize*sizeof(_XML_ATTRIBUTE));
      
      if allocPtr = NIL then
        retcode := -2;
        return;
      end_if;

      // copy old List into new one
      _memcpy(allocPtr, pAdd^.Attributes.pList, oldSize*sizeof(_XML_ATTRIBUTE));
      
      // free the old list
      StdLib.Free(pAdd^.Attributes.pList);
      
      // set pointer to new list and set the new size
      pAdd^.Attributes.pList := allocPtr$^_XML_ATTRIBUTE;
      pAdd^.Attributes.no := newSize;
      
      // now finally add the values
      hptr := pAdd^.Attributes.pList + (oldSize*sizeof(_XML_ATTRIBUTE));
      
      NameLen   := _strlen(pName) + 1;
      ValueLen  := _strlen(pValue) + 1;
      
      hptr^.Name$^void  := StdLib.Malloc(NameLen);
      hptr^.Value$^void := StdLib.Malloc(ValueLen);
      
      if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
        retcode := -2;
        return;
      end_if;
      
      _strcpy(hptr^.Name, pName);
      _strcpy(hptr^.Value, pValue);
      
      // success
      retcode := 0;
      
    end_if;
  
  end_if;  
  
END_FUNCTION //AddAttributeAscii


FUNCTION _XMLStructCreator::AddAttributeUni
	VAR_INPUT
		pName 	: ^UINT;
		pValue 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
   VAR
  	allocPtr  : ^void;
    hptr      : ^_XML_ATTRIBUTE;
    newSize   : UDINT;
    oldSize   : UDINT;
    NameLen   : UDINT;
    ValueLen  : UDINT;
  END_VAR
  
  retcode := -1;

  // we only will add an Attribute, if this method is called right after WriteStartElement!!
  if pAdd^.isClosed = FALSE then
  
    if pAdd^.Attributes.no = 0 then
      // no attribute until now -> create new list with 1 entry
      allocPtr := StdLib.Malloc(sizeof(_XML_ATTRIBUTE));
      if allocPtr = NIL then
        retcode := -2;
        return;
      end_if;

      pAdd^.Attributes.pList  := allocPtr$^_XML_ATTRIBUTE;
      pAdd^.Attributes.no     := 1;
      
      // now we just can easily add the name and the value
      hptr := pAdd^.Attributes.pList;

      NameLen   := SigCLib.StrLen16(pName) * 2 + 2;
      ValueLen  := SigCLib.StrLen16(pValue) * 2 + 2;
      
      hptr^.Name$^void  := StdLib.Malloc(NameLen);
      hptr^.Value$^void := StdLib.Malloc(ValueLen);
      
      if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
        retcode := -2;
        return;
      end_if;
      
      SigCLib.StrCpy16(hptr^.Name$^UINT, pName);
      SigCLib.StrCpy16(hptr^.Value$^UINT, pValue);

      // success
      retcode := 0;
      
    else
      
      // we already have at least 1 Element, so lets make a new list (with 1 Attrib more)
      oldSize := pAdd^.Attributes.no;
      newSize := oldSize + 1;
      allocPtr := StdLib.Malloc(newSize*sizeof(_XML_ATTRIBUTE));
      
      if allocPtr = NIL then
        retcode := -2;
        return;
      end_if;
      
      // copy old List into new one
      _memcpy(allocPtr, pAdd^.Attributes.pList, oldSize*sizeof(_XML_ATTRIBUTE));
      
      // free the old list
      StdLib.Free(pAdd^.Attributes.pList);
      
      // set pointer to new list and set the new size
      pAdd^.Attributes.pList := allocPtr$^_XML_ATTRIBUTE;
      pAdd^.Attributes.no := newSize;
      
      // now finally add the values
      hptr := pAdd^.Attributes.pList + (oldSize*sizeof(_XML_ATTRIBUTE));
      
      NameLen   := SigCLib.StrLen16(pName) * 2 + 2;
      ValueLen  := SigCLib.StrLen16(pValue) * 2 + 2;
      
      hptr^.Name$^void  := StdLib.Malloc(NameLen);
      hptr^.Value$^void := StdLib.Malloc(ValueLen);
      
      if (hptr^.Name = NIL) | (hptr^.Value = NIL) then
        retcode := -2;
        return;
      end_if;
      
      SigCLib.StrCpy16(hptr^.Name$^UINT, pName);
      SigCLib.StrCpy16(hptr^.Value$^UINT, pValue);
      
      // success
      retcode := 0;
      
    end_if;
  
  end_if;  
  
END_FUNCTION //AddAttributeUni


FUNCTION _XMLStructCreator::AddTextAscii
	VAR_INPUT
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	TextLen   : UDINT;
    allocPtr  : ^void;
  END_VAR
  
  retcode := -1;

  // now we just have to set the text and then close the Element
  TextLen := _strlen(pText); //but first we need some memory for our text
  TextLen += 1; // zero-termination
  
  allocPtr := StdLib.Malloc(TextLen);
  if allocPtr = NIL then
    retcode := -2;
    return;
  end_if;
  
  pAdd^.pText$^void := allocPtr;
  _strcpy(pAdd^.pText, pText);
  
  retcode := 0;
  
END_FUNCTION //AddTextUni


FUNCTION _XMLStructCreator::AddTextUni
	VAR_INPUT
		pText 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
  	TextLen   : UDINT;
    allocPtr  : ^void;
  END_VAR
  
  retcode := -1;

  // now we just have to set the text and then close the Element
  TextLen := SigCLib.StrLen16(pText) * 2; //but first we need some memory for our text
  TextLen += 2; // zero-termination
  
  allocPtr := StdLib.Malloc(TextLen);
  if allocPtr = NIL then
    retcode := -2;
    return;
  end_if;
  
  pAdd^.pText$^void := allocPtr;
  SigCLib.StrCpy16(pAdd^.pText$^UINT, pText);
  
  retcode := 0;
  
END_FUNCTION //AddTextUni


FUNCTION _XMLStructCreator::CloseElementAscii
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := -1;
  
  if pAdd^.isClosed = FALSE then
    
    // we are pointing at an open Element -> just close it
    // but first see if we have to check the name
    if pName <> NIL then
      if _strcmp(pAdd^.Name, pName) <> 0 then
        return;
      end_if;
    end_if;
    
    pAdd^.isClosed := TRUE;
    retcode := 0;
    
  else
    
    // we are pointing at an closed Element -> search for the Father and then close
    // therefore we have to go to the first-born brother, because he has the connection to the father
    while pAdd^.pPrevious <> NIL do
      
      pAdd := pAdd^.pPrevious;
      
    end_while;
    
    // now we are pointing to the first-born brother (no Previous brother available)
    pAdd := pAdd^.pFather;
    
    if pName <> NIL then
      if _strcmp(pAdd^.Name, pName) <> 0 then
        return;
      end_if;
    end_if;

    pAdd^.isClosed := TRUE;
    retcode := 0;
    
  end_if;
  
END_FUNCTION //CloseElementAscii


FUNCTION _XMLStructCreator::CloseElementUni
	VAR_INPUT
		pName 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := -1;
    
  if pAdd^.isClosed = FALSE then
    
    // we are pointing at an open Element -> just close it
    // but first see if we have to check the name
    if pName <> NIL then
      if SigCLib.StrCmp16(pAdd^.Name$^UINT, pName) <> 0 then
        return;
      end_if;
    end_if;
    
    pAdd^.isClosed := TRUE;
    retcode := 0;
    
  else
    
    // we are pointing at an closed Element -> search for the Father and then close
    // therefore we have to go to the first-born brother, because he has the connection to the father
    while pAdd^.pPrevious <> NIL do
      
      pAdd := pAdd^.pPrevious;
      
    end_while;
    
    // now we are pointing to the first-born brother (no Previous brother available)
    pAdd := pAdd^.pFather;
    
    if pName <> NIL then
      if SigCLib.StrCmp16(pAdd^.Name$^UINT, pName) <> 0 then
        return;
      end_if;
    end_if;

    pAdd^.isClosed := TRUE;
    retcode := 0;
    
  end_if;
  
END_FUNCTION //CloseElementUni


FUNCTION GLOBAL _XMLStructCreator::CheckAddAttribute
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
		pName 	: ^USINT;
		bIsUnicode 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retcode 	: BOOL;
	END_VAR
  VAR
  	pAtt : ^_XML_ATTRIBUTE;
    i : UDINT;
  END_VAR
  
  pAtt := pElement^.Attributes.pList;
  for i := 1 to pElement^.Attributes.no do 
    
    // check which strcmp-function we have to use
    if bIsUnicode = TRUE then
      
      if SigCLib.StrCmp16(pName$^UINT, pAtt^.Name$^UINT) = 0 then
        retcode := FALSE;
        return; // Attrib already added -> error
      end_if;

    else
      
      if SigCLib.StrCmp(pName, pAtt^.Name) = 0 then
        retcode := FALSE;
        return; // Attrib already added -> error
      end_if;
      
    end_if;
    
  end_for;
  
  retcode := TRUE;
  
END_FUNCTION

// ================================================================================
// ===  sprdie v2.0 - new functions to handle memory management of _XMLReader   ===
// ================================================================================
FUNCTION GLOBAL _XMLStructCreator::AllocPredefinedHeap
	VAR_INPUT
		elementCount 	: UDINT;
		attribCount 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  
  retcode := 0;
  
  // check given parameters
  if ((elementCount = 0) | (attribCount = 0)) then
    retcode := -1;
    return;
  end_if;
  
  // prepare element-buffer and init variables
  pElementBuffer$^void := StdLib.Malloc(elementCount * sizeof(_XML_ELEMENT));
  if (pElementBuffer = NIL) then
    retcode := -2;
    return;
  end_if;
  elementsUsed := 0;
  maxElements := elementCount;
  _memset(pElementBuffer, 0, elementCount * sizeof(_XML_ELEMENT));
  pLastElement := pElementBuffer + (maxElements * sizeof(_XML_ELEMENT));
  
  // prepare attribute-buffer and init variables
  pAttributeBuffer$^void := StdLib.Malloc(attribCount * sizeof(_XML_ATTRIBUTE));
  if (pAttributeBuffer = NIL) then
    retcode := -2;
    return;
  end_if;
  attribsUsed := 0;
  maxAttributes := attribCount;
  _memset(pAttributeBuffer, 0, attribCount * sizeof(_XML_ATTRIBUTE));
  pLastAttrib := pAttributeBuffer + (maxAttributes * sizeof(_XML_ATTRIBUTE));
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::GetElementMemory
	VAR_OUTPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
  
  pElement := NIL;
  
  if elementsUsed >= maxElements then
    return;
  end_if;
  
  pElement := pElementBuffer + (elementsUsed * sizeof(_XML_ELEMENT));
  elementsUsed += 1;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::GetAttribMemory
	VAR_OUTPUT
		pAttribute 	: ^_XML_ATTRIBUTE;
	END_VAR
  
  pAttribute := NIL;
  
  if attribsUsed >= maxAttributes then
    return;
  end_if;
  
  pAttribute := pAttributeBuffer + (attribsUsed * sizeof(_XML_ATTRIBUTE));
  attribsUsed += 1;
  
END_FUNCTION


FUNCTION _XMLStructCreator::AddElementToMem
	VAR_INPUT
		pName 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    allocPtr  : ^_XML_ELEMENT;
  END_VAR
     
  retcode := -1;
  
  if (pAdd = pStruct^.MajorElement) & (pStruct^.MajorElement^.Name = NIL) then
    
    // add-ptr points to first Element which is empty until now    
    // => just set pointer to name
    pAdd^.Name := pName;
    if (pAdd^.Name = NIL) then
      retcode := -2;
      return;
    end_if;
    
  else

    // we have at least 1 element so lets look if we have to be a child or brother (brother = pNext) 
    if (pAdd^.isClosed = FALSE) then
      //No children if element has text
      if (pAdd^.pText <> NIL) then 
        return;
      end_if;
      // Element is open -> we are a child...
      // ...so get memory for pChildren
      allocPtr := GetElementMemory();
      pAdd^.pChildren := allocPtr;
      if (pAdd^.pChildren = NIL) then
        return; // Error at getting memory
      end_if;
      
      // first born child has backwards-connection to the father
      pAdd^.pChildren^.pFather := pAdd;
      
      // now let us point to the child
      pAdd := pAdd^.pChildren;
      
      // and let's give it a name      
      pAdd^.Name := pName;
      if (pAdd^.Name = NIL) then
        retcode := -2;
        return;
      end_if;
      
    else
      // Element ist closed -> we are a brother
      allocPtr := GetElementMemory();
      pAdd^.pNext := allocPtr;
      if (pAdd^.pNext = NIL) then
        retcode := -2;
        return;
      end_if;
      
      // brother has a backwards-connection to us
      pAdd^.pNext^.pPrevious := pAdd;
      
      // now let us give some attention to our new brother
      pAdd := pAdd^.pNext;
      
      // and now set the name
      pAdd^.Name := pName;
      if (pAdd^.Name = NIL) then
        retcode := -2;
        return;
      end_if;
      
    end_if;

  end_if;

  retcode := 0;
  
END_FUNCTION


FUNCTION _XMLStructCreator::AddAttributeToMem
	VAR_INPUT
		pName 	: ^USINT;
		pValue 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR
  VAR
    hptr      : ^_XML_ATTRIBUTE;
  END_VAR

  retcode := -1;
  
  // we only will add an Attribute, if this method is called right after WriteStartElement!!
  if pAdd^.isClosed = FALSE then
    
    hptr := GetAttribMemory();
    if hptr = NIL then
      retcode := -2;
      return;
    end_if;
    
    // if there is no attribute until now, we set list-pointer to first attrib
    // next attrib will get next buffer-entry and so we automtically get a list of attributes
    if pAdd^.Attributes.no = 0 then
      pAdd^.Attributes.pList  := hptr;
    end_if;
    
    // now we just can easily add the name and the value
    hptr^.Name := pName;
    hptr^.Value := pValue;
    
    // attribute added
    pAdd^.Attributes.no += 1;
    
    // success
    retcode := 0;
  
  end_if;
  
END_FUNCTION


FUNCTION _XMLStructCreator::AddTextToMem
	VAR_INPUT
		pText 	: ^USINT;
	END_VAR
	VAR_OUTPUT
		retcode 	: DINT;
	END_VAR

  // now we just have to set the text and then close the Element    
  pAdd^.pText := pText;
  
  retcode := 0;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::SetFileBufferInfo
	VAR_INPUT
		pFileBuffer 	: ^USINT;
		fileSize 	: UDINT;
	END_VAR
  
  pTextBuffer := pFileBuffer;
  textSize := fileSize;
  
  pLastText := pTextBuffer + textSize;
  
END_FUNCTION


FUNCTION GLOBAL _XMLStructCreator::FreePointer
	VAR_INPUT
		pFree 	: ^void;
		freeType 	: _XML_FREE_TYPE;
	END_VAR
  
  // only free the pointer if adress is not in buffer-space
  case freeType of
  	
    _XML_FREE_ELEMENT:
      if (pFree < pElementBuffer) | (pFree >= pLastElement) then
        StdLib.Free(pFree);
      end_if;
    
  	_XML_FREE_ATTRIBUTE:
      if (pFree < pAttributeBuffer) | (pFree >= pLastAttrib) then
        StdLib.Free(pFree);
      end_if;
    
  	_XML_FREE_TEXT:
      if (pFree < pTextBuffer) | (pFree >= pLastText) then
        StdLib.Free(pFree);
      end_if;
    
  end_case;

END_FUNCTION
// ================================================================================
// ================================================================================
