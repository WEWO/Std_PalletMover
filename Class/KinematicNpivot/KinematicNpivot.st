//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#Define PIVOTWHEEL1       1
#Define PIVOTWHEEL2       2
#Define PIVOTWHEEL3       3
#Define PIVOTWHEEL4       4
#Define PIVOTWHEEL5       5
#Define PIVOTWHEEL6       6
#Define PIVOTWHEEL7       7
#Define PIVOTWHEEL8       8

#define PI    3.14159265359
#define DEG2RAD PI/180
#define INF   10**30

//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "KinematicNpivot"
	Revision           = "0.0"
	GUID               = "{D43E1483-5BB2-4F59-913B-D5D445BFB2F6}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(686,120)">
	<Channels>
		<Server Name="ACTIVATE" GUID="{7C7629B1-C304-4F16-BE21-0E5496E61328}" Visualized="false" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false"/>
		<Server Name="ActualTotalDirection" GUID="{EBF4D237-BA63-45D4-9666-0B7A7EE2DCC2}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ActualTotalRadius" GUID="{D581BBA2-1001-49A9-AFDD-877C76F37245}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ActualTotalSpeed" GUID="{A65E7E48-AED5-4E5D-868E-56E846997920}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="AGVInMotion" GUID="{9973B670-646C-4125-AB99-249838ECFECB}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ChaoticManualFrontDirection" GUID="{1635641E-1DA0-47E8-A00F-C6DC1A7BE612}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ChaoticManualFrontSpeed" GUID="{B49FEAD6-8B83-4254-BD97-1A6DA7B31F1B}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ChaoticManualRearDirection" GUID="{6C563127-788E-491F-9BF0-082D6F0F1B66}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ChaoticManualRearSpeed" GUID="{E34F2889-6C01-422E-AC67-1C018D6940E6}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ClassSvr" GUID="{9E8FB4EB-847F-4A44-95E7-887DEDD7D7FD}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Direction" GUID="{2545E6CE-EEBD-42B6-9DC9-BA748D01461A}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="NumberOfPivotWheels" GUID="{03EED40A-E3A0-47A6-BFA6-D9FC727B0388}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Radius" GUID="{AACEF715-2056-43E1-8EA3-96F81B1FA9C3}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ReferenceWheel1" GUID="{FA7F1C51-E2BA-43AD-A05D-129F882C1BE1}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="ReferenceWheel2" GUID="{117AA57C-CD28-45A6-BB0D-4BEAB342EA0D}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="Speed" GUID="{93D9FA6F-FAA7-415B-BB34-D869E93FE3A5}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="AGVMode" Required="true" Internal="false"/>
		<Client Name="chaoticManualModeActive" Required="false" Internal="false"/>
		<Client Name="objPivotWheel1" Required="false" Internal="false"/>
		<Client Name="objPivotWheel2" Required="false" Internal="false"/>
		<Client Name="objPivotWheel3" Required="false" Internal="false"/>
		<Client Name="objPivotWheel4" Required="false" Internal="false"/>
		<Client Name="objPivotWheel5" Required="false" Internal="false"/>
		<Client Name="objPivotWheel6" Required="false" Internal="false"/>
		<Client Name="objPivotWheel7" Required="false" Internal="false"/>
		<Client Name="objPivotWheel8" Required="false" Internal="false"/>
		<Client Name="sigClib" Required="false" Internal="false"/>
	</Channels>
	<Separators>
		<Servers>
			<SepChn Position="9"/>
			<SepChn Position="14"/>
		</Servers>
		<Clients>
			<SepChn Position="8"/>
		</Clients>
	</Separators>
</Class>
*)
KinematicNpivot : CLASS
	TYPE
	  tnPivotStatus : ARRAY [1..8] OF PivotWheel::tPivotWheelStatus;  //! <Type Public="true" Name="tnPivotStatus"/>
#pragma pack(push, 1)
	  tReferenceWheelsInfo : STRUCT  //! <Type Public="true" Name="tReferenceWheelsInfo"/>
	    rwi_ReferenceWheel1Angle : REAL;
	    rwi_ReferenceWheel1Speed : REAL;
	    rwi_ReferenceWheel2Angle : REAL;
	    rwi_ReferenceWheel2Speed : REAL;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	NumberOfPivotWheels 	: SvrCh_DINT;
	ReferenceWheel1 	: SvrCh_DINT;
	ReferenceWheel2 	: SvrCh_DINT;
	AGVInMotion 	: SvrCh_DINT;
	Speed 	: SvrCh_REAL;
	Direction 	: SvrCh_REAL;
	Radius 	: SvrCh_REAL;
	ACTIVATE 	: SvrCh_DINT;
	ChaoticManualFrontSpeed 	: SvrCh_REAL;
	ChaoticManualFrontDirection 	: SvrCh_REAL;
	ChaoticManualRearSpeed 	: SvrCh_REAL;
	ChaoticManualRearDirection 	: SvrCh_REAL;
	ActualTotalRadius 	: SvrCh_REAL;
	ActualTotalDirection 	: SvrCh_REAL;
	ActualTotalSpeed 	: SvrCh_REAL;
  //Clients:
	objPivotWheel1 	: CltChCmd_I_PivotWheel;
	objPivotWheel2 	: CltChCmd_I_PivotWheel;
	objPivotWheel3 	: CltChCmd_I_PivotWheel;
	objPivotWheel4 	: CltChCmd_I_PivotWheel;
	objPivotWheel5 	: CltChCmd_I_PivotWheel;
	objPivotWheel6 	: CltChCmd_I_PivotWheel;
	objPivotWheel7 	: CltChCmd_I_PivotWheel;
	objPivotWheel8 	: CltChCmd_I_PivotWheel;
	chaoticManualModeActive 	: CltCh_DINT;
	AGVMode 	: CltCh_eAGVMode_PTofCls_Standard;
	sigClib 	: CltChCmd_SigCLib;
  //Variables:
		_InitCounter 	: DINT;
		_tmpPivotWheelParameters 	: PivotWheel::tPivotWheelParameters;
		_nPivotStatus : ARRAY [0..1] OF I_PivotWheel::tPivotWheelStatus;

		_previousSetpointAngle : ARRAY [1..8] OF REAL;

		RadiusDirection 	: REAL;
		TurningPointX 	: REAL;
		TurningPointY 	: REAL;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION _getWheelParameters
		VAR_INPUT
			pivotWheel 	: DINT;
		END_VAR
		VAR_OUTPUT
			WheelParameters 	: I_PivotWheel::tPivotWheelParameters;
		END_VAR;
	
	FUNCTION _setNewWheelSetpoints
		VAR_INPUT
			pivotWheel 	: DINT;
			Angle 	: REAL;
			Speed 	: REAL;
		END_VAR;
	
	FUNCTION _ReadClients;
	
	FUNCTION GLOBAL GetReferenceWheelsInfo
		VAR_OUTPUT
			OutParam 	: tReferenceWheelsInfo;
		END_VAR;
	
	FUNCTION GLOBAL SetAGVSetpoints
		VAR_INPUT
			DrivingVectorAngle 	: REAL;
			SteeringRadius 	: REAL;
			DrivingSpeed 	: REAL;
		END_VAR;
	
	FUNCTION _getnPivotStatus;
	
	FUNCTION _sign
		VAR_INPUT
			input 	: REAL;
		END_VAR
		VAR_OUTPUT
			returnValue 	: REAL;
		END_VAR;
	
	FUNCTION GLOBAL SetChaoticManualSetpoints
		VAR_INPUT
			FrontDirection 	: REAL;
			FrontSpeed 	: REAL;
			RearDirection 	: REAL;
			RearSpeed 	: REAL;
		END_VAR;
	
	FUNCTION _KinematicReverseModel;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd I_PivotWheel
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB KinematicNpivot::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_KINEMATICNPIVOT
0$UINT, 0$UINT, (SIZEOF(::KinematicNpivot))$UINT, 
16$UINT, 11$UINT, 0$UINT, 
TO_UDINT(1530409541), "KinematicNpivot", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::KinematicNpivot.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::KinematicNpivot.NumberOfPivotWheels.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3732336522), "NumberOfPivotWheels", 
(::KinematicNpivot.ReferenceWheel1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3503252186), "ReferenceWheel1", 
(::KinematicNpivot.ReferenceWheel2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1237726048), "ReferenceWheel2", 
(::KinematicNpivot.AGVInMotion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2538423241), "AGVInMotion", 
(::KinematicNpivot.Speed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4168236102), "Speed", 
(::KinematicNpivot.Direction.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2055786332), "Direction", 
(::KinematicNpivot.Radius.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3414469084), "Radius", 
(::KinematicNpivot.ACTIVATE.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1884657889), "ACTIVATE", 
(::KinematicNpivot.ChaoticManualFrontSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2488242353), "ChaoticManualFrontSpeed", 
(::KinematicNpivot.ChaoticManualFrontDirection.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2679578763), "ChaoticManualFrontDirection", 
(::KinematicNpivot.ChaoticManualRearSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1254618602), "ChaoticManualRearSpeed", 
(::KinematicNpivot.ChaoticManualRearDirection.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1603685491), "ChaoticManualRearDirection", 
(::KinematicNpivot.ActualTotalRadius.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1916058636), "ActualTotalRadius", 
(::KinematicNpivot.ActualTotalDirection.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(198553421), "ActualTotalDirection", 
(::KinematicNpivot.ActualTotalSpeed.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(783541552), "ActualTotalSpeed", 
//Clients:
(::KinematicNpivot.objPivotWheel1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1407998262), "objPivotWheel1", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel2.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3404007564), "objPivotWheel2", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel3.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3185719322), "objPivotWheel3", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel4.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(596028857), "objPivotWheel4", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel5.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1417780527), "objPivotWheel5", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel6.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3448294549), "objPivotWheel6", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel7.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3129998339), "objPivotWheel7", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.objPivotWheel8.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(707846546), "objPivotWheel8", TO_UDINT(282033681), "I_PivotWheel", 0$UINT, 0$UINT, 
(::KinematicNpivot.chaoticManualModeActive.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3441859921), "chaoticManualModeActive", 
(::KinematicNpivot.AGVMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1510331407), "AGVMode", 
(::KinematicNpivot.sigClib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "sigClib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
END_FUNCTION


#define USER_CNT_KinematicNpivot 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_KinematicNpivot] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION KinematicNpivot::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_KinematicNpivot, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ReferenceWheel1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ReferenceWheel1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ReferenceWheel2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ReferenceWheel2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ACTIVATE.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ACTIVATE.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
FUNCTION VIRTUAL GLOBAL KinematicNpivot::Init
  _InitCounter += 1;

  case _InitCounter of
    INIT_CYCLE_1:
      NumberOfPivotWheels := IsClientConnected(#objPivotWheel1)
                           + IsClientConnected(#objPivotWheel2)
                           + IsClientConnected(#objPivotWheel3)
                           + IsClientConnected(#objPivotWheel4)
                           + IsClientConnected(#objPivotWheel5)
                           + IsClientConnected(#objPivotWheel6)
                           + IsClientConnected(#objPivotWheel7)
                           + IsClientConnected(#objPivotWheel8);
                            // This goes to settings ?? 
  end_case;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL KinematicNpivot::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR
  VAR
  	i : DINT;
    tmpPivotWheelParameter : I_PivotWheel::tPivotWheelParameters;
    distanceCenterX : REAL;
    distanceCenterY : REAL;
    vX: REAL;
    vY: REAL;
    tmpSetpointAngle : Array[1..8] of REAL;
    tmpSetpointSpeed : Array[1..8] of REAL;
    tmpMaxSpeedSetpoint : REAL;
  END_VAR

  _ReadClients();
  _getnPivotStatus();
  tmpMaxSpeedSetpoint := 0;  
    
  // Loop through available pivot wheels
  for i := 1 to NumberOfPivotWheels do

    tmpPivotWheelParameter := _getWheelParameters(i);
    distanceCenterX := tmpPivotWheelParameter.pwp_DistanceToCenterX;
    distanceCenterY := tmpPivotWheelParameter.pwp_DistanceToCenterY;    
    
    if AGVMode = StateControl::am_Manual then
      if chaoticManualModeActive = FALSE then
    
      // Calculations
      // Useful values
      vX := Speed * cos(Direction);
      vy := Speed * sin(Direction);       
      
      // Calculate direction
      if Speed <> 0 then
        if (Radius * cos(Direction) - distanceCenterY / 1000) <> 0 then
          tmpSetpointAngle[i] := (180/SigClib_pi)*atan((Radius * sin(Direction) + distanceCenterX /1000)/(Radius * cos(Direction) - distanceCenterY / 1000));
          
          ////////////////////////
          if AGVMode = StateControl::am_Manual then
            if Speed > 0 then
            if Speed * cos(Direction) < 0 & Speed * sin(Direction) > 0 then
              tmpSetpointAngle[i] += 180;
            end_if;
            if Speed * cos(Direction) < 0 & Speed * sin(Direction) < 0 then
              tmpSetpointAngle[i] -= 180;
            end_if;
            end_if;
            if Speed < 0 then
            if Speed * cos(Direction) > 0 & Speed * sin(Direction) < 0 then
              tmpSetpointAngle[i] += 180;
            end_if;
            if Speed * cos(Direction) > 0 & Speed * sin(Direction) > 0 then
              tmpSetpointAngle[i] -= 180;
            end_if;
            end_if;
          end_if;
        else
          tmpSetpointAngle[i] := _previousSetpointAngle[i];
        end_if;
      else
        tmpSetpointAngle[i] := _previousSetpointAngle[i];
      end_if;
      
      // Calculate speed
      if Radius <> 0 then
        tmpSetpointSpeed[i] := sqrt((vx - (distanceCenterY/1000) / Radius * Speed)**2 + (vy + (distanceCenterX/1000) / Radius * Speed)**2);
        
        if abs(Speed) <> 0 then
          tmpSetpointSpeed[i] *= Speed/abs(Speed); // keep the sign of speed
        else
          tmpSetpointSpeed[i] := 0;
        end_if;
        
        if (tmpSetpointSpeed[i] > Speed & Speed > 0) | (tmpSetpointSpeed[i] < Speed & Speed < 0) then
          tmpSetpointSpeed[i] := Speed;
              
        end_if;
      else
        tmpSetpointSpeed[i] := Speed;
      end_if;

    else
      // Forward chaotic setpoints
      if distanceCenterX > 0 then
        tmpSetpointAngle[i] := ChaoticManualFrontDirection * (180/SigClib_pi);
        tmpSetpointSpeed[i] := ChaoticManualFrontSpeed;
      else
        tmpSetpointAngle[i] := ChaoticManualRearDirection * (180/SigClib_pi);
        tmpSetpointSpeed[i] := ChaoticManualRearSpeed;
      end_if;
    end_if;
    
    end_if;
    
    // AUTO
    
    if AGVMode = StateControl::am_Auto then
      
        RadiusDirection := Direction + _sign(Radius) * SigClib_pi/2;
        TurningPointX := abs(Radius)*cos(RadiusDirection);
        TurningPointY := abs(Radius)*sin(RadiusDirection);
        
        if (TurningPointX - distanceCenterX/1000) > 0 then
          tmpSetpointAngle[i] := (180/SigClib_pi)*atan((TurningPointY-distanceCenterY/1000)/(TurningPointX - distanceCenterX/1000))-_sign(Radius) * 90;
        else
          tmpSetpointAngle[i] := (180/SigClib_pi)*atan((TurningPointY-distanceCenterY/1000)/(TurningPointX - distanceCenterX/1000))-_sign(Radius) * 90 + 180;
          if tmpSetpointAngle[i] < -180 then
            tmpSetpointAngle[i] += 360;
          elsif tmpSetpointAngle[i] > 180 then
            tmpSetpointAngle[i] -= 360;
          end_if;

        end_if;
        if abs(Radius) <> 0 then
          tmpSetpointSpeed[i] := sqrt((TurningPointX - distanceCenterX/1000)**2 + (TurningPointY - distanceCenterY/1000)**2)/abs(Radius) * Speed;
        else
          tmpSetpointSpeed[i] := Speed;
        end_if;
        
        if abs(tmpSetpointSpeed[i]) > tmpMaxSpeedSetpoint then
          tmpMaxSpeedSetpoint := abs(tmpSetpointSpeed[i]);
        end_if;
    end_if; 
  end_for;

    if ACTIVATE then
  // Loop through available pivot wheels
  for i := 1 to NumberOfPivotWheels do
  
      if (tmpMaxSpeedSetpoint <> 0) & (tmpMaxSpeedSetpoint > abs(Speed)) then
        tmpSetpointSpeed[i] := tmpSetpointSpeed[i]/tmpMaxSpeedSetpoint * abs(Speed);
      end_if;
  
      _setNewWheelSetpoints(i,tmpSetpointAngle[i],tmpSetpointSpeed[i]);
      _previousSetpointAngle[i] := tmpSetpointAngle[i];
  end_for;
      end_if; 
      
      _KinematicReverseModel();
END_FUNCTION


FUNCTION KinematicNpivot::_getWheelParameters
	VAR_INPUT
		pivotWheel 	: DINT;
	END_VAR
	VAR_OUTPUT
		WheelParameters 	: I_PivotWheel::tPivotWheelParameters;
	END_VAR

  // Get current status
  case pivotWheel of
   1:
      WheelParameters := objPivotWheel1.GetPivotWheelParameters();
   2:
      WheelParameters := objPivotWheel2.GetPivotWheelParameters();    
   3:
      WheelParameters := objPivotWheel3.GetPivotWheelParameters();
   4:
      WheelParameters := objPivotWheel4.GetPivotWheelParameters();
   5:
      WheelParameters := objPivotWheel5.GetPivotWheelParameters();
   6:
      WheelParameters := objPivotWheel6.GetPivotWheelParameters();
   7:
      WheelParameters := objPivotWheel7.GetPivotWheelParameters();
   8:
      WheelParameters := objPivotWheel8.GetPivotWheelParameters();
  end_case;

END_FUNCTION


FUNCTION KinematicNpivot::_setNewWheelSetpoints
	VAR_INPUT
		pivotWheel 	: DINT;
		Angle 	: REAL;
		Speed 	: REAL;
	END_VAR
  
  // Set new setpoints
  case pivotWheel of
    PIVOTWHEEL1:
      objPivotWheel1.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL2:
      objPivotWheel2.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL3:
      objPivotWheel3.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL4:
      objPivotWheel4.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL5:
      objPivotWheel5.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL6:
      objPivotWheel6.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL7:
      objPivotWheel7.SetPivotWheelSetpoints(Speed,Angle);
    PIVOTWHEEL8:
      objPivotWheel8.SetPivotWheelSetpoints(Speed,Angle);
  end_case;   

END_FUNCTION


FUNCTION KinematicNpivot::_ReadClients
  
  chaoticManualModeActive := chaoticManualModeActive.Read();
  AGVMode := AGVMode.Read();
  
END_FUNCTION


FUNCTION GLOBAL KinematicNpivot::GetReferenceWheelsInfo
	VAR_OUTPUT
		OutParam 	: tReferenceWheelsInfo;
	END_VAR

  case ReferenceWheel1 of
    PIVOTWHEEL1:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel1.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel1.GetActualSpeed();
    PIVOTWHEEL2:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel2.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel2.GetActualSpeed();
    PIVOTWHEEL3:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel3.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel3.GetActualSpeed();
    PIVOTWHEEL4:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel4.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel4.GetActualSpeed();
    PIVOTWHEEL5:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel5.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel5.GetActualSpeed();
    PIVOTWHEEL6:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel6.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel6.GetActualSpeed();
    PIVOTWHEEL7:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel7.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel7.GetActualSpeed();
    PIVOTWHEEL8:
      OutParam.rwi_ReferenceWheel1Angle := objPivotWheel8.GetActualAngle();
      OutParam.rwi_ReferenceWheel1Speed := objPivotWheel8.GetActualSpeed();  
  end_case;
  case ReferenceWheel2 of
    PIVOTWHEEL1:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel1.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel1.GetActualSpeed();
    PIVOTWHEEL2:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel2.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel2.GetActualSpeed();
    PIVOTWHEEL3:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel3.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel3.GetActualSpeed();
    PIVOTWHEEL4:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel4.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel4.GetActualSpeed();
    PIVOTWHEEL5:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel5.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel5.GetActualSpeed();
    PIVOTWHEEL6:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel6.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel6.GetActualSpeed();
    PIVOTWHEEL7:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel7.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel7.GetActualSpeed();
    PIVOTWHEEL8:
      OutParam.rwi_ReferenceWheel2Angle := objPivotWheel8.GetActualAngle();
      OutParam.rwi_ReferenceWheel2Speed := objPivotWheel8.GetActualSpeed();  
  end_case;

END_FUNCTION


FUNCTION GLOBAL KinematicNpivot::SetAGVSetpoints
	VAR_INPUT
		DrivingVectorAngle 	: REAL;
		SteeringRadius 	: REAL;
		DrivingSpeed 	: REAL;
	END_VAR
  
  Radius := SteeringRadius;
  Speed := DrivingSpeed;
  Direction := DrivingVectorAngle;

END_FUNCTION


FUNCTION KinematicNpivot::_getnPivotStatus
  VAR
  	pivotWheel       : DINT;  
    tmpAGVInMotion   : BOOL;
  END_VAR

  tmpAGVInMotion := FALSE;
  _memset(dest:=#_nPivotStatus, usByte:=0, cntr:=sizeof(_nPivotStatus));

  for pivotWheel := 1 to NumberOfPivotWheels do
    case pivotWheel of
      1:
        _nPivotStatus[pivotWheel] :=objPivotWheel1.GetPivotWheelStatus();
       
      2:
        _nPivotStatus[pivotWheel] := objPivotWheel2.GetPivotWheelStatus();
      3:
        _nPivotStatus[pivotWheel] := objPivotWheel3.GetPivotWheelStatus();
      4:
        _nPivotStatus[pivotWheel] := objPivotWheel4.GetPivotWheelStatus();
      5:
        _nPivotStatus[pivotWheel] := objPivotWheel5.GetPivotWheelStatus();
      6:
        _nPivotStatus[pivotWheel] := objPivotWheel6.GetPivotWheelStatus();
      7:
        _nPivotStatus[pivotWheel] := objPivotWheel7.GetPivotWheelStatus();
      8:
        _nPivotStatus[pivotWheel] := objPivotWheel8.GetPivotWheelStatus();
    end_case;
    if _nPivotStatus[pivotWheel].pws_Driving.ds_Actual <> 0 then
      tmpAGVInMotion := TRUE;
    end_if;
  end_for;
  
  AGVInMotion := tmpAGVInMotion;
  
END_FUNCTION


FUNCTION GLOBAL KinematicNpivot::SetChaoticManualSetpoints
	VAR_INPUT
		FrontDirection 	: REAL;
		FrontSpeed 	: REAL;
		RearDirection 	: REAL;
		RearSpeed 	: REAL;
	END_VAR
  
  ChaoticManualFrontSpeed := FrontSpeed;
  ChaoticManualFrontDirection := FrontDirection;
  ChaoticManualRearSpeed := RearSpeed;
  ChaoticManualRearDirection := RearDirection;

END_FUNCTION


FUNCTION KinematicNpivot::_sign
	VAR_INPUT
		input 	: REAL;
	END_VAR
	VAR_OUTPUT
		returnValue 	: REAL;
	END_VAR
  
  if input >= 0 then
    returnValue := 1;
  elsif input < 0 then
    returnValue := -1;
  end_if;

END_FUNCTION


FUNCTION KinematicNpivot::_KinematicReverseModel
 VAR
  	W1  : REAL;
    W2  : REAL;
    W3  : REAL;
    W4  : REAL;
    Wheel1Angle : real;
    Wheel2Angle : real;
    Wheel3Angle : real;
    Wheel4Angle : real;
    Wheel1Speed:real;
    Wheel2Speed:real;
    Wheel3Speed:real;
    Wheel4Speed:real;
    omega :real;
    Vx :real;
    Vy:real;
    
    
  END_VAR
  // this function needs rework
  
  // Get values;
  Wheel1Angle := objPivotWheel1.GetActualAngle();
  Wheel2Angle := objPivotWheel2.GetActualAngle();
  Wheel3Angle := objPivotWheel3.GetActualAngle();
  Wheel4Angle := objPivotWheel4.GetActualAngle();
  
    Wheel1Speed := objPivotWheel1.GetActualSpeed();
    Wheel2Speed := objPivotWheel1.GetActualSpeed();
    Wheel3Speed := objPivotWheel1.GetActualSpeed();
    Wheel4Speed := objPivotWheel1.GetActualSpeed();
  
  
  
  w1:= 0.0;
  w2:= 0.0 ;
  w3:= 0.0;
  w4:= 0.0;


 // Calculate weights W1 to W4 so later calculations look less messy
 if NumberOfPivotWheels > 0 then
    W1 := (-objPivotWheel1.DistanceToCenterY * cos(Wheel1Angle*DEG2RAD) + objPivotWheel1.DistanceToCenterX * sin(Wheel1Angle*DEG2RAD))/(4 * (objPivotWheel1.DistanceToCenterY**2 + objPivotWheel1.DistanceToCenterX**2));
 end_if;

 if NumberOfPivotWheels > 1 then
    W2 := (-objPivotWheel2.DistanceToCenterY * cos(Wheel2Angle*DEG2RAD) + objPivotWheel2.DistanceToCenterX * sin(Wheel2Angle*DEG2RAD))/(4 * (objPivotWheel2.DistanceToCenterY**2 + objPivotWheel2.DistanceToCenterX**2));
end_if

if NumberOfPivotWheels > 2 then
    W3 := (-objPivotWheel3.DistanceToCenterY * cos(Wheel3Angle*DEG2RAD) + objPivotWheel3.DistanceToCenterX * sin(Wheel3Angle*DEG2RAD))/(4 * (objPivotWheel3.DistanceToCenterY**2 + objPivotWheel3.DistanceToCenterX**2));
end_if;
  
   if NumberOfPivotWheels > 3 then
     W4 := (-objPivotWheel4.DistanceToCenterY * cos(Wheel4Angle*DEG2RAD) + objPivotWheel4.DistanceToCenterX * sin(Wheel4Angle*DEG2RAD))/(4 * (objPivotWheel4.DistanceToCenterY**2 + objPivotWheel4.DistanceToCenterX**2));
   end_if;

  // Calculate Speed in X, Y and angular velocity
  Vx := (to_real(Wheel1Speed) * cos(Wheel1Angle*DEG2RAD) + to_real(Wheel2Speed) * cos(Wheel2Angle*DEG2RAD) + to_real(Wheel3Speed) * cos(Wheel3Angle*DEG2RAD) + to_real(Wheel4Speed) * cos(Wheel4Angle*DEG2RAD))/4;
  Vy := (to_real(Wheel1Speed) * sin(Wheel1Angle*DEG2RAD) + to_real(Wheel2Speed) * sin(Wheel2Angle*DEG2RAD) + to_real(Wheel3Speed) * sin(Wheel3Angle*DEG2RAD) + to_real(Wheel4Speed) * sin(Wheel4Angle*DEG2RAD))/4;
  omega := -(to_real(Wheel1Speed) * W1 + to_real(Wheel2Speed) * W2 + to_real(Wheel3Speed) * W3 + to_real(Wheel4Speed) * W4);
  
  // Calculate serverss(Vy) * 
  ActualTotalSpeed := sqrt(Vx**2 + Vy**2);
  if Vx <> 0 then
    ActualTotalDirection := atan(Vy/Vx);
    if Wheel1Speed > 0 & Wheel2Speed > 0 & Wheel3Speed > 0 & Wheel4Speed > 0 then
      ActualTotalSpeed *= -1;
    end_if;
  else
    if Vy <> 0 then
      ActualTotalDirection := (Vy/abs(Vy))*(PI/2);
    end_if;
  end_if;
  if omega <> 0 then
    ActualTotalRadius := ActualTotalSpeed/omega;
  else
    ActualTotalRadius := INF;
  end_if;
END_FUNCTION
