//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "LinkedObjectBase"
	Revision           = "0.10"
	GUID               = "{95A2D2ED-4A0D-4320-8853-2C94093622DE}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(654,120)"
	Comment            = "Base class for linked objects&#13;&#10;">
	<Channels>
		<Client Name="p_NextObject" Required="false" Internal="false" Comment="Pointer to next object in linked list"/>
		<Client Name="p_PreviousObject" Required="false" Internal="false" Comment="Pointer to previous object in linked list&#13;&#10;(is automatically filled if p_NextObject is connected)"/>
	</Channels>
	<RevDoku>
		<Owner Company="Safan BV" Author="HenOdi"/>
		<Dokumentation Revision="0.10" Date="2012-03-14" Author="HenOdi" Company="Safan BV" Description="Init() Only set p_NextObject durin initCnt=2&#13;&#10;Prepare to remove methodes (add DO_NOT_USE) in future"/>
		<Dokumentation Revision="0.9" Date="2011-11-22" Author="NieTie" Company="Safan BV" Description="Split up Linked List functionality into&#13;&#10;- Linked List Control base&#13;&#10;- Linked List object base&#13;&#10;&#13;&#10;Remove control functionality from "/>
	</RevDoku>
	<Network Name="LinkedObjectBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{A552B37B-F16D-44A8-B20B-D9653B9D9C8F}"
				Class      = "WewoBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="m_Id"/>
					<Server Name="m_p_Name"/>
					<Server Name="o_ErrorWarningStatus"/>
					<Server Name="ObjectStatus"/>
					<Server Name="ToObject"/>
					<Client Name="c_Group"/>
					<Client Name="op_LogData"/>
					<Client Name="toOsLibTaskObjControl"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ToObject" Destination="_base.ToObject" Vertices="(856,210),(684,210),"/>
			<Connection Source="_base.op_LogData" Destination="this.op_LogData" Vertices="(218,210),(30,150),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using WewoBase

LinkedObjectBase : CLASS
: WewoBase
  //Servers:
  //Clients:
	p_PreviousObject 	: CltChCmd_LinkedObjectBase;
	p_NextObject 	: CltChCmd_LinkedObjectBase;
  //Variables:
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Get pointer to previous object in chain list" Name="GetPreviousObjectPtr"/>
	FUNCTION GLOBAL GetPreviousObjectPtr
		VAR_OUTPUT
			p_Object 	: pVoid;
		END_VAR;
				//! <Function Comment="Set pointer to previous object in chain list" Name="SetPreviousObjectPtr"/>
	FUNCTION GLOBAL SetPreviousObjectPtr
		VAR_INPUT
			p_Object 	: pVoid;
		END_VAR;
				//! <Function Comment="Get pointer to next object in chain list" Name="GetNextObjectPtr"/>
	FUNCTION GLOBAL GetNextObjectPtr
		VAR_OUTPUT
			p_Object 	: pVoid;
		END_VAR;
				//! <Function Comment="Set pointer to next object in chain list" Name="SetNextObjectPtr"/>
	FUNCTION GLOBAL SetNextObjectPtr
		VAR_INPUT
			p_Object 	: pVoid;
		END_VAR;
				//! <Function Comment="This methode is reserved for application specific &#13;&#10;functionality that should be handled in a synchronise &#13;&#10;(in sequence of linked list) way." Name="SyncTask"/>
	FUNCTION VIRTUAL GLOBAL SyncTask
		VAR_INPUT
			p_SyncTaskData 	: pVoid;			//! <Variable Comment="Pointer to data(structure) used to handover parameters &#13;&#10;and return data." Name="SyncTask.p_SyncTaskData"/>
		END_VAR
		VAR_OUTPUT
			State 	: BOOL;			//! <Variable Comment="State&#13;&#10;TRUE if OK&#13;&#10;FALSE if failure detected" Name="SyncTask.State"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LinkedListAddObject
		VAR_INPUT
			p_PrevObj 	: pVoid;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LinkedListRemoveObject
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL DO_NOT_USE_SearchObjectNextTree
		VAR_INPUT
			ObjectId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			p_Object 	: pVoid;
		END_VAR;
	
	FUNCTION GLOBAL DO_NOT_USE_SearchObjecPreviousTree
		VAR_INPUT
			ObjectId 	: UDINT;
		END_VAR
		VAR_OUTPUT
			p_Object 	: pVoid;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB LinkedObjectBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_LINKEDOBJECTBASE
0$UINT, 10$UINT, (SIZEOF(::LinkedObjectBase))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(1708657366), "LinkedObjectBase", //Class
TO_UDINT(817841270), "WewoBase", 0$UINT, 29$UINT, //Baseclass
//Servers:
//Clients:
(::LinkedObjectBase.p_PreviousObject.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(218962243), "p_PreviousObject", TO_UDINT(1708657366), "LinkedObjectBase", 0$UINT, 10$UINT, 
(::LinkedObjectBase.p_NextObject.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(5254340), "p_NextObject", TO_UDINT(1708657366), "LinkedObjectBase", 0$UINT, 10$UINT, 
END_FUNCTION


#define USER_CNT_LinkedObjectBase 15

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_LinkedObjectBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION LinkedObjectBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= WewoBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= WewoBase::ToObject.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, WewoBase::ToObject.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_LinkedObjectBase;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #SyncTask();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #LinkedListAddObject();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #LinkedListRemoveObject();

#pragma warning (default : 74)
	WewoBase::ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF WewoBase::ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION VIRTUAL GLOBAL LinkedObjectBase::Init

WewoBase::Init();

  if initCnt = 2 then
    p_NextObject := p_NextObject.Read();
    if p_NextObject <> NIL then
      p_NextObject^$LinkedObjectBase.SetPreviousObjectPtr(p_Object:=this);
    end_if;

  end_if;

END_FUNCTION

(***************************************************************
LinkedObjectBase::GetPreviousObjectPtr

Description:    Get pointer to previous object in chain list
              
              
Parameter:      - 
Return:         Pointer to previous object in chain.
                NIL is returned if no object is connected.
***************************************************************)
FUNCTION GLOBAL LinkedObjectBase::GetPreviousObjectPtr
	VAR_OUTPUT
		p_Object 	: pVoid;
	END_VAR
  
  p_Object := p_PreviousObject;

END_FUNCTION


(***************************************************************
LinkedObjectBase::SetPreviousObjectPtr

Description:    Set pointer to previous object in chain list
              
              
Parameter:      Pointer to previous object in chain. 
Return:         -
***************************************************************)
FUNCTION GLOBAL LinkedObjectBase::SetPreviousObjectPtr
	VAR_INPUT
		p_Object 	: pVoid;
	END_VAR
  
  p_PreviousObject := p_Object;

END_FUNCTION


(***************************************************************
LinkedObjectBase::GetNextObjectPtr

Description:    Get pointer to next object in chain list
              
              
Parameter:      - 
Return:         Pointer to next object in chain.
                NIL is returned if no object is connected.
***************************************************************)
FUNCTION GLOBAL LinkedObjectBase::GetNextObjectPtr
	VAR_OUTPUT
		p_Object 	: pVoid;
	END_VAR
  
  p_Object := p_NextObject;

END_FUNCTION


(***************************************************************
LinkedObjectBase::SetNextObjectPtr

Description:    Set pointer to next object in chain list
              
              
Parameter:      Pointer to next object in chain. 
Return:         -
***************************************************************)
FUNCTION GLOBAL LinkedObjectBase::SetNextObjectPtr
	VAR_INPUT
		p_Object 	: pVoid;
	END_VAR
  
  p_NextObject := p_Object;

END_FUNCTION




#pragma warning (disable : 73)

(***************************************************************
LinkedObjectBase::SyncTask

Description:       This methode is reserved for application specific 
                   functionality that should be handled in a synchronise 
                   (in sequence of linked list) way.
              
Parameter:         Pointer to data(structure) used to handover parameters 
                   and return data.
                   
Return:            State
                   TRUE if OK
                   FALSE if failure detected
***************************************************************)

FUNCTION VIRTUAL GLOBAL LinkedObjectBase::SyncTask
	VAR_INPUT
		p_SyncTaskData 	: pVoid;
	END_VAR
	VAR_OUTPUT
		State 	: BOOL;
	END_VAR

  State := FALSE;        // Default return failure, No functionality implemented yet

END_FUNCTION

#pragma warning (default : 73)




//******************************************************************************
// ******************************************************************************
//  START NIET MEER GEBRUIKEN WORDT VERIJDERD
// ********************************************************************************
//******************************************************************************

//***************************************************************
//LinkedObjectBase::LinkedListAddObject
//
//Description:       Add object in linked list.
//
//                   situation before this method is called
//                   PrevObj -> (P,2,N)
//                   (P,this,N)
//                   linked list -> (P,1,N)<->(P,2,N)<->(P,3,N)<->NIL
//
//                   situation after this method
//                   linked list -> (P,1,N)<->(P,2,N)<->(P,this,N)<->(P,3,N)->NIL
//                   
//Parameter:         Pointer to previous object in linked list. 
//                   
//Return:            0  if OK
//                   -1 if SW error
//Note:              This methode is only valid if list is not empty.
//                   First object in list should be set outsite this method.
//***************************************************************
// *******************************************************************************
//  NIET MEER GEBRUIKEN WORDT VERIJDERD
// ********************************************************************************

FUNCTION VIRTUAL GLOBAL LinkedObjectBase::LinkedListAddObject
	VAR_INPUT
		p_PrevObj 	: pVoid;
	END_VAR
	VAR_OUTPUT
		State 	: DINT;
	END_VAR

  if p_PrevObj <> NIL then
    // Valid parameter

    // Set Our next and previous pointers 
    p_NextObject      := p_PrevObj^$LinkedObjectBase.GetNextObjectPtr();
    p_PreviousObject  := p_PrevObj;

    // Set next pointer in previous object
    p_PrevObj^$LinkedObjectBase.SetNextObjectPtr(this);
    
    // Set Previous pointer in next object
    if p_NextObject <> NIL then
      // We are not last object in list
      p_NextObject^$LinkedObjectBase.SetPreviousObjectPtr(this);
    end_if;
    
    State := 0;
  else
  // Error pointer parameter is NIL
    WriteActiveErrorWarning(IntErrorWarningId:= MSGID_NIL_POINTER,
                            LogLevel         := LL_ERROR_INTERNAL, 
                            p_msg            := "LinkedObjectBase::LinkedListAddObject Error p_PrevObj = NIL"
                           );
    State := -1;
    
  end_if;

END_FUNCTION

 
//***************************************************************
//LinkedObjectBase::LinkedListRemoveObject
//
//Description:       Remove object from linked list.
//
//                   situation before this method is called
//                   linked list -> (P,1,N)<->(P,this,N)<->(P,3,N)<->NIL
//
//                   situation after this method
//                   
//                   NIL <-(P,this,N) -> NIL
//                   linked list -> (P,1,N)<->(P,3,N)->NIL
//                   
//Parameter:         -
//Return:            0  if OK
//                   -1 if SW error
//Note:              0
//***************************************************************
//*******************************************************************************
//  NIET MEER GEBRUIKEN WORDT VERIJDERD
// ********************************************************************************

FUNCTION VIRTUAL GLOBAL LinkedObjectBase::LinkedListRemoveObject
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  
  
  // Set previous pointer in next object
  if p_NextObject <> NIL then
    p_NextObject^$LinkedObjectBase.SetPreviousObjectPtr(p_Object:=p_PreviousObject);
  
  end_if;

  // Set next pointer in previous object
  if p_PreviousObject <> NIL then
    p_PreviousObject^$LinkedObjectBase.SetNextObjectPtr(p_Object:=p_NextObject);
  
  end_if;
  
  // Clear our next and previous pointers
  p_NextObject      := NIL;
  p_PreviousObject  := NIL;

  State := 0;
  
END_FUNCTION




//***************************************************************
//LinkedObjectBase::SearchObjectNextTree
//
//Description:       Searches an  object in linked list via Next pointer.
//                   Object should have an Id filled in m_id.
//              
//Parameter:         Object Id.
//                   
//Return:            pointer to object if found
//                   NIL if not found
//***************************************************************
//*******************************************************************************
//  NIET MEER GEBRUIKEN WORDT VERIJDERD
//********************************************************************************

FUNCTION GLOBAL LinkedObjectBase::DO_NOT_USE_SearchObjectNextTree
	VAR_INPUT
		ObjectId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		p_Object 	: pVoid;
	END_VAR

	VAR
    Id       : UDINT;
  END_VAR

  p_Object := this;           // Start searching with this object
  
  while p_Object <> NIL do
    // Next object available in chain .

    Id := p_Object^$LinkedObjectBase.m_Id.Read();

    if ObjectId = Id then
      // Object found,
      exit;             // exit loop
      
    end_if;

    // Get next object in linked list  
    p_Object := p_Object^$LinkedObjectBase.GetNextObjectPtr();
    
  end_while;

END_FUNCTION


// *******************************************************************************
//  NIET MEER GEBRUIKEN WORDT VERIJDERD
// ********************************************************************************
 
FUNCTION GLOBAL LinkedObjectBase::DO_NOT_USE_SearchObjecPreviousTree
	VAR_INPUT
		ObjectId 	: UDINT;
	END_VAR
	VAR_OUTPUT
		p_Object 	: pVoid;
	END_VAR

	VAR
    Id       : UDINT;
  END_VAR

  p_Object := this;           // Start searching with this object
  
  while p_Object <> NIL do
    // Next object available in chain .

    Id := p_Object^$LinkedObjectBase.m_Id.Read();

    if ObjectId = Id then
      // Object found,
      exit;             // exit loop
      
    end_if;

    // Get previous object in linked list  
    p_Object := p_Object^$LinkedObjectBase.GetPreviousObjectPtr();
    
  end_while;

END_FUNCTION

// ******************************************************************************
// *******************************************************************************
//   EIND NIET MEER GEBRUIKEN WORDT VERIJDERD
// *******************************************************************************
// ******************************************************************************



