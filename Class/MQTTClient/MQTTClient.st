//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION
#include "..\..\Class\MQTTClient\MQTTClient_LogTexts.h"

(*!
<Class
	Name               = "MQTTClient"
	Revision           = "1.5"
	GUID               = "{16E2B6F2-2046-4EBA-9692-069419DE0EDF}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "1 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\MQTTClient\mqtt.ico"
	SharedCommandTable = "true"
	Objectsize         = "(772,120)"
	Comment            = "This class is an MQTT Client that provides the ability to connect to an MQTT Broker using:&#13;&#10;1. TCP&#13;&#10;2. Encrypted TCP (SSL / TLS)&#13;&#10;&#13;&#10;The Class also provides the ability to publish and subscribe to topics.&#13;&#10;&#13;&#10;The user can use the class alone or use the MQTTClientInterface class that already contains an object of this MQTTClient class with an easy to use interface.">
	<Channels>
		<Server Name="CleanSession" GUID="{2D359EDF-4735-4595-921B-AE52CF75DD7F}" Visualized="true" Initialize="true" DefValue="0" WriteProtected="false" Retentive="SRam" Comment="Servers used to indicate whether the session to be created must be created as a Clean Session or not:&#13;&#10;1 - Request a Clean Session&#13;&#10;0 - Request a non-Clean Session (Continuous session)&#13;&#10;&#13;&#10;If the connection is created with a continuous sesion the client does not have to resubscribe to all topics, etc."/>
		<Server Name="ClientID" GUID="{C9535767-B2CD-4DC0-BD02-835094E755E1}" Class="String" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="ClientID of the MQTTClient Interface, String function can be accessed using this Object Channel."/>
		<Server Name="MQTTClientState" GUID="{2CD51665-FF2C-4924-9C43-FDE0979245D4}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="SessionPresent" GUID="{726627B9-7AE3-431D-A253-11F6360F5E9F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Indicates whether the Broker acknowledged the existence of a session with this client.&#13;&#10;The ClientID is used for session identification and must therefor be unique on the MQTT Broker."/>
		<Client Name="_TCPIPClient" Required="true" Internal="true"/>
		<Client Name="cConnectTimeout" Required="true" Internal="false" DefValue="MQTTCLIENT_CONNECT_TIMEOUT" Comment="Connect Timeout must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="cDisconnectTimeout" Required="true" Internal="false" DefValue="MQTTCLIENT_DISCONNECT_SEND_TIMEOUT" Comment="Disconnect Timeout must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="cMultitaskEnable" Required="true" Internal="false" Comment="Sets whether the MQTT Client uses the Cyclic Thread or attempts to create a Multitask thread for its tasks.&#13;&#10;1 - Use a Multitask Thread&#13;&#10;0 - Use the Cyclic Thread&#13;&#10;&#13;&#10;Client must be initialized."/>
		<Client Name="cPacketReceiveWatchdog" Required="true" Internal="false" DefValue="MQTTCLIENT_TCP_RECEIVE_WATCHDOG" Comment="The TCP Packet Receive Timeout must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="cPacketRetryCount" Required="true" Internal="false" DefValue="MQTTCLIENT_MAX_RERTYCOUNT" Comment="The Packet Rety Count must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="cPublishTimeout" Required="true" Internal="false" DefValue="MQTTCLIENT_PUBLISH_TIMEOUT" Comment="Publish Timeout must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="cSubscribeTimeout" Required="true" Internal="false" DefValue="MQTTCLIENT_SUBSCRIBE_TIMEOUT" Comment="Subscribe Timeout must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="cUnsubscribeTimeout" Required="true" Internal="false" DefValue="MQTTCLIENT_UNSUBSCRIBE_TIMEOUT" Comment="Unsubscribe Timeout must be specified on this client.&#13;&#10;The value must be initialized."/>
		<Client Name="IncomingPackets" Required="true" Internal="true"/>
		<Client Name="InflightMsgsCritSect" Required="true" Internal="true"/>
		<Client Name="MemoryHeap" Required="true" Internal="true"/>
		<Client Name="MQTTClientID" Required="true" Internal="true"/>
		<Client Name="Multitask" Required="false" Internal="false" Comment="Object Channel to the Multitask OS Interface.&#13;&#10;Client must not be connected."/>
		<Client Name="OutgoingPackets" Required="true" Internal="true"/>
		<Client Name="PublishCritSect" Required="true" Internal="true"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Object Channel to the SigCLib OS Interface.&#13;&#10;Client must not be connected."/>
		<Client Name="Stdlib" Required="false" Internal="false" Comment="Object Channel to the StdLib OS Interface.&#13;&#10;Client must not be connected."/>
		<Client Name="TCPIPClientInterface_MQTTClient" Required="true" Internal="true"/>
		<Client Name="Worker" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\lsl_st_syssernum.h" Include="true"/>
			<File Path=".\Class\MQTTClient\mqtt_client.h" Include="true"/>
			<File Path=".\Class\MQTTClient\MQTTClient_LogTexts.h" Include="true"/>
			<File Path=".\Class\MQTTClient\MQTTClient_en.pdf"/>
			<File Path=".\Class\MQTTClient\MQTTClient_de.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.5" Date="2021-05-27" Author="MehMar&#13;&#10;VelGer" Company="Sigmatek" Description="1. BugFix: When the connection is lost but the socket is not closed, the message queue builds up and is not emptied anymore.&#13;&#10;2. BugFix: The SessionPresent Information was not processed correctly, this has been corrected."/>
		<Dokumentation Revision="1.4" Date="2021-02-22" Author="MehMar" Company="Sigmatek" Description="1. Bugfix: Reconnect can hang if the host is an IP address."/>
		<Dokumentation Revision="1.31" Date="2021-01-15" Author="VelGer" Company="Sigmatek" Description="1. BugFix: The _TCPIPClient contained in the class has now been set to use the asynchronous thread as a standard.&#13;&#10;2. BugFix: The method (mqtt_username_pw_set) has been reworked so that it operates as expected (setting a username / password with length 0 is assumed to be no username / password).&#13;&#10;3. BugFix: When an error occured in the mqtt_publish() method it could occur that a Mutex was left active, this could result in a deadlock, this problem has now been corrected."/>
		<Dokumentation Revision="1.3" Date="2020-05-19" Author="MehMar" Company="Sigmatek" Description="1. Bugfix: If DNS requests take too long it might happen that a runtime exception occurs."/>
		<Dokumentation Revision="1.2" Date="2020-04-21" Author="VelGer" Company="Sigmatek" Description="1. BugFix: The global method mqtt_reconnect_delay_set() interpreted the input parameter values as milliseconds, even though they should be interpreted as seconds. This has been corrected.&#13;&#10;2. Improvement: Logging Texts have been reworked so that they are uniform throughout the MQTT Package.&#13;&#10;3. Improvement: A unique group and message number is now logged with each event to allow the user to uniquely identify the events from within the Application.&#13;&#10;4. Special: Overall comments in the Class have been improved.&#13;&#10;5. BugFix: If the TCP User Interface failed to initialize, an Access error could occur during the connection procedure. This has been corrected, an error message is logged, and the crash avoided."/>
		<Dokumentation Revision="1.1" Date="2020-03-05" Author="VelGer" Company="Sigmatek" Description="1. BugFix: TCP Watchdog was previously not active, this has now been activated.&#13;&#10;2. BugFix: A memory calculation error has been fixed in the method mqtt_max_inflight_messages_set().&#13;&#10;3. Improvement: Timeout values have been increased.&#13;&#10;4. Improvement: MemoryHandling for incoming and outgoing packets has been reworked, an Instance of _MemoryBubbles is now used for accessing memory functions.&#13;&#10;5. BugFix: A maximum of 2 incoming TCP Packets were processed per cycle, the handling has now been changed so that all messages are processed."/>
		<Dokumentation Revision="1.0" Date="2019-03-15" Author="VelGer" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
	<Network Name="MQTTClient">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_TCPIPClient"
				GUID       = "{FE83E919-1838-4B5A-929A-C83C582DC6C0}"
				Class      = "_TCPIPClient_MQTTClient"
				Position   = "(240,150)"
				Visualized = "true"
				Remotely   = "true"
				CyclicTime = "1 ms">
				<Channels>
					<Server Name="Control"/>
					<Server Name="SemaName01"/>
					<Server Name="SemaName02"/>
					<Server Name="SetPort"/>
					<Server Name="TaskName"/>
					<Client Name="_MultiTask"/>
					<Client Name="_StdLib"/>
					<Client Name="_TaskObjectControl"/>
					<Client Name="Config" Value="1"/>
					<Client Name="MaxConnections" Value="MQTTCLIENT_DEFAULT_MAX_CONNECTIONS"/>
					<Client Name="Port" Value="MQTTCLIENT_DEFAULT_PORT"/>
					<Client Name="SigCLib"/>
					<Client Name="SizeOfTXBuffer"/>
				</Channels>
			</Object>
			<Object
				Name       = "IncomingPackets"
				GUID       = "{6EEB9F94-2AC6-4DDA-8B1A-4026EE53FFA8}"
				Class      = "MQTTPacketQueue"
				Position   = "(240,840)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="MemoryHeap"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "InflightMsgsCritSect"
				GUID       = "{34B14D62-5043-48F5-859E-08DF557E9EB3}"
				Class      = "CriticalSection"
				Position   = "(990,1260)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "MemoryHeap"
				GUID       = "{F10EFC0A-399A-4F61-AE9E-E3994E3926E2}"
				Class      = "_MemoryBubbles"
				Position   = "(240,1170)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="_StdLib"/>
					<Client Name="AutoFree" Value="1"/>
					<Client Name="DefaultMark" Value="MQTTCLIENT_DEFAULT_MALLOC_MARK"/>
					<Client Name="DefaultSize" Value="MQTT_MESSAGEQUEUE_DATABLOCK_SIZE"/>
					<Client Name="MaxBubbles" Value="MEMORYHEAP_DEFAULT_MAX"/>
					<Client Name="SigCLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "MQTTClientID"
				GUID       = "{61DB40AD-0FE4-4B01-9112-BD32E59F5749}"
				Class      = "String"
				Position   = "(1140,570)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
			<Object
				Name       = "OutgoingPackets"
				GUID       = "{B279A921-1EC9-40DC-A03A-AB28C179A6AA}"
				Class      = "MQTTPacketQueue"
				Position   = "(990,840)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Client Name="MemoryHeap"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "PublishCritSect"
				GUID       = "{E278D096-F158-46A9-B0C6-F6E087E55D39}"
				Class      = "CriticalSection"
				Position   = "(990,1410)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "TCPIPClientInterface_MQTTClient"
				GUID       = "{CE96D194-9EE1-4F1D-845E-99906340AEF5}"
				Class      = "_TCPIPClientInterface_MQTTClient"
				Position   = "(960,150)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="ErrorCode"/>
					<Server Name="ErrorGroup"/>
					<Server Name="ErrorState"/>
					<Server Name="State"/>
					<Client Name="_TCPIPClient"/>
					<Client Name="cPort"/>
				</Channels>
			</Object>
			<Object
				Name           = "Worker"
				GUID           = "{235D2F6C-73A8-4FD4-9153-00BDBF12C0A5}"
				Class          = "MQTTBackgroundWorker"
				Position       = "(990,1110)"
				Visualized     = "false"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="CurrentState"/>
					<Client Name="SigCLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.TCPIPClientInterface_MQTTClient" Destination="TCPIPClientInterface_MQTTClient.ClassSvr"/>
			<Connection Source="this.IncomingPackets" Destination="IncomingPackets.ClassSvr"/>
			<Connection Source="this.OutgoingPackets" Destination="OutgoingPackets.ClassSvr"/>
			<Connection Source="this.MQTTClientID" Destination="MQTTClientID.Data"/>
			<Connection Source="this.ClientID" Destination="MQTTClientID.Data" Vertices="(2048,270),(1680,270),(1650,300),(1650,630),(1620,660),(1876,660),"/>
			<Connection Source="this._TCPIPClient" Destination="_TCPIPClient.Control"/>
			<Connection Source="TCPIPClientInterface_MQTTClient._TCPIPClient" Destination="_TCPIPClient.Control" Vertices="(960,240),(760,240),"/>
			<Connection Source="TCPIPClientInterface_MQTTClient.cPort" Destination="_TCPIPClient.SetPort" Vertices="(960,300),(930,300),(900,330),(900,450),(870,480),(760,480),"/>
			<Connection Source="this.MemoryHeap" Destination="MemoryHeap.ClassSvr"/>
			<Connection Source="IncomingPackets.MemoryHeap" Destination="MemoryHeap.ClassSvr" Vertices="(240,1050),(210,1050),(180,1080),(180,1110),(210,1140),(840,1140),(870,1170),(870,1230),(840,1260),(810,1260),"/>
			<Connection Source="OutgoingPackets.MemoryHeap" Destination="MemoryHeap.ClassSvr" Vertices="(990,1050),(900,1050),(870,1080),(870,1230),(840,1260),(810,1260),"/>
			<Connection Source="this.Worker" Destination="Worker.CurrentState"/>
			<Connection Source="this.InflightMsgsCritSect" Destination="InflightMsgsCritSect.ClassSvr"/>
			<Connection Source="this.PublishCritSect" Destination="PublishCritSect.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
MQTTClient : CLASS
	TYPE
	  bdMQTTClientStatus : BDINT
	  [
	    1 ThreadRunning,
	    2 Connected,
	    3 TaskActivate,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  t_bd_IsConnected : BDINT
	  [
	    1 SubscribeTimeout,
	    2 PublishTimeout,
	    3 UnsubscribeTimeout,
	    4 PacketRetryCount,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  t_e_ControlPacketTasks :
	  (
	    CPT_Init,
	    CPT_Clear,
	    CPT_GetPtr
	  )$UDINT;
	  t_e_Errors :
	  (
	    MQTTErr_Multitask_NoThread,
	    MQTTErr_Multitask_CreateThreadFail,
	    MQTTErr_Multitask_SuspendThreadFail,
	    MQTTErr_Multitask_MULTITASKLIB_NOMEM:=4294967195,
	    MQTTErr_Multitask_MULTITASKLIB_NOFCT:=4294967194,
	    MQTTErr_Multitask_MULTITASKLIB_FCTNOTINMEM:=4294967193,
	    MQTTErr_Multitask_MULTITASKLIB_WRONGPRIOR:=4294967192,
	    MQTTErr_Multitask_MULTITASKLIB_STACK:=4294967191,
	    MQTTErr_Multitask_MULTITASKLIB_NAME:=4294967190,
	    MQTTErr_Multitask_MULTITASKLIB_NAMEUSED:=4294967189,
	    MQTTErr_Multitask_MULTITASKLIB_HANDLE:=4294967188,
	    MQTTErr_Multitask_MULTITASKLIB_NOTALLOWED:=4294967187,
	    MQTTErr_Multitask_MULTITASKLIB_MESSAGESIZE:=4294967186,
	    MQTTErr_Multitask_MULTITASKLIB_DATA:=4294967185,
	    MQTTErr_Multitask_MULTITASKLIB_PTR:=4294967184,
	    MQTTErr_Multitask_MULTITASKLIB_TASKID:=4294967183,
	    MQTTErr_Multitask_MULTITASKLIB_NOTASK:=4294967182,
	    MQTTErr_Multitask_MULTITASKLIB_NOIFFNC:=4294967181,
	    MQTTErr_MQTT_CONN_PENDING:=99,
	    MQTTErr_MQTT_SUCCESS:=100,
	    MQTTErr_MQTT_NOMEM:=101,
	    MQTTErr_MQTT_PROTOCOL:=102,
	    MQTTErr_MQTT_INVAL:=103,
	    MQTTErr_MQTT_NO_CONN:=104,
	    MQTTErr_MQTT_CONN_REFUSED:=105,
	    MQTTErr_MQTT_NOT_FOUND:=106,
	    MQTTErr_MQTT_CONN_LOST:=107,
	    MQTTErr_MQTT_TLS:=108,
	    MQTTErr_MQTT_PAYLOAD_SIZE:=109,
	    MQTTErr_MQTT_NOT_SUPPORTED:=110,
	    MQTTErr_MQTT_AUTH:=111,
	    MQTTErr_MQTT_ACL_DENIED:=112,
	    MQTTErr_MQTT_UNKNOWN:=113,
	    MQTTErr_MQTT_ERRNO:=114,
	    MQTTErr_MQTT_EAI:=115,
	    MQTTErr_MQTT_PROXY:=116,
	    MQTTErr_MQTT_PLUGIN_DEFER:=117,
	    MQTTErr_MQTT_MALFORMED_UTF8:=118,
	    MQTTErr_MQTT_KEEPALIVE:=119,
	    MQTTErr_MQTT_LOOKUP:=120
	  )$DINT;
	  t_e_InflightMessages :
	  (
	    IM_Subscribe,
	    IM_Unsubscribe,
	    IM_Publish
	  )$UDINT;
	  t_e_InflightMsg_Ret :
	  (
	    IFM_Busy,
	    IFM_Done
	  )$UDINT;
	  t_e_MessageTxStates :
	  (
	    MTS_Data,
	    MTS_Payload,
	    MTS_Done
	  )$UDINT;
	  t_e_MQTTClientStates :  //! <Type Public="true" Name="t_e_MQTTClientStates"/>
	  (
	    MCS_Initialise,
	    MCS_Connect,
	    MCS_Connected,
	    MCS_Reconnect,
	    MCS_Disconnect,
	    MCS_Error
	  )$UDINT;
	  t_e_MQTTClientStates_Connect :
	  (
	    CS_DNSLookup,
	    CS_udToASCII,
	    CS_ConnectTCP,
	    CS_WaitForConnectTCP,
	    CS_BuildCONNECT,
	    CS_WaitForCONNACK,
	    CS_Finalize,
	    CS_ConnectionRejected,
	    CS_Error,
	    CS_WaitDNSLookup
	  )$UDINT;
	  t_e_MQTTClientStates_Disconnect :
	  (
	    DS_BuildPacket,
	    DS_WaitForSendConfirmation,
	    DS_DeleteConnection,
	    DS_Finalize
	  )$UDINT;
	  t_e_MQTTClientStates_Reconnect :
	  (
	    RS_Init,
	    RS_WaitForInterval,
	    RS_Reconnect
	  )$UDINT;
	  t_e_MQTTControlPackets :  //! <Type Public="true" Name="t_e_MQTTControlPackets"/>
	  (
	    MCP_CONNECT,
	    MCP_CONNACK,
	    MCP_PUBLISH,
	    MCP_PUBACK,
	    MCP_PUBREC,
	    MCP_PUBREL,
	    MCP_PUBCOMP,
	    MCP_SUBSCRIBE,
	    MCP_SUBACK,
	    MCP_UNSUBSCRIBE,
	    MCP_UNSUBACK,
	    MCP_PINGREQ,
	    MCP_PINGRESP,
	    MCP_DISCONNECT,
	    MCP_UNKNOWN
	  )$UDINT;
	  t_e_MQTTErrors :  //! <Type Public="true" Name="t_e_MQTTErrors"/>
	  (
	    MQTT_ERR_CONN_PENDING:=4294967295,
	    MQTT_ERR_SUCCESS:=0,
	    MQTT_ERR_NOMEM:=1,
	    MQTT_ERR_PROTOCOL:=2,
	    MQTT_ERR_INVAL:=3,
	    MQTT_ERR_NO_CONN:=4,
	    MQTT_ERR_CONN_REFUSED:=5,
	    MQTT_ERR_NOT_FOUND:=6,
	    MQTT_ERR_CONN_LOST:=7,
	    MQTT_ERR_TLS:=8,
	    MQTT_ERR_PAYLOAD_SIZE:=9,
	    MQTT_ERR_NOT_SUPPORTED:=10,
	    MQTT_ERR_AUTH:=11,
	    MQTT_ERR_ACL_DENIED:=12,
	    MQTT_ERR_UNKNOWN:=13,
	    MQTT_ERR_ERRNO:=14,
	    MQTT_ERR_EAI:=15,
	    MQTT_ERR_PROXY:=16,
	    MQTT_ERR_PLUGIN_DEFER:=17,
	    MQTT_ERR_MALFORMED_UTF8:=18,
	    MQTT_ERR_KEEPALIVE:=19,
	    MQTT_ERR_LOOKUP:=20,
	    MQTT_ERR_ALREADY_SUB:=21
	  )$INT;
	  t_e_SendMessageProcessStates :
	  (
	    MPS_WaitForMessage,
	    MPS_SendMessage
	  )$UDINT;
	  t_e_TCPRecvProcessStates :
	  (
	    TRS_WaitForMessage,
	    TRS_ReceiveMessage
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_Callback : STRUCT
	    pMethod : ^void;
	    pThis : ^void;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Callbacks : STRUCT
	    ConnectCallback : t_s_Callback;
	    ConnectWithFlagsCallback : t_s_Callback;
	    DisconnectCallback : t_s_Callback;
	    PublishCallback : t_s_Callback;
	    MessageCallback : t_s_Callback;
	    SubscribeCallback : t_s_Callback;
	    UnsubscribeCallback : t_s_Callback;
	    LogCallback : t_s_Callback;
	    LogWithDetailCallback : t_s_Callback;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConnectionData : STRUCT
	    aHostName : ARRAY [0..MQTTCLIENT_HOSTNAME_MAX_LEN-1] OF UINT;
	    bConnect : BOOL;
	    aIP : ARRAY [0..MQTTCLIENT_IP_MAX_LEN-1] OF CHAR;
	    dPort : DINT;
	    bTLS : BOOL;
	    udIPAddress : UDINT;
	    dTCPHandle : DINT;
	    aClientID : ARRAY [0..MQTT_PROT_MAX_CLIENTID_NAME_LEN] OF UINT;
	    WillData : STRUCT
	      aWillTopic : ARRAY [0..MQTTCLIENT_WILL_TOPIC_MAX_LEN] OF UINT;
	      aWillMessage : ARRAY [0..MQTTCLIENT_WILL_PAYLOAD_MAX_LEN] OF BYTE;
	      bWill : BOOL;
	      bWillRetain : BOOL;
	      usWillQoS : USINT;
	      udWillMessageLen : UDINT;
	    END_STRUCT;
	    aCACertPEMFile : ARRAY [0..MQTTCLIENT_CONNECT_MAX_FILENAME_LEN-1] OF CHAR;
	    aClientCertChainPEMFilename : ARRAY [0..MQTTCLIENT_CONNECT_MAX_FILENAME_LEN-1] OF CHAR;
	    aClientCertKeyPEMFilename : ARRAY [0..MQTTCLIENT_CONNECT_MAX_FILENAME_LEN-1] OF CHAR;
	    aKeyDecryptPwd : ARRAY [0..MQTTCLIENT_CONNECT_MAX_PASSWORD_LEN-1] OF CHAR;
	    KeepaliveData : STRUCT
	      udLastPINGRESP : UDINT;
	      udLastPINGREQ : UDINT;
	      uiKeepAlive : UINT;
	    END_STRUCT;
	    AuthData : STRUCT
	      aUsername : ARRAY [0..MQTTCLIENT_CONNECT_MAX_USERNAME_LEN] OF UINT;
	      aPassword : ARRAY [0..MQTTCLIENT_CONNECT_MAX_PASSWORD_LEN] OF BYTE;
	      bUsername : BOOL;
	      bPassword : BOOL;
	      udPassLen : UDINT;
	    END_STRUCT;
	    dDisconnectMsgID : DINT;
	    ReconnectData : STRUCT
	      udReconnectMin : UDINT;
	      udReconnectMax : UDINT;
	      bExponential : BOOL;
	      udExponent : UDINT;
	      udCurrentDelay : UDINT;
	    END_STRUCT;
	    iMid : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_IncomingMessageData : STRUCT
	    dID : DINT;
	    MsgType : t_e_MQTTControlPackets;
	    udLen : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_InflightMessage : STRUCT
	    MsgType : t_e_InflightMessages;
	    Direction :
	    (
	      MD_Incoming,
	      MD_Outgoing
	    )$UDINT;
	    MsgState : UDINT;
	    iPacketID : INT;
	    bDup : BOOL;
	    iQoS : INT;
	    bRetain : BOOL;
	    bRemove : BOOL;  //! <Type Comment="This bit is set if the message can be removed, (finished processing). The message is then removed in the method InflightMsgs_ProcessQueue()." Name="t_s_InflightMessage.bRemove"/>
	    aTopic : ARRAY [0..MQTTCLIENT_TOPIC_MAX_LEN-1] OF UINT;
	    pPayload : ^void;
	    udPayloadLen : UDINT;
	    dPacketQueueID : DINT;
	    dHoldPacketQueueID : DINT;
	    udTimestamp : UDINT;
	    udRetrycount : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_InflightMsgs : STRUCT
	    udInflightMsgs : UDINT;
	    udMaxInflightMsgs : UDINT;
	    InflightMsgs : t_s_InflightMessage;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_MQTTMessage : STRUCT  //! <Type Public="true" Name="t_s_MQTTMessage"/>
	    mid : INT;  //! <Type Comment="ID of the message" Name="t_s_MQTTMessage.mid"/>
	    topic : ^UINT;  //! <Type Comment="Pointer to the topic name" Name="t_s_MQTTMessage.topic"/>
	    payload : ^void;  //! <Type Comment="Pointer to the data" Name="t_s_MQTTMessage.payload"/>
	    payloadlen : UDINT;  //! <Type Comment="Size of the data" Name="t_s_MQTTMessage.payloadlen"/>
	    qos : INT;  //! <Type Comment="Quality of Service" Name="t_s_MQTTMessage.qos"/>
	    bRetain : BOOL;  //! <Type Comment="Data Retained (true or false)" Name="t_s_MQTTMessage.bRetain"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_MultitaskData : STRUCT
	    ThreadHandle : MT_TASKHANDLE;
	    aTaskName : ARRAY [0..MQTTCLIENT_MULTITASK_TASKNAME_MAXLEN-1] OF CHAR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_OutgoingMessageData : STRUCT
	    ProcessState : t_e_SendMessageProcessStates;
	    pSend : ^void;
	    Message : MQTTPacketQueue::t_s_Packet;
	    dMessageID : DINT;
	    MessageState : t_e_MessageTxStates;  //! <Type Comment="FALSE : Data&#13;&#10;TRUE : Payload" Name="t_s_OutgoingMessageData.MessageState"/>
	    pCBThis : ^void;
	    pCBMeth : ^void;
	    MsgType : DINT;
	    Direction : DINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_Statuses : STRUCT
	    Connect : t_e_MQTTClientStates_Connect;
	    Disconnect : t_e_MQTTClientStates_Disconnect;
	    Reconnect : t_e_MQTTClientStates_Reconnect;
	  END_STRUCT;
#pragma pack(pop)
	  t_s_TCPPacket : ARRAY [0..MQTTCLIENT_LASALOS_MAX_TCP_SIZE-1] OF BYTE;
#pragma pack(push, 1)
	  t_s_TCPRecvMsgData : STRUCT
	    ProcessState : t_e_TCPRecvProcessStates;
	    udLen : DINT;
	    dQueueID : DINT;
	    dID : DINT;
	    udMsgTS : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	MQTTClientState 	: SvrChCmd_t_e_MQTTClientStates_PTofCls_MQTTClient;
	ClientID 	: SvrChCmd_UDINT;
	CleanSession 	: SvrCh_DINT;
	SessionPresent 	: SvrCh_DINT;
  //Clients:
	cMultitaskEnable 	: CltCh_DINT;
	Multitask 	: CltChCmd__MultiTask;
	SigCLib 	: CltChCmd_SigCLib;
	Stdlib 	: CltChCmd__StdLib;
	MQTTClientID 	: CltChCmd_String;
	IncomingPackets 	: CltChCmd_MQTTPacketQueue;
	OutgoingPackets 	: CltChCmd_MQTTPacketQueue;
	cConnectTimeout 	: CltCh_UDINT;
	cDisconnectTimeout 	: CltCh_UDINT;
	cSubscribeTimeout 	: CltCh_UDINT;
	cPublishTimeout 	: CltCh_UDINT;
	cUnsubscribeTimeout 	: CltCh_UDINT;
	cPacketReceiveWatchdog 	: CltCh_UDINT;
	cPacketRetryCount 	: CltCh_UDINT;
	TCPIPClientInterface_MQTTClient 	: CltChCmd__TCPIPClientInterface_MQTTClient;
	_TCPIPClient 	: CltChCmd__TCPIPClient_MQTTClient;
	MemoryHeap 	: CltChCmd__MemoryBubbles;
	Worker 	: CltChCmd_MQTTBackgroundWorker;
	InflightMsgsCritSect 	: CltChCmd_CriticalSection;
	PublishCritSect 	: CltChCmd_CriticalSection;
  //Variables:
		udInitCounter 	: UDINT;
		States 	: t_s_Statuses;
		MultitaskDataStruct 	: t_s_MultitaskData;
		CallbacksStruct 	: t_s_Callbacks;
		ConnectionDataStruct 	: t_s_ConnectionData;
		TxPktDataStruct 	: t_s_OutgoingMessageData;
		RxPktDataStruct 	: t_s_IncomingMessageData;
		TCPRecvDataStruct 	: t_s_TCPRecvMsgData;
		TCPPacket 	: t_s_TCPPacket;
		ClientStatus 	: bdMQTTClientStatus;
		udTimeoutTS 	: UDINT;
		pCtrlPkt2 	: ^void;
		pCtrlPkt1 	: ^void;
		pPLCInfo 	: ^LSL_PLCINFO;
		pISysSernum 	: ^LSL_ISYSSERNUM;
		pInFlightMsgs 	: ^t_s_InflightMsgs;
		ConnectedClients 	: t_bd_IsConnected;
		dPara1Temp 	: DINT;
		dPara2Temp 	: DINT;
		dPara3Temp 	: DINT;
		lsl_tcp_user 	: ^LSL_TCP_USER;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION InflightMsgs_AddMsg
		VAR_INPUT
			MsgType 	: t_e_InflightMessages;
			bOutgoing 	: BOOL;
			pMid 	: ^INT;
			iQoS 	: INT;
			bRetain 	: BOOL;
			pTopic 	: ^UINT;
			pPayload 	: ^void;
			udPayloadLen 	: UDINT;
			dQueueID 	: DINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Incoming
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Incoming_QoS0
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Incoming_QoS1
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Incoming_QoS2
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Outgoing
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Outgoing_QoS0
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Outgoing_QoS1
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Publish_Outgoing_QoS2
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Subscribe
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_ProcessQueue_Unsubscribe
		VAR_INPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR
		VAR_OUTPUT
			retCode 	: t_e_InflightMsg_Ret;
		END_VAR;
	
	FUNCTION InflightMsgs_RemoveMsg
		VAR_INPUT
			udMsg 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION InflightMsgs_Clear;
	
	FUNCTION KeepAlive_ProcessPing;
	
	FUNCTION Log_CreateLog
		VAR_INPUT
			usLevel 	: USINT;
			dMsgGroup 	: DINT;
			dMsgNbr 	: DINT;
			pMsg 	: ^CHAR;
			pPara1 	: ^DINT;
			pPara2 	: ^DINT;
			pPara3 	: ^DINT;
			pPara4 	: ^DINT;
		END_VAR;
	
	FUNCTION Log_GetText_ControlPackets
		VAR_INPUT
			ControlPacket 	: t_e_MQTTControlPackets;
		END_VAR
		VAR_OUTPUT
			pChar 	: ^CHAR;
		END_VAR;
	
	FUNCTION Log_GetText_MQTTClientState
		VAR_INPUT
			ClientState 	: t_e_MQTTClientStates;
		END_VAR
		VAR_OUTPUT
			pChar 	: ^CHAR;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_CONNECT
		VAR_OUTPUT
			dPcktID 	: DINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_DISCONNECT;
	
	FUNCTION MQP_ControlPacket_PINGREQ;
	
	FUNCTION MQP_ControlPacket_PINGRESP;
	
	FUNCTION MQP_ControlPacket_PUBACK
		VAR_INPUT
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			dPacketID 	: DINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_PUBCOMP
		VAR_INPUT
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			dPacketID 	: DINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_PUBLISH
		VAR_INPUT
			bDup 	: BOOL;
			iQoS 	: INT;
			bRetain 	: BOOL;
			pTopic 	: ^UINT;
			iMid 	: INT;
			pPayload 	: ^void;
			udPayloadLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			dPacketID 	: DINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_PUBREC
		VAR_INPUT
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			dPacketID 	: DINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_PUBREL
		VAR_INPUT
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			dPacketID 	: DINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_SUBSCRIBE
		VAR_INPUT
			iMid 	: INT;
			pTopic 	: ^UINT;
			sQoS 	: SINT;
		END_VAR;
	
	FUNCTION MQP_ControlPacket_UNSUBSCRIBE
		VAR_INPUT
			iMid 	: INT;
			pTopic 	: ^UINT;
		END_VAR;
	
	FUNCTION MQP_ControlPackets
		VAR_INPUT
			usPacket 	: USINT;
			CPTask 	: t_e_ControlPacketTasks;
		END_VAR
		VAR_OUTPUT
			pPacket 	: ^void;
		END_VAR;
	
	FUNCTION MQP_DataToMQTTPayload
		VAR_INPUT
			pData 	: ^void;
			udDataLen 	: UDINT;
			pMQTTPayload 	: ^void;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_FixedHeader
		VAR_INPUT
			pData 	: ^void;
			HeaderType 	: t_e_MQTTControlPackets;
			udRemainingLen 	: UDINT;
			sQoS 	: SINT;
			bDUP 	: BOOL;
			bRetain 	: BOOL;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_DecRemLen
		VAR_INPUT
			pData 	: ^void;
			pValue 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			udBytes 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_EncRemLen
		VAR_INPUT
			udRemainingLen 	: UDINT;
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			udBytes 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_GetDup
		VAR_INPUT
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			bDup 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_GetLen
		VAR_INPUT
			pData 	: ^void;
			pLen 	: ^UDINT;
		END_VAR
		VAR_OUTPUT
			udBytes 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_GetQoS
		VAR_INPUT
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			iQoS 	: INT;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_GetRet
		VAR_INPUT
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			bRet 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_FixedHeader_GetType
		VAR_INPUT
			pData 	: ^void;
		END_VAR
		VAR_OUTPUT
			MsgType 	: t_e_MQTTControlPackets;
		END_VAR;
	
	FUNCTION MQP_Payload_CONNECT
		VAR_INPUT
			pData 	: ^void;
			pClientID 	: ^UINT;
			pWillTopic 	: ^UINT;
			pWillMessage 	: ^void;
			udWillMessageLen 	: UDINT;
			pUserName 	: ^UINT;
			pPassword 	: ^BYTE;
			udPassLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_Payload_SUBSCRIBE
		VAR_INPUT
			pData 	: ^void;
			pTopic 	: ^UINT;
			sQoS 	: SINT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_Payload_UNSUBSCRIBE
		VAR_INPUT
			pData 	: ^void;
			pTopic 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_Process_CONNACK
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PINGREQ
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PINGRESP
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PUBACK
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PUBCOMP
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PUBLISH
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
			iQoS 	: INT;
			bDup 	: BOOL;
			bRetain 	: BOOL;
			dQueueID 	: DINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PUBREC
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_PUBREL
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_SUBACK
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Process_UNSUBACK
		VAR_INPUT
			pData 	: ^void;
			udLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
	
	FUNCTION MQP_Str16ToMQTTString
		VAR_INPUT
			pStr16 	: ^UINT;
			pMQTTStr 	: ^void;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_TurnBytes
		VAR_INPUT
			usBytes 	: USINT;
			pData 	: ^void;
		END_VAR;
	
	FUNCTION MQP_UTF8ByteLen
		VAR_INPUT
			pUTF8 	: ^void;
		END_VAR
		VAR_OUTPUT
			udLen 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_CONNECT
		VAR_INPUT
			pData 	: ^void;
			bUserName 	: BOOL;
			bPassword 	: BOOL;
			bWillRetain 	: BOOL;
			usWillQoS 	: USINT;
			bWill 	: BOOL;
			bCleanSession 	: BOOL;
			uiKeepAlive 	: UINT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_PUBCOMP
		VAR_INPUT
			pData 	: ^void;
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_PUBLISH
		VAR_INPUT
			pData 	: ^void;
			pTopic 	: ^UINT;
			iMid 	: INT;
			iQoS 	: INT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_PUBREC
		VAR_INPUT
			pData 	: ^void;
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_PUBREL
		VAR_INPUT
			pData 	: ^void;
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_SUBSCRIBE
		VAR_INPUT
			pData 	: ^void;
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQP_VarHeader_UNSUBSCRIBE
		VAR_INPUT
			pData 	: ^void;
			iMid 	: INT;
		END_VAR
		VAR_OUTPUT
			udBytesWritten 	: UDINT;
		END_VAR;
	
	FUNCTION MQTTInit;
	
	FUNCTION MQTTTask;
	
	FUNCTION MQTTTask_Connect;
	
	FUNCTION MQTTTask_Disconnect;
	
	FUNCTION MQTTTask_Reconnect;
	
	FUNCTION PacketQueue_MsgSent
		VAR_INPUT
			MsgType 	: DINT;
			dDirection 	: DINT;
			dID 	: DINT;
		END_VAR;
	
	FUNCTION PacketQueue_MsgSent_Callback
		VAR_INPUT
			pThis 	: ^void;
			dID 	: DINT;
			MsgType 	: DINT;
			dDirection 	: DINT;
		END_VAR;
	
	FUNCTION PacketQueue_ProcessIncoming;
	
	FUNCTION PacketQueue_ProcessOutgoing;
	
	FUNCTION TCP_DataReceive
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION TCP_DataReceive_Callback
		VAR_INPUT
			pThis 	: ^void;
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION TCP_ErrorOccurred
		VAR_INPUT
			TCPFSM 	: _TCPIPClient::_FSM_TCPIP_CLIENT;
			ErrorGroup 	: DINT;
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION TCP_ErrorOccurred_Callback
		VAR_INPUT
			pThis 	: ^void;
			TCPFSM 	: _TCPIPClient::_FSM_TCPIP_CLIENT;
			ErrorGroup 	: DINT;
			ErrorCode 	: DINT;
		END_VAR;
	
	FUNCTION TCP_WatchDogTask;
	
	FUNCTION __CDECL ThreadCall;
				//! <Function Comment="This method Initialises the MQTT Instance Memory &amp; Thread before running." Name="mqtt_reinitialise"/>
	FUNCTION GLOBAL mqtt_reinitialise
		VAR_INPUT
			id 	: ^UINT;
			clean_session 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_connect_callback_set"/>
	FUNCTION GLOBAL mqtt_connect_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_connect 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_connect_with_flags_callback_set"/>
	FUNCTION GLOBAL mqtt_connect_with_flags_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_connect_with_flags 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_disconnect_callback_set"/>
	FUNCTION GLOBAL mqtt_disconnect_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_disconnect 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_publish_callback_set"/>
	FUNCTION GLOBAL mqtt_publish_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_publish 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_message_callback_set"/>
	FUNCTION GLOBAL mqtt_message_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_message 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_subscribe_callback_set"/>
	FUNCTION GLOBAL mqtt_subscribe_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_subscribe 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_unsubscribe_callback_set"/>
	FUNCTION GLOBAL mqtt_unsubscribe_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_unsubscribe 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_xxxx: Pointer to the Callback method (See documentation for description)." Name="mqtt_log_callback_set"/>
	FUNCTION GLOBAL mqtt_log_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_log 	: ^void;
		END_VAR;
				//! <Function Comment="Called during MCS_Initialise to set the callback for runtime.&#13;&#10;pThis: Passed back to the calling class so that the class can enter its own instance&#13;&#10;on_log_with_detail: Pointer to the method to be executed." Name="mqtt_log_with_detail_callback_set"/>
	FUNCTION GLOBAL mqtt_log_with_detail_callback_set
		VAR_INPUT
			pThis 	: ^void;
			on_log_with_detail 	: ^void;
		END_VAR;
				//! <Function Comment="Set the usename &amp; password to connect to the broker with.&#13;&#10;The username must be of type String16.&#13;&#10;The password can be a byte array or any form of string (Broker dependent).&#13;&#10;&#13;&#10;Possible combinations:&#13;&#10;- username &amp; password&#13;&#10;- username" Name="mqtt_username_pw_set"/>
	FUNCTION GLOBAL mqtt_username_pw_set
		VAR_INPUT
			username 	: ^UINT;
			password 	: ^BYTE;
			udPassLen 	: UDINT;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method to set the will to be used during next connection attempt.&#13;&#10;&#13;&#10;Topic must be String16 format string (same rules as for publish topic).&#13;&#10;The payload can be any form of data (block of memory)." Name="mqtt_will_set"/>
	FUNCTION GLOBAL mqtt_will_set
		VAR_INPUT
			topic 	: ^UINT;
			payloadLen 	: UDINT;
			payload 	: ^void;
			qos 	: INT;
			retain_will 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method to clear the will data set with mqtt_will_set()." Name="mqtt_will_clear"/>
	FUNCTION GLOBAL mqtt_will_clear
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method to set the TLS data to use during the next connection attempt.&#13;&#10;If the input to this method is valid, the MQTTClient will attempt to setup a TLS connection to the broker.&#13;&#10;&#13;&#10;Only available on Salamander, calling this method on RTK will cause a connection failure.&#13;&#10;&#13;&#10;cafile, certfile &amp; keyfile are pointers to strings containing the names of the respective files&#13;&#10;placed in the LSLSYS/SSL/ directory. (Excluding path).&#13;&#10;&#13;&#10;pw is a pointer to a string containing the password to decode the keyfile.&#13;&#10;&#13;&#10;See the OS_SSL documentation for further information on establishing an SSL/TLS connection.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_INVAL - Input value incorrect, pointer set and the length of the string beind the pointer is not OK.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully set." Name="mqtt_tls_set"/>
	FUNCTION GLOBAL mqtt_tls_set
		VAR_INPUT
			cafile 	: ^CHAR;
			certfile 	: ^CHAR;
			keyfile 	: ^CHAR;
			pw 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method used to set the reconnect delay options.&#13;&#10;&#13;&#10;Initial reconnect is made at the interval set to the reconnect_delay value, subsequent reconnects take longer until the upper interval limit specified in reconnect_delay_max is reached.&#13;&#10;The reconnect interval can be increased by either exponential / linear operation.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_INVAL - Input value incorrect, limits equal or inversed.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully set." Name="mqtt_reconnect_delay_set"/>
	FUNCTION GLOBAL mqtt_reconnect_delay_set
		VAR_INPUT
			reconnect_delay 	: UINT;
			reconnect_delay_max 	: UINT;
			reconnect_exponential_delay 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method to set the maximum number of inflight messages to keep in the queue.&#13;&#10;Minimum value determined by define (default 20).&#13;&#10;The number of inflight messages are limited by the amount of memory availbale in the CPU.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_INVAL - Input value incorrect:&#13;&#10;- max_inflight_msgs too low&#13;&#10;- MQTTClientInterface &lt;&gt; MCS_initialise.&#13;&#10;- Inflight messages not initialised internally.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_NOMEM - Not enough memory available.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully set." Name="mqtt_max_inflight_messages_set"/>
	FUNCTION GLOBAL mqtt_max_inflight_messages_set
		VAR_INPUT
			max_inflight_messages 	: INT;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method used to start the loop execution of the Client instance." Name="mqtt_loop_start"/>
	FUNCTION GLOBAL mqtt_loop_start
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method used to stop the loop execution of the Client instance." Name="mqtt_loop_stop"/>
	FUNCTION GLOBAL mqtt_loop_stop
		VAR_INPUT
			force 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method used to establish the connection to the broker.&#13;&#10;&#13;&#10;Properties for the connection must be set before calling this method using the methods:&#13;&#10;- mqtt_xxxxx_callback_set()&#13;&#10;- mqtt_username_pw_set()&#13;&#10;- mqtt_will_set()&#13;&#10;- mqtt_tls_set()&#13;&#10;&#13;&#10;retCode = MQTT_ERR_INVAL - Input value error:&#13;&#10;- Pointer host = NIL.&#13;&#10;- String behind pointer host too long.&#13;&#10;- Value passed to port = 0.&#13;&#10;- Value set to keepalive &lt; 0.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully started connection procedure." Name="mqtt_connect_async"/>
	FUNCTION GLOBAL mqtt_connect_async
		VAR_INPUT
			host 	: ^UINT;
			port 	: INT;
			keepalive 	: INT;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method called to initiate reconnect procedure.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_INVAL - Incorrect Client State:&#13;&#10;- MQTTClientState &lt;&gt; MCS_Connected.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully started the reconnect procedure." Name="mqtt_reconnect_async"/>
	FUNCTION GLOBAL mqtt_reconnect_async
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method must be called to disconnect from the broker.&#13;&#10;&#13;&#10;retCode = MQTT_ERR_NO_CONN - Not connected.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully started the disconnect procedure." Name="mqtt_disconnect"/>
	FUNCTION GLOBAL mqtt_disconnect
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method called to publish data to a specified topic:&#13;&#10;&#13;&#10;Input values:&#13;&#10;mid - ^INT - The assigned mid is written to the memory that the pointer points to. This is not necesarry for operation but affords the possibility to debug the connection / communication.&#13;&#10;topic - ^UINT - Pointer to the String16 formatted string containing the topic to subscribe to. &#13;&#10;  - Max Len = Define (1024).&#13;&#10;  - No Wildcards allowable.&#13;&#10;payloadLen - UDINT - Length of the payload in bytes-&#13;&#10;  - Max Len = 256MB&#13;&#10;payload - ^void - Pointer to the payload memory to transfer.&#13;&#10;qos - INT - QoS (Quality of Service) to publish the message with, guaranteed delivery:&#13;&#10;  - 0 (Fire &amp; Forget).&#13;&#10;  - 1 (Delivered atleast once).&#13;&#10;  - 2 (Delivered only once).&#13;&#10;retain_pub - BOOL - Flag indicating whether the message should be retained on the broker.&#13;&#10;&#13;&#10;Return codes:&#13;&#10;retCode = MQTT_ERR_INVAL - Input value error:&#13;&#10;  - Pointer mid = NIL&#13;&#10;  - Pointer topic = NIL&#13;&#10;  - qos &lt; 0 / qos &gt; 2&#13;&#10;retCode = MQTT_ERR_NO_CONN - Connection Error:&#13;&#10;  - No Connection / Not Reconnecting.&#13;&#10;retCode = MQTT_ERR_NOMEM - Out of Memory Error:&#13;&#10;  - All Inflight message slots are used.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully added the publish request to the Inflight Message Queue." Name="mqtt_publish"/>
	FUNCTION GLOBAL mqtt_publish
		VAR_INPUT
			mid 	: ^INT;
			topic 	: ^UINT;
			payloadLen 	: UDINT;
			payload 	: ^void;
			qos 	: INT;
			retain_pub 	: BOOL;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method called to subscribe to a topic(s):&#13;&#10;&#13;&#10;Input values:&#13;&#10;mid - ^INT - The assigned mid is written to the memory that the pointer points to. This is not necesarry for operation but affords the possibility to debug the connection / communication.&#13;&#10;subscribe - ^UINT - Pointer to the String16 formatted string containing the topic to subscribe to. &#13;&#10;  - Max Len = Define (1024).&#13;&#10;  - Wildcards allowable.&#13;&#10;    - # - Subscribe to all subsequent topics.&#13;&#10;    - + - Subscribe to all topics that match the filer specified with +.&#13;&#10;qos - INT - QoS (Quality of Service) to subscribe to the topic with, guaranteed delivery:&#13;&#10;  - 0 (Fire &amp; Forget).&#13;&#10;  - 1 (Delivered atleast once).&#13;&#10;  - 2 (Delivered only once).&#13;&#10;&#13;&#10;Return codes:&#13;&#10;retCode = MQTT_ERR_INVAL - Input value error:&#13;&#10;  - Pointer mid = NIL&#13;&#10;  - Pointer subscribe = NIL&#13;&#10;  - qos &lt; 0 / qos &gt; 2&#13;&#10;retCode = MQTT_ERR_NO_CONN - Connection Error:&#13;&#10;  - No Connection / Not Reconnecting.&#13;&#10;retCode = MQTT_ERR_NOMEM - Out of Memory Error:&#13;&#10;  - All Inflight message slots are used.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully added the subscribe request to the Inflight Message Queue." Name="mqtt_subscribe"/>
	FUNCTION GLOBAL mqtt_subscribe
		VAR_INPUT
			mid 	: ^INT;
			subscribe 	: ^UINT;
			qos 	: INT;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method used to unsubscribe from a subscribed topic.&#13;&#10;&#13;&#10;Input Values:&#13;&#10;mid - ^INT - The assigned mid is written to the memory that the pointer points to. This is not necesarry for operation but affords the possibility to debug the connection / communication.&#13;&#10;unsub - ^UINT - Pointer to the String16 formatted string containing the topic to unsubscribe from. &#13;&#10;&#13;&#10;Return Codes:&#13;&#10;retCode = MQTT_ERR_INVAL - Input value error.&#13;&#10;  - Pointer mid = NIL.&#13;&#10;  - Pointer unsub = NIL.&#13;&#10;  - String behind the pointer unsub &gt; Define (1024).&#13;&#10;retCode = MQTT_ERR_NO_CONN - MQTT Connection Error.&#13;&#10;  - No Connection / No reconnection occurring.&#13;&#10;retCode = MQTT_ERR_NOMEM - Memory Error.&#13;&#10;  - No Inflight Message Slots available.&#13;&#10;retCode = MQTT_ERR_SUCCESS - Successfully added the Unsubscribe request to the Inflight Message Queue." Name="mqtt_unsubscribe"/>
	FUNCTION GLOBAL mqtt_unsubscribe
		VAR_INPUT
			mid 	: ^INT;
			unsub 	: ^UINT;
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Method to query the MQTT Version." Name="mqtt_lib_version"/>
	FUNCTION GLOBAL mqtt_lib_version
		VAR_INPUT
			major 	: ^INT;
			minor 	: ^INT;
			revision 	: ^INT;
		END_VAR;
				//! <Function Comment="CAUTION: This functioin is for internal use only.&#13;&#10;&#13;&#10;This function passes the MallocV1() call on to the MQTT-Internal MemoryHeap Management." Name="MallocV1"/>
	FUNCTION GLOBAL MallocV1
		VAR_INPUT
			size0 	: UDINT;
			mark0 	: USINT;
		END_VAR
		VAR_OUTPUT
			pUser 	: ^void;
		END_VAR;
				//! <Function Comment="CAUTION: This functioin is for internal use only.&#13;&#10;&#13;&#10;This function passes the Free() call on to the MQTT-Internal MemoryHeap Management." Name="Free"/>
	FUNCTION GLOBAL Free
		VAR_INPUT
			mptr 	: ^void;
		END_VAR;
				//! <Function Comment="Callback function which is used to asynchronously resolve a hostname via DNS. An error is shown as IP address of 0xFFFFFFFF." Name="Callback_DNS_Lookup_Async"/>
	FUNCTION GLOBAL Callback_DNS_Lookup_Async
		VAR_INPUT
			ip 	: UDINT;			//! <Variable Comment="The UDINT representation of the IP address which was resolved. In case of an error, the function is called with the value 0xFFFFFFFF." Name="Callback_DNS_Lookup_Async.ip"/>
		END_VAR;
	
	FUNCTION InflightMsgs_GetMsgByMid
		VAR_INPUT
			MsgType 	: t_e_InflightMessages;
			mid 	: INT;
			Direction 	: DINT;
		END_VAR
		VAR_OUTPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR;
	
	FUNCTION InflightMsgs_GetMsgByPacketQueueID
		VAR_INPUT
			MsgType 	: t_e_InflightMessages;
			ID 	: DINT;
			Direction 	: DINT;
		END_VAR
		VAR_OUTPUT
			pMsg 	: ^t_s_InflightMessage;
		END_VAR;
	
	FUNCTION Counters_GetNextMID
		VAR_OUTPUT
			iMid 	: INT;
		END_VAR;
				//! <Function Comment="This method can be used to remove an inflight message that has not been published yet (OnPublish callback has not been executed for the message yet).&#13;&#10;Caution: This method may only be called from the Cyclic Thread." Name="mqtt_publish_cancel"/>
	FUNCTION GLOBAL mqtt_publish_cancel
		VAR_INPUT
			mid 	: INT;			//! <Variable Comment="Message ID of the message to be removed.&#13;&#10;See: mqtt_publish() mid parameter." Name="mqtt_publish_cancel.mid"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;			//! <Variable Comment="Result of the operation Possible Values:&#13;&#10;MQTT_ERR_SUCCESS - The message was found and set to be removed.&#13;&#10;MQTT_ERR_NOT_FOUND - The message could not be found." Name="mqtt_publish_cancel.retCode"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClientID::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClientID::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _MemoryBubbles
#pragma using _TCPIPClient_MQTTClient
#pragma using _TCPIPClientInterface_MQTTClient
#pragma using CriticalSection
#pragma using MQTTBackgroundWorker
#pragma using MQTTPacketQueue
#pragma using String
#pragma usingLtd _MultiTask
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MQTTClient::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MQTTCLIENT
1$UINT, 5$UINT, (SIZEOF(::MQTTClient))$UINT, 
4$UINT, 20$UINT, 0$UINT, 
TO_UDINT(1836049339), "MQTTClient", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MQTTClient.MQTTClientState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(1690459759), "MQTTClientState", 
(::MQTTClient.ClientID.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(3115012432), "ClientID", 
(::MQTTClient.CleanSession.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(528144264), "CleanSession", 
(::MQTTClient.SessionPresent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2160867824), "SessionPresent", 
//Clients:
(::MQTTClient.cMultitaskEnable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2637594962), "cMultitaskEnable", 
(::MQTTClient.Multitask.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3505031941), "Multitask", TO_UDINT(2641766936), "_MultiTask", 1$UINT, 1$UINT, 
(::MQTTClient.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::MQTTClient.Stdlib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(584375759), "Stdlib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::MQTTClient.MQTTClientID.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(803326692), "MQTTClientID", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::MQTTClient.IncomingPackets.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(130050413), "IncomingPackets", TO_UDINT(4175763163), "MQTTPacketQueue", 1$UINT, 2$UINT, 
(::MQTTClient.OutgoingPackets.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2611271075), "OutgoingPackets", TO_UDINT(4175763163), "MQTTPacketQueue", 1$UINT, 2$UINT, 
(::MQTTClient.cConnectTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2610202812), "cConnectTimeout", 
(::MQTTClient.cDisconnectTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3799960644), "cDisconnectTimeout", 
(::MQTTClient.cSubscribeTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(953818992), "cSubscribeTimeout", 
(::MQTTClient.cPublishTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3482395436), "cPublishTimeout", 
(::MQTTClient.cUnsubscribeTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2802426798), "cUnsubscribeTimeout", 
(::MQTTClient.cPacketReceiveWatchdog.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3979397108), "cPacketReceiveWatchdog", 
(::MQTTClient.cPacketRetryCount.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2830960695), "cPacketRetryCount", 
(::MQTTClient.TCPIPClientInterface_MQTTClient.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(191478651), "TCPIPClientInterface_MQTTClient", TO_UDINT(1222095338), "_TCPIPClientInterface_MQTTClient", 1$UINT, 0$UINT, 
(::MQTTClient._TCPIPClient.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1778057824), "_TCPIPClient", TO_UDINT(2164437777), "_TCPIPClient_MQTTClient", 1$UINT, 0$UINT, 
(::MQTTClient.MemoryHeap.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3266143373), "MemoryHeap", TO_UDINT(217061216), "_MemoryBubbles", 1$UINT, 0$UINT, 
(::MQTTClient.Worker.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1867151588), "Worker", TO_UDINT(2139750182), "MQTTBackgroundWorker", 1$UINT, 2$UINT, 
(::MQTTClient.InflightMsgsCritSect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3899248848), "InflightMsgsCritSect", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
(::MQTTClient.PublishCritSect.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1712410361), "PublishCritSect", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_MQTTClient 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MQTTClient] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MQTTClient::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_MQTTClient, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	MQTTClientState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF MQTTClientState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ClientID.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #ClientID::Read();
	vmt.CmdTable.Write		:= #ClientID::Write();
	ClientID.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClientID.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CleanSession.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF CleanSession.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
//================================================================================================================================================================
//-------------------------------------------------------------------CALLBACK PROTOTYPES--------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MessageSentCallback        VAR_INPUT pThis : ^void; dID      : DINT;                         MsgType : DINT; dDirection : DINT;                                                                                                                                  END_VAR;
FUNCTION OnLog                      VAR_INPUT pThis : ^void; level    : INT;                          pStr      : ^CHAR;                                                                                                                END_VAR;
FUNCTION OnLog_WithDetail           VAR_INPUT pThis : ^void; usLevel 	: USINT;                        dMsgGroup : DINT;   dMsgNbr 	  : DINT;   pMsg  : ^CHAR;  pPara1  : ^DINT;  pPara2  : ^DINT;  pPara3  : ^DINT;  pPara4  : ^DINT;  udClient : UDINT; END_VAR;
FUNCTION OnConnect                  VAR_INPUT pThis : ^void; retCode  : INT;                                                                                                                                                            END_VAR;
FUNCTION OnConnectWithFlags         VAR_INPUT pThis : ^void; retCode  : INT;                          flags     : BYTE;                                                                                                                 END_VAR;
FUNCTION OnDisconnect               VAR_INPUT pThis : ^void; retCode  : INT;                                                                                                                                                            END_VAR;
FUNCTION OnPublish                  VAR_INPUT pThis : ^void; mid      : INT;                                                                                                                                                            END_VAR;
FUNCTION OnMessage                  VAR_INPUT pThis : ^void; pMessage : ^MQTTClient::t_s_MQTTMessage;                                                                                                                                   END_VAR;
FUNCTION OnSubscribe                VAR_INPUT pThis : ^void; mid      : INT;                          qos_count : INT;    granted_qos : ^INT;                                                                                           END_VAR;
FUNCTION OnUnsubscribe              VAR_INPUT pThis : ^void; mid      : INT;                                                                                                                                                            END_VAR;
//================================================================================================================================================================
//---------------------------------------------------------------END OF CALLBACK PROTOTYPES-----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//---------------------------------------------------------------------INTERFACE METHODS--------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION GLOBAL MQTTClient::mqtt_connect_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_connect 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.ConnectCallback.pThis   := pThis;
    CallbacksStruct.ConnectCallback.pMethod := on_connect;
    
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_connect_with_flags_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_connect_with_flags 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.ConnectWithFlagsCallback.pThis   := pThis;
    CallbacksStruct.ConnectWithFlagsCallback.pMethod := on_connect_with_flags;
    
  end_if;

END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_disconnect_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_disconnect 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.DisconnectCallback.pThis   := pThis;
    CallbacksStruct.DisconnectCallback.pMethod := on_disconnect;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_publish_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_publish 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.PublishCallback.pThis   := pThis;
    CallbacksStruct.PublishCallback.pMethod := on_publish;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_message_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_message 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.MessageCallback.pThis   := pThis;
    CallbacksStruct.MessageCallback.pMethod := on_message;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_subscribe_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_subscribe 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.SubscribeCallback.pThis   := pThis;
    CallbacksStruct.SubscribeCallback.pMethod := on_subscribe;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_unsubscribe_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_unsubscribe 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.UnsubscribeCallback.pThis   := pThis;
    CallbacksStruct.UnsubscribeCallback.pMethod := on_unsubscribe;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_log_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_log 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.LogCallback.pThis   := pThis;
    CallbacksStruct.LogCallback.pMethod := on_log;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_log_with_detail_callback_set
	VAR_INPUT
		pThis 	: ^void;
		on_log_with_detail 	: ^void;
	END_VAR
  
  //If in init state, store the values in the callbacks structure
  if MQTTClientState = MCS_Initialise then
    
    CallbacksStruct.LogWithDetailCallback.pThis   := pThis;
    CallbacksStruct.LogWithDetailCallback.pMethod := on_log_with_detail;
    
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_connect_async
	VAR_INPUT
		host 	: ^UINT;
		port 	: INT;
		keepalive 	: INT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  //If the input parameters are not ok
  if host = NIL                                                     |
     SigCLib.StrLen16(str0:=host) > MQTTCLIENT_HOSTNAME_MAX_LEN     |
     port = 0                                                       |
     keepalive < 0                                                  then
    
    //Log Error
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_CONNECTION_INPUT_INVALID_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_CONNECTION_INPUT_INVALID_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_CONNECTION_INPUT_INVALID_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);
    
    
    //Stop execution
    return;
    
  end_if;
  
  //Prepare the parameters
  SigCLib.MemSet(dst  :=  #ConnectionDataStruct.aHostName[0], 
                 c    :=  0x00, 
                 len  :=  sizeof(ConnectionDataStruct.aHostName));
                   
  SigCLib.StrCpy16( dst0  :=  #ConnectionDataStruct.aHostName[0], 
                    src0  :=  host);
  
  ConnectionDataStruct.dPort := to_dint(port);
  
  //If Keepalive is set
  if keepalive <> 0 then
  
    //If Keepalive is too small
    if keepalive*1secs < MQTTCLIENT_MIN_KEEPALIVE_INTERVAL then
      keepalive := MQTTCLIENT_MIN_KEEPALIVE_INTERVAL/(1secs);
    end_if;
    
  end_if;

  ConnectionDataStruct.KeepaliveData.uiKeepAlive := to_uint(keepalive);
  
  //Set the connect flag
  ConnectionDataStruct.bConnect := TRUE;
  
  //Set the retcode
  retCode := MQTT_ERR_SUCCESS;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_disconnect
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //If supposed to have a connection
  if ConnectionDataStruct.bConnect then
    
    ConnectionDataStruct.bConnect := FALSE;
    retCode := MQTT_ERR_SUCCESS;
  
  //If there is no connection to disconnect
  else
    
    retCode := MQTT_ERR_NO_CONN;
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_loop_start
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	dRet : DINT;
  END_VAR

  //Assume Not OK
  retCode := MQTT_ERR_INVAL;
  
  //If not in Init state, stop
  if MQTTClientState <> MCS_Initialise then
    return;
  end_if;
  
  //OK
  retCode := MQTT_ERR_SUCCESS;
  
  //If the Thread is created
  if MultitaskDataStruct.ThreadHandle then
    
    //Resume the thread
    dRet := Multitask.RESUME(handle0:=MultitaskDataStruct.ThreadHandle);
    
    //If an error occurred, log it
    if dRet <> MTERROR_NONE then
            
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_CONFIGURATION_THREAD_START_FAIL_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_CONFIGURATION_THREAD_START_FAIL_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_CONFIGURATION_THREAD_START_FAIL_TEXT,
                    pPara1		:=	#dRet,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
    
    //No Error occurred
    else
      
      //Set Status
      ClientStatus.ThreadRunning := TRUE;
          
    end_if;
    
  end_if;
  
  //Set the TaskActivate Flag
  ClientStatus.TaskActivate := TRUE;
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_loop_stop
	VAR_INPUT
		force 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	dRet : DINT;
  END_VAR

  //Assume Not OK
  retCode := MQTT_ERR_INVAL;
  
  //If not in Init state, stop
  if MQTTClientState <> MCS_Initialise then
    return;
  end_if;
  
  //OK
  retCode := MQTT_ERR_SUCCESS;
  
  //If the Thread is created
  if  cMultitaskEnable = 1              &
      MultitaskDataStruct.ThreadHandle  then
    
    //If not forced and connected
    if ClientStatus.Connected &
       force = FALSE          then
      
      Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                    dMsgGroup	:=	MQCLI_LOG_WARNING_CONNECTION_MULTITASK_SUSPEND_IGNORED_GRP,
                    dMsgNbr		:=	MQCLI_LOG_WARNING_CONNECTION_MULTITASK_SUSPEND_IGNORED_MSG,
                    pMsg			:=	MQCLI_LOG_WARNING_CONNECTION_MULTITASK_SUSPEND_IGNORED_TEXT,
                    pPara1		:=	NIL,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
            
      //Set RetCode
      retCode := MQTT_ERR_INVAL;
      return;
      
    //If Not connected
    elsif ClientStatus.Connected = FALSE  |
          force                           then
        
      //Stop the thread
      dRet := Multitask.SUSPEND(handle0:=MultitaskDataStruct.ThreadHandle);
      
      //If a Multitask error occurred, log it
      if dRet <> MTERROR_NONE then
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_MULTITASK_SUSPEND_FAIL_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_MULTITASK_SUSPEND_FAIL_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_MULTITASK_SUSPEND_FAIL_TEXT,
                      pPara1		:=	#dRet,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      
      //No Error occurred
      else
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_MULTITASK_THREAD_STOPPED_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_MULTITASK_THREAD_STOPPED_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_MULTITASK_THREAD_STOPPED_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
                
        //Set the Status
        ClientStatus.ThreadRunning := FALSE;
              
      end_if;
    
    end_if;
    
  end_if;
  
  //Set the TaskActivate Flag
  ClientStatus.TaskActivate := FALSE;

END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_username_pw_set
	VAR_INPUT
		username 	: ^UINT;
		password 	: ^BYTE;
		udPassLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	udUserNameLen : UDINT;
  END_VAR
  
  // Possibilities are: 
    //Usn+Pass
    //Usn
    //Usn+NoPass
    //NoUsn+NoPass
  
  //Assume Error
  retCode := MQTT_ERR_INVAL;
  
  // If the username is set, get the length
  if username then
    udUserNameLen := SigCLib.StrLen16(str0:=username);
  end_if;
  
  // If both Username and Password are set
  if (username & udUserNameLen > 0) &
     (password & udPassLen > 0)     then
    
    // If the data lengths are ok
    if udUserNameLen <= MQTTCLIENT_CONNECT_MAX_USERNAME_LEN &
       udPassLen <= MQTTCLIENT_CONNECT_MAX_PASSWORD_LEN     then
      
      //Clear the current Username and Password
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aUsername, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.AuthData.aUsername));
                      
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aPassword, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.AuthData.aPassword));
      
      //Copy the Username and Password
      SigCLib.StrCpy16( dst0  :=  #ConnectionDataStruct.AuthData.aUsername[0], 
                        src0  :=  username);
                        
      SigCLib.MemCpy( dst0  :=  #ConnectionDataStruct.AuthData.aPassword[0], 
                      src0  :=  password, 
                      len0  :=  udPassLen);
            
      ConnectionDataStruct.AuthData.bUsername := TRUE;
      ConnectionDataStruct.AuthData.bPassword := TRUE;
      ConnectionDataStruct.AuthData.udPassLen := udPassLen;
      
      retCode := MQTT_ERR_SUCCESS;
      
    end_if;
    
    
  // If only the username is set
  elsif (username & udUserNameLen > 0)    &
        (password = NIL | udPassLen = 0)  then
        
     //If the string length is ok
    if udUserNameLen <= MQTTCLIENT_CONNECT_MAX_USERNAME_LEN then
      
      //Clear the current Username and Password
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aUsername, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.AuthData.aUsername));
                      
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aPassword, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.AuthData.aPassword));
      
      //Copy the Username
      SigCLib.StrCpy16( dst0  :=  #ConnectionDataStruct.AuthData.aUsername[0], 
                        src0  :=  username);
      
      ConnectionDataStruct.AuthData.bUsername := TRUE;
      ConnectionDataStruct.AuthData.bPassword := FALSE;      
      ConnectionDataStruct.AuthData.udPassLen := 0;
      
      retCode := MQTT_ERR_SUCCESS;
        
    end_if;
    
  // If the username is not set, the password does not matter
  else
  
    //Clear the current Username and Password
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aUsername, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.AuthData.aUsername));
                      
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aPassword, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.AuthData.aPassword));
      
      ConnectionDataStruct.AuthData.bUsername := TRUE;
      ConnectionDataStruct.AuthData.bPassword := FALSE;      
      ConnectionDataStruct.AuthData.udPassLen := 0;
      
      retCode := MQTT_ERR_SUCCESS;
  
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_lib_version
	VAR_INPUT
		major 	: ^INT;
		minor 	: ^INT;
		revision 	: ^INT;
	END_VAR
  
  //If the pointer is set, write the version information
  if major then
    major^ := MQTTCLIENT_VERSION_MAJOR;
  end_if;
  
  if minor then
    minor^ := MQTTCLIENT_VERSION_MINOR;
  end_if;
  
  if revision then
    revision^ := MQTTCLIENT_VERSION_REVISION;
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_reinitialise
	VAR_INPUT
		id 	: ^UINT;
		clean_session 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  //If the MQTTClient is in the wrong state, stop
  if MQTTClientState <> MCS_Initialise then
    return;
  end_if;

  //Call internal Init
  MQTTInit();
  
  //If the input values are ok
  if id <> NIL then
  
    //If the ID is a suitable length
    if SigCLib.StrLen16(str0:=id) <= MQTT_PROT_MAX_CLIENTID_NAME_LEN then
      
      //Prepare the ID
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.aClientID, 
                      c   :=  0x00, 
                      len :=  sizeof(ConnectionDataStruct.aClientID));
      
      MQTTClientID.TxtSet(dstchrsize  :=  2, 
                          psrc        :=  id, 
                          srcchrsize  :=  2);
      
      SigCLib.StrCpy16( dst0  :=  #ConnectionDataStruct.aClientID[0], 
                        src0  :=  id);
      
      //Set CleanSession
      if clean_session then
        CleanSession := 1;
      else
        CleanSession := 0;
      end_if;

      //Retcode
      retCode := MQTT_ERR_SUCCESS;
      
    end_if;

  //If the ID is not set, define it automatically
  elsif id = NIL then
    
    //If the PLCInfo pointer is ok, set the PLC Serial number as the ClientID
    if pPLCInfo then
      
      //Prepare the Client ID
      if pPLCInfo^.szSerialNumber[0] = 0 then
        MQTTClientID.WriteDataOff(udLen :=  SigCLib.StrLen(str:=MQTTCLIENT_UNDEF_CLIENT_ID), 
                                  udOff :=  0,  
                                  pData :=  MQTTCLIENT_UNDEF_CLIENT_ID);
      else
        MQTTClientID.WriteDataOff(udLen :=  SigCLib.StrLen(str:=#pPLCInfo^.szSerialNumber[0]), 
                                  udOff :=  0,  
                                  pData :=  #pPLCInfo^.szSerialNumber[0]);      
      end_if;

      MQTTClientID.ToUniCode();
      
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.aClientID, 
                        c   :=  0x00, 
                        len :=  sizeof(ConnectionDataStruct.aClientID));
                        
      MQTTClientID.TxtGet(pdst    :=  #ConnectionDataStruct.aClientID[0], 
                          dstsize :=  sizeof(ConnectionDataStruct.aClientID));
      
    
    //If the PLCInfo pointer is not OK, set the preset ClientID
    else
    
      //Prepare the Client ID
      MQTTClientID.WriteDataOff(udLen :=  SigCLib.StrLen(str:=MQTTCLIENT_UNDEF_CLIENT_ID), 
                                udOff :=  0,  
                                pData :=  MQTTCLIENT_UNDEF_CLIENT_ID);
      MQTTClientID.ToUniCode();
      
      SigCLib.MemSet( dst :=  #ConnectionDataStruct.aClientID, 
                        c   :=  0x00, 
                        len :=  sizeof(ConnectionDataStruct.aClientID));
                        
      MQTTClientID.TxtGet(pdst    :=  #ConnectionDataStruct.aClientID[0], 
                          dstsize :=  sizeof(ConnectionDataStruct.aClientID));
      
    end_if;
    
    //Set CleanSession
    if clean_session then
      CleanSession := 1;
    else
      CleanSession := 0;
    end_if;
    
    retCode := MQTT_ERR_SUCCESS;
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_will_set
	VAR_INPUT
		topic 	: ^UINT;
		payloadLen 	: UDINT;
		payload 	: ^void;
		qos 	: INT;
		retain_will 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	udTopicLen : UDINT;
  END_VAR

  //Assume Error
  retCode := MQTT_ERR_INVAL;
  
  //If the input values are OK
  if qos >= 0 &
     qos <= 2 then
    
    //If only the topic is set
    if topic          &
       payload = NIL  &
       payloadLen = 0 then
      
      //If the topic len is OK
      udTopicLen := SigCLib.StrLen16(str0:=topic);
      if udTopicLen <= MQTTCLIENT_WILL_TOPIC_MAX_LEN  &
         udTopicLen >  0                              then
        
        //Set the flags
        ConnectionDataStruct.WillData.bWill       := TRUE;
        ConnectionDataStruct.WillData.bWillRetain := retain_will;
        
        //Clear the will data
        SigCLib.MemSet(dst:=#ConnectionDataStruct.WillData.aWillTopic, c:=0x00, len:=sizeof(ConnectionDataStruct.WillData.aWillTopic));
        SigCLib.MemSet(dst:=#ConnectionDataStruct.WillData.aWillMessage, c:=0x00, len:=sizeof(ConnectionDataStruct.WillData.aWillMessage));
        
        //Copy the Will Topic
        SigCLib.StrCpy16(dst0:=#ConnectionDataStruct.WillData.aWillTopic[0], src0:=topic);
        
        ConnectionDataStruct.WillData.usWillQoS := to_usint(qos);
        ConnectionDataStruct.WillData.udWillMessageLen := 0;
        
        retCode := MQTT_ERR_SUCCESS;
        
      end_if;
    
    //If both the topic and payload are set
    elsif topic                                           &
          payload                                         &
          payloadLen >  0                                 &
          payloadLen <= MQTTCLIENT_WILL_PAYLOAD_MAX_LEN   then
      
      //If the topic len is OK
      udTopicLen := SigCLib.StrLen16(str0:=topic);
      if udTopicLen <= MQTTCLIENT_WILL_TOPIC_MAX_LEN  &
         udTopicLen >  0                              then
        
        //Set the flags
        ConnectionDataStruct.WillData.bWill       := TRUE;
        ConnectionDataStruct.WillData.bWillRetain := retain_will;
        
        //Clear the will data
        SigCLib.MemSet(dst:=#ConnectionDataStruct.WillData.aWillTopic, c:=0x00, len:=sizeof(ConnectionDataStruct.WillData.aWillTopic));
        SigCLib.MemSet(dst:=#ConnectionDataStruct.WillData.aWillMessage, c:=0x00, len:=sizeof(ConnectionDataStruct.WillData.aWillMessage));
        
        //Copy the Will Topic and payload
        SigCLib.StrCpy16( dst0  :=  #ConnectionDataStruct.WillData.aWillTopic[0], 
                          src0  :=  topic);
                          
        SigCLib.MemCpy( dst0  :=  #ConnectionDataStruct.WillData.aWillMessage, 
                        src0  :=  payload, 
                        len0  :=  payloadLen);
        
        ConnectionDataStruct.WillData.usWillQoS := to_usint(qos);
        ConnectionDataStruct.WillData.udWillMessageLen := payloadLen;
        
        retCode := MQTT_ERR_SUCCESS;
        
      end_if;
      
    end_if;

    
  end_if;
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_will_clear
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  //If the will is set
  if ConnectionDataStruct.WillData.bWill then
    
    //Reset Will
    SigCLib.MemSet(dst  :=  #ConnectionDataStruct.WillData.aWillTopic, 
                   c    :=  0x00, 
                   len  :=  sizeof(ConnectionDataStruct.WillData.aWillTopic));
                     
    SigCLib.MemSet(dst  :=  #ConnectionDataStruct.WillData.aWillMessage, 
                   c    :=  0x00, 
                   len  :=  sizeof(ConnectionDataStruct.WillData.aWillMessage));
                     
    ConnectionDataStruct.WillData.bWill       := FALSE;
    ConnectionDataStruct.WillData.bWillRetain := FALSE;
    ConnectionDataStruct.WillData.usWillQoS   := 0;
    
    //Set Return
    retCode := MQTT_ERR_SUCCESS;
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_publish
	VAR_INPUT
		mid 	: ^INT;
		topic 	: ^UINT;
		payloadLen 	: UDINT;
		payload 	: ^void;
		qos 	: INT;
		retain_pub 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	iMid : INT;
  END_VAR

  
  PublishCritSect.SectionStart();
  
  //Assume fail
  retCode := MQTT_ERR_INVAL;
  
  //Check input values
  if topic = NIL                                                |
     SigCLib.StrLen16(str0:=topic) > MQTTCLIENT_TOPIC_MAX_LEN   |
     SigCLib.StrLen16(str0:=topic) = 0                          |
     qos < MQTT_PROT_QOS_MIN                                    |
     qos > MQTT_PROT_QOS_MAX                                    then
											

    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_INP_INVALID_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_INP_INVALID_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_INP_INVALID_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);
    
    PublishCritSect.SectionStop();  
    return;
  
  end_if; 
  
  //If the state is not OK
  if MQTTClientState < MCS_Connected |
     MQTTClientState > MCS_Reconnect then
    

    Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                  dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_WRONG_STATE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_WRONG_STATE_MSG,
                  pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_WRONG_STATE_TEXT,
                  pPara1		:=	#MQTTClientState$DINT,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

    
    retCode := MQTT_ERR_NO_CONN;
    PublishCritSect.SectionStop();
    return;
    
  end_if;
  
  if InflightMsgs_AddMsg( MsgType       :=  IM_Publish, 
                          bOutgoing     :=  TRUE, 
                          pMid          :=  #iMid, 
                          iQoS          :=  qos, 
                          bRetain       :=  retain_pub, 
                          pTopic        :=  topic, 
                          pPayload      :=  payload, 
                          udPayloadLen  :=  payloadLen,
                          dQueueID      :=  0) = FALSE then
  
    retCode := MQTT_ERR_NOMEM;
    PublishCritSect.SectionStop();
    return;  
  
  end_if;
  
  if mid then
    mid^ := iMid;
  end_if;
  
  //Create Log:
  dPara1Temp := to_dint(iMid);
    
	Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
								dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_ADD_SUCCESS_GRP,
								dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_ADD_SUCCESS_MSG,
								pMsg			:=	MQCLI_LOG_INFO_PUBLISH_ADD_SUCCESS_TEXT,
								pPara1		:=	#dPara1Temp,
								pPara2		:=	NIL,
								pPara3		:=	NIL,
								pPara4		:=	NIL);

                
  retCode := MQTT_ERR_SUCCESS;
  
  PublishCritSect.SectionStop();
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_subscribe
	VAR_INPUT
		mid 	: ^INT;
		subscribe 	: ^UINT;
		qos 	: INT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	iMid : INT;
  END_VAR

  
  //Assume Failure
  retCode := MQTT_ERR_INVAL;
  
  //If the input values or state are not oK
  if //mid = NIL                                                      |
     subscribe = NIL                                                |
     SigCLib.StrLen16(str0:=subscribe) > MQTTCLIENT_TOPIC_MAX_LEN   |
     SigCLib.StrLen16(str0:=subscribe) = 0                          |
     qos < MQTT_PROT_QOS_MIN                                        |
     qos > MQTT_PROT_QOS_MAX                                        then
     
    //Create Log:
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_SUBSCRIBE_INP_INVALID_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_SUBSCRIBE_INP_INVALID_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_SUBSCRIBE_INP_INVALID_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

    return;
  end_if;
  
  //If the state is not OK
  if MQTTClientState < MCS_Connected |
     MQTTClientState > MCS_Reconnect then
    

    Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                  dMsgGroup	:=	MQCLI_LOG_WARNING_SUBSCRIBE_WRONG_STATE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_WARNING_SUBSCRIBE_WRONG_STATE_MSG,
                  pMsg			:=	MQCLI_LOG_WARNING_SUBSCRIBE_WRONG_STATE_TEXT,
                  pPara1		:=	#MQTTClientState$DINT,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);
 
    
    retCode := MQTT_ERR_NO_CONN;
    return;
  end_if;

  
  if InflightMsgs_AddMsg( MsgType       :=  IM_Subscribe,  
                          bOutgoing     :=  TRUE, 
                          pMid          :=  #iMid, 
                          iQoS          :=  qos, 
                          bRetain       :=  FALSE, 
                          pTopic        :=  subscribe,  
                          pPayload      :=  NIL, 
                          udPayloadLen  :=  0,
                          dQueueID      :=  0) = FALSE then
    
    retCode := MQTT_ERR_NOMEM;
    return;
    
  end_if;
  
  if mid then
    mid^ := iMid;
  end_if;
  
  //Create Log:
  
  dPara1Temp := to_dint(iMid);
  dPara2Temp := to_dint(qos);
  
	Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
								dMsgGroup	:=	MQCLI_LOG_INFO_SUBSCRIBE_ADD_SUCCESS_GRP,
								dMsgNbr		:=	MQCLI_LOG_INFO_SUBSCRIBE_ADD_SUCCESS_MSG,
								pMsg			:=	MQCLI_LOG_INFO_SUBSCRIBE_ADD_SUCCESS_TEXT,
								pPara1		:=	#dPara1Temp,
								pPara2		:=	#dPara2Temp,
								pPara3		:=	NIL,
								pPara4		:=	NIL);

  retCode := MQTT_ERR_SUCCESS;
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_tls_set
	VAR_INPUT
		cafile 	: ^CHAR;
		certfile 	: ^CHAR;
		keyfile 	: ^CHAR;
		pw 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR

    
  //Assume input value failure
  retCode := MQTT_ERR_INVAL;
  
  //If atleast one string is set and the length is OK
  if ((cafile   = NIL)  | (cafile   & (SigCLib.StrLen(str:=cafile)    <= MQTTCLIENT_CONNECT_MAX_FILENAME_LEN)))   &
     ((certfile = NIL)  | (certfile & (SigCLib.StrLen(str:=certfile)  <= MQTTCLIENT_CONNECT_MAX_FILENAME_LEN)))   &
     ((keyfile  = NIL)  | (keyfile  & (SigCLib.StrLen(str:=keyfile)   <= MQTTCLIENT_CONNECT_MAX_FILENAME_LEN)))   &
     ((pw       = NIL)  | (pw       & ((SigCLib.StrLen(str:=pw)       <= MQTTCLIENT_CONNECT_MAX_PASSWORD_LEN))))  then
    
    //Password
    if pw then
    
      SigCLib.MemSet(dst  :=  #ConnectionDataStruct.aKeyDecryptPwd, 
                     c    :=  0x00, 
                     len  :=  sizeof(ConnectionDataStruct.aKeyDecryptPwd));
      SigCLib.StrCpy(dst0 :=  #ConnectionDataStruct.aKeyDecryptPwd[0], 
                     src0 :=  pw);
    end_if;
    
    //cafile
    if cafile then
    
      SigCLib.MemSet(dst  :=  #ConnectionDataStruct.aCACertPEMFile, 
                     c    :=  0x00, 
                     len  :=  sizeof(ConnectionDataStruct.aCACertPEMFile));
      SigCLib.StrCpy( dst0  :=  #ConnectionDataStruct.aCACertPEMFile[0], 
                      src0  :=  cafile);
    end_if;
    
    //cafile
    if certfile then
    
      SigCLib.MemSet(dst  :=  #ConnectionDataStruct.aClientCertChainPEMFilename, 
                     c    :=  0x00, 
                     len  :=  sizeof(ConnectionDataStruct.aClientCertChainPEMFilename));
      SigCLib.StrCpy( dst0  :=  #ConnectionDataStruct.aClientCertChainPEMFilename[0], 
                      src0  :=  certfile);
    end_if;
    
    //keyfile
    if keyfile then
    
      SigCLib.MemSet(dst  :=  #ConnectionDataStruct.aClientCertKeyPEMFilename, 
                     c    :=  0x00, 
                     len  :=  sizeof(ConnectionDataStruct.aClientCertKeyPEMFilename));
      SigCLib.StrCpy( dst0  :=  #ConnectionDataStruct.aClientCertKeyPEMFilename[0], 
                      src0  :=  keyfile);
    end_if;
    
    ConnectionDataStruct.bTLS := TRUE;
    retCode := MQTT_ERR_SUCCESS;
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_reconnect_delay_set
	VAR_INPUT
		reconnect_delay 	: UINT;
		reconnect_delay_max 	: UINT;
		reconnect_exponential_delay 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  //If the input data is ok
  if reconnect_delay <= reconnect_delay_max then
    
    //Set the connection data
    ConnectionDataStruct.ReconnectData.udReconnectMin := to_udint(reconnect_delay)*1secs;
    ConnectionDataStruct.ReconnectData.udReconnectMax := to_udint(reconnect_delay_max)*1secs;
    
    //Set the Min time to not zero.
    if ConnectionDataStruct.ReconnectData.udReconnectMin = 0 then
      ConnectionDataStruct.ReconnectData.udReconnectMin := 1;
      //Handle edge case where Min now equals Max.
      if ConnectionDataStruct.ReconnectData.udReconnectMin = ConnectionDataStruct.ReconnectData.udReconnectMax then
        ConnectionDataStruct.ReconnectData.udReconnectMax += 1;
      end_if;
    end_if;
    
    ConnectionDataStruct.ReconnectData.udExponent     := 1;
    ConnectionDataStruct.ReconnectData.bExponential   := reconnect_exponential_delay;
    ConnectionDataStruct.ReconnectData.udCurrentDelay := ConnectionDataStruct.ReconnectData.udReconnectMin;
    
    //Success
    retCode := MQTT_ERR_SUCCESS;
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_max_inflight_messages_set
	VAR_INPUT
		max_inflight_messages 	: INT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR


  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  //If the input value is not ok, log, stop
  if max_inflight_messages < MQTTCLIENT_MIN_INFLIGHT_MSGS then
  
    dPara1Temp := to_dint(max_inflight_messages);
    dPara2Temp := to_dint(MQTTCLIENT_MIN_INFLIGHT_MSGS);
    
    //Create Log:
    Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                  dMsgGroup	:=	MQCLI_LOG_WARNING_CONFIGURATION_SETINF_TOOLOW_GRP,
                  dMsgNbr		:=	MQCLI_LOG_WARNING_CONFIGURATION_SETINF_TOOLOW_MSG,
                  pMsg			:=	MQCLI_LOG_WARNING_CONFIGURATION_SETINF_TOOLOW_TEXT,
                  pPara1		:=	#dPara2Temp,
                  pPara2		:=	#dPara1Temp,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

                  
    return;
  end_if;
  
  //If the state is not OK, log, stop
  if MQTTClientState <> MCS_Initialise then
    

    Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                  dMsgGroup	:=	MQCLI_LOG_WARNING_CONFIGURATION_SETINF_STATE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_WARNING_CONFIGURATION_SETINF_STATE_MSG,
                  pMsg			:=	MQCLI_LOG_WARNING_CONFIGURATION_SETINF_STATE_TEXT,
                  pPara1		:=	#MQTTClientState$DINT,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

    return;
  end_if;

  //If the inflight message pointer is OK
  if pInFlightMsgs then
    
    //If there is enough memory available
    if ((sizeof(t_s_InflightMsgs) + ((to_udint(max_inflight_messages) - 1) * sizeof(t_s_InflightMessage))) < _UserHeapFreeMem) then
    
      pInFlightMsgs^.udMaxInflightMsgs := to_udint(max_inflight_messages);

      //ReAlloc
      pInFlightMsgs$^void := MemoryHeap.ReallocV1(mptr0   :=  pInFlightMsgs, 
                                                  newsize :=  sizeof(t_s_InflightMsgs) + ((to_udint(max_inflight_messages) - 1) * sizeof(t_s_InflightMessage)), 
                                                  mark0   :=  MQTTCLIENT_DEFAULT_MALLOC_MARK);
          
      //If the pointer is OK
      if pInFlightMsgs then
        
        dPara1Temp := to_dint(max_inflight_messages);
        dPara2Temp := to_dint(_UserHeapFreeMem);
        
        //Create Log:
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_CONFIGURATION_INF_MSGS_SET_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_CONFIGURATION_INF_MSGS_SET_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_CONFIGURATION_INF_MSGS_SET_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	#dPara2Temp,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

                      
        retCode := MQTT_ERR_SUCCESS;
        return;
      
      //Pointer not OK
      else
        
        dPara1Temp := to_dint(max_inflight_messages);
        dPara2Temp := to_dint((sizeof(t_s_InflightMsgs) + ((to_udint(max_inflight_messages) - 1) * sizeof(t_s_InflightMessage))));
        dPara3Temp := to_dint(_UserHeapFreeMem);
        
        //Create Log:
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_REALLOC_FAIL_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_REALLOC_FAIL_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_REALLOC_FAIL_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	#dPara2Temp,
                      pPara3		:=	#dPara3Temp,
                      pPara4		:=	NIL);

                      
        retCode := MQTT_ERR_NOMEM;
        MQTTClientState := MCS_Error;
        return;
        
      end_if;

      
    //Not enough free mem, log, set ret, return
    else
      
      dPara1Temp := to_dint(max_inflight_messages);
      dPara2Temp := to_dint((sizeof(t_s_InflightMsgs) + ((to_udint(max_inflight_messages) - 1) * sizeof(t_s_InflightMessage))));
      dPara3Temp := to_dint(_UserHeapFreeMem);
      
      //Create Log:
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_MEM_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_MEM_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_MEM_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	#dPara2Temp,
                    pPara3		:=	#dPara3Temp,
                    pPara4		:=	NIL);

      
      retCode := MQTT_ERR_NOMEM;
      return;
      
    end_if;

  //Inflight messages not inited, log, return
  else
    
    dPara1Temp := to_dint(max_inflight_messages);
    
    //Create Log:
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_NOTINIT_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_NOTINIT_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_CONFIGURATION_INF_MSGS_NOTINIT_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_reconnect_async
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //If Connected
  if MQTTClientState = MCS_Connected then
    
    //Reset the Reconnect Paras
    ConnectionDataStruct.ReconnectData.udCurrentDelay := ConnectionDataStruct.ReconnectData.udReconnectMin;
    ConnectionDataStruct.ReconnectData.udExponent     := 1;
    
    MQTTClientState := MCS_Reconnect;
    
    retCode := MQTT_ERR_SUCCESS;
  
  else
  
    retCode := MQTT_ERR_INVAL;
  
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::mqtt_unsubscribe
	VAR_INPUT
		mid 	: ^INT;
		unsub 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	iMid : INT;
  END_VAR


  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  //Check input values
  if //mid = NIL                                                    |
     unsub = NIL                                                  |
     SigCLib.StrLen16(str0:=unsub) > MQTTCLIENT_TOPIC_MAX_LEN     |
     SigCLib.StrLen16(str0:=unsub) = 0                            then
    return;
  end_if;
  
  //Check Connection State
  if (MQTTClientState < MCS_Connected) |
     (MQTTClientState > MCS_Reconnect) then
    retCode := MQTT_ERR_NO_CONN;
    return;
  end_if;

  //Add the Unsubscribe request
  if InflightMsgs_AddMsg( MsgType       :=  IM_Unsubscribe, 
                          bOutgoing     :=  TRUE, 
                          pMid          :=  #iMid, 
                          iQoS          :=  1, 
                          bRetain       :=  FALSE, 
                          pTopic        :=  unsub, 
                          pPayload      :=  NIL, 
                          udPayloadLen  :=  0,
                          dQueueID      :=  0) = FALSE then
    
    retCode := MQTT_ERR_NOMEM;
    return;
    
  end_if;
  
  if mid then
    mid^ := iMid;
  end_if;
  
  retCode := MQTT_ERR_SUCCESS;
  
END_FUNCTION
//================================================================================================================================================================
//------------------------------------------------------------------END OF INTERFACE METHODS----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-----------------------------------------------------------------------INIT METHODS-----------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION VIRTUAL GLOBAL MQTTClient::Init
  
  //Increment Init Coutner
  udInitCounter += 1;
  
  //If in correct Init State
  if udInitCounter = MQTTCLIENT_INIT_CYCLE then
    
    //Handle Connected Clients
    ConnectedClients.SubscribeTimeout   := (IsClientConnected(input:=#cSubscribeTimeout) = 1);
    ConnectedClients.PublishTimeout     := (IsClientConnected(input:=#cPublishTimeout) = 1);
    ConnectedClients.UnsubscribeTimeout := (IsClientConnected(input:=#cUnsubscribeTimeout) = 1);
    ConnectedClients.PacketRetryCount   := (IsClientConnected(input:=#cPacketRetryCount) = 1);
    
    //Call init Method
    mqtt_reinitialise(id            :=  NIL, 
                      clean_session :=  (CleanSession = 1));
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQTTInit
  VAR
  	aThis     : ARRAY[0..MQTTCLIENT_MULTITASK_THIS_MAX_LEN] of CHAR;
    udInfMsgs : UDINT;
    dRet      : DINT;
  END_VAR

  //=======================================================
  //SYSINFO Interface
  //=======================================================
  if OS_CILGET( "ISYSSERNUM", #pISysSernum ) <> SYS_ERR_NONE then
    pISysSernum := NIL;
  else
    pPLCInfo := ISYSSERNUM_SERNUMGETPLCINFO();
  end_if;
  
  //=======================================================
  //TCP Interface - Required for STRTULONG()
  //=======================================================
  if OS_CILGET( "TCP_USER", #lsl_tcp_user) <> SYS_ERR_NONE then
    lsl_tcp_user := NIL;
  end_if;
  
  //=======================================================
  //Multitasking Thread Init
  //=======================================================
  //If task does not exist yet and must
  if cMultitaskEnable = 1 then
  
    if MultitaskDataStruct.ThreadHandle = NIL then
    
      //Prep Name String
      SigCLib.MemSet( dst :=  #MultitaskDataStruct.aTaskName[0], 
                      c   :=  0x00, 
                      len :=  sizeof(MultitaskDataStruct.aTaskName));
                      
      SigCLib.StrCpy( dst0  :=  #MultitaskDataStruct.aTaskName[0], 
                      src0  :=  MQTTCLIENT_MULTITASK_TASKNAME_PREFIX);
                      
      SigCLib.MemSet( dst :=  #aThis, 
                      c   :=  0x00, 
                      len :=  sizeof(aThis));                  
                      
      SigCLib.IToA( val   :=  this$DINT, 
                    dst   :=  #aThis[0], 
                    base  :=  10);  
                    
      SigCLib.StrCat( ps1 :=  #MultitaskDataStruct.aTaskName[0], 
                      ps2 :=  #aThis[SigCLib.StrLen(str:=#aThis[0])-MQTTCLIENT_MULTITASK_THIS_RIGHT_LEN]);
      
      //Create thread
      MultitaskDataStruct.ThreadHandle := Multitask.CREATETHREAD( taskfunction0 :=  #ThreadCall(), 
                                                                  priority0     :=  MQTTCLIENT_MULTITASK_TASK_PRIORITY, 
                                                                  stackSize0    :=  MQTTCLIENT_MULTITASK_TASK_STACKSIZE, 
                                                                  flags0        :=  MQTTCLIENT_MULTITASK_TASK_CREATE_MODE, 
                                                                  parameter0    :=  this, 
                                                                  name0         :=  #MultitaskDataStruct.aTaskName[SigCLib.StrLen(str:=#MultitaskDataStruct.aTaskName[0])]);
    
      //If an error occurred, create log
      if MultitaskDataStruct.ThreadHandle = NIL then
                
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_MULTITASK_CREATE_FAIL_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_MULTITASK_CREATE_FAIL_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_MULTITASK_CREATE_FAIL_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      end_if;
    
    //If the task does exist, suspend it
    else
      
      //Suspend the task, if it fails then log an error
      dRet := Multitask.SUSPEND(handle0:=MultitaskDataStruct.ThreadHandle);
      if dRet <> MTERROR_NONE then
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_MULTITASK_SUSPEND_FAIL_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_MULTITASK_SUSPEND_FAIL_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_MULTITASK_SUSPEND_FAIL_TEXT,
                      pPara1		:=	#dRet,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      end_if;
      
    end_if;
  
  end_if;
  
  //If there is an active TCP Handle, try to delete the connection
  if ConnectionDataStruct.dTCPHandle > 0 then
    TCPIPClientInterface_MQTTClient.DelConnection();
    ConnectionDataStruct.dTCPHandle := 0;
  end_if;
  
  //=======================================================
  //Memory Initialisation
  //=======================================================
  
  //Inflight Messages
  if pInFlightMsgs = NIL then
    
    udInfMsgs := MQTTCLIENT_DEFAULT_INFLIGHT_MSGS;
    
    pInFlightMsgs$^void := MemoryHeap.MallocV1( size0 :=  sizeof(t_s_InflightMsgs) + ((udInfMsgs - 1) * sizeof(t_s_InflightMessage)),  
                                                mark0 :=  MQTTCLIENT_DEFAULT_MALLOC_MARK);
    
    if pInFlightMsgs then
      SigCLib.MemSet( dst :=  pInFlightMsgs, 
                      c   :=  0x00, 
                      len :=  sizeof(t_s_InflightMsgs.udInflightMsgs) + ((udInfMsgs-1) * sizeof(t_s_InflightMessage)));
      pInFlightMsgs^.udMaxInflightMsgs := udInfMsgs;
    end_if;
    
  end_if;
  
  //The MID cannot be -1 / 0
  ConnectionDataStruct.iMid := 1;

  
  //Init the Temp Control Packets
  MQP_ControlPackets( usPacket  :=  1, 
                      CPTask    :=  CPT_Init);
  MQP_ControlPackets( usPacket  :=  2, 
                      CPTask    :=  CPT_Init);
  
  //ConnectionDataStruct
  
    //Connection
    ConnectionDataStruct.bConnect := FALSE;
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aHostName, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aHostName));
                    
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aIP, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aIP));
                    
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aClientID, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aClientID));
    //Will
    ConnectionDataStruct.WillData.bWill := FALSE;
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.WillData.aWillTopic, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.WillData.aWillTopic));
                    
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.WillData.aWillMessage, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.WillData.aWillMessage));
    //TLS
    ConnectionDataStruct.bTLS := FALSE;
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aCACertPEMFile, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aCACertPEMFile));
                    
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aClientCertChainPEMFilename, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aClientCertChainPEMFilename));
                    
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aClientCertKeyPEMFilename, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aClientCertKeyPEMFilename));
                    
    SigCLib.MemSet( dst   :=  #ConnectionDataStruct.aKeyDecryptPwd, 
                    c     :=  0x00, 
                    len   :=  sizeof(ConnectionDataStruct.aKeyDecryptPwd));
    
    //User Details
    ConnectionDataStruct.AuthData.bUsername := FALSE;
    ConnectionDataStruct.AuthData.bPassword := FALSE;
    SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aUsername, 
                    c   :=  0x00, 
                    len :=  sizeof(ConnectionDataStruct.AuthData.aUsername));
                    
    SigCLib.MemSet( dst :=  #ConnectionDataStruct.AuthData.aPassword, 
                    c   :=  0x00, 
                    len :=  sizeof(ConnectionDataStruct.AuthData.aPassword));
    
    //Reconnect
    ConnectionDataStruct.ReconnectData.udReconnectMin :=  MQTTCLIENT_RECONNECT_MIN_TIME;
    ConnectionDataStruct.ReconnectData.udReconnectMax :=  MQTTCLIENT_RECONNECT_MAX_TIME;
    ConnectionDataStruct.ReconnectData.bExponential   :=  FALSE;
    ConnectionDataStruct.ReconnectData.udCurrentDelay :=  ConnectionDataStruct.ReconnectData.udReconnectMin;
    
    //Ping
    ConnectionDataStruct.KeepaliveData.uiKeepAlive     := 0;
    ConnectionDataStruct.KeepaliveData.udLastPINGRESP  := 0;
    ConnectionDataStruct.KeepaliveData.udLastPINGREQ   := 0;
    
  //Callbacks
  SigCLib.MemSet( dst :=  #CallbacksStruct, 
                  c   :=  0x00, 
                  len :=  sizeof(CallbacksStruct));
END_FUNCTION
//================================================================================================================================================================
//--------------------------------------------------------------------END OF INIT METHODS-------------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//---------------------------------------------------------------------CYCLIC METHODS-----------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION __CDECL MQTTClient::ThreadCall

  while TRUE do
  
    //Call the MQTTTask
    //MQTTTask();
  
    //Delay the task
    Multitask.TASKDELAY(timeout0:=MQTTCLIENT_MULTITASK_TASKINTERVAL);
  
  end_while;
  
END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  
	state := READY;

  //If the thread is not created and the task should be started, call the MQTTTask
  if MultitaskDataStruct.ThreadHandle = NIL &
     ClientStatus.TaskActivate              then
    
    MQTTTask();
    
  end_if;


END_FUNCTION

FUNCTION MQTTClient::MQTTTask
  
  //=====================================================
  //============Main MQTTClient FSM======================
  //=====================================================
  case MQTTClientState of
  
    //-------------------------------------------------
    //Initialise
    //-------------------------------------------------
  	MQTTClient::t_e_MQTTClientStates::MCS_Initialise:
    
      //If the connection needs to be open
      if ConnectionDataStruct.bConnect = TRUE then
        
        //Change Main FSM state
        MQTTClientState := MCS_Connect;
        
        //Init Secondary FSM States
        States.Connect    := CS_DNSLookup;
        States.Disconnect := DS_BuildPacket;
      end_if;
      
    //-------------------------------------------------
    //Connect
    //-------------------------------------------------
  	MQTTClient::t_e_MQTTClientStates::MCS_Connect:
    
      MQTTTask_Connect();
      PacketQueue_ProcessOutgoing();
      PacketQueue_ProcessIncoming();
      
      //If the connection needs to be closed
      if ConnectionDataStruct.bConnect = FALSE then
        MQTTClientState := MCS_Disconnect;
      end_if;
      
    //-------------------------------------------------
    //Connected
    //-------------------------------------------------
  	MQTTClient::t_e_MQTTClientStates::MCS_Connected:
      
      //Keep Alive Ping
      KeepAlive_ProcessPing();
      
      //Call Watchdog
      TCP_WatchDogTask();
      
      //Incoming Packet Queue
      PacketQueue_ProcessIncoming();
            
      //Message Queue
      InflightMsgs_ProcessQueue();
      
      //Outgoing Packet Queue
      PacketQueue_ProcessOutgoing();
                  
      //If the connection needs to be closed, go to the disconnect state
      if ConnectionDataStruct.bConnect = FALSE then
        MQTTClientState := MCS_Disconnect;
      end_if;
    
    //-------------------------------------------------
    //Reconnect
    //-------------------------------------------------
  	MQTTClient::t_e_MQTTClientStates::MCS_Reconnect:
      
      MQTTTask_Reconnect();      
      PacketQueue_ProcessOutgoing();
      PacketQueue_ProcessIncoming();
    
    //-------------------------------------------------
    //Disconnect
    //-------------------------------------------------
  	MQTTClient::t_e_MQTTClientStates::MCS_Disconnect:
      
      MQTTTask_Disconnect();
    
    //-------------------------------------------------
    //Error
    //-------------------------------------------------
  	MQTTClient::t_e_MQTTClientStates::MCS_Error:
      
      MQTTClientState := MCS_Initialise;
      
  end_case;

  //Perform Cyclic work of MessageQueues
  IncomingPackets.CyclicWork();
  OutgoingPackets.CyclicWork();
  
END_FUNCTION

FUNCTION MQTTClient::MQTTTask_Connect
  VAR
  	aHostString : ARRAY[0..MQTTCLIENT_HOSTNAME_MAX_LEN] of CHAR;
    pCA, pCert, pKey, pPW : ^CHAR;
    dTemp : DINT;
  END_VAR

  //====================================================
  //FSM For the Connect Procedure
  //====================================================
  case States.Connect of
  
    // MehMar: v1.3: The DNS might take longer to answer so the request is moved to a background task. Apparently the OS is taking care
    // of timeouts on requesting the DNS so it is not necessary to do something other than wait here. The callback will be called in any
    // case and therefore this step is left.
    t_e_MQTTClientStates_Connect::CS_WaitDNSLookup:
        
    //------------------------------------------------------------
    //Get the encoded IP Address from the DNSName
    //CAUTION: OS IP, Gateway and DNS must be set for this to work
    //------------------------------------------------------------
    t_e_MQTTClientStates_Connect::CS_DNSLookup:
      
      //Prepare the local Host String
      SigCLib.MemSet( dst :=  #aHostString, 
                      c   :=  0x00, 
                      len :=  sizeof(aHostString));
                      
      SigCLib.Str16ToUtf8(dst :=  #aHostString[0], 
                          src :=  #ConnectionDataStruct.aHostName[0]);
                          
      States.Connect := CS_WaitDNSLookup;
      Worker.ConvertHostToIP(hostName:=#aHostString[0], pThis:=this);
      
    //--------------------------------------------------------
    //Convert Encoded IP to String
    //--------------------------------------------------------
    t_e_MQTTClientStates_Connect::CS_udToASCII:
    
      if ConnectionDataStruct.udIPAddress <> 0 then
        
        //Get the String IP Address from the OS TCP USER Interface (The ptr is checked in the previous step)
        if OS_TCP_USER_ULONGTOSTR(#ConnectionDataStruct.aIP[0], MQTTCLIENT_IP_MAX_LEN, ConnectionDataStruct.udIPAddress) <> 0 then
          
          //Log Error
          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                        dMsgGroup	:=	MQCLI_LOG_ERROR_CONNECTION_HOST_IP_GRP,
                        dMsgNbr		:=	MQCLI_LOG_ERROR_CONNECTION_HOST_IP_MSG,
                        pMsg			:=	MQCLI_LOG_ERROR_CONNECTION_HOST_IP_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          States.Connect := CS_Error;
          
        //Success
        else
        
          States.Connect := CS_ConnectTCP;
        
        end_if;

      end_if;

    
    //--------------------------------------------------------
    //Get the encoded IP Address from the DNSName
    //--------------------------------------------------------
    t_e_MQTTClientStates_Connect::CS_ConnectTCP:
      
      pCA := pCert := pKey := pPW := NIL;
    
      if ConnectionDataStruct.aCACertPEMFile[0] <> 0x00 then
        pCA := #ConnectionDataStruct.aCACertPEMFile[0];
      end_if;
      if ConnectionDataStruct.aClientCertChainPEMFilename[0] <> 0x00 then
        pCert := #ConnectionDataStruct.aClientCertChainPEMFilename[0];
      end_if;
      if ConnectionDataStruct.aClientCertKeyPEMFilename[0] <> 0x00 then
        pKey := #ConnectionDataStruct.aClientCertKeyPEMFilename[0];
      end_if;
      if ConnectionDataStruct.aKeyDecryptPwd[0] <> 0x00 then
        pPW := #ConnectionDataStruct.aKeyDecryptPwd[0];
      end_if;
      
      ConnectionDataStruct.dTCPHandle := TCPIPClientInterface_MQTTClient.AddConnectionMQTT( pIPAddress                  :=  #ConnectionDataStruct.aIP[0], 
                                                                                            dPort                       :=  ConnectionDataStruct.dPort, 
                                                                                            udTimeout                   :=  MQTTCLIENT_CONNECT_TCPCLI_TIMEOUT, 
                                                                                            bSSL                        :=  ConnectionDataStruct.bTLS, 
                                                                                            pCACertPEMFilename          :=  pCA, 
                                                                                            pClientCertChainPEMFilename :=  pCert, 
                                                                                            pClientCertKeyPEMFilename   :=  pKey, 
                                                                                            pKeyDecryptPwd              :=  pPW);
      //If the connection is accepted
      if ConnectionDataStruct.dTCPHandle <> 0 then
        
        //Install Connection Error Callback
        TCPIPClientInterface_MQTTClient.InstallConnErrCallback( pThis         :=  this, 
                                                                pCallbackMeth :=  #TCP_ErrorOccurred_Callback());
        
        TCPIPClientInterface_MQTTClient.InstallDataReceivedCallback(pThis         :=  this, 
                                                                    pCallbackMeth :=  #TCP_DataReceive_Callback());
        
        udTimeoutTS := ops.tAbsolute;
        States.Connect := CS_WaitForConnectTCP;
                
      //Not Accepted
      else
        
        dTemp := _TCPIPClient.GetLastError();
        
        //Log Error
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_ADDCONN_FAIL_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_ADDCONN_FAIL_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_TCP_ADDCONN_FAIL_TEXT,
                      pPara1		:=	#dTemp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        States.Connect := CS_Error;
        
      end_if;

      
    //--------------------------------------------------------
    //Wait for the TCP Connection to be establised
    //-------------------------------------------------------- 
  	t_e_MQTTClientStates_Connect::CS_WaitForConnectTCP:
    
      //If connected
      if TCPIPClientInterface_MQTTClient.IsConnected() then
      
        States.Connect := CS_BuildCONNECT;
      
      //If timeout
      elsif ops.tAbsolute - udTimeoutTS >= cConnectTimeout then
        
        //Delete the connection
        TCPIPClientInterface_MQTTClient.DelConnection();        
        //Log Error
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_TCP_CONN_TIMEOUT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_TCP_CONN_TIMEOUT_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_TCP_TCP_CONN_TIMEOUT_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        States.Connect := CS_Error;
        
      end_if;
    
    //--------------------------------------------------------
    //Build CONNECT Message, Load into Outgoing Messages list
    //--------------------------------------------------------
  	t_e_MQTTClientStates_Connect::CS_BuildCONNECT:
    
      if MQP_ControlPacket_CONNECT() < 0 then
        //Log Error
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_CONNECTION_CONNECT_PCKT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_CONNECTION_CONNECT_PCKT_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_CONNECTION_CONNECT_PCKT_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      end_if;
      States.Connect := CS_WaitForCONNACK;
      udTimeoutTS := ops.tAbsolute;
    
    //--------------------------------------------------------
    //Wait For CONNACK, Handle Timeout
    //--------------------------------------------------------
  	t_e_MQTTClientStates_Connect::CS_WaitForCONNACK:
    
      //If connected
      if ops.tAbsolute - udTimeoutTS >= cConnectTimeout then
        
        //Log Error
        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_CONNECTION_CONNACK_TIMEOUT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_CONNECTION_CONNACK_TIMEOUT_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_CONNECTION_CONNACK_TIMEOUT_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        States.Connect := CS_Error;
        
      end_if;
    
    //--------------------------------------------------------
    //Conn Rejected
    //--------------------------------------------------------
    t_e_MQTTClientStates_Connect::CS_ConnectionRejected:
      
      //Set FSMs
      States.Connect := CS_DNSLookup;
      ConnectionDataStruct.bConnect := FALSE;
      
    //--------------------------------------------------------
    //Finalize, Prepare for next state
    //--------------------------------------------------------
  	t_e_MQTTClientStates_Connect::CS_Finalize:
      
      //Set FSMs
      States.Connect := CS_DNSLookup;
      MQTTClientState := MCS_Connected;
      
      //Reset Reconnect
      ConnectionDataStruct.ReconnectData.udExponent := 1;
      
      //Update Keepalive Timestamp
      ConnectionDataStruct.KeepaliveData.udLastPINGREQ := ops.tAbsolute;
      ConnectionDataStruct.KeepaliveData.udLastPINGRESP := ops.tAbsolute;
      
    //--------------------------------------------------------
    //Error Occurred
    //--------------------------------------------------------
    t_e_MQTTClientStates_Connect::CS_Error:
      
      //Set FSMs
      States.Connect := CS_DNSLookup;
      States.Reconnect := RS_Init;
      MQTTClientState := MCS_Reconnect;
      
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient::MQTTTask_Reconnect
  
  //====================================================
  //Reconnect FSM
  //====================================================
  case States.Reconnect of
    
    //-------------------------------------------------
    //Init The Reconnect
    //-------------------------------------------------
    t_e_MQTTClientStates_Reconnect::RS_Init:
    
      //Set timestamp and variables
      udTimeoutTS := ops.tAbsolute;
      
      if ConnectionDataStruct.ReconnectData.bExponential then
        ConnectionDataStruct.ReconnectData.udCurrentDelay := to_udint((ConnectionDataStruct.ReconnectData.udReconnectMin)**ConnectionDataStruct.ReconnectData.udExponent);
      else
        ConnectionDataStruct.ReconnectData.udCurrentDelay := to_udint(ConnectionDataStruct.ReconnectData.udReconnectMin*ConnectionDataStruct.ReconnectData.udExponent);
      end_if;

      if ConnectionDataStruct.ReconnectData.udCurrentDelay <= ConnectionDataStruct.ReconnectData.udReconnectMax then
        ConnectionDataStruct.ReconnectData.udExponent += 1;
      end_if;
      
      if ConnectionDataStruct.ReconnectData.udCurrentDelay > ConnectionDataStruct.ReconnectData.udReconnectMax then
        ConnectionDataStruct.ReconnectData.udCurrentDelay := ConnectionDataStruct.ReconnectData.udReconnectMax;
      end_if;

      States.Reconnect := RS_WaitForInterval;
    
    //-------------------------------------------------
    //Wait for the required interval
    //-------------------------------------------------
    t_e_MQTTClientStates_Reconnect::RS_WaitForInterval:
    
      //If the timeout has completed
      if ops.tAbsolute - udTimeoutTS >= ConnectionDataStruct.ReconnectData.udCurrentDelay then
        States.Reconnect := RS_Reconnect;
        //Log Error
        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_CONNECTION_RECONN_TIMEOUT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_CONNECTION_RECONN_TIMEOUT_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_CONNECTION_RECONN_TIMEOUT_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        
      end_if;
    
    //-------------------------------------------------
    //Reconnect
    //-------------------------------------------------
    t_e_MQTTClientStates_Reconnect::RS_Reconnect:
    
      //Prepare the Connection to be remade
      TCPIPClientInterface_MQTTClient.DelConnection();
      
      States.Reconnect := RS_Init;
      
      //Go to Connect State
      States.Connect := CS_DNSLookup;
      MQTTClientState := MCS_Connect;
      
  end_case;

  
  
END_FUNCTION

FUNCTION MQTTClient::MQTTTask_Disconnect
  
  //Process the Outgoing message queue until the DISCONNECT packet has been sent, not after
  if States.Disconnect <= DS_WaitForSendConfirmation then
    PacketQueue_ProcessOutgoing();
  end_if;

  //==============================================================
  //FSM For the DISCONNECT Procedure
  //==============================================================
  case States.Disconnect of
  
    //-------------------------------------------------
    //Build DISCONNECT Packet
    //-------------------------------------------------
    t_e_MQTTClientStates_Disconnect::DS_BuildPacket:
     
      MQP_ControlPacket_DISCONNECT();
      udTimeoutTS := ops.tAbsolute;
      States.Disconnect := DS_WaitForSendConfirmation;
    
    //-------------------------------------------------
    //Wait for the send confirmation
    //-------------------------------------------------
    t_e_MQTTClientStates_Disconnect::DS_WaitForSendConfirmation:
    
      //If waiting for the confirmation (by callback) that the DISCONNECT Packet has been sent times out, manually advance state
      if ops.tAbsolute - udTimeoutTS >= cDisconnectTimeout then
        
        States.Disconnect := DS_DeleteConnection;
        
        //Log Error
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_CONNECTION_DISCONNECT_TIMEOUT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_CONNECTION_DISCONNECT_TIMEOUT_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_CONNECTION_DISCONNECT_TIMEOUT_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        
      end_if;
      
    //-------------------------------------------------
    //Delete TCP Connection
    //-------------------------------------------------
    t_e_MQTTClientStates_Disconnect::DS_DeleteConnection:
    
      //Prepare the Connection to be remade
      TCPIPClientInterface_MQTTClient.DelConnection();    
    
      States.Disconnect := DS_Finalize;
    
    //-------------------------------------------------
    //Finalize & Cleanup
    //-------------------------------------------------
    t_e_MQTTClientStates_Disconnect::DS_Finalize:

      States.Disconnect := DS_BuildPacket;
      MQTTClientState   := MCS_Initialise;
      
      //If the Disconnect Callback is set, perform it
      if CallbacksStruct.DisconnectCallback.pMethod &
         CallbacksStruct.DisconnectCallback.pThis then
        
        CallbacksStruct.DisconnectCallback.pMethod$OnDisconnect(pThis   :=  CallbacksStruct.DisconnectCallback.pThis, 
                                                                retCode :=  MQTTCLIENT_DISCONNECT_RETCODE_USER);
        
      end_if;

    
  end_case;

    
END_FUNCTION

FUNCTION MQTTClient::KeepAlive_ProcessPing
  
  //If keepalive is disabled
  if ConnectionDataStruct.KeepaliveData.uiKeepAlive = 0 then
    return;
  end_if;
  
  //If the ping interval (For Transmitting) has timed out
  if ops.tAbsolute - ConnectionDataStruct.KeepaliveData.udLastPINGREQ >= (ConnectionDataStruct.KeepaliveData.uiKeepAlive*1secs)/2 then
    
    //Create PINGREQ Message
    MQP_ControlPacket_PINGREQ();
    
    //Update Timestamp
    ConnectionDataStruct.KeepaliveData.udLastPINGREQ := ops.tAbsolute;
  
  //If the ping receive interval has timed out
  elsif ops.tAbsolute - ConnectionDataStruct.KeepaliveData.udLastPINGRESP >= ConnectionDataStruct.KeepaliveData.uiKeepAlive*1secs then
    
    //Log
    Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                  dMsgGroup	:=	MQCLI_LOG_WARNING_KEEPALIVE_TIMEOUT_GRP,
                  dMsgNbr		:=	MQCLI_LOG_WARNING_KEEPALIVE_TIMEOUT_MSG,
                  pMsg			:=	MQCLI_LOG_WARNING_KEEPALIVE_TIMEOUT_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

    
    //Initiate Reconnect
    MQTTClientState := MCS_Reconnect;
    
    //If the Disconnect Callback is set, perform it
    if CallbacksStruct.DisconnectCallback.pMethod &
       CallbacksStruct.DisconnectCallback.pThis then
      
      CallbacksStruct.DisconnectCallback.pMethod$OnDisconnect(pThis   :=  CallbacksStruct.DisconnectCallback.pThis, 
                                                              retCode :=  MQTTCLIENT_DISCONNECT_RETCODE_UNEXP);
      
    end_if;
    
  end_if;
  
END_FUNCTION
//================================================================================================================================================================
//------------------------------------------------------------------END OF CYCLIC METHODS-------------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//------------------------------------------------------------------PACKET QUEUE METHODS--------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient::PacketQueue_ProcessOutgoing
  VAR
  	udLen, udRemainingLen, udOffset : UDINT;
    dRet : DINT;
  END_VAR
  
  
  //=========================================================================
  //Send Message FSM
  //=========================================================================
  case TxPktDataStruct.ProcessState of
    
    //--------------------------------------------
    //Wait for new outgoing message
    //--------------------------------------------
    t_e_SendMessageProcessStates::MPS_WaitForMessage:
      
      //Get Msg
      TxPktDataStruct.dMessageID := OutgoingPackets.GetPacket(pMessage  :=  #TxPktDataStruct.Message, 
                                                              pCBThis   :=  #TxPktDataStruct.pCBThis, 
                                                              pCBMeth   :=  #TxPktDataStruct.pCBMeth,
                                                              pMsgType    :=  #TxPktDataStruct.MsgType,
                                                              pDirection  :=  #TxPktDataStruct.Direction);
      
      //If there is a message
      if TxPktDataStruct.dMessageID >= 0 then
        
        //Advance State
        TxPktDataStruct.ProcessState  := MPS_SendMessage;
        TxPktDataStruct.pSend         := TxPktDataStruct.Message.pData;
        TxPktDataStruct.MessageState  := MTS_Data;
        
      end_if;

    //--------------------------------------------
    //Send Current Message
    //--------------------------------------------
    t_e_SendMessageProcessStates::MPS_SendMessage:
      
      //===================================
      //Determine send parameters
      //===================================
      case TxPktDataStruct.MessageState of
        
        //----------------
        //Initial Section
        //----------------
        MTS_Data:
          
          //If the amount of data remaining fits into one send with bytes to spare
          if (TxPktDataStruct.Message.pData$UDINT + TxPktDataStruct.Message.udDataSize) - TxPktDataStruct.pSend$UDINT < MQTTCLIENT_LASALOS_MAX_TCP_SIZE then
          
            //If there is a payload
            if TxPktDataStruct.Message.pPayload then
              
              //Clear temp message
              //Copy the data to temp message
              //Set pointers and len
              
              SigCLib.MemSet(dst  :=  #TCPPacket, 
                               c    :=  0x00, 
                               len  :=  sizeof(TCPPacket));
                               
              SigCLib.MemCpy(dst0 :=  #TCPPacket, 
                               src0 :=  TxPktDataStruct.pSend, 
                               len0 :=  (TxPktDataStruct.Message.pData$UDINT + TxPktDataStruct.Message.udDataSize) - TxPktDataStruct.pSend$UDINT);
              
              
              //Calc Remaining length in this packet
              udRemaininglen := MQTTCLIENT_LASALOS_MAX_TCP_SIZE - ((TxPktDataStruct.Message.pData$UDINT + TxPktDataStruct.Message.udDataSize) - TxPktDataStruct.pSend$UDINT);
              
              TxPktDataStruct.pSend := #TCPPacket;
              
              //If the payload is longer than the remaining len
              if TxPktDataStruct.Message.udPayloadSize > udRemainingLen then
                
                //Copy the section of the payload into remaining len
                SigCLib.MemCpy( dst0  :=  (#TCPPacket$UDINT) + sizeof(TCPPacket) - udRemainingLen, 
                                  src0  :=  TxPktDataStruct.Message.pPayload, 
                                  len0  :=  udRemainingLen);
                
                //Set offset for next cycle
                udOffset := udRemainingLen;
                
                //We will process the payload next
                TxPktDataStruct.MessageState := MTS_Payload;
                
                udLen := MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
                
              else
                
                //Copy the payload into the Remaining Length
                SigCLib.MemCpy( dst0  :=  (#TCPPacket$UDINT) + sizeof(TCPPacket) - udRemainingLen, 
                                  src0  :=  TxPktDataStruct.Message.pPayload, 
                                  len0  :=  TxPktDataStruct.Message.udPayloadSize);                
                
                udLen := TxPktDataStruct.Message.udDataSize + TxPktDataStruct.Message.udPayloadSize;
                
                //Message is done processing
                TxPktDataStruct.MessageState := MTS_Done;
                
              end_if;

              
            //No payload
            else
              
              udLen := (TxPktDataStruct.Message.pData$UDINT + TxPktDataStruct.Message.udDataSize) - TxPktDataStruct.pSend$UDINT;
              
              //Message is done processing
              TxPktDataStruct.MessageState := MTS_Done;
              
            end_if;

          //If there is more data than one send cycle
          elsif (TxPktDataStruct.Message.pData$UDINT + TxPktDataStruct.Message.udDataSize) - TxPktDataStruct.pSend$UDINT > MQTTCLIENT_LASALOS_MAX_TCP_SIZE then
          
            //Set the len to the full amount of data
            udLen := MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
            udOffset := TxPktDataStruct.pSend$UDINT - TxPktDataStruct.Message.pData$UDINT + MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
            
            TxPktDataStruct.pSend$UDINT += udOffset;
            
            TxPktDataStruct.MessageState := MTS_Data;
          
          //If the Data section fits perfectly into the TCP Send
          elsif (TxPktDataStruct.Message.pData$UDINT + TxPktDataStruct.Message.udDataSize) - TxPktDataStruct.pSend$UDINT = MQTTCLIENT_LASALOS_MAX_TCP_SIZE then
            
            //Set the len to the full amount of data
            udLen := MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
            udOffset := 0;
            
            //If there is a payload
            if TxPktDataStruct.Message.pPayload then
            
              //Send the payload
              TxPktDataStruct.MessageState := MTS_Payload;
            
            else
            
              //Message is done processing
              TxPktDataStruct.MessageState := MTS_Done;
            
            end_if;

          end_if;
        
        //----------------
        //Separate Payload
        //----------------
        MTS_Payload:
        
          //If there is less data available than will fit in a message
          if (TxPktDataStruct.Message.pPayload$UDINT + TxPktDataStruct.Message.udPayloadSize) - TxPktDataStruct.pSend$UDINT < MQTTCLIENT_LASALOS_MAX_TCP_SIZE then
            
            udLen := (TxPktDataStruct.Message.pPayload$UDINT + TxPktDataStruct.Message.udPayloadSize) - TxPktDataStruct.pSend$UDINT;
            TxPktDataStruct.MessageState := MTS_Done;
          
          //If there is more data available than will fit in a message
          elsif (TxPktDataStruct.Message.pPayload$UDINT + TxPktDataStruct.Message.udPayloadSize) - TxPktDataStruct.pSend$UDINT > MQTTCLIENT_LASALOS_MAX_TCP_SIZE then
            
            udLen := MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
            udOffset := TxPktDataStruct.pSend$UDINT - TxPktDataStruct.Message.pPayload$UDINT + MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
            TxPktDataStruct.MessageState := MTS_Payload;
            
          //If there is exactly the same amount of data as space in a message
          elsif (TxPktDataStruct.Message.pPayload$UDINT + TxPktDataStruct.Message.udPayloadSize) - TxPktDataStruct.pSend$UDINT = MQTTCLIENT_LASALOS_MAX_TCP_SIZE then
          
            udLen := MQTTCLIENT_LASALOS_MAX_TCP_SIZE;
            udOffset := 0;
            TxPktDataStruct.MessageState := MTS_Done;
          
          end_if;

        
      end_case;
      
      //Send Message
      dRet := TCPIPClientInterface_MQTTClient.SendData( pData   :=  TxPktDataStruct.pSend, 
                                                        udSize  :=  udLen,  
                                                        bDirect :=  TRUE);
      
      
      if dRet <> TCP_CLT_SEND_OK then
        

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_SEND_FAIL_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_SEND_FAIL_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_TCP_SEND_FAIL_TEXT,
                      pPara1		:=	#TxPktDataStruct.dMessageID,
                      pPara2		:=	#dRet,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      end_if;

      //Set pSend for next cycle:
      case TxPktDataStruct.MessageState of
        
        MTS_Data:
          
          TxPktDataStruct.pSend$UDINT := TxPktDataStruct.Message.pData$UDINT + udOffset;
          
        MTS_Payload:
        
          TxPktDataStruct.pSend$UDINT := TxPktDataStruct.Message.pPayload$UDINT + udOffset;
        
        MTS_Done:
          
          //If the Callback is set, perform it
          if TxPktDataStruct.pCBThis &
             TxPktDataStruct.pCBMeth then
            
            TxPktDataStruct.pCBMeth$MessageSentCallback(pThis :=  TxPktDataStruct.pCBThis, 
                                                        dID   :=  TxPktDataStruct.dMessageID,
                                                        MsgType   :=  TxPktDataStruct.MsgType,
                                                        dDirection :=  TxPktDataStruct.Direction);
            
          end_if;

          
          //Clear the message
          OutgoingPackets.ClearPacket(dID:=TxPktDataStruct.dMessageID);
          
          //Clear the Struct
          TxPktDataStruct.ProcessState          := MPS_WaitForMessage;
          TxPktDataStruct.pSend                 := NIL;
          TxPktDataStruct.Message.pData         := NIL;
          TxPktDataStruct.Message.pPayload      := NIL;
          TxPktDataStruct.Message.udDataSize    := 0;
          TxPktDataStruct.Message.udPayloadSize := 0;
          TxPktDataStruct.dMessageID            := -1;
          TxPktDataStruct.pCBThis               := NIL;
          TxPktDataStruct.pCBMeth               := NIL;
                    
      end_case;

      
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient::PacketQueue_ProcessIncoming
  VAR
  	ThisPacket  : MQTTPacketQueue::t_s_Packet;
    bDup        : BOOL;
    iQoS        : INT;
    bRetain     : BOOL;
    udOffset    : UDINT;
  END_VAR

  //Get the message data
  RxPktDataStruct.dID := IncomingPackets.GetPacket(pMessage   :=  #ThisPacket,
                                                   pCBThis    :=  NIL,
                                                   pCBMeth    :=  NIL,
                                                   pMsgType   :=  NIL,
                                                   pDirection :=  NIL);
  
  //If we didn't get a message, stop
  if RxPktDataStruct.dID < 0 then
    return;
  end_if;
  
  bDup := FALSE;
  iQoS := -1;
  bRetain := FALSE;
  
  //Determine Message Type and size
  RxPktDataStruct.MsgType := MQP_FixedHeader_GetType(pData:=ThisPacket.pData);
  udOffset                := MQP_FixedHeader_GetLen(pData:=ThisPacket.pData, pLen:=#RxPktDataStruct.udLen);
  
  //If the length was decoded successfully
  if udOffset = 0 then
  
    //Create Log:
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_MQTT_PCKT_LEN_DECODE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_MQTT_PCKT_LEN_DECODE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_MQTT_PCKT_LEN_DECODE_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

                  
    IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
    return;
  end_if;
  
  bDup    := MQP_FixedHeader_GetDup(pData:=ThisPacket.pData);
  iQoS    := MQP_FixedHeader_GetQoS(pData:=ThisPacket.pData);
  bRetain := MQP_FixedHeader_GetRet(pData:=ThisPacket.pData);
  
  //Offset the data pointer to skip the Flags and Len of the Fixed Header
  ThisPacket.pData$UDINT += 1;
  ThisPacket.pData$UDINT += udOffset; 
  
  //=========================================
  //Based on the type of message, process it
  //=========================================
  case RxPktDataStruct.MsgType of
    //-------------------------------------------------
    //CONNECT
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_CONNECT:
    
      //Create Log:
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_MQTT_CONNECT_RX_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_MQTT_CONNECT_RX_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_MQTT_CONNECT_RX_TEXT,
                    pPara1		:=	NIL,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //CONNACK
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_CONNACK:
      
      MQP_Process_CONNACK( pData :=  ThisPacket.pData, 
                           udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //PUBLISH Message -> Data for a subscribed topic
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PUBLISH:
      
      MQP_Process_PUBLISH(  pData     :=  ThisPacket.pData, 
                            udLen     :=  RxPktDataStruct.udLen, 
                            iQoS      :=  iQoS, 
                            bDup      :=  bDup, 
                            bRetain   :=  bRetain,
                            dQueueID  :=  RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Publish Acknowledgement
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PUBACK:
    
      MQP_Process_PUBACK( pData :=  ThisPacket.pData, 
                          udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Publish Received
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PUBREC:
      
      MQP_Process_PUBREC( pData :=  ThisPacket.pData, 
                          udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Publish Release
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PUBREL:
      
      MQP_Process_PUBREL( pData :=  ThisPacket.pData, 
                          udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Publish Complete
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PUBCOMP:
      
      MQP_Process_PUBCOMP( pData :=  ThisPacket.pData, 
                           udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Subscribe -> Should never receive
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_SUBSCRIBE:
      
      //Create Log:
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_MQTT_SUBSCRIBE_RX_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_MQTT_SUBSCRIBE_RX_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_MQTT_SUBSCRIBE_RX_TEXT,
                    pPara1		:=	NIL,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Subscribe Acknowledgement
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_SUBACK:
      
      MQP_Process_SUBACK( pData :=  ThisPacket.pData, 
                          udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);

    //-------------------------------------------------
    //Unsubscribe -> Should Never receive
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_UNSUBSCRIBE:
      
      //Create Log:
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_MQTT_UNSUBSCRIBE_RX_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_MQTT_UNSUBSCRIBE_RX_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_MQTT_UNSUBSCRIBE_RX_TEXT,
                    pPara1		:=	NIL,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Unsubscribe Acknowledgement -> Acknowledgement for unsubscribe request
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_UNSUBACK:
      
      MQP_Process_UNSUBACK( pData :=  ThisPacket.pData, 
                            udLen :=  RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Ping Request -> Respond with Ping Response
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PINGREQ:
      
      MQP_Process_PINGREQ(pData := ThisPacket.pData, 
                          udLen := RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Ping Response -> Response to a Ping Request
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_PINGRESP:
      
      MQP_Process_PINGRESP(pData  := ThisPacket.pData, 
                           udLen  := RxPktDataStruct.udLen);
      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Disconnect -> Should never receive
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_DISCONNECT:
      
      //Create Log: 
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_MQTT_DISCONNECT_RX_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_MQTT_DISCONNECT_RX_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_MQTT_DISCONNECT_RX_TEXT,
                    pPara1		:=	NIL,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
      
    //-------------------------------------------------
    //Unknown -> Should never receive this
    //-------------------------------------------------
    MQTTClient::t_e_MQTTControlPackets::MCP_UNKNOWN:
    
      //Create Log:
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_MQTT_UNKNOWN_PKT_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_MQTT_UNKNOWN_PKT_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_MQTT_UNKNOWN_PKT_TEXT,
                    pPara1		:=	NIL,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      
      IncomingPackets.ClearPacket(dID:=RxPktDataStruct.dID);
  
  end_case;
  
END_FUNCTION
//================================================================================================================================================================
//-------------------------------------------------------------- END OF PACKET QUEUE METHODS----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//---------------------------------------------------------------------LOGGING METHODS----------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient::Log_CreateLog
	VAR_INPUT
		usLevel 	: USINT;
		dMsgGroup 	: DINT;
		dMsgNbr 	: DINT;
		pMsg 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		pPara3 	: ^DINT;
		pPara4 	: ^DINT;
	END_VAR
  VAR
  	aLogString  : ARRAY[0..MQTT_LOG_MAX_TEXT_LEN] of CHAR;
    aParaString : ARRAY[0..MQTT_LOG_PARA_TEXT_LEN] of CHAR;
    udLen, udParaLen, udDelimLen : UDINT;
  END_VAR

  //If the user has set a log callback, buid the string to log and call the callback
  //With Details
  if CallbacksStruct.LogWithDetailCallback.pThis    &
     CallbacksStruct.LogWithDetailCallback.pMethod  then
  
    CallbacksStruct.LogWithDetailCallback.pMethod$OnLog_WithDetail( pThis     :=  CallbacksStruct.LogWithDetailCallback.pThis, 
                                                                    usLevel   :=  usLevel,
                                                                    dMsgGroup :=  dMsgGroup, 
                                                                    dMsgNbr   :=  dMsgNbr, 
                                                                    pMsg      :=  pMsg, 
                                                                    pPara1    :=  pPara1, 
                                                                    pPara2    :=  pPara2, 
                                                                    pPara3    :=  pPara3, 
                                                                    pPara4    :=  pPara4,
                                                                    1);

  //We need to bake the details into the String ourselves
  elsif CallbacksStruct.LogCallback.pThis    &
        CallbacksStruct.LogCallback.pMethod  then
    
    if pMsg = NIL then
      
      return;
    end_if;

    udLen := SigCLib.StrLen(str:=pMsg);
      
    SigCLib.MemSet( dst :=  #aLogString[0], 
                      c   :=  0x00, 
                      len :=  sizeof(aLogString));
    
    //If the string fits, copy else truncate it to fit, log that we truncated and return.
    if udLen < MQTT_LOG_MAX_TEXT_LEN then
      SigCLib.StrCpy( dst0  :=  #aLogString[0], 
                      src0  :=  pMsg);
    else
      SigCLib.MemCpy( dst0  :=  #aLogString[0], 
                      src0  :=  pMsg, 
                      len0  :=  MQTT_LOG_MAX_TEXT_LEN);  
      CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                 level :=  MQTT_LOG_ERR, 
                                                 pStr  :=  #aLogString[0]);
      return;
    end_if;
    
    //For each parameter, convert the para, if it fits add it, else log and return.
    //--------------------------------------------------------------------------------
    //Para 1
    //--------------------------------------------------------------------------------
    if pPara1 then
      
      SigCLib.MemSet( dst :=  #aParaString, 
                      c   :=  0x00, 
                      len :=  sizeof(aParaString));
      
      SigCLib.IToA( val   :=  pPara1^, 
                    dst   :=  #aParaString[0], 
                    base  :=  10);
      
      udParaLen   := SigCLib.StrLen(str :=  #aParaString[0]);
      udDelimLen  := SigCLib.StrLen(str :=  MQTT_LOG_PARA_DELIM);
      
      if udParaLen + udLen + udDelimLen < MQTT_LOG_MAX_TEXT_LEN then
        
        SigCLib.StrCat( ps1 :=  #aLogString[0], 
                        ps2 :=  MQTT_LOG_PARA_DELIM);
        
        SigCLib.StrCat( ps1 :=  #aLogString[0], 
                        ps2 :=  #aParaString[0]);
      
      else
        
        CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                   level :=  to_int(usLevel), 
                                                   pStr  :=  #aLogString[0]);
        
        CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                   level :=  MQTT_LOG_ERR, 
                                                   pStr  :=  MQTT_LOG_ERROR_LOGFAILED_STRINGTOOLONG);
        return;        
        
      end_if;

    end_if;
    
    //--------------------------------------------------------------------------------
    //Para 2
    //--------------------------------------------------------------------------------
    if pPara2 then
      
      SigCLib.MemSet( dst :=  #aParaString, 
                      c   :=  0x00, 
                      len :=  sizeof(aParaString));
      
      SigCLib.IToA( val   :=  pPara2^, 
                    dst   :=  #aParaString[0], 
                    base  :=  10);
      
      udParaLen   := SigCLib.StrLen(str :=  #aParaString[0]);
      udDelimLen  := SigCLib.StrLen(str :=  MQTT_LOG_PARA_DELIM);
      
      if udParaLen + udLen + udDelimLen < MQTT_LOG_MAX_TEXT_LEN then
        
        SigCLib.StrCat( ps1 :=  #aLogString[0], 
                        ps2 :=  MQTT_LOG_PARA_DELIM);
        
        SigCLib.StrCat( ps1 :=  #aLogString[0], 
                        ps2 :=  #aParaString[0]);
      
      else
        
        CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                   level :=  to_int(usLevel), 
                                                   pStr  :=  #aLogString[0]);
        
        CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                   level :=  MQTT_LOG_ERR, 
                                                   pStr  :=  MQTT_LOG_ERROR_LOGFAILED_STRINGTOOLONG);
        return;        
        
      end_if;

    end_if;
    
    //--------------------------------------------------------------------------------
    //Para 3
    //--------------------------------------------------------------------------------
    if pPara3 then
      
      SigCLib.MemSet( dst :=  #aParaString, 
                      c   :=  0x00, 
                      len :=  sizeof(aParaString));
      
      SigCLib.IToA( val   :=  pPara3^, 
                    dst   :=  #aParaString[0], 
                    base  :=  10);
      
      udParaLen   := SigCLib.StrLen(str :=  #aParaString[0]);
      udDelimLen  := SigCLib.StrLen(str :=  MQTT_LOG_PARA_DELIM);
      
      if udParaLen + udLen + udDelimLen < MQTT_LOG_MAX_TEXT_LEN then
        
        SigCLib.StrCat( ps1 :=  #aLogString[0], 
                        ps2 :=  MQTT_LOG_PARA_DELIM);
        
        SigCLib.StrCat( ps1 :=  #aLogString[0], 
                        ps2 :=  #aParaString[0]);
      
      else
        
        CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                   level :=  to_int(usLevel), 
                                                   pStr  :=  #aLogString[0]);
        
        CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                                   level :=  MQTT_LOG_ERR, 
                                                   pStr  :=  MQTT_LOG_ERROR_LOGFAILED_STRINGTOOLONG);
        return;        
        
      end_if;

    end_if;
        
    CallbacksStruct.LogCallback.pMethod$OnLog( pThis :=  CallbacksStruct.LogCallback.pThis, 
                                               level :=  to_int(usLevel), 
                                               pStr  :=  pMsg);
  
  end_if;

  
END_FUNCTION
//================================================================================================================================================================
//------------------------------------------------------------------END OF LOGGING METHODS------------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-----------------------------------------------------------------SERVER INTERFACE METHODS-----------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION VIRTUAL GLOBAL MQTTClient::ClientID::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	ClientID := MQTTClientID.Data.Read();
	output := ClientID;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient::ClientID::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	ClientID := input;
	result := (MQTTClientID.Data.Write(ClientID))$UDINT;

END_FUNCTION
//================================================================================================================================================================
//--------------------------------------------------------------END OF SERVER INTERFACE METHODS-------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//--------------------------------------------------------------------TCP INTEFACE METHODS------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient::TCP_DataReceive_Callback
	VAR_INPUT
		pThis 	: ^void;
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
  
  //If the this pointer is OK, call the MQTTClient internal method
  if pThis then
    
    pThis$^MQTTClient^.TCP_DataReceive( pData   := pData,
                                        udSize  := udSize);
    
  end_if;
  
END_FUNCTION



FUNCTION MQTTClient::TCP_DataReceive
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
  VAR
    udLen, udConsumed : UDINT;
    bComplete : BOOL;
    dLen : DINT;
  	bBusy : BOOL;
  END_VAR

  //If the pointers and size are not ok, stop
  if pData = NIL  |
     udSize = 0   then
    return;
  end_if;
  
  //=======================================
  //FSM For Receiving an MQTT Message
  //=======================================
  case TCPRecvDataStruct.ProcessState of
    
  //-----------------------------------------------
  //Wait for a new message, receive single part Msg
  //-----------------------------------------------
  t_e_TCPRecvProcessStates::TRS_WaitForMessage:
    
    bBusy := TRUE;
    
    while bBusy do
      
      //Calc len (Remaining Len + size of Fixed Header)
      //In this call udLen is increased twice, once over the pointer and secondly as return value.
      udLen         += MQP_FixedHeader_GetLen(pData:=pData, pLen:=#udLen);  
      udLen         += 1;
      
      TCPRecvDataStruct.dQueueID := IncomingPackets.InsertPacket( pData             :=  pData, 
                                                                  udSize            :=  udLen, 
                                                                  pPayload          :=  NIL, 
                                                                  udPayloadSize     :=  0, 
                                                                  udBytesAvailable  :=  udSize,
                                                                  pCBThis           :=  NIL,
                                                                  pCBMeth           :=  NIL,
                                                                  Direction         :=  1,
                                                                  MsgType           :=  MCP_PUBLISH); //This message type does not matter.
         
      //If the message was accepted
      if TCPRecvDataStruct.dQueueID >= 0 then
        
        
        //If the Message is multipart, go to next state
        if udLen > udSize then
          
          bBusy := FALSE;
          TCPRecvDataStruct.ProcessState  := TRS_ReceiveMessage;
          TCPRecvDataStruct.udMsgTS       := ops.tAbsolute;
        
        //If this is more than one message (Xth message in TCP stream).
        elsif udSize > udLen then
          
          bBusy := TRUE;
          udSize      -= udLen;
          pData$UDINT += udLen;
          
        //We end on exactly one message
        else
          
          bBusy := FALSE;
          
        end_if;
      
      //Socket Error
      else
        
        bBusy := FALSE;   //KNEMAR 20200930
        
        //Initiate Reconnect
        MQTTClientState := MCS_Reconnect;
        
        dLen := to_dint(udSize);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_SOCKET_ERR_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_SOCKET_ERR_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_TCP_SOCKET_ERR_TEXT,
                      pPara1		:=	#TCPRecvDataStruct.dQueueID,
                      pPara2		:=	#dLen,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      end_if;
      
    end_while;
    
  //-----------------------------------------------
  //Receive Multipart Msg
  //-----------------------------------------------
  t_e_TCPRecvProcessStates::TRS_ReceiveMessage:
    
    //If the append is successful
    udConsumed := IncomingPackets.AppendToPacket( dID               :=  TCPRecvDataStruct.dQueueID, 
                                                  pData             :=  pData, 
                                                  udBytesAvailable  :=  udSize, 
                                                  pComplete         :=  #bComplete);
    
    //Did not accept any data
    if udConsumed = 0 then
      
      dLen := to_dint(udSize);
      
      //Create Log:
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_APPEND_FAIL_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_APPEND_FAIL_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_TCP_APPEND_FAIL_TEXT,
                    pPara1		:=	#TCPRecvDataStruct.dQueueID,
                    pPara2		:=	#dLen,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
      
      //finalize and change state
      TCPRecvDataStruct.ProcessState := TRS_WaitForMessage;
      TCPRecvDataStruct.dQueueID := -1;
    
    //Message is completed
    elsif bComplete then

      TCPRecvDataStruct.ProcessState := TRS_WaitForMessage;
      
      //If a new message start already lies in the data we received
      if udConsumed < udSize then
        TCP_DataReceive(pData   :=  (pData$UDINT + udConsumed)$^void, 
                        udSize  :=  udSize - udConsumed);
      end_if;
    
    //Message still appending, reset watchdog timeout.
    else
      
      TCPRecvDataStruct.udMsgTS := ops.tAbsolute;
      
    end_if;

    
  end_case;
  
END_FUNCTION

FUNCTION MQTTClient::TCP_ErrorOccurred_Callback
	VAR_INPUT
		pThis 	: ^void;
		TCPFSM 	: _TCPIPClient::_FSM_TCPIP_CLIENT;
		ErrorGroup 	: DINT;
		ErrorCode 	: DINT;
	END_VAR
  
  //If the this pointer is OK, call the internal method to process the callback data.
  if pThis then
    
    pThis$^MQTTClient^.TCP_ErrorOccurred( TCPFSM      := TCPFSM,
                                          ErrorGroup  := ErrorGroup,
                                          ErrorCode   := ErrorCode);
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::TCP_ErrorOccurred
	VAR_INPUT
		TCPFSM 	: _TCPIPClient::_FSM_TCPIP_CLIENT;
		ErrorGroup 	: DINT;
		ErrorCode 	: DINT;
	END_VAR
  
  //If connected, Log, call the disconnected callback and Reconnect
  if MQTTClientState = MCS_Connected  | 
     MQTTClientState = MCS_Reconnect  |
     MQTTClientState = MCS_Connect    then
    
    //Delete the TCP Connection Handle
    if ConnectionDataStruct.dTCPHandle <> 0 then
      TCPIPClientInterface_MQTTClient.DelConnection();
      ConnectionDataStruct.dTCPHandle := 0;
    end_if;
    
    //Create Log
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_COM_ERROR_CBK_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_COM_ERROR_CBK_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_TCP_COM_ERROR_CBK_TEXT,
                  pPara1		:=	#ErrorGroup,
                  pPara2		:=	#ErrorCode,
                  pPara3		:=	#TCPFSM$DINT,
                  pPara4		:=	NIL);
    

    //If connected and the Disconnect Callback is set, perform it
    if  MQTTClientState = MCS_Connected             &
        CallbacksStruct.DisconnectCallback.pMethod  &
        CallbacksStruct.DisconnectCallback.pThis    then
      
      CallbacksStruct.DisconnectCallback.pMethod$OnDisconnect(pThis   :=  CallbacksStruct.DisconnectCallback.pThis, 
                                                              retCode :=  MQTTCLIENT_DISCONNECT_RETCODE_UNEXP);
      
    end_if;
    
    //==============================================================================
    //Based on the current state and error code returned, set the MQTTClient State
    //==============================================================================
    case MQTTClientState of
    
      //--------------------------------------------
      //Currently connecting, catch the case where
      //the TCP Socket cannot be created 
      //(No MQTT / TCP Server on the Port)
    	//--------------------------------------------
      MQTTClient::t_e_MQTTClientStates::MCS_Connect:
      
        //TCP Socket could not be created - No server at the address
        if ErrorCode = TCP_NET_UNREACH then
          
          MQTTClientState := MCS_Reconnect;
          States.Reconnect := RS_Init;
        
        //Any other error - try to reconnect
        else
        
          //Reconnect
          MQTTClientState := MCS_Reconnect;
          States.Reconnect := RS_Init;
        
        end_if;
        
      //Not in any of the states handled above
      else
      
        //Reconnect
        MQTTClientState := MCS_Reconnect;
        States.Reconnect := RS_Init;
      
    end_case;

    
    
  
  end_if;

END_FUNCTION
//================================================================================================================================================================
//---------------------------------------------------------------END OF TCP INTERFACE METHODS---------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-------------------------------------------------------------------MQTT PROTOCOL METHODS------------------------------------------------------------------------
//================================================================================================================================================================

FUNCTION MQTTClient::MQP_ControlPackets
	VAR_INPUT
		usPacket 	: USINT;
		CPTask 	: t_e_ControlPacketTasks;
	END_VAR
	VAR_OUTPUT
		pPacket 	: ^void;
	END_VAR
  VAR
  	pPtr : ^void;
  END_VAR

  //Assume Fail
  pPacket := NIL;
  
  if usPacket = 1 then
    pPtr := pCtrlPkt1;    
  elsif usPacket = 2 then
    pPtr := pCtrlPkt2;    
  end_if;
  
  //===========================
  //Do work
  //===========================
  case CPTask of
    //-------------------------------
    //Malloc
    //-------------------------------
  	t_e_ControlPacketTasks::CPT_Init:
      
      case usPacket of
      
      1:      
          if pCtrlPkt1 = NIL then
            
            pCtrlPkt1 := MemoryHeap.MallocV1( size0 :=  MQTTCLIENT_TEMP_CTLPACKET_SIZE, 
                                              mark0 :=  MQTTCLIENT_DEFAULT_MALLOC_MARK);
            
            //If the malloc succeeded
            if pCtrlPkt1 then
              pPacket := pCtrlPkt1;
            end_if;

            
          end_if;
          
      2:      
          if pCtrlPkt2 = NIL then
            
            pCtrlPkt2 := MemoryHeap.MallocV1( size0 :=  MQTTCLIENT_TEMP_CTLPACKET_SIZE, 
                                              mark0 :=  MQTTCLIENT_DEFAULT_MALLOC_MARK);
            
            //If the malloc succeeded
            if pCtrlPkt2 then
              pPacket := pCtrlPkt2;
            end_if;

            
          end_if;
          
      end_case;

    //-------------------------------
    //MemSet
    //-------------------------------
  	t_e_ControlPacketTasks::CPT_Clear:
      
      //If the packet is inited
      if pPtr then
        
        //Clear
        SigCLib.MemSet( dst :=  pPtr, 
                          c   :=  0x00, 
                          len :=  MQTTCLIENT_TEMP_CTLPACKET_SIZE);
        
        //OK
        pPacket := pPtr;
        
      end_if;
    
    //-------------------------------
    //Get Pointer
    //-------------------------------
  	t_e_ControlPacketTasks::CPT_GetPtr:
      
      pPacket := pPtr;
    
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Str16ToMQTTString
	VAR_INPUT
		pStr16 	: ^UINT;
		pMQTTStr 	: ^void;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
  	udStr16Len, udCharsWritten : UDINT;
  END_VAR

  //Assume Fail
  udBytesWritten := 0;
  
  //If the Input values are not ok, stop
  if pStr16 = NIL   |
     pMQTTStr = NIL then
    return;        
  end_if;

  //If the string is too long, stop
  udStr16Len := SigCLib.StrLen16(str0:=pStr16);
  if udStr16Len > MQTTCLIENT_CONTROLPACKET_MAX_STR_LEN  then
    return;        
  end_if;
  
  //Do the conversion
  udCharsWritten := SigCLib.Str16ToUtf8(dst :=  (pMQTTStr$UDINT + 2)$^void, 
                                          src :=  pStr16);
    
  //Set the number of bytes written (UTF8 is backwards comaptible with ASCII & NULL Terminated)
  (pMQTTStr$^UINT)^ := to_uint(SigCLib.StrLen(str  :=  (pMQTTStr$UDINT + 2)$^CHAR));
  
  //Set number of bytes written (Add 2 bytes for the heading bytes)
  udBytesWritten := to_udint(pMQTTStr^$UINT + 2);
  
  //Turn the bytes for spec
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pMQTTStr);
  
  
END_FUNCTION

FUNCTION MQTTClient::MQP_DataToMQTTPayload
	VAR_INPUT
		pData 	: ^void;
		udDataLen 	: UDINT;
		pMQTTPayload 	: ^void;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR

  //Assume Fail
  udBytesWritten := 0;
  
  //If the Input values are not ok, stop
  if pData = NIL   |
     pMQTTPayload = NIL then
    return;        
  end_if;

  //If the data is too long, stop
  if udDataLen > MQTTCLIENT_CONTROLPACKET_MAX_STR_LEN  then
    return;        
  end_if;
  
  //Set number of bytes written (Add 2 for the heading bytes)
  udBytesWritten := udDataLen + 2;
  
  //Copy the data
  SigCLib.MemCpy(dst0 :=  (pMQTTPayload$UDINT + 2)$^void, 
                   src0 :=  pData,  
                   len0 :=  udDataLen);
    
  //Set the number of bytes written
  (pMQTTPayload$^UINT)^ := to_uint(udDataLen);
  
  //Turn the bytes for spec
  MQP_TurnBytes(usBytes :=  2, 
            pData   :=  pMQTTPayload);

END_FUNCTION

FUNCTION MQTTClient::MQP_UTF8ByteLen
	VAR_INPUT
		pUTF8 	: ^void;
	END_VAR
	VAR_OUTPUT
		udLen 	: UDINT;
	END_VAR
  VAR
  	bIsChar : BOOL;
    pThisChar : ^void;
  END_VAR

  //Assume 0
  udLen := 0;
  
  //If the input pointer is incorrect, stop
  if pUTF8 = NIL then
    return;
  end_if;
  
  bIsChar := TRUE;
  pThisChar := pUTF8;
  
  while bIsChar do
    
    bIsChar := TRUE;
    
    //If this is a NULL Char
    if pThisChar^$BYTE = 0x00 then
      
      bIsChar := FALSE;
      
    //If this is a single byte char
    elsif (pThisChar^$BYTE OR 0x80) = 0x00 then
      
      pThisChar$UDINT += 1;
      
    //If this is a double byte char
    elsif (pThisChar^$BYTE OR 0xE0) = 0xC0 then
    
      pThisChar$UDINT += 2;
    
    //If this is a triple byte char
    elsif (pThisChar^$BYTE OR 0xF0) = 0xE0 then
    
      pThisChar$UDINT += 3;
    
    //If this is a quadruple byte char
    elsif (pThisChar^$BYTE OR 0xF8) = 0xF0 then
    
      pThisChar$UDINT += 4;
    
    end_if;

    
  end_while;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_TurnBytes
	VAR_INPUT
		usBytes 	: USINT;
		pData 	: ^void;
	END_VAR
  VAR
  	Temp : BYTE;
    p1, p2 : ^BYTE;
  END_VAR

  //If the number of bytes is not ok or pointer not set, stop
  if  pData = NIL   |
      (usBytes <> 1 &
       usBytes <> 2 &
       usBytes <> 4 ) then
    return;  
  end_if;

  case usBytes of
    
    
    2:  
        p1 := pData$^BYTE;
        p2 := (pData$UDINT + 1)$^BYTE;
        Temp  := p1^;
        p1^   := p2^;
        p2^   := Temp;
    
    4:  
        p1 := pData$^BYTE;
        p2 := (pData$UDINT + 3)$^BYTE;
        Temp  := p1^;
        p1^   := p2^;
        p2^   := Temp;
        
        p1 := (pData$UDINT + 1)$^BYTE;
        p2 := (pData$UDINT + 2)$^BYTE;
        Temp  := p1^;
        p1^   := p2^;
        p2^   := Temp;
        
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader
	VAR_INPUT
		pData 	: ^void;
		HeaderType 	: t_e_MQTTControlPackets;
		udRemainingLen 	: UDINT;
		sQoS 	: SINT;
		bDUP 	: BOOL;
		bRetain 	: BOOL;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
  	byPUB : BYTE;
  END_VAR

  //Assume 0 Bytes
  udBytesWritten := 0;
  
  //If the input data is not ok
  if pData = NIL                                  |
     udRemainingLen > MQTTCLIENT_MAX_DATA_LEN - 2 then
    return;
  end_if;
  
  //Bytes Written for ID and Flags
  udBytesWritten += 1;
  
  //=======================================
  //Based on packet type, build ID & Flags
  //=======================================
  case HeaderType of
  	t_e_MQTTControlPackets::MCP_CONNECT:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_CONNECT OR 
                     MQTT_PROT_FIXHDR_FLAGS_CONNECT;
    
  	t_e_MQTTControlPackets::MCP_CONNACK:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_CONNACK OR 
                     MQTT_PROT_FIXHDR_FLAGS_CONNACK;
    
  	t_e_MQTTControlPackets::MCP_PUBLISH:
      
      //Setup Flags
      byPUB := 0;
      byPUB := byPUB OR ((bDUP$BYTE) SHL MQTT_PROT_FIXHDR_FLAGS_PUBLISH_DUP);
      byPUB := byPUB OR ((sQoS$BYTE) SHL MQTT_PROT_FIXHDR_FLAGS_PUBLISH_QOS);
      byPUB := byPUB OR ((bRetain$BYTE) SHL MQTT_PROT_FIXHDR_FLAGS_PUBLISH_RET);
      
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PUBLISH OR 
                     byPUB;
    
  	t_e_MQTTControlPackets::MCP_PUBACK:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PUBACK OR 
                     MQTT_PROT_FIXHDR_FLAGS_PUBACK;
    
  	t_e_MQTTControlPackets::MCP_PUBREC:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PUBREC OR 
                     MQTT_PROT_FIXHDR_FLAGS_PUBREC;
    
  	t_e_MQTTControlPackets::MCP_PUBREL:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PUBREL OR 
                     MQTT_PROT_FIXHDR_FLAGS_PUBREL;
    
  	t_e_MQTTControlPackets::MCP_PUBCOMP:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PUBCOMP OR 
                     MQTT_PROT_FIXHDR_FLAGS_PUBCOMP;
    
  	t_e_MQTTControlPackets::MCP_SUBSCRIBE:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_SUBSCRIBE OR 
                     MQTT_PROT_FIXHDR_FLAGS_SUBSCRIBE;
    
  	t_e_MQTTControlPackets::MCP_SUBACK:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_SUBACK OR 
                     MQTT_PROT_FIXHDR_FLAGS_SUBACK;
    
  	t_e_MQTTControlPackets::MCP_UNSUBSCRIBE:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_UNSUBSCRIBE OR 
                     MQTT_PROT_FIXHDR_FLAGS_UNSUBSCRIBE;
    
  	t_e_MQTTControlPackets::MCP_UNSUBACK:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_UNSUBACK OR 
                     MQTT_PROT_FIXHDR_FLAGS_UNSUBACK;
    
  	t_e_MQTTControlPackets::MCP_PINGREQ:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PINGREQ OR 
                     MQTT_PROT_FIXHDR_FLAGS_PINGREQ;
    
  	t_e_MQTTControlPackets::MCP_PINGRESP:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_PINGRESP OR 
                     MQTT_PROT_FIXHDR_FLAGS_PINGRESP;
    
  	t_e_MQTTControlPackets::MCP_DISCONNECT:
    
      pData^$BYTE := MQTT_PROT_FIXHDR_ID_DISCONNECT OR 
                     MQTT_PROT_FIXHDR_FLAGS_DISCONNECT;
    
  end_case;
  
  //Encode Remaining Length
  udBytesWritten += MQP_FixedHeader_EncRemLen(udRemainingLen  :=  udRemainingLen, 
                                              pData           :=  (pData$UDINT + 1)$^void);
  
  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_GetType
	VAR_INPUT
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		MsgType 	: t_e_MQTTControlPackets;
	END_VAR
  
  //Assume unknown
  MsgType := MCP_UNKNOWN;
  
  //If the message pointer is ok
  if pData then
    
    //Set the Message type based on the header
    case (pData$^BYTE^ AND 0xF0)$INT of
      
    MQTT_PROT_FIXHDR_ID_CONNECT$INT:
      MsgType := MCP_CONNECT;
      
    MQTT_PROT_FIXHDR_ID_CONNACK$INT:
      MsgType := MCP_CONNACK;
      
    MQTT_PROT_FIXHDR_ID_PUBLISH$INT:
      MsgType := MCP_PUBLISH;
      
    MQTT_PROT_FIXHDR_ID_PUBACK$INT:
      MsgType := MCP_PUBACK;
      
    MQTT_PROT_FIXHDR_ID_PUBREC$INT:
      MsgType := MCP_PUBREC;
      
    MQTT_PROT_FIXHDR_ID_PUBREL$INT:
      MsgType := MCP_PUBREL;
      
    MQTT_PROT_FIXHDR_ID_PUBCOMP$INT:
      MsgType := MCP_PUBCOMP;
      
    MQTT_PROT_FIXHDR_ID_SUBSCRIBE$INT:
      MsgType := MCP_SUBSCRIBE;
      
    MQTT_PROT_FIXHDR_ID_SUBACK$INT:
      MsgType := MCP_SUBACK;
      
    MQTT_PROT_FIXHDR_ID_UNSUBSCRIBE$INT:
      MsgType := MCP_SUBACK;
      
    MQTT_PROT_FIXHDR_ID_UNSUBACK$INT:
      MsgType := MCP_UNSUBACK;
      
    MQTT_PROT_FIXHDR_ID_PINGREQ$INT:
      MsgType := MCP_PINGREQ;
      
    MQTT_PROT_FIXHDR_ID_PINGRESP$INT:
      MsgType := MCP_PINGRESP;
      
    MQTT_PROT_FIXHDR_ID_DISCONNECT$INT:
      MsgType := MCP_DISCONNECT;
      
    end_case;

    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_GetLen
	VAR_INPUT
		pData 	: ^void;
		pLen 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		udBytes 	: UDINT;
	END_VAR

  //Assume Fail
  udBytes := 0;
  pLen^ := 0;
  
  //If the pointer is ok
  if pData  &
     pLen   then
    
    //Get Len, if fail, then clear value and stop
    udBytes := MQP_FixedHeader_DecRemLen(pData:=(pData$UDINT + 1)$^void, pValue:=pLen);
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_DecRemLen
	VAR_INPUT
		pData 	: ^void;
		pValue 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		udBytes 	: UDINT;
	END_VAR
  VAR
  	udMult : UDINT;
    MyByte : BYTE;
  END_VAR

  //Assume not OK
  udBytes := 0;
  
  udMult := 1;
  pValue^ := 0;
    
  repeat
    
    udBytes += 1;
    MyByte := pData^$BYTE;
    
    pValue^ += to_udint(MyByte AND 127) * udMult;
    udMult *= 128;
    if udMult > 128*128*128*128 then
      udBytes := 0;
      return;
    end_if;
    
    pData$UDINT += 1;
    
  until (MyByte AND 128) = 0 end_repeat;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_EncRemLen
	VAR_INPUT
		udRemainingLen 	: UDINT;
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		udBytes 	: UDINT;
	END_VAR
  VAR
    MyByte : BYTE;
  END_VAR
  
  udBytes := 0;
  
  //If pointer is not ok, stop execution
  if pData = NIL then
    return;
  end_if;
  
  udBytes := 1;
  
  while udRemainingLen > 0 do
    
    MyByte := udRemainingLen MOD 128;
    udRemainingLen := udRemainingLen / 128;
    
    if udRemainingLen > 0 then
      
      pData^$BYTE := MyByte OR 128;
      pData$UDINT += 1;
      udBytes += 1;
      
    else
      
      pData^$BYTE := MyBYTE;
      
    end_if;

    
  end_while;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_GetDup
	VAR_INPUT
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		bDup 	: BOOL;
	END_VAR

  //Assume False
  bDup := FALSE;
  
  //If the pointer is ok
  if pData then
    
    bDup := to_bool(pData$^BYTE^ AND MQTT_PROT_FIXHDR_FLAGS_PUBLISH_DUP_MASK);
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_GetRet
	VAR_INPUT
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		bRet 	: BOOL;
	END_VAR

  //Assume False
  bRet := FALSE;
  
  //If the pointer is ok
  if pData then
    
    bRet := to_bool(pData$^BYTE^ AND MQTT_PROT_FIXHDR_FLAGS_PUBLISH_RET_MASK);
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_FixedHeader_GetQoS
	VAR_INPUT
		pData 	: ^void;
	END_VAR
	VAR_OUTPUT
		iQoS 	: INT;
	END_VAR

  //Assume Fail
  iQoS := -1;
  
  //If the pointer is ok
  if pData then
    
    iQoS := to_int(((pData$^BYTE^ AND MQTT_PROT_FIXHDR_FLAGS_PUBLISH_QOS_MASK)$BYTE) shr MQTT_PROT_FIXHDR_FLAGS_PUBLISH_QOS_SHR );
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_CONNECT
	VAR_OUTPUT
		dPcktID 	: DINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets( usPacket  :=  1, 
                           CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets( usPacket  :=  2, 
                           CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Read the Client ID
  SigCLib.MemSet(dst  :=  #ConnectionDataStruct.aClientID, 
                   c    :=  0x00, 
                   len  :=  sizeof(ConnectionDataStruct.aClientID));
  MQTTClientID.ToUniCode();
  MQTTClientID.TxtGet(pdst    :=  #ConnectionDataStruct.aClientID[0], 
                      dstsize :=  sizeof(ConnectionDataStruct.aClientID));
  
  //Build the CONNECT Packet
  udBytes := MQP_VarHeader_CONNECT( pData         :=  pPtr2, 
                                    bUserName     :=  ConnectionDataStruct.AuthData.bUsername, 
                                    bPassword     :=  ConnectionDataStruct.AuthData.bPassword, 
                                    bWillRetain   :=  ConnectionDataStruct.WillData.bWillRetain, 
                                    usWillQoS     :=  ConnectionDataStruct.WillData.usWillQoS, 
                                    bWill         :=  ConnectionDataStruct.WillData.bWill, 
                                    bCleanSession :=  (CleanSession = 1), 
                                    uiKeepAlive   :=  ConnectionDataStruct.KeepaliveData.uiKeepAlive);
  
  udBytes += MQP_Payload_CONNECT( pData             :=  (pPtr2$UDINT + udBytes)$^void, 
                                  pClientID         :=  #ConnectionDataStruct.aClientID[0], 
                                  pWillTopic        :=  #ConnectionDataStruct.WillData.aWillTopic[0], 
                                  pWillMessage      :=  #ConnectionDataStruct.WillData.aWillMessage, 
                                  udWillMessageLen  :=  ConnectionDataStruct.WillData.udWillMessageLen,
                                  pUserName         :=  #ConnectionDataStruct.AuthData.aUsername[0], 
                                  pPassword         :=  #ConnectionDataStruct.AuthData.aPassword[0],
                                  udPassLen         :=  ConnectionDataStruct.AuthData.udPassLen);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_CONNECT, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  FALSE, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                    src0  :=  pPtr2, 
                    len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  dPcktID := OutgoingPackets.InsertPacket(  pData             :=  pPtr1, 
                                            udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                            pPayload          :=  NIL,  
                                            udPayloadSize     :=  0, 
                                            udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                            pCBThis           :=  NIL,
                                            pCBMeth           :=  NIL,
                                            Direction         :=  0,
                                            MsgType           :=  MCP_CONNECT);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PINGREQ
  VAR
  	udLen : UDINT;
    pPtr1, pPtr : ^void;
    dID : DINT;
  END_VAR

  //Clear the temp packet, prep pointers
  pPtr1 := MQP_ControlPackets( usPacket  :=  1, 
                           CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build Message
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                       HeaderType      :=  MCP_PINGREQ, 
                                       udRemainingLen  :=  0, 
                                       sQoS            :=  FALSE, 
                                       bDUP            :=  FALSE, 
                                       bRetain         :=  FALSE);
  
  udLen := pPtr$UDINT - pPtr1$UDINT;
  
  //Load the Message
  dID := OutgoingPackets.InsertPacket(pData             :=  pPtr1, 
                                      udSize            :=  udLen, 
                                      pPayload          :=  NIL, 
                                      udPayloadSize     :=  0, 
                                      udBytesAvailable  :=  udLen,
                                      pCBThis           :=  NIL,
                                      pCBMeth           :=  NIL,
                                      Direction         :=  0,
                                      MsgType           :=  MCP_PINGREQ);
  
  //If adding the message failed, log the error
  if dID < 0 then
    //Create Log:
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_OUT_PINGREQ_PCKT_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_OUT_PINGREQ_PCKT_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_OUT_PINGREQ_PCKT_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  end_if;
  
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PINGRESP
  VAR
  	udLen : UDINT;
    pPtr1, pPtr : ^void;
    dID : DINT;
  END_VAR

  //Clear the temp packet, prep pointers
  pPtr1 := MQP_ControlPackets(usPacket  :=  1, 
                              CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build Message
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_PINGRESP, 
                                 udRemainingLen  :=  0, 
                                 sQoS            :=  FALSE, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);

  udLen := pPtr$UDINT - pPtr1$UDINT;
  
  //Load the Message
  dID := OutgoingPackets.InsertPacket(pData            :=  pPtr1, 
                                      udSize           :=  udLen, 
                                      pPayload         :=  NIL, 
                                      udPayloadSize    :=  0, 
                                      udBytesAvailable :=  udLen,
                                      pCBThis          :=  NIL,
                                      pCBMeth          :=  NIL,
                                      Direction        :=  0,
                                      MsgType          :=  MCP_PINGRESP);
  
  //If adding the message failed, log the error
  if dID < 0 then
    //Create Log:
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_OUT_PINGRESP_PCKT_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_OUT_PINGRESP_PCKT_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_OUT_PINGRESP_PCKT_TEXT,
                  pPara1		:=	NIL,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_DISCONNECT
  VAR
    pPtr1, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets( usPacket  :=  1, 
                           CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Create DISCONNECT HEader
  pPtr$UDINT += MQP_FixedHeader(pData           :=  pPtr1, 
                                HeaderType      :=  MCP_DISCONNECT, 
                                udRemainingLen  :=  0, 
                                sQoS            :=  0, 
                                bDUP            :=  FALSE, 
                                bRetain         :=  FALSE);
  
  //Add Packet to outgoing queue
  ConnectionDataStruct.dDisconnectMsgID := OutgoingPackets.InsertPacket(pData             :=  pPtr1, 
                                                                        udSize            :=  pPtr$UDINT - pPtr1$UDINT, 
                                                                        pPayload          :=  NIL,  
                                                                        udPayloadSize     :=  0, 
                                                                        udBytesAvailable  :=  pPtr$UDINT - pPtr1$UDINT,
                                                                        pCBThis           :=  this,
                                                                        pCBMeth           :=  #PacketQueue_MsgSent_Callback(),
                                                                        Direction         :=  0,
                                                                        MsgType           :=  MCP_DISCONNECT);

END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_SUBSCRIBE
	VAR_INPUT
		iMid 	: INT;
		pTopic 	: ^UINT;
		sQoS 	: SINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets(  usPacket  :=  1, 
                                CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets(  usPacket  :=  2, 
                                CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the SUBSCRIBE Packet
  udBytes := MQP_VarHeader_SUBSCRIBE( pData :=  pPtr2, 
                                      iMid  :=  iMid);
  
  udBytes += MQP_Payload_SUBSCRIBE( pData   :=  (pPtr2$UDINT + udBytes)$^void, 
                                    pTopic  :=  pTopic, 
                                    sQoS    :=  sQoS);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_SUBSCRIBE, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  0, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                    src0  :=  pPtr2, 
                    len0  :=  udBytes);
    
  //Add Packet to outgoing queue
  OutgoingPackets.InsertPacket( pData             :=  pPtr1, 
                                udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                pPayload          :=  NIL,  
                                udPayloadSize     :=  0, 
                                udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                pCBThis           :=  NIL,
                                pCBMeth           :=  NIL,
                                Direction         :=  0,
                                MsgType           :=  MCP_SUBSCRIBE);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_UNSUBSCRIBE
	VAR_INPUT
		iMid 	: INT;
		pTopic 	: ^UINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets(  usPacket  :=  1, 
                                CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets(  usPacket  :=  2, 
                                CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the SUBSCRIBE Packet
  udBytes := MQP_VarHeader_UNSUBSCRIBE( pData :=  pPtr2, 
                                        iMid  :=  iMid);
  
  udBytes += MQP_Payload_UNSUBSCRIBE( pData   :=  (pPtr2$UDINT + udBytes)$^void, 
                                      pTopic  :=  pTopic);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_UNSUBSCRIBE, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  0, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                    src0  :=  pPtr2, 
                    len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  OutgoingPackets.InsertPacket( pData             :=  pPtr1, 
                                udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                pPayload          :=  NIL,  
                                udPayloadSize     :=  0, 
                                udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                pCBThis           :=  NIL,
                                pCBMeth           :=  NIL,
                                Direction         :=  0,
                                MsgType           :=  MCP_UNSUBSCRIBE);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PUBLISH
	VAR_INPUT
		bDup 	: BOOL;
		iQoS 	: INT;
		bRetain 	: BOOL;
		pTopic 	: ^UINT;
		iMid 	: INT;
		pPayload 	: ^void;
		udPayloadLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		dPacketID 	: DINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets( usPacket  :=  1, 
                               CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets( usPacket  :=  2, 
                               CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the PUBLISH Packet
  udBytes := MQP_VarHeader_PUBLISH( pData   :=  pPtr2, 
                                    pTopic  :=  pTopic, 
                                    iMid    :=  iMid,
                                    iQoS    :=  iQoS);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr, 
                                 HeaderType      :=  MCP_PUBLISH, 
                                 udRemainingLen  :=  udBytes + udPayloadLen, 
                                 sQoS            :=  to_sint(iQoS), 
                                 bDUP            :=  bDup, 
                                 bRetain         :=  bRetain);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                  src0  :=  pPtr2, 
                  len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  dPacketID := OutgoingPackets.InsertPacket(  pData             :=  pPtr1, 
                                              udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                              pPayload          :=  pPayload,  
                                              udPayloadSize     :=  udPayloadLen, 
                                              udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                              pCBThis           :=  this,
                                              pCBMeth           :=  #PacketQueue_MsgSent_Callback(),
                                              Direction         :=  0,
                                              MsgType           :=  MCP_PUBLISH);

END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PUBREC
	VAR_INPUT
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		dPacketID 	: DINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets(  usPacket  :=  1, 
                                CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets(  usPacket  :=  2, 
                                CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the PUBREC Packet
  udBytes := MQP_VarHeader_PUBREC( pData :=  pPtr2, 
                                   iMid  :=  iMid);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_PUBREC, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  0, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                    src0  :=  pPtr2, 
                    len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  dPacketID := OutgoingPackets.InsertPacket(  pData             :=  pPtr1, 
                                              udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                              pPayload          :=  NIL,  
                                              udPayloadSize     :=  0, 
                                              udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                              pCBThis           :=  this,
                                              pCBMeth           :=  #PacketQueue_MsgSent_Callback(),
                                              Direction         :=  1,  //We are responding to an incoming PUBLISH QoS 2
                                              MsgType           :=  MCP_PUBREC);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PUBREL
	VAR_INPUT
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		dPacketID 	: DINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets(  usPacket  :=  1, 
                                CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets(  usPacket  :=  2, 
                                CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the PUBREC Packet
  udBytes := MQP_VarHeader_PUBREL( pData :=  pPtr2, 
                                   iMid  :=  iMid);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_PUBREL, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  0, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                    src0  :=  pPtr2, 
                    len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  dPacketID := OutgoingPackets.InsertPacket(  pData             :=  pPtr1, 
                                              udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                              pPayload          :=  NIL,  
                                              udPayloadSize     :=  0, 
                                              udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                              pCBThis           :=  this,
                                              pCBMeth           :=  #PacketQueue_MsgSent_Callback(),
                                              Direction         :=  0,  //We are sending an outgoig QoS2 Publish
                                              MsgType           :=  MCP_PUBREL);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PUBCOMP
	VAR_INPUT
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		dPacketID 	: DINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets(  usPacket  :=  1, 
                                CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets(  usPacket  :=  2, 
                                CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the PUBREC Packet
  udBytes := MQP_VarHeader_PUBCOMP( pData :=  pPtr2, 
                                    iMid  :=  iMid);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_PUBCOMP, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  0, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                    src0  :=  pPtr2, 
                    len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  dPacketID := OutgoingPackets.InsertPacket(  pData             :=  pPtr1, 
                                              udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                              pPayload          :=  NIL,  
                                              udPayloadSize     :=  0, 
                                              udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                              pCBThis           :=  this,
                                              pCBMeth           :=  #PacketQueue_MsgSent_Callback(),
                                              Direction         :=  1,  //We are responding to an incoming PUBLISH QoS2
                                              MsgType           :=  MCP_PUBCOMP);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_ControlPacket_PUBACK
	VAR_INPUT
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		dPacketID 	: DINT;
	END_VAR
  VAR
  	udBytes : UDINT;
    pPtr1, pPtr2, pPtr : ^void;
  END_VAR

  //Clear the temp packet
  pPtr1 := MQP_ControlPackets(  usPacket  :=  1, 
                                CPTask    :=  CPT_Clear);
  pPtr2 := MQP_ControlPackets(  usPacket  :=  2, 
                                CPTask    :=  CPT_Clear);
  
  pPtr := pPtr1;
  
  //Build the PUBREC Packet
  udBytes := MQP_VarHeader_PUBREC( pData :=  pPtr2, 
                                   iMid  :=  iMid);
  
  pPtr$UDINT += MQP_FixedHeader( pData           :=  pPtr1, 
                                 HeaderType      :=  MCP_PUBACK, 
                                 udRemainingLen  :=  udBytes, 
                                 sQoS            :=  0, 
                                 bDUP            :=  FALSE, 
                                 bRetain         :=  FALSE);
  //Copy to packet 1
  SigCLib.MemCpy( dst0  :=  pPtr, 
                  src0  :=  pPtr2, 
                  len0  :=  udBytes);
  
  //Add Packet to outgoing queue
  dPacketID := OutgoingPackets.InsertPacket(  pData             :=  pPtr1, 
                                              udSize            :=  pPtr$UDINT + udBytes - pPtr1$UDINT, 
                                              pPayload          :=  NIL,  
                                              udPayloadSize     :=  0, 
                                              udBytesAvailable  :=  pPtr$UDINT + udBytes - pPtr1$UDINT,
                                              pCBThis           :=  this,
                                              pCBMeth           :=  #PacketQueue_MsgSent_Callback(),
                                              Direction         :=  1, // We are responding to an incoming PUBLISH QoS 1
                                              MsgType           :=  MCP_PUBACK);
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_CONNECT
	VAR_INPUT
		pData 	: ^void;
		bUserName 	: BOOL;
		bPassword 	: BOOL;
		bWillRetain 	: BOOL;
		usWillQoS 	: USINT;
		bWill 	: BOOL;
		bCleanSession 	: BOOL;
		uiKeepAlive 	: UINT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  	aTempASCII : ARRAY[0..4] of CHAR;
    aTempSTR16 : ARRAY[0..4] of UINT;
    byFlags : BYTE;
  END_VAR
  
  udBytesWritten := 0;
  
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Protocol Name
  SigCLib.MemSet( dst :=  #aTempASCII, 
                  c   :=  0x00, 
                  len :=  sizeof(aTempASCII));
                  
  SigCLib.MemSet( dst :=  #aTempSTR16, 
                  c   :=  0x00, 
                  len :=  sizeof(aTempSTR16));
                  
  SigCLib.StrCpy( dst0  :=  #aTempASCII[0], 
                  src0  :=  MQTT_PROT_PROTNAME);
                  
  SigCLib.ToStr16(dst0  :=  #aTempSTR16[0], 
                  src0  :=  #aTempASCII[0]);
    
  pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  #aTempSTR16[0], 
                                        pMQTTStr  :=  pWrite);
  
  //Protocol Level
  pWrite$^USINT^ := MQTT_PROT_LEVEL;
  pWrite$UDINT   += 1;
  
  //Flags
  byFlags := 0x00;
    //Username
    byFlags := byFlags OR (bUserName SHL 7);
    //Password
    byFlags := byFlags OR (bPassword SHL 6);
    //Will Retain
    byFlags := byFlags OR (bWillRetain SHL 5);
    //Will QoS
    byFlags := byFlags OR (usWillQoS SHL 3);
    //Will Flag
    byFlags := byFlags OR (bWill SHL 2);
    //Clean Session
    byFlags := byFlags OR (bCleanSession SHL 1);
  
  pWrite$^BYTE^ := byFlags;
  pWrite$UDINT  += 1;
  
  //Keep Alive
  pWrite$^UINT^ := uiKeepAlive;
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pWrite);
  pWrite$UDINT += 2;
  
  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_SUBSCRIBE
	VAR_INPUT
		pData 	: ^void;
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  END_VAR
  
  udBytesWritten := 0;
    
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Packet Identifier
  pWrite$^INT^ := iMid;
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pWrite);
  pWrite$UDINT += 2;
  
  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_UNSUBSCRIBE
	VAR_INPUT
		pData 	: ^void;
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  END_VAR
  
  udBytesWritten := 0;
    
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Packet Identifier
  pWrite$^INT^ := iMid;
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pWrite);
  pWrite$UDINT += 2;
  
  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_PUBLISH
	VAR_INPUT
		pData 	: ^void;
		pTopic 	: ^UINT;
		iMid 	: INT;
		iQoS 	: INT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  END_VAR
  
  udBytesWritten := 0;
  
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Topic
  if pTopic^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pTopic, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  //Packet Identifier  
  if iQoS <> 0 then
    pWrite$^INT^ := iMid;
    MQP_TurnBytes(usBytes :=  2, 
                  pData   :=  pWrite);
    pWrite$UDINT += 2;
  end_if;

  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_PUBREC
	VAR_INPUT
		pData 	: ^void;
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  END_VAR
  
  udBytesWritten := 0;
    
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Packet Identifier
  pWrite$^INT^ := iMid;
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pWrite);
  pWrite$UDINT += 2;
  
  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_PUBREL
	VAR_INPUT
		pData 	: ^void;
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  END_VAR
  
  udBytesWritten := 0;
    
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Packet Identifier
  pWrite$^INT^ := iMid;
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pWrite);
  pWrite$UDINT += 2;
  
  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_VarHeader_PUBCOMP
	VAR_INPUT
		pData 	: ^void;
		iMid 	: INT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
    pWrite : ^void;
  END_VAR
  
  udBytesWritten := 0;
    
  //If the input is not OK
  if pData = NIL then
    return;
  end_if;
  
  pWrite := pData;
  
  //Packet Identifier
  pWrite$^INT^ := iMid;
  MQP_TurnBytes(usBytes :=  2, 
                pData   :=  pWrite);
  pWrite$UDINT += 2;
  
  //Number of bytes written
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_Payload_CONNECT
	VAR_INPUT
		pData 	: ^void;
		pClientID 	: ^UINT;
		pWillTopic 	: ^UINT;
		pWillMessage 	: ^void;
		udWillMessageLen 	: UDINT;
		pUserName 	: ^UINT;
		pPassword 	: ^BYTE;
		udPassLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
  	pWrite : ^void;
  END_VAR

  //If the Data pointer is not ok, return
  if pData = NIL then
    return;    
  end_if;
  
  pWrite := pData;
  
  //Client ID
  if pClientID^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pClientID, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  //Will Topic
  if pWillTopic^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pWillTopic, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  //Will Message
  if pWillMessage$^BYTE^ <> 0x00 then
    pWrite$UDINT += MQP_DataToMQTTPayload(pData         :=  pWillMessage, 
                                          udDataLen     :=  udWillMessageLen, 
                                          pMQTTPayload  :=  pWrite);
  end_if;
  
  //UserName
  if pUserName^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pUserName, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  //Password
  if pPassword$^BYTE^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pPassword$^UINT, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_Payload_SUBSCRIBE
	VAR_INPUT
		pData 	: ^void;
		pTopic 	: ^UINT;
		sQoS 	: SINT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
  	pWrite : ^void;
  END_VAR

  //If the Data pointer is not ok, return
  if pData = NIL then
    return;    
  end_if;
  
  pWrite := pData;
  
  //Topic
  if pTopic^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pTopic, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  //Requested QoS
  pWrite$^SINT^ := sQoS;
  pWrite$UDINT += 1;
  
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_Payload_UNSUBSCRIBE
	VAR_INPUT
		pData 	: ^void;
		pTopic 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		udBytesWritten 	: UDINT;
	END_VAR
  VAR
  	pWrite : ^void;
  END_VAR

  //If the Data pointer is not ok, return
  if pData = NIL then
    return;    
  end_if;
  
  pWrite := pData;
  
  //Topic
  if pTopic^ <> 0x00 then
    pWrite$UDINT += MQP_Str16ToMQTTString(pStr16    :=  pTopic, 
                                          pMQTTStr  :=  pWrite);
  end_if;
  
  udBytesWritten := pWrite$UDINT - pData$UDINT;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_CONNACK
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	usRetCode : USINT;
    byFlags : BYTE;
  END_VAR

  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK
  if pData &
     udLen = 2 then
    
    //Successfully processed the message
    bOK := TRUE;
        
    byFlags     := pData$^BYTE^;
    pData$UDINT += 1;
    usRetCode   := pData$^USINT^;
    
    //If the MQTTClient FSM is in the correct state
    if MQTTClientState = MCS_Connect then
      
      //=================================
      //Process RetCode
      //=================================
      case usRetCode of
      
        //---------------------------------
        //Connection was accepted
        //---------------------------------
        MQTT_PROT_CONNACK_RET_CONNACCEPTED:
          
          // Set the SessionPresent flag
          SessionPresent := (byFlags AND MQTT_PROT_CONNACK_FLAGS_SESS_PR);
          
          if SessionPresent = 0 then
            InflightMsgs_Clear();
          end_if;

          
          //Create Log:
          Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                        dMsgGroup	:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_OK_GRP,
                        dMsgNbr		:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_OK_MSG,
                        pMsg			:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_OK_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          
          //Advance State
          States.Connect := CS_Finalize;
          
        //---------------------------------
        //Incorrect Protocol version
        //---------------------------------
        MQTT_PROT_CONNACK_RET_PROTVERSION:
          
          //Create Log:
          Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                        dMsgGroup	:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_VER_GRP,
                        dMsgNbr		:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_VER_MSG,
                        pMsg			:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_VER_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          
      
          //Advance State
          States.Connect := CS_ConnectionRejected;
          
        //---------------------------------
        //Client ID Rejected
        //---------------------------------
        MQTT_PROT_CONNACK_RET_ID_REJECTED:
        
          //Create Log:
          
          Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                        dMsgGroup	:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_ID_REJ_GRP,
                        dMsgNbr		:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_ID_REJ_MSG,
                        pMsg			:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_ID_REJ_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          
          
          //Advance State
          States.Connect := CS_ConnectionRejected;
        
        //---------------------------------
        //Server Unavailable
        //---------------------------------
        MQTT_PROT_CONNACK_RET_SERVER_UNAVAIL:
        
          //Create Log:

          Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                        dMsgGroup	:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_SVR_UNAV_GRP,
                        dMsgNbr		:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_SVR_UNAV_MSG,
                        pMsg			:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_SVR_UNAV_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          
          
          //Advance State
          States.Connect := CS_ConnectionRejected;
        
        //---------------------------------
        //Incorrect Username / Password
        //---------------------------------
        MQTT_PROT_CONNACK_RET_USN_PASS:
        
          //Create Log:
          Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                        dMsgGroup	:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_USNPWD_GRP,
                        dMsgNbr		:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_USNPWD_MSG,
                        pMsg			:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_USNPWD_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          
          //Advance State
          States.Connect := CS_ConnectionRejected;      
                  
        //---------------------------------
        //Not Authorised
        //---------------------------------
        MQTT_PROT_CONNACK_RET_NOT_AUTHD:
        
          //Create Log:

          Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                        dMsgGroup	:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_NOTAUTHED_GRP,
                        dMsgNbr		:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_NOTAUTHED_MSG,
                        pMsg			:=	MQCLI_LOG_INFO_CONNECTION_MQP_INC_CONNACK_NOTAUTHED_TEXT,
                        pPara1		:=	NIL,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

         
          //Advance State
          States.Connect := CS_ConnectionRejected; 
                
      //Not implemented
      else
        
        //Log the error
        dPara1Temp := to_dint(usRetCode);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_CONNECTION_MQP_INC_CONNACK_UNKNOWN_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_CONNECTION_MQP_INC_CONNACK_UNKNOWN_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_CONNECTION_MQP_INC_CONNACK_UNKNOWN_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        
        //Advance State
        States.Connect := CS_ConnectionRejected;
        
      end_case;
      
      //If the Callback pointer is set
      if CallbacksStruct.ConnectCallback.pMethod  &
         CallbacksStruct.ConnectCallback.pThis    then
         
        CallbacksStruct.ConnectCallback.pMethod$OnConnect(pThis   :=  CallbacksStruct.ConnectCallback.pThis, 
                                                          retCode :=  to_int(usRetCode));
      
      end_if;
      
      if CallbacksStruct.ConnectWithFlagsCallback.pMethod  &
         CallbacksStruct.ConnectWithFlagsCallback.pThis    then
         
        CallbacksStruct.ConnectWithFlagsCallback.pMethod$OnConnectWithFlags(pThis   :=  CallbacksStruct.ConnectWithFlagsCallback.pThis, 
                                                                            retCode :=  to_int(usRetCode), 
                                                                            flags   :=  byFlags);
      
      end_if;
      
    //Not in correct state
    else
    
      //Create Log:
      dPara1Temp := to_dint(usRetCode);
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_CONNECTION_MQP_INC_CONNACK_STATE_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_CONNECTION_MQP_INC_CONNACK_STATE_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_CONNECTION_MQP_INC_CONNACK_STATE_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      
      //Advance State
      States.Connect := CS_ConnectionRejected;
      
    end_if;

    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PINGREQ
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK
  if pData &
     udLen = 0 then
    
    //Successfully processed the message
    bOK := TRUE;
  
    //Build a PINGRESP Package
    MQP_ControlPacket_PINGRESP();
  
  else
  
    //Create Log:
    dPara1Temp := to_dint(udLen);
    
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_INC_PINGREQ_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_INC_PINGREQ_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_KEEPALIVE_MQP_INC_PINGREQ_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PINGRESP
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the input values are OK
  if pData &
     udLen = 0 then
    
    //Accept Message OK
    bOK := TRUE;
    
    //Update Timestamp
    ConnectionDataStruct.KeepaliveData.udLastPINGRESP := ops.tAbsolute;
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_SUBACK
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid, iCount : INT;
    iNumGrantedQos : INT;
    pThisMsg : ^t_s_InflightMessage;
    aGrantedQoS : ARRAY[0..MQTTCLIENT_SUBACK_MAX_NUM_GRANTEDQOS-1] of INT;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK (Var header (2Bytes) and atleast 1 x Subscription (1Byte) )
  if pData &
     udLen >= 3 then
    
    //Successfully processed the message
    bOK := TRUE;
    
    //Get the return code
    MQP_TurnBytes( usBytes :=  2, 
                   pData   :=  pData);
               
    iMid := pData$^INT^;
    
    pData$UDINT += 2;
    
    //Number of Grant QoS pairs = Total Size - Size of Var header (2 bytes)
    iNumGrantedQoS := to_int(udLen) - 2;
    
    //If the Num granted QoS is 0
    if iNumGrantedQos = 0 then
      //Create Log:
      dPara1Temp := to_dint(iMid);

      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_ZERO_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_ZERO_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_ZERO_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      bOK := FALSE;
      return;
    end_if;

    //If the Number of granted QoS is too high, log and return
    if iNumGrantedQoS > MQTTCLIENT_SUBACK_MAX_NUM_GRANTEDQOS then
      //Create Log:
      dPara1Temp := to_dint(iMid);

      Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                    dMsgGroup	:=	MQCLI_LOG_WARNING_SUBSCRIBE_MQP_INC_SUBACK_TOO_MANY_GRP,
                    dMsgNbr		:=	MQCLI_LOG_WARNING_SUBSCRIBE_MQP_INC_SUBACK_TOO_MANY_MSG,
                    pMsg			:=	MQCLI_LOG_WARNING_SUBSCRIBE_MQP_INC_SUBACK_TOO_MANY_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      iNumGrantedQos := MQTTCLIENT_SUBACK_MAX_NUM_GRANTEDQOS;
      bOK := FALSE;
    end_if;
    
    //Repack the granted qos
    SigCLib.MemSet(dst  :=  #aGrantedQoS, 
                   c    :=  0x00, 
                   len  :=  sizeof(aGrantedQoS));
                   
    for iCount := 0 to iNumGrantedQoS - 1 do
      aGrantedQoS[iCount] := to_int(pData$^SINT^);
      pData$UDINT += 1;
    end_for;

    //Find the inflight message the SUBACK is responding to and set it to be removed
    pThisMsg := InflightMsgs_GetMsgByMid( MsgType   :=  IM_Subscribe, 
                                          mid       :=  iMid, 
                                          Direction :=  0);
    
    //Message Found
    if pThisMsg then
      
      pThisMsg^.MsgState += 1;
      pThisMsg^.bRemove := TRUE;
      
      //If the Callback pointer is set
      if CallbacksStruct.SubscribeCallback.pMethod  &
         CallbacksStruct.SubscribeCallback.pThis    then
         
        CallbacksStruct.SubscribeCallback.pMethod$OnSubscribe(pThis       :=  CallbacksStruct.SubscribeCallback.pThis, 
                                                              mid         :=  iMid, 
                                                              qos_count   :=  iNumGrantedQos, 
                                                              granted_qos :=  #aGrantedQoS[0]);
        
        dPara1Temp := to_dint(iMid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_SUBSCRIBE_MQP_INC_SUBACK_DONE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_SUBSCRIBE_MQP_INC_SUBACK_DONE_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_SUBSCRIBE_MQP_INC_SUBACK_DONE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        
      end_if;
    
    //inflight message could not be found
    else
      
      //Create Log:
      dPara1Temp := to_dint(iMid);

      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_INF_NOTFOUND_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_INF_NOTFOUND_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_INF_NOTFOUND_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
    
    end_if;
    
  else
  
    //Create Log:
    
    dPara1Temp := to_dint(udLen);
    
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_SUBSCRIBE_MQP_INC_SUBACK_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_UNSUBACK
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid : INT;
    pThisMsg : ^t_s_InflightMessage;
    bFoundInfMsg : BOOL;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK (Always 2 Bytes)
  if pData      &
     udLen = 2  then
    
    //Successfully processed the message
    bOK := TRUE;
    
    //Get the return code
    MQP_TurnBytes(  usBytes :=  2, 
                    pData   :=  pData);
               
    iMid := pData$^INT^;
    
    pThisMsg := InflightMsgs_GetMsgByMid( MsgType   :=  IM_Unsubscribe, 
                                          mid       :=  iMid, 
                                          Direction :=  0);
    
    //Message Found
    if pThisMsg then
      
      bFoundInfMsg := TRUE;
      pThisMsg^.bRemove := TRUE;
    
    //Message Not Found
    else
      
      dPara1Temp := to_dint(iMid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_MQP_INC_UNSUBACK_INF_NOTFOUND_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_MQP_INC_UNSUBACK_INF_NOTFOUND_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_MQP_INC_UNSUBACK_INF_NOTFOUND_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
      
    end_if;
    
    //If the Callback pointer is set
    if CallbacksStruct.UnsubscribeCallback.pMethod  &
       CallbacksStruct.UnsubscribeCallback.pThis    then
       
      CallbacksStruct.UnsubscribeCallback.pMethod$OnUnsubscribe(pThis :=  CallbacksStruct.SubscribeCallback.pThis, 
                                                                mid   :=  iMid);
                                                                
      dPara1Temp := to_dint(iMid);

      Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                    dMsgGroup	:=	MQCLI_LOG_INFO_UNSUBSCRIBE_MQP_INC_UNSUBACK_DONE_GRP,
                    dMsgNbr		:=	MQCLI_LOG_INFO_UNSUBSCRIBE_MQP_INC_UNSUBACK_DONE_MSG,
                    pMsg			:=	MQCLI_LOG_INFO_UNSUBSCRIBE_MQP_INC_UNSUBACK_DONE_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
                                                                      
    
    end_if;
      
  else
  
    //Create Log:
    
    dPara1Temp := to_dint(udLen);
    
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_MQP_INC_UNSUBACK_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_MQP_INC_UNSUBACK_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_MQP_INC_UNSUBACK_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PUBACK
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid           : INT;
    pThisMsg       : ^t_s_InflightMessage;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK (Var header (2Bytes))
  if pData &
     udLen = 2 then
    
    //Successfully processed the message
    bOK := TRUE;
    
    //Get the Mid
    MQP_TurnBytes( usBytes :=  2, 
                   pData   :=  pData);
               
    iMid := pData$^INT^;
        
    pData$UDINT += 2;
    
    
    pThisMsg := InflightMsgs_GetMsgByMid( MsgType   :=  IM_Publish, 
                                          mid       :=  iMid, 
                                          Direction :=  0);
    
    //Message Found
    if pThisMsg then
    
      if pThisMsg^.MsgState = MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS1_WAITFORPUBACK then
          
        pThisMsg^.udTimestamp := ops.tAbsolute;
        pThisMsg^.MsgState += 1;  
        

        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBACK_DONE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBACK_DONE_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBACK_DONE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
        
      else
      
        //Create Log:
        dPara1Temp := to_dint(iMid);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_STATE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_STATE_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_STATE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      end_if;
    
    else
      //Create Log:
      dPara1Temp := to_dint(iMid);
      Log_CreateLog(usLevel		:=	MQTT_LOG_DEBUG,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_INF_NOTFOUND_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_INF_NOTFOUND_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_INF_NOTFOUND_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

    end_if;
    
//    //If the Callback pointer is set, perform the callback
//    if CallbacksStruct.PublishCallback.pMethod  &
//       CallbacksStruct.PublishCallback.pThis    then
//       
//      CallbacksStruct.PublishCallback.pMethod$OnPublish(pThis :=  CallbacksStruct.PublishCallback.pThis, 
//                                                        mid   :=  iMid);
//    
//    end_if;
    
  else
    
    //Create Log:
    
    dPara1Temp := to_dint(udLen);
    
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBACK_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PUBREC
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid : INT;
    pThisMsg : ^t_s_InflightMessage;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK (Var header (2Bytes))
  if pData &
     udLen = 2 then
    
    //Successfully processed the message
    bOK := TRUE;
    
    //Get the Mid
    MQP_TurnBytes( usBytes :=  2, 
                   pData   :=  pData);
               
    iMid := pData$^INT^;
    
    pData$UDINT += 2;
    
    pThisMsg := InflightMsgs_GetMsgByMid( MsgType   :=  IM_Publish, 
                                          mid       :=  iMid, 
                                          Direction :=  0);
    
    if pThisMsg then
      
      //State OK
      if pThisMsg^.MsgState = MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBREC then
      
        pThisMsg^.udTimestamp := ops.tAbsolute;
        pThisMsg^.MsgState += 1;  
        
        dPara1Temp := to_dint(iMid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBREC_STATE_ADV_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBREC_STATE_ADV_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBREC_STATE_ADV_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
                 
      //State Not OK        
      else
        //Create Log:
        dPara1Temp := to_dint(iMid);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_STATE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_STATE_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_STATE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      end_if;
    
    //Inflight Message not found
    else
    
        //Create Log:
        dPara1Temp := to_dint(iMid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_INF_NOTFOUND_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_INF_NOTFOUND_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_INF_NOTFOUND_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
    end_if;
  
  else
  
    //Create Log:
    dPara1Temp := to_dint(udLen);
    
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREC_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PUBREL
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid : INT;
    pThisMsg : ^t_s_InflightMessage;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK (Var header (2Bytes))
  if pData &
     udLen = 2 then
    
    //Successfully processed the message
    bOK := TRUE;
    
    //Get the Mid
    MQP_TurnBytes( usBytes :=  2, 
                   pData   :=  pData);
               
    iMid := pData$^INT^;
    
    pData$UDINT += 2;
    
    pThisMsg := InflightMsgs_GetMsgByMid( MsgType   :=  IM_Publish, 
                                          mid       :=  iMid, 
                                          Direction :=  1);
    
    //Message Found
    if pThisMsg then
      
      //If the state is correct
      if pThisMsg^.MsgState = MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_WAITFORPUBREL then
      
        pThisMsg^.udTimestamp := ops.tAbsolute;
        pThisMsg^.MsgState += 1;
        
        dPara1Temp := to_dint(iMid);

        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBREL_STATE_ADV_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBREL_STATE_ADV_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBREL_STATE_ADV_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      
      //State not OK
      else
      
        //Create Log:
        dPara1Temp := to_dint(iMid);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_STATE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_STATE_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_STATE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
                      
      end_if;
    
    //Message not found
    else
    
      //Create Log:
      dPara1Temp := to_dint(iMid);
      
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_INF_NOTFOUND_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_INF_NOTFOUND_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_INF_NOTFOUND_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

    end_if;
    
  else
  
    //Create Log:
    
    dPara1Temp := to_dint(udLen);
    
    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBREL_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PUBCOMP
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid : INT;
    pThisMsg : ^t_s_InflightMessage;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK (Var header (2Bytes))
  if pData &
     udLen = 2 then
    
    //Successfully processed the message
    bOK := TRUE;
    
    //Get the Mid
    MQP_TurnBytes( usBytes :=  2, 
                   pData   :=  pData);
               
    iMid := pData$^INT^;
    
    pData$UDINT += 2;
    
    pThisMsg := InflightMsgs_GetMsgByMid( MsgType   :=  IM_Publish, 
                                          mid       :=  iMid, 
                                          Direction :=  0);
    
    //Message Found
    if pThisMsg then
      
      //State OK
      if pThisMsg^.MsgState = MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBCOMP then
      
        pThisMsg^.udTimestamp := ops.tAbsolute;
        pThisMsg^.MsgState += 1;  
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBCOMP_STATE_ADV_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBCOMP_STATE_ADV_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_MQP_INC_PUBCOMP_STATE_ADV_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      //State not OK
      else
      
        //Create Log:
        dPara1Temp := to_dint(iMid);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_STATE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_STATE_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_STATE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      end_if;
    
    //Message not found
    else
    
      //Create Log:
      dPara1Temp := to_dint(iMid);
      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_INF_NOTFOUND_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_INF_NOTFOUND_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_INF_NOTFOUND_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
    end_if;

//    //If the Callback pointer is set, perform the callback
//    if CallbacksStruct.PublishCallback.pMethod  &
//       CallbacksStruct.PublishCallback.pThis    then
//       
//      CallbacksStruct.PublishCallback.pMethod$OnPublish(pThis :=  CallbacksStruct.PublishCallback.pThis, 
//                                                        mid   :=  iMid);
//    
//    end_if;
  
  else
    
    //Create Log:

    dPara1Temp := to_dint(udLen);

    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_SIZE_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_SIZE_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_INC_PUBCOMP_SIZE_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient::MQP_Process_PUBLISH
	VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
		iQoS 	: INT;
		bDup 	: BOOL;
		bRetain 	: BOOL;
		dQueueID 	: DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	iMid : INT;
    uiTopicLen : UINT;
    aTopic16 : ARRAY[0..MQTTCLIENT_TOPIC_MAX_LEN] of UINT;
    aTopic8 : ARRAY[0..MQTTCLIENT_TOPIC_MAX_LEN] of CHAR;
    pPayload, pPtr  : ^void;
    udPayloadLen : UDINT;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //If the incoming data is OK
  if pData &
     udLen <= MQTTCLIENT_MAX_DATA_LEN &
     iQoS >= MQTT_PROT_QOS_MIN        &
     iQoS <= MQTT_PROT_QOS_MAX        then
    
    pPtr := pData;
    
    //Topic String
    uiTopicLen := pPtr$^UINT^;
    MQP_TurnBytes(usBytes :=  2, 
                  pData   :=  #uiTopicLen$void);
    
    pPtr$UDINT += sizeof(UINT);
    
    SigCLib.MemSet( dst :=  #aTopic8, 
                    c   :=  0x00, 
                    len :=  sizeof(aTopic8));
    SigCLib.MemSet( dst :=  #aTopic16, 
                    c   :=  0x00, 
                    len :=  sizeof(aTopic16));
    SigCLib.MemCpy( dst0  :=  #aTopic8[0], 
                    src0  :=  pPtr, 
                    len0  :=  uiTopicLen);
    SigCLib.ToStr16(dst0  :=  #aTopic16[0], 
                    src0  :=  #aTopic8[0]);
        
    pPtr$UDINT += uiTopicLen;
    
    //Packet Identifier
    if iQoS > 0 then
         
      iMid := pPtr$^INT^;
      MQP_TurnBytes(usBytes :=  2, 
                    pData   :=  #iMid$void);
      
      pPtr$UDINT += sizeof(iMid);
    
    else
      iMid := 0;
    end_if;
    
    //Payload
    pPayload      := pPtr;
    udPayloadLen  := udLen - (pPtr$UDINT - pData$UDINT);
    
    //Add to InflightList
      //Success - Lock Msg
    
    if InflightMsgs_AddMsg( MsgType       :=  IM_Publish, 
                            bOutgoing     :=  FALSE, 
                            pMid          :=  #iMid, 
                            iQoS          :=  iQoS, 
                            bRetain       :=  bRetain, 
                            pTopic        :=  #aTopic16[0], 
                            pPayload      :=  pPayload, 
                            udPayloadLen  :=  udPayloadLen,
                            dQueueID      :=  dQueueID) = TRUE then
       
        //Successfully processed the message
        bOK := TRUE;
       
        IncomingPackets.LockPacket( dID   :=  dQueueID, 
                                    bLock :=  TRUE);
        return;
        
    else
      
      //The Incoming is not used anymore, delete it.
      IncomingPackets.ClearPacket(dID:=dQueueID);
      
      //Create Log:
      dPara1Temp := to_dint(iMid);

      Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                    dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_PROCESS_INF_ADD_GRP,
                    dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_PROCESS_INF_ADD_MSG,
                    pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_PROCESS_INF_ADD_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

    end_if;
  
  else
  
    //The Incoming is not used anymore, delete it.
    IncomingPackets.ClearPacket(dID:=dQueueID);
  
    //Create Log:
    dPara1Temp := to_dint(iQoS);

    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_MQP_PROCESS_INP_VAL_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_MQP_PROCESS_INP_VAL_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_MQP_PROCESS_INP_VAL_TEXT,
                  pPara1		:=	#dPara1Temp,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);

  
  end_if;

  
END_FUNCTION

//================================================================================================================================================================
//---------------------------------------------------------------END OF MQTT PROTOCOL METHODS---------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-------------------------------------------------------------------INFLIGHT MSG METHODS-------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient::InflightMsgs_ProcessQueue
  VAR
  	udCount, udNumMsgs, udMsgCnt : UDINT;
    pThisMsg : ^t_s_InflightMessage;
  END_VAR
  
  //If the Inflight pointer is not OK, stop
  if pInFlightMsgs = NIL then
    return;
  end_if;

  //Step over Inflight Messages
  if pInFlightMsgs^.udInflightMsgs > 0 then
    
    //=====================================================================================================
    //Process the messages
    //=====================================================================================================

    for udCount := 0 to pInFlightMsgs^.udInflightMsgs - 1 do

      pThisMsg$UDINT := ((#pInFlightMsgs^.InflightMsgs)$UDINT) + (udCount*sizeof(t_s_InflightMessage));

      if pThisMsg^.udRetrycount >= 1 then
        pThisMsg^.udRetrycount += 1;
        pThisMsg^.udRetrycount -= 1;
      end_if;


      //If the current message has not been set to be removed, process it
      if pThisMsg^.bRemove = FALSE then

        //====================================
        //Process the msg based on type
        //====================================
        case pThisMsg^.MsgType of

        //-----------------------------------------
        //Should always be outgoing, await SUBACK
        //-----------------------------------------
        t_e_InflightMessages::IM_Subscribe:

          //=============================================================
          //Based on the Response from the Process Queue, delete or keep
          //=============================================================
          case InflightMsgs_ProcessQueue_Subscribe(pMsg:=pThisMsg) of
          IFM_Busy:
            
          IFM_Done:
            pThisMsg^.bRemove := TRUE;
          end_case;

        //-----------------------------------------
        //Should always be outgoing, await UNSUBACK
        //-----------------------------------------
        t_e_InflightMessages::IM_Unsubscribe:

          //=============================================================
          //Based on the Response from the Process Queue, delete or keep
          //=============================================================
          case InflightMsgs_ProcessQueue_Unsubscribe(pMsg:=pThisMsg) of
          IFM_Busy:
            
          IFM_Done:
            pThisMsg^.bRemove := TRUE;
          end_case;

        //-----------------------------------------
        //Outgoing / Incoming
        //-----------------------------------------
        t_e_InflightMessages::IM_Publish:

          //====================================
          //Based on incoming / outgoing PUBLISH
          //====================================
          case pThisMsg^.Direction of

          //-----------------------
          //Outgoing
          //-----------------------
          MD_Outgoing:
            
            //=============================================================
            //Based on the Response from the Process Queue, delete or keep
            //=============================================================
            case InflightMsgs_ProcessQueue_Publish_Outgoing(pMsg:=pThisMsg) of
              IFM_Busy:
                
              IFM_Done:
                pThisMsg^.bRemove := TRUE;
            end_case;
           
          //-----------------------
          //Incoming
          //-----------------------
          MD_Incoming:

            //=============================================================
            //Based on the Response from the Process Queue, delete or keep
            //=============================================================
            case InflightMsgs_ProcessQueue_Publish_Incoming(pMsg:=pThisMsg) of
              IFM_Busy:
                
              IFM_Done:
                pThisMsg^.bRemove := TRUE;
            end_case;
            
          end_case;

        end_case;

      end_if;

    end_for;
      
    //=====================================================================================================
    //Remove the messages that are complete
    //=====================================================================================================
    
    //Pointer to first message
    pThisMsg  := #pInFlightMsgs^.InflightMsgs;
    udNumMsgs := pInFlightMsgs^.udInflightMsgs - 1;
    udMsgCnt  := 0;
      
    for udCount := 0 to udNumMsgs do
      
      //If the message can be removed, remove it, do not advance the pointer as the next message will be in this position afterwards.
      if pThisMsg^.bRemove then
        
        InflightMsgs_RemoveMsg(udMsg:=udMsgCnt);
      
      //If the message cannot be removed, advance the pointer to check the next
      else
      
        udMsgCnt += 1;
        pThisMsg$UDINT += sizeof(t_s_InflightMessage);          
        
      end_if;
            
    end_for;

  end_if;
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Subscribe
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  
  if pMsg = NIL then
    retCode := IFM_Done;
    return;
  end_if;
  
  retCode := IFM_Busy;
  
  //=============================
  //Perform Tasks based on State
  //=============================
  case pMsg^.MsgState of
    
    //---------------------
    //Send SUBSCRIBE
    //---------------------
    0:
        MQP_ControlPacket_SUBSCRIBE(iMid    :=  pMsg^.iPacketID, 
                                    pTopic  :=  #pMsg^.aTopic[0], 
                                    sQoS    :=  to_sint(pMsg^.iQoS));
        pMsg^.udTimestamp := ops.tAbsolute;
        pMsg^.MsgState += 1;
        
    //---------------------
    //Await SUBACK
    //---------------------
    1:
        if ops.tAbsolute - pMsg^.udTimestamp >= cSubscribeTimeout then
          
          pMsg^.udRetrycount += 1;
          
          if pMsg^.udRetrycount >= cPacketRetryCount then
            
            //Create Log:
            dPara1Temp := to_dint(pMsg^.iPacketID);

            Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                          dMsgGroup	:=	MQCLI_LOG_ERROR_SUBSCRIBE_SUBSCRIBE_RETRY_GRP,
                          dMsgNbr		:=	MQCLI_LOG_ERROR_SUBSCRIBE_SUBSCRIBE_RETRY_MSG,
                          pMsg			:=	MQCLI_LOG_ERROR_SUBSCRIBE_SUBSCRIBE_RETRY_TEXT,
                          pPara1		:=	#dPara1Temp,
                          pPara2		:=	NIL,
                          pPara3		:=	NIL,
                          pPara4		:=	NIL);

            retCode := IFM_Done;
            return;
            
          end_if;
          
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_SUBSCRIBE_SUBSCCRIBE_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_SUBSCRIBE_SUBSCCRIBE_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_SUBSCRIBE_SUBSCCRIBE_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.MsgState -= 1;

        end_if;
        
  end_case;
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Unsubscribe
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR

  if pMsg = NIL then
    retCode := IFM_Done;
    return;
  end_if;
  
  retCode := IFM_Busy;
  
  //=============================
  //Perform Tasks based on State
  //=============================
  case pMsg^.MsgState of
    
    //---------------------
    //Send UNSUBSCRIBE
    //---------------------
    0:
        
        MQP_ControlPacket_UNSUBSCRIBE(iMid    :=  pMsg^.iPacketID, 
                                      pTopic  :=  #pMsg^.aTopic[0]);
                                      
        pMsg^.udTimestamp := ops.tAbsolute;
        pMsg^.MsgState += 1;
        
    //---------------------
    //Await UNSUBACK
    //---------------------
    1:
        
        if ops.tAbsolute - pMsg^.udTimestamp >= cUnsubscribeTimeout then
          
          pMsg^.udRetrycount += 1;
          
          if pMsg^.udRetrycount >= cPacketRetryCount then
            
            //Create Log:
            dPara1Temp := to_dint(pMsg^.iPacketID);

            Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                          dMsgGroup	:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_UNSUBSCRIBE_RETRY_GRP,
                          dMsgNbr		:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_UNSUBSCRIBE_RETRY_MSG,
                          pMsg			:=	MQCLI_LOG_ERROR_UNSUBSCRIBE_UNSUBSCRIBE_RETRY_TEXT,
                          pPara1		:=	#dPara1Temp,
                          pPara2		:=	NIL,
                          pPara3		:=	NIL,
                          pPara4		:=	NIL);

            retCode := IFM_Done;
            return;
            
          end_if;
          
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_UNSUBSCRIBE_UNSUBSCRIBE_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_UNSUBSCRIBE_UNSUBSCRIBE_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_UNSUBSCRIBE_UNSUBSCRIBE_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.MsgState -= 1;

        end_if;
      
  end_case;
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Incoming
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  
  if pMsg = NIL then
    retCode := IFM_Done;
    return;
  end_if;
  
  retCode := IFM_Busy;
  
  //==================================================
  //Based on the QoS required, perform the sequence
  //==================================================
  case pMsg^.iQoS of
    0:  retCode := InflightMsgs_ProcessQueue_Publish_Incoming_QoS0(pMsg:=pMsg);
    1:  retCode := InflightMsgs_ProcessQueue_Publish_Incoming_QoS1(pMsg:=pMsg);
    2:  retCode := InflightMsgs_ProcessQueue_Publish_Incoming_QoS2(pMsg:=pMsg);
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Incoming_QoS0
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  VAR
  	ThisMsg : t_s_MQTTMessage;
  END_VAR
  
  retCode := IFM_Busy;
  
  //=======================================
  //QoS 0 Message FSM
  //=======================================
  case pMsg^.MsgState of
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS0_HANDLEMSG:
      
      if CallbacksStruct.MessageCallback.pMethod  &
         CallbacksStruct.MessageCallback.pThis    then
        
        ThisMsg.mid         := pMsg^.iPacketID;
        ThisMsg.topic       := #pMsg^.aTopic[0];
        ThisMsg.payload     := pMsg^.pPayload;
        ThisMsg.payloadlen  := pMsg^.udPayloadLen;
        ThisMsg.qos         := pMsg^.iQoS;
        ThisMsg.bRetain     := pMsg^.bRetain;
        
        CallbacksStruct.MessageCallback.pMethod$OnMessage(pThis     :=  CallbacksStruct.MessageCallback.pThis,  
                                                          pMessage  :=  #ThisMsg);
        
        
        dPara1Temp := to_dint(ThisMsg.mid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_Q0_INC_PUBLISH_DONE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_Q0_INC_PUBLISH_DONE_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_Q0_INC_PUBLISH_DONE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
              
        
      else
      
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q0_INC_PUBLISH_CALLBACK_NOTSET_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q0_INC_PUBLISH_CALLBACK_NOTSET_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q0_INC_PUBLISH_CALLBACK_NOTSET_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      
      end_if;
      
      pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS0_FINALIZE;
    
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS0_FINALIZE:
      
      retCode := IFM_Done;
    
  end_case;


   
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Incoming_QoS1
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  VAR
  	ThisMsg : t_s_MQTTMessage;
  END_VAR
  
  if pMsg & pMsg^.udRetrycount >= 1 then
    TRACE("Stop Here");
  end_if;
  
  retCode := IFM_Busy;
  
  //==================================
  //Process Msg FSM
  //==================================
  case pMsg^.MsgState of
    //------------------------------------------------------
    //Send the PUBACK
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS1_PUBACK:
    
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBACK(iMid:=pMsg^.iPacketID);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q1_INC_PUBACK_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q1_INC_PUBACK_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q1_INC_PUBACK_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
                      
        retCode := IFM_Done;
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS1_WAITFORPUBACK;
        pMsg^.udTimestamp := ops.tAbsolute;
      
      end_if;
    
    //------------------------------------------------------
    //Wait for the PUBACK to finish Sending
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS1_WAITFORPUBACK:
    
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
                
        if pMsg^.udRetrycount < cPacketRetryCount then
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q1_INC_PUBLISH_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q1_INC_PUBLISH_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q1_INC_PUBLISH_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.udRetrycount  += 1;
          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS1_PUBACK;
          pMsg^.bDup          := TRUE;
        else
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                        dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q1_INC_PUBLISH_RETRY_GRP,
                        dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q1_INC_PUBLISH_RETRY_MSG,
                        pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q1_INC_PUBLISH_RETRY_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          retCode := IFM_Done;
        end_if;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
    
    //------------------------------------------------------
    //Callback the Application
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS1_FINALIZE:
      
      if CallbacksStruct.MessageCallback.pMethod  &
         CallbacksStruct.MessageCallback.pThis    then
        
        ThisMsg.mid         := pMsg^.iPacketID;
        ThisMsg.topic       := #pMsg^.aTopic[0];
        ThisMsg.payload     := pMsg^.pPayload;
        ThisMsg.payloadlen  := pMsg^.udPayloadLen;
        ThisMsg.qos         := pMsg^.iQoS;
        ThisMsg.bRetain     := pMsg^.bRetain;
        
        CallbacksStruct.MessageCallback.pMethod$OnMessage(pThis     :=  CallbacksStruct.MessageCallback.pThis,  
                                                          pMessage  :=  #ThisMsg);

        
        dPara1Temp := to_dint(ThisMsg.mid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_Q1_INC_PUBLISH_DONE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_Q1_INC_PUBLISH_DONE_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_Q1_INC_PUBLISH_DONE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        
      else
      
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q1_INC_PUBLISH_CALLBACK_NOTSET_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q1_INC_PUBLISH_CALLBACK_NOTSET_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q1_INC_PUBLISH_CALLBACK_NOTSET_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
      
      end_if;
      
      retCode := IFM_Done;
    
  end_case;


END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Incoming_QoS2
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  VAR
  	ThisMsg : t_s_MQTTMessage;
  END_VAR

  retCode := IFM_Busy;
  
  //==================================
  //Process Msg FSM
  //==================================
  case pMsg^.MsgState of
    //------------------------------------------------------
    //Send the PUBREC
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_PUBREC:
    
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBREC(iMid:=pMsg^.iPacketID);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREC_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREC_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREC_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        retCode := IFM_Done;
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_WAITFORPUBREC;
        pMsg^.udTimestamp := ops.tAbsolute;
      
      end_if;
    
    //------------------------------------------------------
    //Wait for the PUBREC to finish Sending
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_WAITFORPUBREC:
    
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
        if pMsg^.udRetrycount < cPacketRetryCount then
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBREC_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBREC_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBREC_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.udRetrycount  += 1;
          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_PUBREC;
          pMsg^.bDup          := TRUE;
        else
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREC_RETRY_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREC_RETRY_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREC_RETRY_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

          retCode := IFM_Done;
        end_if;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
    
    //------------------------------------------------------
    //Wait for the PUBREL
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_WAITFORPUBREL:
    
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
        if pMsg^.udRetrycount < cPacketRetryCount then
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBREL_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBREL_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBREL_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.udRetrycount  += 1;
          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_PUBREC;
          pMsg^.bDup          := TRUE;
        else 
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                        dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREL_RETRY_GRP,
                        dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREL_RETRY_MSG,
                        pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBREL_RETRY_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          retCode := IFM_Done;
        end_if;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
    
    //------------------------------------------------------
    //Send the PUBCOMP
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_PUBCOMP:
      
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBCOMP(iMid:=pMsg^.iPacketID);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBCOMP_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBCOMP_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBCOMP_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        retCode := IFM_Done;
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_WAITFORPUBCOMP;
        pMsg^.udTimestamp := ops.tAbsolute;
      
      end_if;
      
    //------------------------------------------------------
    //Wait for the PUBCOMP to finish Sending
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_WAITFORPUBCOMP:
    
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
        if pMsg^.udRetrycount < cPacketRetryCount then
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBCOMP_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBCOMP_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBCOMP_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.udRetrycount  += 1;
          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_PUBREC;
          pMsg^.bDup          := TRUE;
        else
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                        dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBCOMP_RETRY_GRP,
                        dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBCOMP_RETRY_MSG,
                        pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_INC_PUBCOMP_RETRY_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          retCode := IFM_Done;
        end_if;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
    
    //------------------------------------------------------
    //Finalize
    //------------------------------------------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_INCOMING_QOS2_FINALIZE:
    
      if CallbacksStruct.MessageCallback.pMethod  &
         CallbacksStruct.MessageCallback.pThis    then
        
        ThisMsg.mid         := pMsg^.iPacketID;
        ThisMsg.topic       := #pMsg^.aTopic[0];
        ThisMsg.payload     := pMsg^.pPayload;
        ThisMsg.payloadlen  := pMsg^.udPayloadLen;
        ThisMsg.qos         := pMsg^.iQoS;
        ThisMsg.bRetain     := pMsg^.bRetain;
        
        CallbacksStruct.MessageCallback.pMethod$OnMessage(pThis     :=  CallbacksStruct.MessageCallback.pThis,  
                                                          pMessage  :=  #ThisMsg);
        
        
        dPara1Temp := to_dint(ThisMsg.mid);
        
        Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                      dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_Q2_INC_PUBLISH_DONE_GRP,
                      dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_Q2_INC_PUBLISH_DONE_MSG,
                      pMsg			:=	MQCLI_LOG_INFO_PUBLISH_Q2_INC_PUBLISH_DONE_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
        
      else
      
        //Create Log:

        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBLISH_CALLBACK_NOTSET_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBLISH_CALLBACK_NOTSET_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_INC_PUBLISH_CALLBACK_NOTSET_TEXT,
                      pPara1		:=	NIL,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

      
      end_if;

      retCode := IFM_Done;
    
  end_case;

END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Outgoing
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  
  if pMsg = NIL then
    retCode := IFM_Done;
    return;
  end_if;
  
  retCode := IFM_Busy;
  
  //==================================================
  //Based on the QoS required, perform the sequence
  //==================================================
  case pMsg^.iQoS of
    0:  retCode := InflightMsgs_ProcessQueue_Publish_Outgoing_QoS0(pMsg:=pMsg);
    1:  retCode := InflightMsgs_ProcessQueue_Publish_Outgoing_QoS1(pMsg:=pMsg);
    2:  retCode := InflightMsgs_ProcessQueue_Publish_Outgoing_QoS2(pMsg:=pMsg);
  end_case;
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Outgoing_QoS0
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  
  //==============================
  //Based on State of Message
  //==============================
  case pMsg^.MsgState of
    //----------------------
    //Send PUBLISH Packet
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS0_PUBLISH:
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBLISH(bDup          :=  pMsg^.bDup, 
                                                        iQoS          :=  pMsg^.iQoS, 
                                                        bRetain       :=  pMsg^.bRetain, 
                                                        pTopic        :=  #pMsg^.aTopic[0], 
                                                        iMid          :=  pMsg^.iPacketID, 
                                                        pPayload      :=  pMsg^.pPayload, 
                                                        udPayloadLen  :=  pMsg^.udPayloadLen);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q0_PUBLISH_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q0_PUBLISH_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q0_PUBLISH_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        retCode := IFM_Done;
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS0_WAITFORPUBLISH;
        pMsg^.udTimestamp := ops.tAbsolute;
        retCode := IFM_Busy;
      
      end_if;
    
    //----------------------
    //Wait For Tx to Finish
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS0_WAITFORPUBLISH:
      
      //There is a risk here that the user has set the Publish timeout too small, this will cause the Publish to retry, causing the PacketQueue to fill up with
      //the same publish repetatively, blocking keepalive msgs that will kick us off the MQTT Broker. -> Thus, set the Publish timeout larger than maximum possible 
      //requirement and set the keepalive high enough so that a bottle-necked queue is not the cause for a communication breakage.
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
        if pMsg^.udRetrycount < cPacketRetryCount then
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q0_PUBLISH_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q0_PUBLISH_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q0_PUBLISH_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          pMsg^.udRetrycount  += 1;
          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS0_PUBLISH;
          pMsg^.bDup          := TRUE;
          retCode := IFM_Busy;
        else
          //Create Log:
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                        dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q0_PUBLISH_RETRY_GRP,
                        dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q0_PUBLISH_RETRY_MSG,
                        pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q0_PUBLISH_RETRY_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

          retCode := IFM_Done;
        end_if;
      else
        retCode := IFM_Busy;
      end_if;

    //----------------------
    //Perform Callback, Clear the Msg
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS0_FINALIZE:
      
      //In the QoS 0 case there is no confirm from the broker, therefor no callback from the MQP_Process_PUBXXX Method,
      //Instead call from here
      //Create Log:
      dPara1Temp := to_dint(pMsg^.iPacketID);

      Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                    dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_Q0_PUBLISH_DONE_GRP,
                    dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_Q0_PUBLISH_DONE_MSG,
                    pMsg			:=	MQCLI_LOG_INFO_PUBLISH_Q0_PUBLISH_DONE_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);

      if CallbacksStruct.PublishCallback.pThis &
         CallbacksStruct.PublishCallback.pMethod then
        CallbacksStruct.PublishCallback.pMethod$OnPublish(pThis:=CallbacksStruct.PublishCallback.pThis, mid:=pMsg^.iPacketID);
      end_if;
      
      retCode := IFM_Done;
      
  end_case;
    
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Outgoing_QoS1
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  
  
  //==============================
  //Based on State of Message
  //==============================
  case pMsg^.MsgState of
    //----------------------
    //Send PUBLISH Packet
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS1_PUBLISH:
        
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBLISH(bDup          :=  pMsg^.bDup, 
                                                        iQoS          :=  pMsg^.iQoS, 
                                                        bRetain       :=  pMsg^.bRetain, 
                                                        pTopic        :=  #pMsg^.aTopic[0], 
                                                        iMid          :=  pMsg^.iPacketID, 
                                                        pPayload      :=  pMsg^.pPayload, 
                                                        udPayloadLen  :=  pMsg^.udPayloadLen);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log:
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q1_PUBLISH_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q1_PUBLISH_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q1_PUBLISH_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS1_WAITFORPUBLISH;
        pMsg^.udTimestamp := ops.tAbsolute;
      
      end_if;
      
      retCode := IFM_Busy;
    
    //----------------------
    //Wait For Tx to Finish
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS1_WAITFORPUBLISH:
      
      //There is a risk here that the user has set the Publish timeout too small, this will cause the Publish to retry, causing the PacketQueue to fill up with
      //the same publish repetatively, blocking keepalive msgs that will kick us off the MQTT Broker. -> Thus, set the Publish timeout larger than maximum possible 
      //requirement and set the keepalive high enough so that a bottle-necked queue is not the cause for a communication breakage.

      retCode := IFM_Busy;
      
    //----------------------
    //Wait for PUBACK
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS1_WAITFORPUBACK:
    
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
          //Create Log: 
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q1_PUBACK_TIMEOUT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q1_PUBACK_TIMEOUT_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q1_PUBACK_TIMEOUT_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        pmsg^.msgstate      := mqttclient_prot_fsm_publish_outgoing_qos1_publish;
        pMsg^.bDup          := TRUE;
        retCode             := IFM_Busy;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
    
   
    //----------------------
    //Clear the Msg
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS1_FINALIZE:
      
      //Create Log: 
      dPara1Temp := to_dint(pMsg^.iPacketID);

      Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                    dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_Q1_PUBLISH_DONE_GRP,
                    dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_Q1_PUBLISH_DONE_MSG,
                    pMsg			:=	MQCLI_LOG_INFO_PUBLISH_Q1_PUBLISH_DONE_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
      
      
      //If the Callback pointer is set, perform the callback
      if CallbacksStruct.PublishCallback.pMethod  &
         CallbacksStruct.PublishCallback.pThis    then
         
        CallbacksStruct.PublishCallback.pMethod$OnPublish(pThis :=  CallbacksStruct.PublishCallback.pThis, 
                                                          mid   :=  pMsg^.iPacketID);
      
      end_if;
      
      retCode := IFM_Done;
      
  end_case;
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_ProcessQueue_Publish_Outgoing_QoS2
	VAR_INPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
	VAR_OUTPUT
		retCode 	: t_e_InflightMsg_Ret;
	END_VAR
  
  //==============================
  //Based on State of Message
  //==============================
  case pMsg^.MsgState of
    //----------------------
    //Send PUBLISH Packet
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_PUBLISH:
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBLISH(bDup          :=  pMsg^.bDup, 
                                                        iQoS          :=  pMsg^.iQoS, 
                                                        bRetain       :=  pMsg^.bRetain, 
                                                        pTopic        :=  #pMsg^.aTopic[0], 
                                                        iMid          :=  pMsg^.iPacketID, 
                                                        pPayload      :=  pMsg^.pPayload, 
                                                        udPayloadLen  :=  pMsg^.udPayloadLen);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log: 
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBLISH_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBLISH_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBLISH_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBLISH;
        pMsg^.udTimestamp := ops.tAbsolute;
      
      end_if;
      
      retCode             := IFM_Busy;
    
    //----------------------
    //Wait For Tx to Finish
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBLISH:
      
      //There is a risk here that the user has set the Publish timeout too small, this will cause the Publish to retry, causing the PacketQueue to fill up with
      //the same publish repetatively, blocking keepalive msgs that will kick us off the MQTT Broker. -> Thus, set the Publish timeout larger than maximum possible 
      //requirement and set the keepalive high enough so that a bottle-necked queue is not the cause for a communication breakage.

      retCode := IFM_Busy;
    //----------------------
    //Wait for PUBREC
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBREC:
    
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
          //Create Log: 
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                      dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBREC_TIMEOUT_GRP,
                      dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBREC_TIMEOUT_MSG,
                      pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBREC_TIMEOUT_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);

        pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_PUBLISH;
        pMsg^.bDup          := TRUE;
        retCode             := IFM_Busy;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
    
    //----------------------
    //Send PUBREL Packet
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_PUBREL:
    
      pMsg^.dPacketQueueID := MQP_ControlPacket_PUBREL(iMid:=pMsg^.iPacketID);
    
      if pMsg^.dPacketQueueID < 0 then
        
        //Create Log: 
        dPara1Temp := to_dint(pMsg^.iPacketID);

        Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                      dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBREL_INS_Q_GRP,
                      dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBREL_INS_Q_MSG,
                      pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBREL_INS_Q_TEXT,
                      pPara1		:=	#dPara1Temp,
                      pPara2		:=	NIL,
                      pPara3		:=	NIL,
                      pPara4		:=	NIL);
        
      else
        
        pMsg^.MsgState := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBREL;
        pMsg^.udTimestamp := ops.tAbsolute;
      
      end_if;
      
      retCode := IFM_Busy;
      
    
    //----------------------
    //Wait for Tx Finish
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBREL:
      
      //There is a risk here that the user has set the Publish timeout too small, this will cause the Publish to retry, causing the PacketQueue to fill up with
      //the same publish repetatively, blocking keepalive msgs that will kick us off the MQTT Broker. -> Thus, set the Publish timeout larger than maximum possible 
      //requirement and set the keepalive high enough so that a bottle-necked queue is not the cause for a communication breakage.
//      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
//                
//        pMsg^.pPayloadAtTimeout := pMsg^.pPayload;
//        
//        if pMsg^.udRetrycount < cPacketRetryCount then
//          //Create Log: 
//          dPara1Temp := to_dint(pMsg^.iPacketID);
//          
//          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
//                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBREL_TIMEOUT_GRP,
//                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBREL_TIMEOUT_MSG,
//                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBREL_TIMEOUT_TEXT,
//                        pPara1		:=	NIL,
//                        pPara2		:=	NIL,
//                        pPara3		:=	NIL,
//                        pPara4		:=	NIL);
//          
//          pMsg^.udRetrycount  += 1;
//          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_PUBLISH;
//          pMsg^.bDup          := TRUE;
//          retCode             := IFM_Busy;
//          
//        else
//        
//          //Create Log: 
//          dPara1Temp := to_dint(pMsg^.iPacketID);
//          
//          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
//                        dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBREL_RETRY_GRP,
//                        dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBREL_RETRY_MSG,
//                        pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBREL_RETRY_TEXT,
//                        pPara1		:=	#dPara1Temp,
//                        pPara2		:=	NIL,
//                        pPara3		:=	NIL,
//                        pPara4		:=	NIL);
//                        
//          retCode := IFM_Done;
//        end_if;
//        
//      else
//      
//        retCode := IFM_Busy;
//        
//      end_if;
      
      retCode := IFM_Busy;
      
    //----------------------
    //Wait For PUBCOMP
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_WAITFORPUBCOMP:
      
      if ops.tAbsolute - pMsg^.udTimestamp >= cPublishTimeout then
        
        if pMsg^.udRetrycount < cPacketRetryCount then
          //Create Log: 
          dPara1Temp := to_dint(pMsg^.iPacketID);

          Log_CreateLog(usLevel		:=	MQTT_LOG_WARNING,
                        dMsgGroup	:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBCOMP_TIMEOUT_GRP,
                        dMsgNbr		:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBCOMP_TIMEOUT_MSG,
                        pMsg			:=	MQCLI_LOG_WARNING_PUBLISH_Q2_PUBCOMP_TIMEOUT_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);

                        
//          pMsg^.udRetrycount  += 1;
          pMsg^.MsgState      := MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_PUBLISH;
          pMsg^.bDup          := TRUE;
          retCode             := IFM_Busy;
        else
          //Create Log: 
          dPara1Temp := to_dint(pMsg^.iPacketID);


          Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                        dMsgGroup	:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBCOMP_RETRY_GRP,
                        dMsgNbr		:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBCOMP_RETRY_MSG,
                        pMsg			:=	MQCLI_LOG_ERROR_PUBLISH_Q2_PUBCOMP_RETRY_TEXT,
                        pPara1		:=	#dPara1Temp,
                        pPara2		:=	NIL,
                        pPara3		:=	NIL,
                        pPara4		:=	NIL);
                        
          retCode := IFM_Done;
        end_if;
        
      else
      
        retCode := IFM_Busy;
        
      end_if;
      
    //----------------------
    //Clear the Msg
    //----------------------
    MQTTCLIENT_PROT_FSM_PUBLISH_OUTGOING_QOS2_FINALIZE:

      //Create Log: 
      dPara1Temp := to_dint(pMsg^.iPacketID);

      Log_CreateLog(usLevel		:=	MQTT_LOG_INFO,
                    dMsgGroup	:=	MQCLI_LOG_INFO_PUBLISH_Q2_PUBLISH_DONE_GRP,
                    dMsgNbr		:=	MQCLI_LOG_INFO_PUBLISH_Q2_PUBLISH_DONE_MSG,
                    pMsg			:=	MQCLI_LOG_INFO_PUBLISH_Q2_PUBLISH_DONE_TEXT,
                    pPara1		:=	#dPara1Temp,
                    pPara2		:=	NIL,
                    pPara3		:=	NIL,
                    pPara4		:=	NIL);
      
      //If the Callback pointer is set, perform the callback
      if CallbacksStruct.PublishCallback.pMethod  &
         CallbacksStruct.PublishCallback.pThis    then
                  
        CallbacksStruct.PublishCallback.pMethod$OnPublish(pThis :=  CallbacksStruct.PublishCallback.pThis, 
                                                          mid   :=  pMsg^.iPacketID);
      
      end_if;
      
      retCode := IFM_Done;
      
  end_case;
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_AddMsg
	VAR_INPUT
		MsgType 	: t_e_InflightMessages;
		bOutgoing 	: BOOL;
		pMid 	: ^INT;
		iQoS 	: INT;
		bRetain 	: BOOL;
		pTopic 	: ^UINT;
		pPayload 	: ^void;
		udPayloadLen 	: UDINT;
		dQueueID 	: DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	pThisMsg : ^t_s_InflightMessage;
    iMid : INT;
  END_VAR
  
  InflightMsgsCritSect.SectionStart();
  
  //Assume Fail
  bOK := FALSE;
  
  //If the inflight queue does not exist or
  //there is no space in the Inflight Queue, stop
  if (pInFlightMsgs = NIL) |
     (pInFlightMsgs^.udInflightMsgs >= pInFlightMsgs^.udMaxInflightMsgs - 1) then
    return;
  end_if;
  
  //==========================================
  //Based on the type of Message, Check & Add
  //==========================================
  case MsgType of
    //-------------------------------------
    //Subscribe
    //-------------------------------------
  	t_e_InflightMessages::IM_Subscribe:
      
      //Check input
      if bOutgoing = FALSE                                            |
         pMid = NIL                                                   |
         iQoS < MQTT_PROT_QOS_MIN                                     |
         iQoS > MQTT_PROT_QOS_MAX                                     | 
         pTopic = NIL                                                 |
         bRetain = TRUE                                               |
         pPayload <> NIL                                              |
         udPayloadLen > 0                                             |
         SigCLib.StrLen16(str0:=pTopic) > MQTTCLIENT_TOPIC_MAX_LEN  then
        return;
      end_if;
      
      //Subscribe is always outgoing:
      iMid := Counters_GetNextMID();
      
      pThisMsg$UDINT := (#pInFlightMsgs^.InflightMsgs)$UDINT + (pInFlightMsgs^.udInflightMsgs * sizeof(t_s_InflightMessage));
      
      pThisMsg^.MsgType         := IM_Subscribe;
      pThisMsg^.Direction       := MD_Outgoing;
      pThisMsg^.MsgState        := 0;
      pThisMsg^.iPacketID       := iMid;
      pThisMsg^.bDup            := FALSE;
      pThisMsg^.iQoS            := iQoS;
      pThisMsg^.bRetain         := FALSE;
      pThisMsg^.bRemove         := FALSE;
      
      SigCLib.MemSet( dst :=  #pThisMsg^.aTopic$void, 
                        c   :=  0x00, 
                        len :=  sizeof(t_s_InflightMessage.aTopic));
      
      SigCLib.StrCpy16( dst0  :=  #pThisMsg^.aTopic[0], 
                          src0  :=  pTopic);
      
      pThisMsg^.pPayload            := NIL;
      pThisMsg^.udPayloadLen        := 0;
      pThisMsg^.dPacketQueueID      := -1;
      pThisMsg^.dHoldPacketQueueID  := 0;
      pThisMsg^.udRetrycount        := 0;
      pThisMsg^.udTimestamp         := 0;
      
      pInFlightMsgs^.udInflightMsgs += 1;
      
      pMid^ := iMid;
      
      bOK := TRUE;
      
    //-------------------------------------
    //Unsubscribe
    //-------------------------------------
  	t_e_InflightMessages::IM_Unsubscribe:
      
      //Check input
      if bOutgoing = FALSE                                            |
         pMid = NIL                                                   |
         iQoS < MQTT_PROT_QOS_MIN                                     |
         iQoS > MQTT_PROT_QOS_MAX                                     | 
         pTopic = NIL                                                 |
         bRetain = TRUE                                               |
         pPayload <> NIL                                              |
         udPayloadLen > 0                                             |
         SigCLib.StrLen16(str0:=pTopic) > MQTTCLIENT_TOPIC_MAX_LEN  then
        return;
      end_if;

      //Unsubscribe is always outgoing:
      iMid := Counters_GetNextMID();

      pThisMsg$UDINT := (#pInFlightMsgs^.InflightMsgs)$UDINT + (pInFlightMsgs^.udInflightMsgs * sizeof(t_s_InflightMessage));
      
      pThisMsg^.MsgType         := IM_Unsubscribe;
      pThisMsg^.Direction       := MD_Outgoing;
      pThisMsg^.MsgState        := 0;
      pThisMsg^.iPacketID       := iMid;
      pThisMsg^.bDup            := FALSE;
      pThisMsg^.iQoS            := 1;
      pThisMsg^.bRetain         := FALSE;
      pThisMsg^.bRemove         := FALSE;
      pThisMsg^.pPayload        := NIL;
      pThisMsg^.udPayloadLen    := 0;
      
      SigCLib.MemSet( dst :=  #pThisMsg^.aTopic$void, 
                      c   :=  0x00, 
                      len :=  sizeof(t_s_InflightMessage.aTopic));
      
      SigCLib.StrCpy16( dst0  :=  #pThisMsg^.aTopic[0], 
                        src0  :=  pTopic);
                          
      pThisMsg^.dPacketQueueID      := -1;
      pThisMsg^.dHoldPacketQueueID  := 0;
      pThisMsg^.udRetrycount        := 0;
      pThisMsg^.udTimestamp         := 0;
      
      pInFlightMsgs^.udInflightMsgs += 1;
      
      pMid^ := iMid;
      
      bOK := TRUE;             
      
    //-------------------------------------
    //Publish
    //-------------------------------------
  	t_e_InflightMessages::IM_Publish:
    
      //Check input
      if pMid = NIL                                                   |
         iQoS < MQTT_PROT_QOS_MIN                                     |
         iQoS > MQTT_PROT_QOS_MAX                                     | 
         pTopic = NIL                                                 |
         SigCLib.StrLen16(str0:=pTopic) > MQTTCLIENT_TOPIC_MAX_LEN  then
        return;
      end_if;
      
      pThisMsg$UDINT := (#pInFlightMsgs^.InflightMsgs)$UDINT + (pInFlightMsgs^.udInflightMsgs * sizeof(t_s_InflightMessage));
      
      pThisMsg^.MsgType         := IM_Publish;
      
      if bOutgoing then
        iMid := Counters_GetNextMID();
        pThisMsg^.Direction           := MD_Outgoing;
      else
        iMid := pMid^;
        pThisMsg^.Direction       := MD_Incoming;
      end_if;

      pThisMsg^.MsgState          := 0;
      pThisMsg^.iPacketID         := iMid;
      pThisMsg^.bDup              := FALSE;
      pThisMsg^.iQoS              := iQoS;
      pThisMsg^.bRetain           := bRetain;
      pThisMsg^.bRemove           := FALSE;
      
      SigCLib.MemSet( dst :=  #pThisMsg^.aTopic$void, 
                      c   :=  0x00, 
                      len :=  sizeof(t_s_InflightMessage.aTopic));
      
      SigCLib.StrCpy16( dst0  :=  #pThisMsg^.aTopic[0], 
                        src0  :=  pTopic);
      
      pThisMsg^.pPayload            := pPayload;
      pThisMsg^.udPayloadLen        := udPayloadLen;
      pThisMsg^.dPacketQueueID      := -1;
      pThisMsg^.dHoldPacketQueueID  := dQueueID;
      pThisMsg^.udRetrycount        := 0;
      pThisMsg^.udTimestamp         := 0;
      
      if bOutgoing then
        pMid^ := iMid;
      end_if;

      pInFlightMsgs^.udInflightMsgs += 1;
      
      bOK := TRUE;
    
  end_case;


  InflightMsgsCritSect.SectionStop();
  
END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_RemoveMsg
	VAR_INPUT
		udMsg 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	pFrom, pTo : ^void;
    udLen : UDINT;
    pThisMsg : ^t_s_InflightMessage;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //if the input is ok
  if pInFlightMsgs                           &
     (udMsg >= 0)                            &
     (udMsg < pInFlightMsgs^.udInflightMsgs) then
    
    pThisMsg$UDINT := (#pInFlightMsgs^.InflightMsgs)$UDINT + (udMsg*sizeof(t_s_InflightMessage));
    
    //If the Inflight Message has a Packet in the PacketQueue, clear it:
    if pThisMsg^.dHoldPacketQueueID > 0   &
       pThisMsg^.Direction = MD_Incoming  then
       
      IncomingPackets.LockPacket( dID   :=  pThisMsg^.dHoldPacketQueueID, 
                                  bLock :=  FALSE);
                                  
      IncomingPackets.ClearPacket(dID   :=  pThisMsg^.dHoldPacketQueueID);
      
    end_if;
    
    //If there are any messages to move up
    if pInFlightMsgs^.udInflightMsgs - 1 > udMsg then
      
      pTo$UDINT := (#pInFlightMsgs^.InflightMsgs)$UDINT + (udMsg*sizeof(t_s_InflightMessage));
      pFrom$UDINT := pTo$UDINT + sizeof(t_s_InflightMessage);
      udLen := (pInFlightMsgs^.udInflightMsgs - 1 - udMsg) * sizeof(t_s_InflightMessage);
      
      SigCLib.MemCpy( dst0  :=  pTo, 
                      src0  :=  pFrom, 
                      len0  :=  udLen);
      
    end_if;
    
    pInFlightMsgs^.udInflightMsgs -= 1;
    
  end_if; 

  
END_FUNCTION
//================================================================================================================================================================
//---------------------------------------------------------------END OF INFLIGHT MSG METHODS----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-----------------------------------------------------------------------CALLBACK METHODS-------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient::PacketQueue_MsgSent_Callback
	VAR_INPUT
		pThis 	: ^void;
		dID 	: DINT;
		MsgType 	: DINT;
		dDirection 	: DINT;
	END_VAR

  //If the pointer is ok, call the method  
  if pThis then
    pThis$^MQTTClient^.PacketQueue_MsgSent(MsgType := MsgType,
                                           dDirection := dDirection,
                                           dID:=dID);
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient::PacketQueue_MsgSent
	VAR_INPUT
		MsgType 	: DINT;
		dDirection 	: DINT;
		dID 	: DINT;
	END_VAR
  VAR
  	pInfMsg : ^t_s_InflightMessage;
    InfMsgType : t_e_InflightMessages;
  END_VAR
  
 //If the ID Matches the DISCONNECT packet ID and the State id correct, advance the state
  if MQTTClientState = MCS_Disconnect               &
     dID = ConnectionDataStruct.dDisconnectMsgID    &
     States.Disconnect = DS_WaitForSendConfirmation then
    
    //Advance the state
    States.Disconnect := DS_DeleteConnection;
  
  //If this is a callback for a PUBLISH Msg, Step through all inflight msgs, find the Msg & advance State
  elsif MQTTClientState = MCS_Connected   & 
        pInFlightMsgs                     &
        pInFlightMsgs^.udInflightMsgs > 0 then
    
    //======================================================================================
    //Prepare the Message Type Variable for finding the Inflight Message we are looking for
    //======================================================================================
    case MsgType$t_e_MQTTControlPackets of
      //------------------------------------------------
      //Connect is not processed as an Inflight Message
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_CONNECT,
    	t_e_MQTTControlPackets::MCP_CONNACK:
        return;
        
      //------------------------------------------------
      //Origin = PUBLISH
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_PUBLISH,
    	t_e_MQTTControlPackets::MCP_PUBACK,
    	t_e_MQTTControlPackets::MCP_PUBREC,
    	t_e_MQTTControlPackets::MCP_PUBREL,
    	t_e_MQTTControlPackets::MCP_PUBCOMP:
        InfMsgType := IM_Publish;
      
      //------------------------------------------------
      //Origin = SUBSCRIBE
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_SUBSCRIBE,
    	t_e_MQTTControlPackets::MCP_SUBACK:
        InfMsgType := IM_Subscribe;
      
      //------------------------------------------------
      //Origin = UNSUBSCRIBE
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_UNSUBSCRIBE,
    	t_e_MQTTControlPackets::MCP_UNSUBACK:
        InfMsgType := IM_Unsubscribe;
      
      //------------------------------------------------
      //PING is not processed as an inflight message
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_PINGREQ,
    	t_e_MQTTControlPackets::MCP_PINGRESP:
        return;
      
      //------------------------------------------------
      //DISCONNECT is not processed as an inflight message
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_DISCONNECT:
        return;
      
      //------------------------------------------------
      //Unknown
      //------------------------------------------------
    	t_e_MQTTControlPackets::MCP_UNKNOWN:
        return;
      
    end_case;
    
    pInfMsg := InflightMsgs_GetMsgByPacketQueueID(MsgType   :=  InfMsgType, 
                                                  ID        :=  dID, 
                                                  Direction :=  dDirection);
    
    if pInfMsg then
      pInfMsg^.MsgState += 1;
      pInfMsg^.udTimestamp := ops.tAbsolute;
    
    else
    
      TRACE("Message Lost!");
      
    end_if;

  end_if;

END_FUNCTION
//================================================================================================================================================================
//-------------------------------------------------------------------END OF CALLBACK METHODS----------------------------------------------------------------------
//================================================================================================================================================================

FUNCTION MQTTClient::TCP_WatchDogTask
  
  if (TCPRecvDataStruct.ProcessState = TRS_ReceiveMessage)                 & 
     (ops.tAbsolute - TCPRecvDataStruct.udMsgTS >= cPacketReceiveWatchdog) then
    
    //Create Log: 

    Log_CreateLog(usLevel		:=	MQTT_LOG_ERR,
                  dMsgGroup	:=	MQCLI_LOG_ERROR_TCP_WATCHDOG_TIMEOUT_GRP,
                  dMsgNbr		:=	MQCLI_LOG_ERROR_TCP_WATCHDOG_TIMEOUT_MSG,
                  pMsg			:=	MQCLI_LOG_ERROR_TCP_WATCHDOG_TIMEOUT_TEXT,
                  pPara1		:=	#TCPRecvDataStruct.dQueueID,
                  pPara2		:=	NIL,
                  pPara3		:=	NIL,
                  pPara4		:=	NIL);
                  
    TCPRecvDataStruct.udLen := 0;
    TCPRecvDataStruct.dID := -1;
    IncomingPackets.LockPacket( dID   :=  TCPRecvDataStruct.dQueueID, 
                                bLock :=  FALSE);
    IncomingPackets.ClearPacket(dID   :=  TCPRecvDataStruct.dQueueID);
    TCPRecvDataStruct.dQueueID := -1;
    TCPRecvDataStruct.ProcessState := TRS_WaitForMessage;
    
  end_if;

  
END_FUNCTION


FUNCTION MQTTClient::Log_GetText_ControlPackets
	VAR_INPUT
		ControlPacket 	: t_e_MQTTControlPackets;
	END_VAR
	VAR_OUTPUT
		pChar 	: ^CHAR;
	END_VAR
  
  pChar := NIL;
  
  //==============================================
  //Based on Control Packet, find the Title
  //==============================================
  case ControlPacket of
  
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_CONNECT:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_CONNECT;
            
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_CONNACK:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_CONNACK;
           
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PUBLISH:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PUBLISH;
            
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PUBACK:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PUBACK;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PUBREC:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PUBREC;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PUBREL:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PUBREL;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PUBCOMP:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PUBCOMP;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_SUBSCRIBE:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_SUBSCRIBE;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_SUBACK:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_SUBACK;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_UNSUBSCRIBE:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_UNSUBSCRIBE;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_UNSUBACK:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_UNSUBACK;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PINGREQ:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PINGREQ;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_PINGRESP:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_PINGRESP;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_DISCONNECT:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_DISCONNECT;
      
    //--------------------------------------
    //CONNECT
    //--------------------------------------
  	t_e_MQTTControlPackets::MCP_UNKNOWN:
    
      pChar := MQTT_CONTROLPACKET_TEXTS_UNKNOWN;
      
  end_case;

  
END_FUNCTION


FUNCTION MQTTClient::Log_GetText_MQTTClientState
	VAR_INPUT
		ClientState 	: t_e_MQTTClientStates;
	END_VAR
	VAR_OUTPUT
		pChar 	: ^CHAR;
	END_VAR
  
  pChar := NIL;
  
  //===================================================
  //Based on the State, pass the pointer to the 
  //relevant text back to the calling party
  //===================================================
  case ClientState of
    //--------------------------------------------
    //MCS_Initialise
    //--------------------------------------------
  	t_e_MQTTClientStates::MCS_Initialise:
      
      pChar := MQTT_STATES_TEXTS_MCS_INITIALISE;
    
    //--------------------------------------------
    //MCS_Connect
    //--------------------------------------------
  	t_e_MQTTClientStates::MCS_Connect:
      
      pChar := MQTT_STATES_TEXTS_MCS_CONNECT;    
    
    //--------------------------------------------
    //MCS_Connected
    //--------------------------------------------
  	t_e_MQTTClientStates::MCS_Connected:
      
      pChar := MQTT_STATES_TEXTS_MCS_CONNECTED;    
    
    //--------------------------------------------
    //MCS_Reconnect
    //--------------------------------------------
  	t_e_MQTTClientStates::MCS_Reconnect:
      
      pChar := MQTT_STATES_TEXTS_MCS_RECONNECT;    
    
    //--------------------------------------------
    //MCS_Disconnect
    //--------------------------------------------
  	t_e_MQTTClientStates::MCS_Disconnect:
      
      pChar := MQTT_STATES_TEXTS_MCS_DISCONNECT;    
    
    //--------------------------------------------
    //MCS_Error
    //--------------------------------------------
  	t_e_MQTTClientStates::MCS_Error:
      
      pChar := MQTT_STATES_TEXTS_MCS_ERROR;    
    
  end_case;

  
END_FUNCTION


FUNCTION GLOBAL MQTTClient::MallocV1
	VAR_INPUT
		size0 	: UDINT;
		mark0 	: USINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^void;
	END_VAR
  
  pUser := MemoryHeap.MallocV1( size0 :=  size0, 
                                mark0 :=  mark0);
  
END_FUNCTION


FUNCTION GLOBAL MQTTClient::Free
	VAR_INPUT
		mptr 	: ^void;
	END_VAR
  
  MemoryHeap.Free(mptr:=mptr);
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient::Callback_DNS_Lookup_Async
	VAR_INPUT
		ip 	: UDINT;
	END_VAR
  
  ConnectionDataStruct.udIPAddress := ip;
  States.Connect := CS_udToASCII;

END_FUNCTION


FUNCTION MQTTClient::InflightMsgs_GetMsgByMid
	VAR_INPUT
		MsgType 	: t_e_InflightMessages;
		mid 	: INT;
		Direction 	: DINT;
	END_VAR
	VAR_OUTPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
  VAR
  	udCount : UDINT;
  END_VAR
  
  pMsg := nil;
  
  if pInFlightMsgs & pInFlightMsgs^.udInflightMsgs > 0 then
    
    pMsg := #pInFlightMsgs^.InflightMsgs;
    
    for udCount := 0 to pInFlightMsgs^.udInflightMsgs - 1 do
      if pMsg^.MsgType = MsgType &
         pMsg^.iPacketID = mid   &
         ((Direction = 1 & pMsg^.Direction = MD_Incoming)|
          (Direction = 0 & pMsg^.Direction = MD_Outgoing)) then
        return;
      end_if;
      pMsg$UDINT += sizeof(t_s_InflightMessage);
    end_for;
    
    pMsg := nil;
    
  end_if;

END_FUNCTION

FUNCTION MQTTClient::InflightMsgs_GetMsgByPacketQueueID
	VAR_INPUT
		MsgType 	: t_e_InflightMessages;
		ID 	: DINT;
		Direction 	: DINT;
	END_VAR
	VAR_OUTPUT
		pMsg 	: ^t_s_InflightMessage;
	END_VAR
  VAR
  	udCount : UDINT;
  END_VAR
  
  pMsg := nil;
  
  if pInFlightMsgs & pInFlightMsgs^.udInflightMsgs > 0 then
    
    pMsg := #pInFlightMsgs^.InflightMsgs;
    
    for udCount := 0 to pInFlightMsgs^.udInflightMsgs - 1 do
      if pMsg^.MsgType = MsgType &
         pMsg^.dPacketQueueID = ID   &
         ((Direction = 1 & pMsg^.Direction = MD_Incoming)|
          (Direction = 0 & pMsg^.Direction = MD_Outgoing)) then
        return;
      end_if;
      pMsg$UDINT += sizeof(t_s_InflightMessage);
    end_for;
    
    pMsg := nil;
    
  end_if;

END_FUNCTION

FUNCTION MQTTClient::Counters_GetNextMID
	VAR_OUTPUT
		iMid 	: INT;
	END_VAR
  VAR
  	bFound : BOOL;
    udCount : UDINT;
    pMsg : ^t_s_InflightMessage;
  END_VAR
  
  if pInFlightMsgs then
  
    if pInFlightMsgs^.udInflightMsgs > 0 then
    
      iMid := ConnectionDataStruct.iMid;
      bFound := TRUE;
      
      while bFound do
        
        bFound := FALSE;  
        iMid += 1;
        
        if iMid = -1 | iMid = 0 | iMid = 32767 then
          iMid := 1;
        end_if;
                
        for udCount := 0 to pInFlightMsgs^.udInflightMsgs - 1 do
          
          pMsg$UDINT := (#pInFlightMsgs^.InflightMsgs)$UDINT + sizeof(t_s_InflightMessage)*udCount;
          
          if pMsg^.iPacketID = iMid then
            bFound := TRUE;
            exit;
          end_if;

        end_for;
            
      end_while;
      
      ConnectionDataStruct.iMid := iMid;
    
    else
      
      ConnectionDataStruct.iMid += 1;
      if ConnectionDataStruct.iMid = -1 |ConnectionDataStruct.iMid = 0 | ConnectionDataStruct.iMid = 32767 then
        ConnectionDataStruct.iMid := 1;
      end_if;
      iMid := ConnectionDataStruct.iMid;
    
    end_if;

  
  end_if;

  
  
  
END_FUNCTION


FUNCTION GLOBAL MQTTClient::mqtt_publish_cancel
	VAR_INPUT
		mid 	: INT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	pMsg : ^t_s_InflightMessage;
  END_VAR

  pMsg := InflightMsgs_GetMsgByMid( MsgType   := IM_Publish, 
                                    mid       := mid, 
                                    Direction := 0);
  
  if pMsg then
    
    pMsg^.bRemove := TRUE;
    retCode := MQTT_ERR_SUCCESS;
  
  else
  
    retCode := MQTT_ERR_NOT_FOUND;
  
  end_if;
  
END_FUNCTION


FUNCTION MQTTClient::InflightMsgs_Clear

  //if the input is ok
  if pInFlightMsgs then
    
    SigCLib.MemSet( dst :=  #pInFlightMsgs^.InflightMsgs, 
                    c   :=  0x00, 
                    len :=  pInFlightMsgs^.udMaxInflightMsgs * sizeof(t_s_InflightMessage));
    
    pInFlightMsgs^.udInflightMsgs := 0;
    
  end_if;
  
END_FUNCTION
