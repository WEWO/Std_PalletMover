//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define JSONREADER_MEMMARK 9
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_JSONReader"
	Revision           = "1.1"
	GUID               = "{EDA654B8-074E-42B8-A7D5-4AB5A324B7C4}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "10 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(444,120)"
	Comment            = "This class provides an interface to read and parse a JSON String from a file.&#13;&#10;Parsing and interrogation of the JSON String is performed using the embedded _cJSON class which ports the cJSON Project to LASAL.&#13;&#10;&#13;&#10;If the requirement is only to parse, manipulate and serialize JSON in the memory (not reading from / writing to the disk) it is recommended that the _cJSON class be used as standalone.&#13;&#10;&#13;&#10;To use the class:&#13;&#10;1. Place a file on the disk containing valid JSON text.&#13;&#10;2. Call the _JSONReader::ReadFile() method, providing the path to the file on the disk.&#13;&#10;3. Once the _JSONReader::ReadFSM server reaches the RS_COMPLETE state the Main Element can be read using the _JSONReader::GetMainElement() method.&#13;&#10;4. The JSON read from the disk can then be inspected / manipulated using the _cJSON methods provided in the _JSONReader class.">
	<Channels>
		<Server Name="ClassSvr" GUID="{886E2687-8121-428F-82AC-CBC5C591764D}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Object channel"/>
		<Server Name="LibraryVersion" GUID="{F2106162-D665-416C-AE17-5509BBD39830}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The embedded cJSON Library version is shown on this Server, the value is read and set once during the _firstscan cycle."/>
		<Server Name="ReadFSM" GUID="{EDD42257-CB65-4DF2-BE5E-495C0521647F}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The status of the read and parse procedure is shown on the server:&#13;&#10;1. Once the FSM Reaches the RS_WAIT step, the ReadFile() method can be used to read and parse a JSON file from the disk.&#13;&#10;2. Once the FSM Reaches the RS_COMPLETE step, the GetMainElement() method can be called to get the MainElement in the JSON Structure, the Structure can then be further inspected / manipulated using the provided _cJSON methods.&#13;&#10;3. If the FSM reaches the RS_ERROR step, the Error can be inspected using the GetLastError() method and cleared using the ResetError() method. It is also possible to restart the process from this state using the ReadFile() method."/>
		<Client Name="_cJSON" Required="true" Internal="true"/>
		<Client Name="_FileSys" Required="false" Internal="false" Comment="Object channel to the _FileSys OSInterface, the functions in the OSInterface are used to read files from the disk."/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="OSInterface to SigCLib, this is required for the underlying cJSON functions to function properly."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="VelGer"/>
		<Dokumentation Revision="1.1" Date="2021-05-02" Author="VelGer" Company="Sigmatek" Description="BugFix: When reading a file of which the length was divisible by 4 the CPU crashed with an ApplMemHeap error, this occurred as one byte too few was allocated for the JSON string read from the file, this problem has been corrected."/>
		<Dokumentation Revision="1.0" Date="2021-01-30" Author="VelGer" Company="Sigmatek" Description="Initial Creation."/>
	</RevDoku>
	<Network Name="_JSONReader">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_cJSON"
				GUID       = "{CCA87F71-9990-469E-AE89-CEF7ED76C0EA}"
				Class      = "_cJSON"
				Position   = "(150,150)"
				Visualized = "true"
				Remotely   = "true"
				Comment    = "This instance of the _cJSON class is used by the encapsulating _JSONReader to access the cJSON library functions.">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="LibraryVersion"/>
					<Client Name="SigCLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._cJSON" Destination="_cJSON.ClassSvr"/>
			<Connection Source="this.LibraryVersion" Destination="_cJSON.LibraryVersion" Vertices="(782,270),(750,270),(720,270),(690,270),(660,300),(610,300),"/>
			<Connection Source="_cJSON.SigCLib" Destination="this.SigCLib" Vertices="(150,240),(120,240),(90,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_JSONReader : CLASS
	TYPE
	  t_e_Errors :  //! <Type Public="true" Comment="This enumeration contains unique values for each of the known errors that can occur in the class.&#13;&#10;For further problem diagnosing information, see the comment of each entry." Name="t_e_Errors"/>
	  (
	    E_NoError:=0,  //! <Type Comment="No Error Occured." Name="t_e_Errors.E_NoError"/>
	    E_FileNameNotSet:=4294967295,  //! <Type Comment="The Filename was not set ( = NIL) in the ReadFile() call." Name="t_e_Errors.E_FileNameNotSet"/>
	    E_ClassState:=4294967294,  //! <Type Comment="The class was not in the correct state to perform the requested operation." Name="t_e_Errors.E_ClassState"/>
	    E_MemFull:=4294967293,  //! <Type Comment="An internal call to Malloc() failed (returned nil), this means that there is not enough memory available to perform the operation or the memory is so fragmented that the OS cannot deliver a single block big enough to server the request." Name="t_e_Errors.E_MemFull"/>
	    E_AsyncIDUnknown:=4294967292,  //! <Type Comment="Whilst querying the status of an async file operation the OS reported that the async ID was not known." Name="t_e_Errors.E_AsyncIDUnknown"/>
	    E_AsyncResultLost:=4294967291,  //! <Type Comment="Whilst querying the status for the async file operation the OS reported that the operation completed (success or failure could have occured) however as only the last 50 operation results are stored and more than 50 operation have been completed after this one, the result has been lost.&#13;&#10;The Application can be inspected to find out if unnecessary async operations are being performed or the interval at which the operation status is queried (the background time of this class) can be increased." Name="t_e_Errors.E_AsyncResultLost"/>
	    E_AsyncOperationResultUnknown:=4294967290,  //! <Type Comment="Whilst querying the status for an asynchronous file access operation the OS reported that the Async Operation Status was unknown." Name="t_e_Errors.E_AsyncOperationResultUnknown"/>
	    E_FileContentsTooSmall:=4294967289,  //! <Type Comment="The File get length operation delivered a value too small for the content to be a JSON String." Name="t_e_Errors.E_FileContentsTooSmall"/>
	    E_FileOperationRequestFailed:=4294967288,  //! <Type Comment="Some File Operation request has failed, the Async Handle returned was negative, if the ErrorCode pointer is set the value returned is written, the errors are defined by the FileSys Class as follows:&#13;&#10;LasalOS File Error Return Codes:&#10;&#13;&#10;0  NO_ERROR&#13;&#10;-1  ERROR_RESERVED &#13;&#10;-2  PARAM_ERROR&#13;&#10;-3  INVALID_FILENAME &#13;&#10;-4  DRIVE_NOT_FOUND&#13;&#10;-5  TOO_MANY_FILES &#13;&#10;-6  NO_MORE_FILES&#13;&#10;-7  WRONG_MEDIA &#13;&#10;-8  INVALID_FILE_SYSTEM&#13;&#10;-9  FILE_NOT_FOUND &#13;&#10;-10  INVALID_FILE_HANDLE&#13;&#10;-11  UNSUPPORTED_DEVICE &#13;&#10;-12  UNSUPPORTED_DRIVER_FUNCTION&#13;&#10;-13  CORRUPTED_PARTITION_TABLE &#13;&#10;-14  TOO_MANY_DRIVES&#13;&#10;-15  INVALID_FILE_POS &#13;&#10;-16  ACCESS_DENIED&#13;&#10;-17  STRING_BUFFER_TOO_SMALL &#13;&#10;-18  GENERAL_FAILURE&#13;&#10;-19  PATH_NOT_FOUND &#13;&#10;-20  FAT_ALLOC_ERROR&#13;&#10;-21  ROOT_DIR_FULL &#13;&#10;-22  DISK_FULL&#13;&#10;-23  TIMEOUT &#13;&#10;-24  BAD_SECTOR&#13;&#10;-25  DATA_ERROR &#13;&#10;-26  MEDIA_CHANGED&#13;&#10;-27  SECTOR_NOT_FOUND &#13;&#10;-28  ADDRESS_MARK_NOT_FOUND&#13;&#10;-29  DRIVE_NOT_READY &#13;&#10;-30  WRITE_PROTECTION&#13;&#10;-31  DMA_OVERRUN &#13;&#10;-32  CRC_ERROR&#13;&#10;-33  DEVICE_RESOURCE_ERROR &#13;&#10;-34  INVALID_SECTOR_SIZE&#13;&#10;-35  OUT_OF_BUFFERS &#13;&#10;-36  FILE_EXISTS&#13;&#10;-37  LONG_FILE_POS &#13;&#10;-38  FILE_TOO_LARGE" Name="t_e_Errors.E_FileOperationRequestFailed"/>
	    E_FileReadError:=4294967287,  //! <Type Comment="An error occurred whilst reading the file, if the ErrorCode pointer is set the delivered error code is written as delivered by the OS File function:&#13;&#10;0  NO_ERROR&#13;&#10;-1  ERROR_RESERVED &#13;&#10;-2  PARAM_ERROR&#13;&#10;-3  INVALID_FILENAME &#13;&#10;-4  DRIVE_NOT_FOUND&#13;&#10;-5  TOO_MANY_FILES &#13;&#10;-6  NO_MORE_FILES&#13;&#10;-7  WRONG_MEDIA &#13;&#10;-8  INVALID_FILE_SYSTEM&#13;&#10;-9  FILE_NOT_FOUND &#13;&#10;-10  INVALID_FILE_HANDLE&#13;&#10;-11  UNSUPPORTED_DEVICE &#13;&#10;-12  UNSUPPORTED_DRIVER_FUNCTION&#13;&#10;-13  CORRUPTED_PARTITION_TABLE &#13;&#10;-14  TOO_MANY_DRIVES&#13;&#10;-15  INVALID_FILE_POS &#13;&#10;-16  ACCESS_DENIED&#13;&#10;-17  STRING_BUFFER_TOO_SMALL &#13;&#10;-18  GENERAL_FAILURE&#13;&#10;-19  PATH_NOT_FOUND &#13;&#10;-20  FAT_ALLOC_ERROR&#13;&#10;-21  ROOT_DIR_FULL &#13;&#10;-22  DISK_FULL&#13;&#10;-23  TIMEOUT &#13;&#10;-24  BAD_SECTOR&#13;&#10;-25  DATA_ERROR &#13;&#10;-26  MEDIA_CHANGED&#13;&#10;-27  SECTOR_NOT_FOUND &#13;&#10;-28  ADDRESS_MARK_NOT_FOUND&#13;&#10;-29  DRIVE_NOT_READY &#13;&#10;-30  WRITE_PROTECTION&#13;&#10;-31  DMA_OVERRUN &#13;&#10;-32  CRC_ERROR&#13;&#10;-33  DEVICE_RESOURCE_ERROR &#13;&#10;-34  INVALID_SECTOR_SIZE&#13;&#10;-35  OUT_OF_BUFFERS &#13;&#10;-36  FILE_EXISTS&#13;&#10;-37  LONG_FILE_POS &#13;&#10;-38  FILE_TOO_LARGE" Name="t_e_Errors.E_FileReadError"/>
	    E_JSONError:=4294967286  //! <Type Comment="An error occured whilst parsing the JSON String, if the ErrorCode pointer is set, the pointer to the position in the string where the error occurred is written.&#13;&#10;In this case, the string read from the file is not automatically cleared as is the case when the parsing of the string succeeded, to clear the string the method ResetError() or ReadFile() can be called." Name="t_e_Errors.E_JSONError"/>
	  )$DINT;
	  t_e_READSTEPS :  //! <Type Public="true" Comment="This enum describes the steps in the FSM used to read a file from the disk and parse it using the cJSON Parser." Name="t_e_READSTEPS"/>
	  (
	    RS_WAIT,  //! <Type Comment="No ongoing operation, to start reading a JSON file, call the _JSONReader::ReadFile() method." Name="t_e_READSTEPS.RS_WAIT"/>
	    RS_OPEN_FILE:=1,  //! <Type Comment="In this step the Open File Command is issued." Name="t_e_READSTEPS.RS_OPEN_FILE"/>
	    RS_WAIT_FOR_OPEN,  //! <Type Comment="The FSM waits in this step until the file has been opened." Name="t_e_READSTEPS.RS_WAIT_FOR_OPEN"/>
	    RS_GET_FILELENGTH:=3,  //! <Type Comment="In this step the Get Filelength Command is issued." Name="t_e_READSTEPS.RS_GET_FILELENGTH"/>
	    RS_WAIT_FOR_LEN:=4,  //! <Type Comment="The FSM waits in this step until the file length has been determined." Name="t_e_READSTEPS.RS_WAIT_FOR_LEN"/>
	    RS_READ_FILE:=5,  //! <Type Comment="In this step the Read File Command is issued." Name="t_e_READSTEPS.RS_READ_FILE"/>
	    RS_WAIT_FOR_READ:=6,  //! <Type Comment="The FSM waits in this step until the file has been read." Name="t_e_READSTEPS.RS_WAIT_FOR_READ"/>
	    RS_CLOSE_FILE:=7,  //! <Type Comment="In this step the Close File Command is issued." Name="t_e_READSTEPS.RS_CLOSE_FILE"/>
	    RS_WAIT_FOR_CLOSE:=8,  //! <Type Comment="The FSM waits in this step until the file has been closed." Name="t_e_READSTEPS.RS_WAIT_FOR_CLOSE"/>
	    RS_PARSE:=9,  //! <Type Comment="In this step the string read from the file is parsed." Name="t_e_READSTEPS.RS_PARSE"/>
	    RS_COMPLETE:=10,  //! <Type Comment="The FSM stops in this state when the operation has completed." Name="t_e_READSTEPS.RS_COMPLETE"/>
	    RS_ERROR:=11  //! <Type Comment="The FSM stops in this state when an error occurred, to determine which error occurred the GetLastError() method can be called." Name="t_e_READSTEPS.RS_ERROR"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_FileAccessStruct : STRUCT  //! <Type Comment="This structure contains the Class Variables for the File Access Functionalities provided by this class." Name="t_s_FileAccessStruct"/>
	    pFileName : ^CHAR;  //! <Type Comment="Name of the File to be read." Name="t_s_FileAccessStruct.pFileName"/>
	    dAsyncID : DINT;  //! <Type Comment="The AsyncID for the current file access operation is stored on this variable." Name="t_s_FileAccessStruct.dAsyncID"/>
	    dFileHandle : DINT;  //! <Type Comment="File Handle for File Operations" Name="t_s_FileAccessStruct.dFileHandle"/>
	    udFileLength : UDINT;  //! <Type Comment="Length of the File to be read." Name="t_s_FileAccessStruct.udFileLength"/>
	    pFileBuffer : ^CHAR;  //! <Type Comment="Buffer to read the file contents into." Name="t_s_FileAccessStruct.pFileBuffer"/>
	    dBytesRead : DINT;  //! <Type Comment="The number of bytes read in the asynchronous read operation." Name="t_s_FileAccessStruct.dBytesRead"/>
	    bErrorOccurred : BOOL;  //! <Type Comment="This bool is set if an error occured so that the class can swith to the error state after passing through the File Close Operation." Name="t_s_FileAccessStruct.bErrorOccurred"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	LibraryVersion 	: SvrCh_UDINT;
	ReadFSM 	: SvrCh_t_e_READSTEPS_PTofCls__JSONReader;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
	_FileSys 	: CltChCmd__FileSys;
	_cJSON 	: CltChCmd__cJSON;
  //Variables:
		MainElement 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="This variable contains the pointer to the MainElement in the JSON structure once the file has been parsed." Name="MainElement"/>
		FileAccessStruct 	: _JSONReader::t_s_FileAccessStruct;			//! <Variable Comment="File Access Relevant values are stored in this structure." Name="FileAccessStruct"/>
		LastError 	: _JSONReader::t_e_Errors;			//! <Variable Comment="The Last error that occurred is stored in this var, the value can be read out using the GetLastError() method." Name="LastError"/>
		LastErrorCode 	: DINT;			//! <Variable Comment="The error code for the last error that occurred is stored in this var, the value can be read out using the GetLastError() method." Name="LastErrorCode"/>
  //Functions:
				//! <Function Comment="File Access and JSON Parsing calls are performed in the Background Task of the Class." Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="This method initiates a new Read and Parse cycle, if the class has parsed before the structure will be cleared before starting the reading and subsequent parse process." Name="ReadFile"/>
	FUNCTION GLOBAL ReadFile
		VAR_INPUT
			FileName 	: ^CHAR;			//! <Variable Comment="The name of the file to be read and parsed, the expected format is a null-terminated ASCII-string." Name="ReadFile.FileName"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="Inidicates whether the operation succeeded or not.&#13;&#10;True = The command was accepted.&#13;&#10;False = The command was rejected." Name="ReadFile.bOK"/>
		END_VAR;
				//! <Function Comment="This function returns the main (first) element in the JSON object tree after the JSON String has been parsed successfully." Name="GetMainElement"/>
	FUNCTION GLOBAL GetMainElement
		VAR_OUTPUT
			MainElement 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Main Element of the parsed JSON String.&#13;&#10;If the string has not been parsed or parsing failed, null is returned." Name="GetMainElement.MainElement"/>
		END_VAR;
				//! <Function Comment="This method allows the MainElement to be cleared after parsing if not required anymore. If the JSONReader is used to parse multiples of times the MainElement will automatically be cleared, calling this method is not necessary." Name="ClearMainElement"/>
	FUNCTION GLOBAL ClearMainElement;
				//! <Function Comment="This method can be used to get the last error that occured in the object. &#13;&#10;This method can only be guaranteed to deliver the correct ErrorCode in the case where the class is only accessed from one thread." Name="GetLastError"/>
	FUNCTION GLOBAL GetLastError
		VAR_INPUT
			pErrorCode 	: ^DINT;			//! <Variable Comment="Pointer to a DINT value where extra information, such as the position in the JSON string where a parse error occurred can be stored. The Description of the Error delivered states, whether this value is used or not, and the purpose thereof is described the comments of each individual entry in the return type." Name="GetLastError.pErrorCode"/>
		END_VAR
		VAR_OUTPUT
			LastError 	: _JSONReader::t_e_Errors;			//! <Variable Comment="The Last Error that occurred." Name="GetLastError.LastError"/>
		END_VAR;
				//! <Function Comment="If an error has occurred the JSON String read from the file as well as Filename are not cleared to allow the opportunity for the Application / User to inspect the error, this method can be used to reset the error and free the memory.&#13;&#10;If an error has occurred and the read / Parse process is restarted before clearing the error, the old memory will automatically be cleared." Name="ResetError"/>
	FUNCTION GLOBAL ResetError;
				//! <Function Comment="This method is used to clear all operating memory to allow the class to start fresh." Name="ResetMem"/>
	FUNCTION ResetMem;
				//! <Function Comment="This method returns the version of cJSON as a string." Name="Version"/>
	FUNCTION GLOBAL Version
		VAR_OUTPUT
			retString 	: ^CHAR;			//! <Variable Comment="Version String." Name="Version.retString"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON, the method then returns a cJSON object that can be interrogated." Name="Parse"/>
	FUNCTION GLOBAL Parse
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="Parse.value"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="Parse.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with a data length, the method then returns a cJSON object that can be interrogated." Name="ParseWithLength"/>
	FUNCTION GLOBAL ParseWithLength
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithLength.value"/>
			buffer_length 	: UDINT;			//! <Variable Comment="Length of the string to be parsed." Name="ParseWithLength.buffer_length"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithLength.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with a data length and some options to help verify that the JSON string is terminated OK, the method then returns a cJSON object that can be interrogated and in the case of failure the pointer to where the error was found in the JSON string." Name="ParseWithLengthOpts"/>
	FUNCTION GLOBAL ParseWithLengthOpts
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithLengthOpts.value"/>
			buffer_length 	: UDINT;			//! <Variable Comment="Length of the string to be parsed." Name="ParseWithLengthOpts.buffer_length"/>
			return_parse_end 	: ^pChar;			//! <Variable Comment="If the parsing of the JSON string fails, the pointer to where the error was detected in the String is passed back over this pointer.&#13;&#10;This value matches that which is delivered by the GetErrorPtr() method and can be used to ensure that the class remains thread safe." Name="ParseWithLengthOpts.return_parse_end"/>
			require_null_terminated 	: BOOL;			//! <Variable Comment="When set the parser ensures that the string passed to the method was null terminated." Name="ParseWithLengthOpts.require_null_terminated"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithLengthOpts.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with some options to help verify that the JSON string is terminated OK, the method then returns a cJSON object that can be interrogated and in the case of failure the pointer to where the error was found in the JSON string." Name="ParseWithOpts"/>
	FUNCTION GLOBAL ParseWithOpts
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithOpts.value"/>
			return_parse_end 	: ^pChar;			//! <Variable Comment="If the parsing of the JSON string fails, the pointer to where the error was detected in the String is passed back over this pointer.&#13;&#10;This value matches that which is delivered by the GetErrorPtr() method and can be used to ensure that the class remains thread safe." Name="ParseWithOpts.return_parse_end"/>
			require_null_terminated 	: BOOL;			//! <Variable Comment="When set the parser ensures that the string passed to the method was null terminated." Name="ParseWithOpts.require_null_terminated"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithOpts.json"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON entity (see _cJSON::t_s_cJSON) can be rendered to string." Name="Print"/>
	FUNCTION GLOBAL Print
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="Print.item"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="Print.string"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON entity (see _cJSON::t_s_cJSON) can be rendered to string whilst ignoring any formatting." Name="PrintUnformatted"/>
	FUNCTION GLOBAL PrintUnformatted
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintUnformatted.item"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintUnformatted.string"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON entity can be printed to string using a prebuffered strategy, this means that the required memory is allocated beforehand and reallocation is thereby reduced.&#13;&#10;As opposed to the unbuffered strategy the user must supply an initial guess describing how large the JSON string will be, if this is exceeded whilst rendering a reallocation is made." Name="PrintBuffered"/>
	FUNCTION GLOBAL PrintBuffered
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintBuffered.item"/>
			prebuffer 	: INT;			//! <Variable Comment="Size of the buffer memory to be allocated initially. See the method comment for a further description of this functionality." Name="PrintBuffered.prebuffer"/>
			fmt 	: BOOL;			//! <Variable Comment="Whether the string is to be printed formatted or not:&#13;&#10;True = Formatted&#13;&#10;False = Unformatted" Name="PrintBuffered.fmt"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintBuffered.string"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON entity can be printed to string using a preallocated strategy, this means that the required memory is allocated by the user and the location and size provided to the class.&#13;&#10;If rendering the JSON string requires more memory than was initially allocated by the user the process will fail." Name="PrintPreallocated"/>
	FUNCTION GLOBAL PrintPreallocated
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintPreallocated.item"/>
			buffer 	: ^CHAR;			//! <Variable Comment="A pointer to the memory that the user has allocated for the rendering of the string." Name="PrintPreallocated.buffer"/>
			length 	: INT;			//! <Variable Comment="The length of the memory allocated (how far the class is allowed to write)." Name="PrintPreallocated.length"/>
			format 	: BOOL;			//! <Variable Comment="Whether the string is to be printed formatted or not:&#13;&#10;True = Formatted&#13;&#10;False = Unformatted" Name="PrintPreallocated.format"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintPreallocated.string"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Structure (see _cJSON::t_s_cJSON) can be deleted (freed) from memory, all subentities to this structure are also freed." Name="Delete"/>
	FUNCTION GLOBAL Delete
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Structure to free." Name="Delete.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the number of items in a JSON Array or JSON object." Name="GetArraySize"/>
	FUNCTION GLOBAL GetArraySize
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Array or Object of which the item count is to be returned." Name="GetArraySize.item"/>
		END_VAR
		VAR_OUTPUT
			size 	: INT;			//! <Variable Comment="The number of items found." Name="GetArraySize.size"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the pointer to the item at the position and in the JSON Array provided." Name="GetArrayItem"/>
	FUNCTION GLOBAL GetArrayItem
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Array in which the item is to be found." Name="GetArrayItem.item"/>
			index 	: UDINT;			//! <Variable Comment="The zero-indexed index number from which the item is to be found." Name="GetArrayItem.index"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The pointer to the item found at the index position, if an error occurs, null." Name="GetArrayItem.entry"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the pointer to the item of which the key value matches the string provided, the search is case-insensitive." Name="GetObjectItem"/>
	FUNCTION GLOBAL GetObjectItem
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="GetObjectItem.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-insentive string value matching the key to be found." Name="GetObjectItem.string"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON entity of which the key was found in the object provided, if not found, null." Name="GetObjectItem.entry"/>
		END_VAR;
				//! <Function Comment="This method operates in the same way as the _cJSON::GetObjectItem() method, the only difference is that the key search is case-sensitive.&#13;&#10;The user can find the pointer to the item of which the key value matches the string provided." Name="GetObjectItemCaseSensitive"/>
	FUNCTION GLOBAL GetObjectItemCaseSensitive
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="GetObjectItemCaseSensitive.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-sensitive string value matching the key to be found." Name="GetObjectItemCaseSensitive.string"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON entity of which the key was found in the object provided, if not found, null." Name="GetObjectItemCaseSensitive.entry"/>
		END_VAR;
				//! <Function Comment="Using this method the user can search through a JSON object to determine whether the object contains the key value provided." Name="HasObjectItem"/>
	FUNCTION GLOBAL HasObjectItem
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="HasObjectItem.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-insentive string value matching the key to be found." Name="HasObjectItem.string"/>
		END_VAR
		VAR_OUTPUT
			hasItem 	: BOOL;			//! <Variable Comment="A bool indicating whether the item searched for was found.&#13;&#10;True = The object contains an item with the key value as provided.&#13;&#10;False = The object does not contain an item with the key value provided." Name="HasObjectItem.hasItem"/>
		END_VAR;
				//! <Function Comment="Using this method the user can retrieve the pointer to the position where the last error occurred in any JSON operation.&#13;&#10;Special care must be taken as the method does not ensure thread-safety, if multiple threads can call functions in the class, it cannot be ensured that the retrieved pointer points to the expected error.&#13;&#10;As opposed to using this method the user can use the thread-safe _cJSON::ParseWithOpts() / _cJSON::ParseWithLengthOpts() to receive the pointer to where a parsing error occured immediately." Name="GetErrorPtr"/>
	FUNCTION GLOBAL GetErrorPtr
		VAR_OUTPUT
			errPtr 	: ^CHAR;			//! <Variable Comment="Pointer to where the last error occured." Name="GetErrorPtr.errPtr"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the string value of the supplied JSON entity.&#13;&#10;If the entity is not valid or not of type string, null is returned." Name="GetStringValue"/>
	FUNCTION GLOBAL GetStringValue
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON string entity of which the value is to be returned." Name="GetStringValue.item"/>
		END_VAR
		VAR_OUTPUT
			value 	: ^CHAR;			//! <Variable Comment="If the entity is of type JSON String, a pointer to the string, if not, null." Name="GetStringValue.value"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the number (LREAL) value of the supplied JSON entity." Name="GetNumberValue"/>
	FUNCTION GLOBAL GetNumberValue
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON number entity of which the value is to be returned." Name="GetNumberValue.item"/>
		END_VAR
		VAR_OUTPUT
			value 	: LREAL;			//! <Variable Comment="If the provided item is of type JSON number, the value, if not, NAN." Name="GetNumberValue.value"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is invalid." Name="IsInvalid"/>
	FUNCTION GLOBAL IsInvalid
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsInvalid.item"/>
		END_VAR
		VAR_OUTPUT
			isInvalid 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Invalid:&#13;&#10;True = Invalid&#13;&#10;False = Not Invalid" Name="IsInvalid.isInvalid"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is False." Name="IsFalse"/>
	FUNCTION GLOBAL IsFalse
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsFalse.item"/>
		END_VAR
		VAR_OUTPUT
			isFalse 	: BOOL;			//! <Variable Comment="Value indicating whether the type is False.&#13;&#10;True = Value is False&#13;&#10;False = Value is not False" Name="IsFalse.isFalse"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is True." Name="IsTrue"/>
	FUNCTION GLOBAL IsTrue
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsTrue.item"/>
		END_VAR
		VAR_OUTPUT
			isTrue 	: BOOL;			//! <Variable Comment="Value indicating whether the type is True.&#13;&#10;True = Value is True&#13;&#10;False = Value is not True" Name="IsTrue.isTrue"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type bool." Name="IsBool"/>
	FUNCTION GLOBAL IsBool
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsBool.item"/>
		END_VAR
		VAR_OUTPUT
			isBool 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Bool.&#13;&#10;True = Value is of tye Bool&#13;&#10;False = Value is not of type Bool" Name="IsBool.isBool"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is null." Name="IsNull"/>
	FUNCTION GLOBAL IsNull
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsNull.item"/>
		END_VAR
		VAR_OUTPUT
			isNull 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Null.&#13;&#10;True = Value is Null&#13;&#10;False = Value is not Null" Name="IsNull.isNull"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type number." Name="IsNumber"/>
	FUNCTION GLOBAL IsNumber
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsNumber.item"/>
		END_VAR
		VAR_OUTPUT
			isNumber 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Number.&#13;&#10;True = Value is of type Number&#13;&#10;False = Value is not of type Number" Name="IsNumber.isNumber"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type string." Name="IsString"/>
	FUNCTION GLOBAL IsString
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsString.item"/>
		END_VAR
		VAR_OUTPUT
			isString 	: BOOL;			//! <Variable Comment="Value indicating whether the type is String.&#13;&#10;True = Value is of type String&#13;&#10;False = Value is not of type String" Name="IsString.isString"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is a JSON Array." Name="IsArray"/>
	FUNCTION GLOBAL IsArray
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsArray.item"/>
		END_VAR
		VAR_OUTPUT
			isArray 	: BOOL;			//! <Variable Comment="Value indicating whether the type is JSON Array.&#13;&#10;True = Value is a JSON Array&#13;&#10;False = Value is not a JSON Array" Name="IsArray.isArray"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is a JSON Object." Name="IsObject"/>
	FUNCTION GLOBAL IsObject
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsObject.item"/>
		END_VAR
		VAR_OUTPUT
			isObject 	: BOOL;			//! <Variable Comment="Value indicating whether the type is a JSON Object.&#13;&#10;True = Value is a JSON Object&#13;&#10;False = Value is not a JSON Object" Name="IsObject.isObject"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type Raw." Name="IsRaw"/>
	FUNCTION GLOBAL IsRaw
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsRaw.item"/>
		END_VAR
		VAR_OUTPUT
			isRaw 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Raw.&#13;&#10;True = Value is of type Raw&#13;&#10;False = Value is not of type Raw" Name="IsRaw.isRaw"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Null." Name="CreateNull"/>
	FUNCTION GLOBAL CreateNull
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateNull.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type True." Name="CreateTrue"/>
	FUNCTION GLOBAL CreateTrue
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateTrue.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type False." Name="CreateFalse"/>
	FUNCTION GLOBAL CreateFalse
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateFalse.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Bool." Name="CreateBool"/>
	FUNCTION GLOBAL CreateBool
		VAR_INPUT
			value 	: BOOL;			//! <Variable Comment="The value to be set in the created item." Name="CreateBool.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateBool.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Number." Name="CreateNumber"/>
	FUNCTION GLOBAL CreateNumber
		VAR_INPUT
			value 	: LREAL;			//! <Variable Comment="The value to be set in the created item." Name="CreateNumber.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateNumber.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type String." Name="CreateString"/>
	FUNCTION GLOBAL CreateString
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="The value to be set in the created item." Name="CreateString.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateString.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Raw." Name="CreateRaw"/>
	FUNCTION GLOBAL CreateRaw
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="The value to be set in the created item." Name="CreateRaw.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateRaw.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type JSON Array." Name="CreateArray"/>
	FUNCTION GLOBAL CreateArray
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type JSON Object." Name="CreateObject"/>
	FUNCTION GLOBAL CreateObject
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateObject.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON entity (see _cJSON::t_s_cJSON) of type string where the string is referenced, this means that the string will not be freed when the returned item is deleted (freed)." Name="CreateStringReference"/>
	FUNCTION GLOBAL CreateStringReference
		VAR_INPUT
			string 	: ^CHAR;			//! <Variable Comment="The string to be referenced in the newly created JSON entity." Name="CreateStringReference.string"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="CreateStringReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON Object entity (see _cJSON::t_s_cJSON) containing the child entity provided where the child is referenced, this means that the child will not be freed when the returned item is deleted (freed)." Name="CreateObjectReference"/>
	FUNCTION GLOBAL CreateObjectReference
		VAR_INPUT
			child 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Entity to reference in the newly created JSON Object Entity." Name="CreateObjectReference.child"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Object entity." Name="CreateObjectReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON Array entity (see _cJSON::t_s_cJSON) containing the child entity provided where the child is referenced, this means that the child will not be freed when the returned Array item is deleted (freed)." Name="CreateArrayReference"/>
	FUNCTION GLOBAL CreateArrayReference
		VAR_INPUT
			child 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Entity to reference in the newly created JSON Array Entity." Name="CreateArrayReference.child"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array entity." Name="CreateArrayReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type INT can be created containing the provided values." Name="CreateIntArray"/>
	FUNCTION GLOBAL CreateIntArray
		VAR_INPUT
			numbers 	: ^INT;			//! <Variable Comment="Pointer to the first item in the array of integers to be added in the newly created JSON Array item." Name="CreateIntArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateIntArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateIntArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type REAL can be created containing the provided values." Name="CreateFloatArray"/>
	FUNCTION GLOBAL CreateFloatArray
		VAR_INPUT
			numbers 	: ^REAL;			//! <Variable Comment="Pointer to the first item in the array of REALs to be added in the newly created JSON Array item." Name="CreateFloatArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateFloatArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateFloatArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type LREAL can be created containing the provided values." Name="CreateDoubleArray"/>
	FUNCTION GLOBAL CreateDoubleArray
		VAR_INPUT
			numbers 	: ^LREAL;			//! <Variable Comment="Pointer to the first item in the array of LREALs to be added in the newly created JSON Array item." Name="CreateDoubleArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateDoubleArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateDoubleArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type String can be created containing the provided values." Name="CreateStringArray"/>
	FUNCTION GLOBAL CreateStringArray
		VAR_INPUT
			strings 	: ^CHAR;			//! <Variable Comment="Pointer to the first item in the array of Strings to be added in the newly created JSON Array item." Name="CreateStringArray.strings"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateStringArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateStringArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Array Entity." Name="AddItemToArray"/>
	FUNCTION GLOBAL AddItemToArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Array entity to which the provided entity is to be added." Name="AddItemToArray.arr"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Entity to add to the Array Entity." Name="AddItemToArray.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the procedure succeeded or not.&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Object Entity where the key-string provided is defined in user memory and should be freed when the object is deleted (freed).&#13;&#10;Before using this method compare this to and ensure a good understanding of the purpose of the method: _cJSON::AddItemToObjectCS()" Name="AddItemToObject"/>
	FUNCTION GLOBAL AddItemToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Obect entity to which the item is to be added." Name="AddItemToObject.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be stored in the object.&#13;&#10;This key value string will be freed along with the object when it is deleted (freed) - ensure not to pass a constant (#define) string or a string that is to outlive the JSON object to this value." Name="AddItemToObject.string"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to store in the object." Name="AddItemToObject.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Object Entity where the key-string provided is constant and should not be freed when the object is deleted (freed).&#13;&#10;Before using this method compare this to and ensure a good understanding of the purpose of the method: _cJSON::AddItemToObject()" Name="AddItemToObjectCS"/>
	FUNCTION GLOBAL AddItemToObjectCS
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Obect entity to which the item is to be added." Name="AddItemToObjectCS.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be stored in the object.&#13;&#10;This key value string will not be freed along with the object when it is deleted (freed)." Name="AddItemToObjectCS.string"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to store in the object." Name="AddItemToObjectCS.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToObjectCS.result"/>
		END_VAR;
				//! <Function Comment="This method can be used to append a reference to a JSON Entity to a JSON Array, this can be used when the JSON entity should not be modified by the operation." Name="AddItemReferenceToArray"/>
	FUNCTION GLOBAL AddItemReferenceToArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Array to which the reference to the JSON Entity is to be added." Name="AddItemReferenceToArray.arr"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to reference in the JSON Array." Name="AddItemReferenceToArray.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemReferenceToArray.result"/>
		END_VAR;
				//! <Function Comment="This method can be used to add a reference to a JSON Entity to a JSON Object, this can be used when the JSON entity should not be modified by the operation." Name="AddItemReferenceToObject"/>
	FUNCTION GLOBAL AddItemReferenceToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Object to which the reference to the JSON Entity is to be added." Name="AddItemReferenceToObject.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be referenced in the object." Name="AddItemReferenceToObject.string"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity to reference in the JSON Object." Name="AddItemReferenceToObject.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemReferenceToObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from another JSON Entity without deleting (freeing) either." Name="DetachItemViaPointer"/>
	FUNCTION GLOBAL DetachItemViaPointer
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The parent item from which the child item is to be detached." Name="DetachItemViaPointer.parent"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Child item which is to be detached from the parent item provided." Name="DetachItemViaPointer.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Pointer to the detached item." Name="DetachItemViaPointer.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from JSON Array without deleting (freeing) either." Name="DetachItemFromArray"/>
	FUNCTION GLOBAL DetachItemFromArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Array from which the item is to be detached." Name="DetachItemFromArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index of the item in the array to be detached." Name="DetachItemFromArray.index"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Pointer to the detached item." Name="DetachItemFromArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be removed and deleted from a JSON Array Entity." Name="DeleteItemFromArray"/>
	FUNCTION GLOBAL DeleteItemFromArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Array from which the item is to be deleted (freed)." Name="DeleteItemFromArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index of the item to be deleted (removed)." Name="DeleteItemFromArray.index"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from a JSON Object without deleting (freeing) either.&#13;&#10;The key value search is non-case-sensitive." Name="DetachItemFromObject"/>
	FUNCTION GLOBAL DetachItemFromObject
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be detached." Name="DetachItemFromObject.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be detached from the parent provided." Name="DetachItemFromObject.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The detached item if the operation succeeded, else null." Name="DetachItemFromObject.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from a JSON Object without deleting (freeing) either.&#13;&#10;The key value search is case-sensitive." Name="DetachItemFromObjectCaseSensitive"/>
	FUNCTION GLOBAL DetachItemFromObjectCaseSensitive
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be detached." Name="DetachItemFromObjectCaseSensitive.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be detached from the parent provided." Name="DetachItemFromObjectCaseSensitive.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The detached item if the operation succeeded, else null." Name="DetachItemFromObjectCaseSensitive.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be deleted (freed) from a JSON Object.&#13;&#10;The key value search is non-case-sensitive." Name="DeleteItemFromObject"/>
	FUNCTION GLOBAL DeleteItemFromObject
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be deleted." Name="DeleteItemFromObject.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be deleted from the parent provided." Name="DeleteItemFromObject.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be deleted (freed) from a JSON Object.&#13;&#10;The key value search is case-sensitive." Name="DeleteItemFromObjectCaseSensitive"/>
	FUNCTION GLOBAL DeleteItemFromObjectCaseSensitive
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="Object from which the item is to be deleted." Name="DeleteItemFromObjectCaseSensitive.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be deleted from the parent provided." Name="DeleteItemFromObjectCaseSensitive.item"/>
		END_VAR;
				//! <Function Comment="Using this method an item can be inserted in a JSON Array at the index provided, the pre-existing items in the array are shifted to the right." Name="InsertItemInArray"/>
	FUNCTION GLOBAL InsertItemInArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Array in which item is to be added." Name="InsertItemInArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index at which the item should be added in the array." Name="InsertItemInArray.index"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be added to the array." Name="InsertItemInArray.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="InsertItemInArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Entity can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation." Name="ReplaceItemViaPointer"/>
	FUNCTION GLOBAL ReplaceItemViaPointer
		VAR_INPUT
			parent 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Entity in which the item is to be replaced." Name="ReplaceItemViaPointer.parent"/>
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The Item to be replaced and deleted (freed)." Name="ReplaceItemViaPointer.item"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Entity (parent)." Name="ReplaceItemViaPointer.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemViaPointer.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Array can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation." Name="ReplaceItemInArray"/>
	FUNCTION GLOBAL ReplaceItemInArray
		VAR_INPUT
			arr 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The JSON Array in which item is to be replaced." Name="ReplaceItemInArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index at which the item that is to be replaced can be found." Name="ReplaceItemInArray.index"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Array at the index provided." Name="ReplaceItemInArray.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Object can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation.&#13;&#10;The key value search is non-case-sensitive." Name="ReplaceItemInObject"/>
	FUNCTION GLOBAL ReplaceItemInObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Object in which the item is to be replaced." Name="ReplaceItemInObject.object"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be replaced in the parent provided." Name="ReplaceItemInObject.item"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Object under the key provided." Name="ReplaceItemInObject.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Object can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation.&#13;&#10;The key value search is case-sensitive." Name="ReplaceItemInObjectCaseSensitive"/>
	FUNCTION GLOBAL ReplaceItemInObjectCaseSensitive
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="JSON Object in which the item is to be replaced." Name="ReplaceItemInObjectCaseSensitive.object"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be replaced in the parent provided." Name="ReplaceItemInObjectCaseSensitive.item"/>
			newItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Object under the key provided." Name="ReplaceItemInObjectCaseSensitive.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInObjectCaseSensitive.result"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON Entity can be duplicated, optionally the children can be copied as well (deep-copy) or the pointers to the original children left in place (shallow-copy)." Name="Duplicate"/>
	FUNCTION GLOBAL Duplicate
		VAR_INPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The item to be duplicated." Name="Duplicate.item"/>
			recurse 	: BOOL;			//! <Variable Comment="Value indicating whether to recurse down the tree or not.&#13;&#10;True = Deep-Copy&#13;&#10;False = Shallow-Copy" Name="Duplicate.recurse"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The duplicated JSON Entity." Name="Duplicate.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method two JSON Entities can be compared, the comparison is performed down the entire tree and case-sensitivity can optionally be checked or ignored." Name="Compare"/>
	FUNCTION GLOBAL Compare
		VAR_INPUT
			compareA 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The first JSON Entity to be used for the comparison." Name="Compare.compareA"/>
			compareB 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The second JSON Entity to be used for the comparison." Name="Compare.compareB"/>
			case_sensitive 	: BOOL;			//! <Variable Comment="Whether case-sensitivity should be considered or not.&#13;&#10;True = Character-Case is considered in the comparison.&#13;&#10;False = Character-Case is ignored in the comparison." Name="Compare.case_sensitive"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Result of the operation.&#13;&#10;True = The provided JSON Entities are identical.&#13;&#10;False = The provided JSON Entities differ." Name="Compare.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON String can be minified, this means that all unnecessary whitespace (&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;) is removed." Name="Minify"/>
	FUNCTION GLOBAL Minify
		VAR_INPUT
			json 	: ^CHAR;			//! <Variable Comment="The JSON String to be minified.&#13;&#10;This value cannot point to a constant memory area, this will cause an access error." Name="Minify.json"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Null to the object specified." Name="AddNullToObject"/>
	FUNCTION GLOBAL AddNullToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddNullToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddNullToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddNullToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type True to the object specified." Name="AddTrueToObject"/>
	FUNCTION GLOBAL AddTrueToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddTrueToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddTrueToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddTrueToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type False to the object specified." Name="AddFalseToObject"/>
	FUNCTION GLOBAL AddFalseToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddFalseToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddFalseToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddFalseToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Bool to the object specified." Name="AddBoolToObject"/>
	FUNCTION GLOBAL AddBoolToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddBoolToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddBoolToObject.name"/>
			boolean 	: BOOL;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddBoolToObject.boolean"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddBoolToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Number to the object specified." Name="AddNumberToObject"/>
	FUNCTION GLOBAL AddNumberToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddNumberToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddNumberToObject.name"/>
			number 	: LREAL;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddNumberToObject.number"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddNumberToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type String to the object specified." Name="AddStringToObject"/>
	FUNCTION GLOBAL AddStringToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddStringToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddStringToObject.name"/>
			string 	: ^CHAR;			//! <Variable Comment="The value to assign to the newly created entity. &#13;&#10;This string will be copied from the dereferenced pointer location provided." Name="AddStringToObject.string"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddStringToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Raw to the object specified." Name="AddRawToObject"/>
	FUNCTION GLOBAL AddRawToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddRawToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddRawToObject.name"/>
			raw 	: ^CHAR;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddRawToObject.raw"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddRawToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type JSON Object to the object specified." Name="AddObjectToObject"/>
	FUNCTION GLOBAL AddObjectToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddObjectToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddObjectToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddObjectToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type JSON Array to the object specified." Name="AddArrayToObject"/>
	FUNCTION GLOBAL AddArrayToObject
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddArrayToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddArrayToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddArrayToObject.item"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the number value of an Entity (see _cJSON::t_s_cJSON) to the value provided." Name="SetNumber"/>
	FUNCTION GLOBAL SetNumber
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the value is to be modified." Name="SetNumber.object"/>
			number 	: LREAL;			//! <Variable Comment="The value to set the entity value to." Name="SetNumber.number"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: LREAL;			//! <Variable Comment="The value that the entity was set to." Name="SetNumber.retVal"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the String value of an Entity (see _cJSON::t_s_cJSON) to the string provided." Name="SetValuestring"/>
	FUNCTION GLOBAL SetValuestring
		VAR_INPUT
			object 	: ^_cJSON::t_s_cJSON;			//! <Variable Comment="The entity of which the string value is to be modified." Name="SetValuestring.object"/>
			valueString 	: ^CHAR;			//! <Variable Comment="The String value to set the entity to, the string will be copied from the dereferenced pointer location provided here." Name="SetValuestring.valueString"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: ^CHAR;			//! <Variable Comment="Pointer to the copied string that was added to the entity." Name="SetValuestring.retVal"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LibraryVersion::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _cJSON
#pragma usingLtd _FileSys
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _JSONReader::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__JSONREADER
1$UINT, 1$UINT, (SIZEOF(::_JSONReader))$UINT, 
3$UINT, 3$UINT, 0$UINT, 
TO_UDINT(722092968), "_JSONReader", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_JSONReader.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_JSONReader.LibraryVersion.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(115726070), "LibraryVersion", 
(::_JSONReader.ReadFSM.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3938107492), "ReadFSM", 
//Clients:
(::_JSONReader.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::_JSONReader._FileSys.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(545279513), "_FileSys", TO_UDINT(545279513), "_FileSys", 1$UINT, 20$UINT, 
(::_JSONReader._cJSON.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(798961397), "_cJSON", TO_UDINT(798961397), "_cJSON", 1$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT__JSONReader 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__JSONReader] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _JSONReader::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__JSONReader, pCmd := #vmt.CmdTable);
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LibraryVersion.pMeth			:= StoreMethod( #LibraryVersion::Read(), #M_NO_F() );
	IF LibraryVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION GLOBAL _JSONReader::ResetError
    
  if ReadFSM = RS_ERROR then
    
    ResetMem();    
    ReadFSM := RS_WAIT;   
    
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _JSONReader::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	dAsyncState, dTemp : DINT;
  END_VAR

	state := READY;
  
  //=================================================================
  // File Reading FSM
  //=================================================================
  case ReadFSM of
        
    //-----------------------------------------------
    // Wait for an operation to start.
    //-----------------------------------------------
  	t_e_READSTEPS::RS_WAIT:
      
      
      
    //-----------------------------------------------
    // Request the specified file to be opened.
    //-----------------------------------------------  
    t_e_READSTEPS::RS_OPEN_FILE:
          
      FileAccessStruct.dAsyncID := _FileSys.FileOpen_A(Async       :=  1, 
                                                       filename    :=  FileAccessStruct.pFileName, 
                                                       attributes  :=  ATT_READ_ONLY);      
      
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        ReadFSM := RS_ERROR;
      else
        ReadFSM := RS_WAIT_FOR_OPEN;
      end_if;

    //-----------------------------------------------
    // Wait for the File Open Operation to complete.
    //-----------------------------------------------  
    t_e_READSTEPS::RS_WAIT_FOR_OPEN:
          
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                             Erg :=  #FileAccessStruct.dFileHandle);
      
      if dAsyncState = 0 then
        // The Async Operation has completed
        ReadFSM := RS_GET_FILELENGTH;
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        ReadFSM := RS_ERROR;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        ReadFSM := RS_ERROR;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        ReadFSM := RS_ERROR;
      
      end_if;
    
    //-----------------------------------------------
    // Read the Length of the file so that we know 
    // how much memory to allocate.
    //-----------------------------------------------  
    t_e_READSTEPS::RS_GET_FILELENGTH:
          
      FileAccessStruct.dAsyncID := _FileSys.FileLength_A(Async   :=  1, 
                                                         handle  :=  FileAccessStruct.dFileHandle);
      
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      else
        ReadFSM := RS_WAIT_FOR_LEN;
      end_if;
    
    //-----------------------------------------------
    // Wait for the File Length Operation to complete.
    //-----------------------------------------------  
    t_e_READSTEPS::RS_WAIT_FOR_LEN:
          
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                             Erg :=  #FileAccessStruct.udFileLength$DINT);
      
      if dAsyncState = 0 then
        // The Async Operation has completed
        ReadFSM := RS_READ_FILE;
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      
      end_if;  
    
    //-----------------------------------------------
    // Request the File to be read.
    //----------------------------------------------- 
  	t_e_READSTEPS::RS_READ_FILE:
      
      if FileAccessStruct.udFileLength >= 2 then
        // the file size is larger than 0, malloc the memory to read into.
        FileAccessStruct.pFileBuffer$^VOID := sigclib_mallocV1( size :=  FileAccessStruct.udFileLength + 1, // (+ Null Termination)
                                                                id   :=  JSONREADER_MEMMARK);
        
        if FileAccessStruct.pFileBuffer = NIL then
          LastError := E_MemFull;
          ReadFSM := RS_CLOSE_FILE;
          FileAccessStruct.bErrorOccurred := TRUE; 
          return;
        end_if;
        
        // Passing here is the good case.
        
      else
      
        // Contents too small to be a JSON String
          LastError := E_FileContentsTooSmall;
          ReadFSM := RS_CLOSE_FILE;
          FileAccessStruct.bErrorOccurred := TRUE; 
          return;        
      
      end_if;

      FileAccessStruct.dAsyncID := _FileSys.FileRead_AV1(Async  := 1, 
                                                         handle := FileAccessStruct.dFileHandle, 
                                                         buffer := FileAccessStruct.pFileBuffer, 
                                                         length := FileAccessStruct.udFileLength);
 
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      else
        ReadFSM := RS_WAIT_FOR_READ;
      end_if;
      
    //-----------------------------------------------
    // Wait for the File Read to complete.
    //----------------------------------------------- 
    t_e_READSTEPS::RS_WAIT_FOR_READ:
    
    
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                             Erg :=  #FileAccessStruct.dBytesRead);
      
      if dAsyncState = 0 then      
        // The Async Operation has completed
        if FileAccessStruct.dBytesRead < 0 then
          FileAccessStruct.bErrorOccurred;
          LastError := E_FileReadError;
          LastErrorCode := FileAccessStruct.dBytesRead;
        else
          // Null-Terminate the string read from the file
          (FileAccessStruct.pFileBuffer$UDINT + FileAccessStruct.dBytesRead$UDINT)$^CHAR^ := 0x00;
        end_if;
        
        ReadFSM := RS_CLOSE_FILE;
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        ReadFSM := RS_CLOSE_FILE;
        FileAccessStruct.bErrorOccurred := TRUE;
      
      end_if;  
    
    //-----------------------------------------------
    // Request the File to be closed.
    //----------------------------------------------- 
    t_e_READSTEPS::RS_CLOSE_FILE:
    
      FileAccessStruct.dAsyncID := _FileSys.FileClose_A(Async   :=  1, 
                                                       handle  :=  FileAccessStruct.dFileHandle);
      
      if FileAccessStruct.dAsyncID < 0 then
        LastError := E_FileOperationRequestFailed;
        LastErrorCode := FileAccessStruct.dAsyncID;
        ReadFSM := RS_ERROR;
      else
        ReadFSM := RS_WAIT_FOR_CLOSE;
      end_if;    
    
    //-----------------------------------------------
    // Wait for the File Close to complete.
    //----------------------------------------------- 
    t_e_READSTEPS::RS_WAIT_FOR_CLOSE:
    
    
      dAsyncState := _FileSys.GetAsyncState( ID  :=  FileAccessStruct.dAsyncID$UDINT, 
                                            Erg :=  #dTemp);
      
      if dAsyncState = 0 then      
        // The Async Operation has completed, the return value does not matter
        if FileAccessStruct.bErrorOccurred then
          ReadFSM := RS_ERROR;
        else
          ReadFSM := RS_PARSE;        
        end_if;        
        
      elsif dAsyncState = RT_INVALID_ID then
        // The AsyncID was unknown
        LastError := E_AsyncIDUnknown;
        ReadFSM := RS_ERROR;
        
      elsif dAsyncState = RT_NOT_STARTED then
        // The Operation has not yet started
      
      elsif dAsyncState = RT_IN_PROGRESS then
        // The Operation is being executed
      
      elsif dAsyncState = RT_ERG_DELETED then
        // The Operation state is unknown
        LastError := E_AsyncResultLost;
        ReadFSM := RS_ERROR;
      
      else
        // The Operation state is unknown
        LastError := E_AsyncOperationResultUnknown;
        ReadFSM := RS_ERROR;
      
      end_if; 
    
    //-----------------------------------------------
    // Parse the JSON string
    //----------------------------------------------- 
  	t_e_READSTEPS::RS_PARSE:
      
      MainElement := _cJSON.ParseWithOpts(value                   :=  FileAccessStruct.pFileBuffer, 
                                          return_parse_end        :=  #LastErrorCode$pChar, 
                                          require_null_terminated :=  FALSE);
      
      if MainElement <> NIL then
        
        // The Operation completed successfully, the memory that we do not require anymore can be freed.
        ReadFSM := RS_COMPLETE;
        sigclib_freeV1(ptr := FileAccessStruct.pFileBuffer);
        FileAccessStruct.pFileBuffer := NIL;
        sigclib_freeV1(ptr := FileAccessStruct.pFileName);
        FileAccessStruct.pFileName := NIL;
        
      else
        
        // An Error Occured, we leave the memory intact for inspection, the mem can be cleared by a call to ResetError() or ReadFile()
        ReadFSM := RS_ERROR;
        LastError := E_JSONError;
      
      end_if;
    
    //-----------------------------------------------
    // Wait for reset / new operation.
    //----------------------------------------------- 
    t_e_READSTEPS::RS_ERROR,
    t_e_READSTEPS::RS_COMPLETE:   
      
      
  end_case;


END_FUNCTION


FUNCTION GLOBAL _JSONReader::ReadFile
	VAR_INPUT
		FileName 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udNameLen   : UDINT;
  END_VAR
  
  bOK := FALSE;
  
  // Test input
  if FileName = NIL then
    LastError := E_FileNameNotSet;
    return;
  end_if;
  
  if (ReadFSM >= RS_OPEN_FILE 
     & ReadFSM <= RS_PARSE) then
    LastError := E_ClassState;
    return;
  end_if;
  
  // This clears all reserved memory before the operation starts
  ResetMem();
  
  // Store the FileName
  udNameLen := SigCLib.StrLen(str := FileName);
  FileAccessStruct.pFileName$^VOID := sigclib_mallocV1( size := udNameLen + sizeof(CHAR), 
                                                        id   := JSONREADER_MEMMARK);
  
  if FileAccessStruct.pFileName <> NIL then
    SigCLib.StrNCpy(dst0  :=  FileAccessStruct.pFileName, 
                    src0  :=  FileName, 
                    count :=  udNameLen);   
    (FileAccessStruct.pFileName$UDINT + udNameLen)$^CHAR^ := 0x00;
  else    
    LastError := E_MemFull;      
  end_if;
  
  // The Read Operation can be started.
  ReadFSM := RS_OPEN_FILE;
  
  bOK := TRUE;

END_FUNCTION

FUNCTION GLOBAL _JSONReader::GetMainElement
	VAR_OUTPUT
		MainElement 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  MainElement := _JSONReader::MainElement;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL _JSONReader::LibraryVersion::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	LibraryVersion := _cJSON.LibraryVersion.Read();
	output := LibraryVersion;

END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetLastError
	VAR_INPUT
		pErrorCode 	: ^DINT;
	END_VAR
	VAR_OUTPUT
		LastError 	: _JSONReader::t_e_Errors;
	END_VAR
  
  if pErrorCode then
    pErrorCode^ := LastErrorCode;
  end_if;
  
  LastError := _JSONReader::LastError;
  
END_FUNCTION


FUNCTION _JSONReader::ResetMem
  
  if FileAccessStruct.pFileName <> NIL then
    sigclib_freeV1(ptr := FileAccessStruct.pFileName);
  end_if;
  
  if FileAccessStruct.pFileBuffer <> NIL then     
    sigclib_freeV1(ptr := FileAccessStruct.pFileBuffer);
  end_if;
  
  if MainElement <> NIL then
    _cJSON.Delete(item:=MainElement);
  end_if;
  
  FileAccessStruct.pFileName      := NIL;
  FileAccessStruct.pFileBuffer    := NIL;
  MainElement                     := NIL;
  FileAccessStruct.dAsyncID       := 0;
  FileAccessStruct.dFileHandle    := 0;
  FileAccessStruct.udFileLength   := 0;
  FileAccessStruct.dBytesRead     := 0;
  FileAccessStruct.bErrorOccurred := FALSE;
  
END_FUNCTION

// =============================================================================
// ============================== _cJSON Methods ===============================
// =============================================================================

FUNCTION GLOBAL _JSONReader::Version
	VAR_OUTPUT
		retString 	: ^CHAR;
	END_VAR
  
  retString := _cJSON.Version();
  
END_FUNCTION

FUNCTION GLOBAL _JSONReader::Parse
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  json := _cJSON.Parse(value := value);

END_FUNCTION

FUNCTION GLOBAL _JSONReader::ParseWithOpts
	VAR_INPUT
		value 	: ^CHAR;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: BOOL;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR

  json := _cJSON.ParseWithOpts(value                   :=  value, 
                               return_parse_end        :=  return_parse_end, 
                               require_null_terminated :=  require_null_terminated);

END_FUNCTION

FUNCTION GLOBAL _JSONReader::ParseWithLength
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR

  json := _cJSON.ParseWithLength(value         :=  value, 
                                 buffer_length :=  buffer_length);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::ParseWithLengthOpts
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: BOOL;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  json := _cJSON.ParseWithLengthOpts(value                   :=  value, 
                                    buffer_length           :=  buffer_length, 
                                    return_parse_end        :=  return_parse_end, 
                                    require_null_terminated :=  require_null_terminated);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::Print
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.Print(item := item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::PrintUnformatted
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.PrintUnformatted(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::PrintBuffered
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		prebuffer 	: INT;
		fmt 	: BOOL;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.PrintBuffered(item      :=  item, 
                                prebuffer :=  prebuffer, 
                                fmt       :=  fmt);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::PrintPreallocated
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		buffer 	: ^CHAR;
		length 	: INT;
		format 	: BOOL;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := _cJSON.PrintPreallocated(item    :=  item, 
                                    buffer  :=  buffer, 
                                    length  :=  length, 
                                    format  :=  format);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::Delete
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  _cJSON.Delete(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetArraySize
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		size 	: INT;
	END_VAR

  size := _cJSON.GetArraySize(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetArrayItem
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  entry := _cJSON.GetArrayItem(item  :=  item, 
                              index :=  index);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetObjectItem
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  entry := _cJSON.GetObjectItem( object  :=  object, 
                                string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetObjectItemCaseSensitive
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  entry := _cJSON.GetObjectItemCaseSensitive(object  :=  object, 
                                            string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::HasObjectItem
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		hasItem 	: BOOL;
	END_VAR
  
  hasItem := _cJSON.HasObjectItem( object  :=  object, 
                                  string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetErrorPtr
	VAR_OUTPUT
		errPtr 	: ^CHAR;
	END_VAR
  
  errPtr := _cJSON.GetErrorPtr();
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetStringValue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: ^CHAR;
	END_VAR
  
  value := _cJSON.GetStringValue(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::GetNumberValue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: LREAL;
	END_VAR
  
  value := _cJSON.GetNumberValue(item := item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsInvalid
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isInvalid 	: BOOL;
	END_VAR
  
  isInvalid := _cJSON.IsInvalid(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsFalse
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isFalse 	: BOOL;
	END_VAR
  
  isFalse := _cJSON.IsFalse(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsTrue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isTrue 	: BOOL;
	END_VAR
  
  isTrue := _cJSON.IsTrue(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsBool
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isBool 	: BOOL;
	END_VAR
  
  isBool := _cJSON.IsBool(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsNull
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNull 	: BOOL;
	END_VAR
  
  isNull := _cJSON.IsNull(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsNumber
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNumber 	: BOOL;
	END_VAR
 
  isNumber := _cJSON.IsNumber(item := item);  
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsString
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isString 	: BOOL;
	END_VAR
  
  isString := _cJSON.IsString(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsArray
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isArray 	: BOOL;
	END_VAR
  
  isArray := _cJSON.IsArray(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsObject
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isObject 	: BOOL;
	END_VAR
  
  isObject := _cJSON.IsObject(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::IsRaw
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isRaw 	: BOOL;
	END_VAR
  
  isRaw := _cJSON.IsRaw(item := item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateNull
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateNull();
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateTrue
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateTrue();

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateFalse
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateFalse();

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateBool
	VAR_INPUT
		value 	: BOOL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateBool(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateNumber
	VAR_INPUT
		value 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateNumber(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateString
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateString(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateRaw
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateRaw(value := value);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateArray
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateArray();

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateObject
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateObject();

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateStringReference
	VAR_INPUT
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateStringReference(string := string);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateObjectReference
	VAR_INPUT
		child 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateObjectReference(child := child);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateArrayReference
	VAR_INPUT
		child 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.CreateArrayReference(child := child);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateIntArray
	VAR_INPUT
		numbers 	: ^INT;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateIntArray( numbers := numbers, 
                                count   := count);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateFloatArray
	VAR_INPUT
		numbers 	: ^REAL;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateFloatArray( numbers :=  numbers, 
                                  count   :=  count);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateDoubleArray
	VAR_INPUT
		numbers 	: ^LREAL;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateDoubleArray(numbers :=  numbers, 
                                  count   :=  count);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::CreateStringArray
	VAR_INPUT
		strings 	: ^CHAR;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.CreateStringArray(strings :=  strings, 
                                  count   :=  count);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddItemToArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemToArray( arr   :=  arr, 
                                  item  :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddItemToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemToObject(object  :=  object,   
                                  string  :=  string, 
                                  item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddItemToObjectCS
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemToObjectCS(object  :=  object, 
                                    string  :=  string, 
                                    item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddItemReferenceToArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemReferenceToArray(arr   :=  arr, 
                                          item  :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddItemReferenceToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.AddItemReferenceToObject( object  :=  object, 
                                            string  :=  string, 
                                            item    :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::DetachItemViaPointer
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  retItem := _cJSON.DetachItemViaPointer(parent  :=  parent, 
                                        item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::DetachItemFromArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.DetachItemFromArray(arr   :=  arr, 
                                    index :=  index);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::DeleteItemFromArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
	END_VAR
  
  _cJSON.DeleteItemFromArray(arr   :=  arr, 
                            index :=  index);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::DetachItemFromObject
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  retItem := _cJSON.DetachItemFromObject(parent  :=  parent, 
                                        item    :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::DetachItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  retItem := _cJSON.DetachItemFromObjectCaseSensitive(parent  :=  parent, 
                                                     item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::DeleteItemFromObject
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
  
  _cJSON.DeleteItemFromObject(parent  :=  parent, 
                             item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::DeleteItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
  
  _cJSON.DeleteItemFromObjectCaseSensitive(parent  :=  parent, 
                                          item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::InsertItemInArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.InsertItemInArray(arr     :=  arr, 
                                    index   :=  index, 
                                    newItem :=  newItem);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::ReplaceItemViaPointer
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemViaPointer(parent  :=  parent, 
                                        item    :=  item, 
                                        newItem :=  newItem);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::ReplaceItemInArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: INT;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemInArray( arr     :=  arr, 
                                      index   :=  index, 
                                      newItem :=  newItem);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::ReplaceItemInObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemInObject(object  :=  object, 
                                      item    :=  item, 
                                      newItem :=  newItem);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::ReplaceItemInObjectCaseSensitive
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.ReplaceItemInObjectCaseSensitive( object  :=  object, 
                                                    item    :=  item, 
                                                    newItem :=  newItem);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::Duplicate
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		recurse 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
    
  retItem := _cJSON.Duplicate( item    :=  item, 
                              recurse :=  recurse);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::Compare
	VAR_INPUT
		compareA 	: ^_cJSON::t_s_cJSON;
		compareB 	: ^_cJSON::t_s_cJSON;
		case_sensitive 	: BOOL;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := _cJSON.Compare(compareA        :=  compareA, 
                          compareB        :=  compareB, 
                          case_sensitive  :=  case_sensitive);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::Minify
	VAR_INPUT
		json 	: ^CHAR;
	END_VAR
  
  _cJSON.Minify(json := json);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddNullToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddNullToObject(object  :=  object, 
                                name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddTrueToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddTrueToObject(object  :=  object, 
                                name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddFalseToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddFalseToObject( object  :=  object, 
                                  name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddBoolToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		boolean 	: BOOL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddBoolToObject(object  :=  object, 
                                name    :=  name, 
                                boolean :=  boolean);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddNumberToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR

  item := _cJSON.AddNumberToObject(object  :=  object, 
                                  name    :=  name, 
                                  number  :=  number);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddStringToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddStringToObject(object  :=  object, 
                                  name    :=  name, 
                                  string  :=  string);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddRawToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		raw 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddRawToObject( object  :=  object, 
                                name    :=  name, 
                                raw     :=  raw);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddObjectToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddObjectToObject(object  :=  object, 
                                  name    :=  name);
  
END_FUNCTION


FUNCTION GLOBAL _JSONReader::AddArrayToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
  
  item := _cJSON.AddArrayToObject( object  :=  object, 
                                  name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::SetNumber
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		retVal 	: LREAL;
	END_VAR
  
  retVal := _cJSON.SetNumber(object  :=  object, 
                             number  :=  number);

END_FUNCTION


FUNCTION GLOBAL _JSONReader::SetValuestring
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		valueString 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retVal 	: ^CHAR;
	END_VAR
  
  retVal := _cJSON.SetValuestring( object      :=  object, 
                                   valueString :=  valueString);

END_FUNCTION

FUNCTION GLOBAL _JSONReader::ClearMainElement

  if MainElement <> NIL then
    _cJSON.Delete(item := MainElement);
  end_if;
  
  MainElement := NIL;

END_FUNCTION
