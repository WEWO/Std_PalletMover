//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define MEMORYHEAP_CHEAP_HEAP_HDR_SIZE    (8*sizeof(UDINT)) //Size of the header for each Heap
#define MEMORYHEAP_MIN_SIZE               MEMORYHEAP_CHEAP_HEAP_HDR_SIZE
#define MEMORYHEAP_DEFAULT_SIZE           1mB
#define MEMORYHEAP_DEFAULT_MARK           0xC
#define MEMORYHEAP_MAX_MARK               0xF
#define MEMORYHEAP_DEFAULT_MAX            100
#define MEMORYHEAP_MIN_NUM                1
#define MEMORYHEAP_CHEAP_MALLOC_HDR_SIZE  4
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_MemoryBubbles"
	Revision           = "1.0"
	GUID               = "{C6926870-68E4-46EA-A976-ADFB495D0561}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(554,120)"
	Comment            = "This class implements a localized memory management from the SigCLib OSInterface.&#13;&#10;&#13;&#10;In an application that has a large allocation list, frequent calls to the Malloc(), ReAlloc() and Free() memory methods have a negative impact on the overall application performance (traversing the used- and free lists requires a long time due to the high number of entries.)&#13;&#10;&#13;&#10;The MemoryHeap class allows the user to localize the memory management for application parts, so that if the overall application has a lot of used- and free list entries, and the specific application part calls the memory management functions frequently, the performance of the specific application part will not be influenced negatively.">
	<Channels>
		<Server Name="ClassSvr" GUID="{160FD856-2F25-4D3C-99A0-C57EF76986FA}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Client Name="_StdLib" Required="false" Internal="false" Comment="Object Channel to the _StdLib OSInterface - No connection is required."/>
		<Client Name="AutoFree" Required="true" Internal="false" DefValue="1" Comment="On this client can be specified whether MemoryHeaps that are created during Runtime are automatically freed once the last malloc from the heap has been cleared.&#13;&#10;The initial heap always remains.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;AutoFree = 1 - Functionality Enabled.&#13;&#10;AutoFree &lt;&gt; 1 - Functionality Disabled."/>
		<Client Name="DefaultMark" Required="true" Internal="false" DefValue="MEMORYHEAP_DEFAULT_MARK" Comment="On this client the Mark used by the class for all internal memory allocations and calls to Malloc() (as opposed to MallocV1()) can be initialised. The value is read during the InitHeaps() call.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;0 &lt;= DefaultMark &lt;= 0xF"/>
		<Client Name="DefaultSize" Required="true" Internal="false" DefValue="MEMORYHEAP_DEFAULT_SIZE" Comment="On this client the default heap size can be specified, this size is used for:&#13;&#10;1. The size of the initial heap allocation - This occurs during the InitHeaps() call.&#13;&#10;2. Minimum size for all other heap allocations.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;MEMORYHEAP_MIN_SIZE (28) &lt;= DefaultSize"/>
		<Client Name="MaxBubbles" Required="true" Internal="false" DefValue="MEMORYHEAP_DEFAULT_MAX" Comment="On this client the maximum number of heaps that will be maintained can be specified. If the object runs out of Heaps, NIL will be returned from a Malloc() call that requires a new heap to be created.&#13;&#10;Note that during the InitHeaps() call a list of Allocations is created, this list is sized based on the number specified on this client, therefor, if the value is unnecessarily high, memory will be wasted and operations will be slower.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;1 &lt;= MaxHeaps"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Object Channel to the SigCLib OSInterface - No connection is required."/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.0" Date="2020-03-03" Author="VelGer" Company="Sigmatek" Description="1. Initial Creation."/>
	</RevDoku>
</Class>
*)
_MemoryBubbles : CLASS
	TYPE
#pragma pack(push, 1)
	  t_st_MemHeapEntry : STRUCT  //! <Type Comment="This structure describes a heap entry, an array of this structure is maintained behind the Config.pHeapEntries Pointer." Name="t_st_MemHeapEntry"/>
	    pHeap : ^void;  //! <Type Comment="Pointer to the heap that this HeapEntry describes, this pointer is maintained using the sigclib_heap_xxx() methods." Name="t_st_MemHeapEntry.pHeap"/>
	    udUsedItems : UDINT;  //! <Type Comment="Number of allocations in this heap." Name="t_st_MemHeapEntry.udUsedItems"/>
	    udSize : UDINT;  //! <Type Comment="Total number of bytes this Heap was initialized with." Name="t_st_MemHeapEntry.udSize"/>
	    udAvailable : UDINT;  //! <Type Comment="Number of bytes available in this heap." Name="t_st_MemHeapEntry.udAvailable"/>
	    pEnd : ^void;  //! <Type Comment="Pointer to the end of the heap, this pointer is used to help find the heap that an allocation belongs to." Name="t_st_MemHeapEntry.pEnd"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_st_HeapConfig : STRUCT  //! <Type Comment="Structure containing the configuration for the MemoryHeap Object.&#13;&#10;Used internally only." Name="t_st_HeapConfig"/>
	    udMaxHeaps : UDINT;  //! <Type Comment="Maximum number of Heaps that can be maintained by the class, this value is set during the InitHeap() call." Name="t_st_HeapConfig.udMaxHeaps"/>
	    udHeaps : UDINT;  //! <Type Comment="Number of active heaps in the HeapEntries Array" Name="t_st_HeapConfig.udHeaps"/>
	    udDefaultSize : UDINT;  //! <Type Comment="Default size of a newly allocated block, this value is read from the the DefaultSize client during the InitHeap() call." Name="t_st_HeapConfig.udDefaultSize"/>
	    udDefaultMark : UDINT;  //! <Type Comment="Default mark used for internal allocations as well as Malloc() allocations, this value is read from the the DefaultMark client during the InitHeap() call." Name="t_st_HeapConfig.udDefaultMark"/>
	    pHeapEntries : ^t_st_MemHeapEntry;  //! <Type Comment="Pointer to the memory that contains an array[0..Config.udMaxHeaps-1] of t_st_MemHeapEntry." Name="t_st_HeapConfig.pHeapEntries"/>
	    bAutoFree : BOOL;  //! <Type Comment="If this bit is set, all but on memory heaps are freed if they are empty.&#13;&#10;The bit is set during the InitHeaps() call." Name="t_st_HeapConfig.bAutoFree"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_UDINT;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
	_StdLib 	: CltChCmd__StdLib;
	MaxBubbles 	: CltCh_UDINT;
	DefaultSize 	: CltCh_UDINT;
	DefaultMark 	: CltCh_UDINT;
	AutoFree 	: CltCh_DINT;
  //Variables:
		Config 	: t_st_HeapConfig;
  //Functions:
				//! <Function Comment="Constructor for the class - not to be implemented directly by the user." Name="_MemoryBubbles"/>
	FUNCTION _MemoryBubbles
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
				//! <Function Comment="This function initializes the heap. (Read below)&#13;&#10;&#13;&#10;CAUTION:&#13;&#10;1. This function deletes all entries that may have been created before using the Malloc() and MallocV1() functions in this class -&gt; All pointers held by the user become invalid.&#13;&#10;2. This function is automatically executed from the constructor of the class and therefor does not have to be called by the user unless the heap must be reinitialized." Name="InitHeaps"/>
	FUNCTION GLOBAL InitHeaps
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="This parameter indicates whether the initialization has failed or succeeded.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;False - Initialization failed, this indicates that there was not enough heap memory available to: &#13;&#10;1. Allocate the Initial heap management list. (See client MaxHeaps).&#13;&#10;2. Create the initial Heap.&#13;&#10;&#13;&#10;True - The operation succeeded." Name="InitHeaps.bOK"/>
		END_VAR;
				//! <Function Comment="This function allows the user to allocate a section of memory inside one of the Heaps. As opposed to MallocV1(), this method has no mark parameter, the default mark (see client DefaultMark) is used for allocations made through this method.&#13;&#10;&#13;&#10;The Allocation works as follows:&#13;&#10;1. It is checked whether the allocated block of memory will fit inside one of the exisiting heaps reserved by the MemoryHeap class, if a viable position can be found, the class allocates the memory in this position and returns the pointer to the memory to the user.&#13;&#10;&#13;&#10;2. The MemoryHeap class attempts to create a new Heap to allow for the requested memory to the be allocated, if the operation succeeds, the requested memory is allocated inside the new heap and a pointer to the allocation is returned to the user. If the creation of the new Heap fails (MaxHeaps reached or not enough UserHeap available) the method returns NIL." Name="Malloc"/>
	FUNCTION GLOBAL Malloc
		VAR_INPUT
			size 	: UDINT;			//! <Variable Comment="Size of the memory to be allocated in bytes.&#13;&#10;&#13;&#10;Possible values:&#13;&#10;0 &lt; size &lt;= 268 435 424 &#13;&#10;&#13;&#10;(The limit for the allocation is dervied from: 256MB - (Size of the HeapHeader (28)) - (Size of the MemoryBlock Header (4))*(Number of allocations(1)))." Name="Malloc.size"/>
		END_VAR
		VAR_OUTPUT
			pUser 	: ^void;			//! <Variable Comment="User pointer to the allocated memory.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;pUser = NIL -&gt; The allocation failed, see the description of the method.&#13;&#10;pUser &lt;&gt; NIL -&gt; The allocation succeeded." Name="Malloc.pUser"/>
		END_VAR;
				//! <Function Comment="This function allows the user to allocate a section of memory inside one of the Heaps. As opposed to Malloc(), this method has a mark parameter, the specified mark value is used for allocations made through this method.&#13;&#10;&#13;&#10;The Allocation works as follows:&#13;&#10;1. It is checked whether the allocated block of memory will fit inside one of the exisiting heaps reserved by the MemoryHeap class, if a viable position can be found, the class allocates the memory in this position and returns the pointer to the memory to the user.&#13;&#10;&#13;&#10;2. The MemoryHeap class attempts to create a new Heap to allow for the requested memory to the be allocated, if the operation succeeds, the requested memory is allocated inside the new heap and a pointer to the allocation is returned to the user. If the creation of the new Heap fails (MaxHeaps reached or not enough UserHeap available) the method returns NIL." Name="MallocV1"/>
	FUNCTION GLOBAL MallocV1
		VAR_INPUT
			size0 	: UDINT;			//! <Variable Comment="Size of the memory to be allocated in bytes.&#13;&#10;&#13;&#10;Possible values:&#13;&#10;0 &lt; size &lt;= 268 435 424 &#13;&#10;&#13;&#10;(The limit for the allocation is dervied from: 256MB - (Size of the HeapHeader (28)) - (Size of the MemoryBlock Header (4))*(Number of allocations(1)))." Name="MallocV1.size0"/>
			mark0 	: USINT;			//! <Variable Comment="Mark to be used for the allocation. (Also see the client DefaultMark).&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;0 &lt;= mark0 &lt;= 0xF" Name="MallocV1.mark0"/>
		END_VAR
		VAR_OUTPUT
			pUser 	: ^void;			//! <Variable Comment="User pointer to the allocated memory.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;pUser = NIL -&gt; The allocation failed, see the description of the method.&#13;&#10;pUser &lt;&gt; NIL -&gt; The allocation succeeded." Name="MallocV1.pUser"/>
		END_VAR;
	
	FUNCTION GLOBAL ReAlloc
		VAR_INPUT
			mptr 	: ^void;
			newsize 	: UDINT;
		END_VAR
		VAR_OUTPUT
			pUser 	: ^void;
		END_VAR;
	
	FUNCTION GLOBAL ReAllocV1
		VAR_INPUT
			mptr0 	: ^void;
			newsize 	: UDINT;
			mark0 	: USINT;
		END_VAR
		VAR_OUTPUT
			pUser 	: ^void;
		END_VAR;
				//! <Function Comment="This function allows the user to free memory that has been previously allocated using the Malloc() or MallocV1() calls.&#13;&#10;If the AutoFree functionality is enabled (See client AutoFree) the heap containing the freed memory is cleared as soon as all allocations in the Heap are cleared." Name="Free"/>
	FUNCTION GLOBAL Free
		VAR_INPUT
			mptr 	: ^void;			//! <Variable Comment="Pointer to the previously allocated memory to be freed." Name="Free.mptr"/>
		END_VAR;
				//! <Function Comment="Internal Malloc Operation - not to be implemented directly by the user." Name="MallocIntern"/>
	FUNCTION MallocIntern
		VAR_INPUT
			size0 	: UDINT;
			mark0 	: DINT;
		END_VAR
		VAR_OUTPUT
			pUser 	: ^void;
		END_VAR;
				//! <Function Comment="This function searches for an existing allocation in the active Heaps.&#13;&#10;&#13;&#10;The input to the function is the pointer to the user allocation and the return of the function is the pointer to the HeapEntry that the Heap belongs to." Name="FindHeapEntry_ByPointer"/>
	FUNCTION FindHeapEntry_ByPointer
		VAR_INPUT
			pAllocation 	: ^void;			//! <Variable Comment="User pointer to search for in the maintained heaps.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;pHeapEntry &lt;&gt; NIL;" Name="FindHeapEntry_ByPointer.pAllocation"/>
		END_VAR
		VAR_OUTPUT
			pHeapEntry 	: ^t_st_MemHeapEntry;			//! <Variable Comment="Pointer to the HeapEntry that the heap containing the Allocation searched for belongs to.&#13;&#10;&#13;&#10;Possible Valus:&#13;&#10;pHeapEntry &lt;&gt; NIL - Pointer to the HeapEntry.&#13;&#10;pHeapEntry = NIL - HeapEntry not found." Name="FindHeapEntry_ByPointer.pHeapEntry"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _MemoryBubbles::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__MEMORYBUBBLES
1$UINT, 0$UINT, (SIZEOF(::_MemoryBubbles))$UINT, 
1$UINT, 6$UINT, 0$UINT, 
TO_UDINT(217061216), "_MemoryBubbles", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_MemoryBubbles.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
//Clients:
(::_MemoryBubbles.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::_MemoryBubbles._StdLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3689364044), "_StdLib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::_MemoryBubbles.MaxBubbles.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1576120944), "MaxBubbles", 
(::_MemoryBubbles.DefaultSize.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(433052757), "DefaultSize", 
(::_MemoryBubbles.DefaultMark.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2289764942), "DefaultMark", 
(::_MemoryBubbles.AutoFree.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3871059219), "AutoFree", 
END_FUNCTION


#define USER_CNT__MemoryBubbles 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__MemoryBubbles] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _MemoryBubbles::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__MemoryBubbles, pCmd := #vmt.CmdTable);
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= _MemoryBubbles();

END_FUNCTION

//{{LSL_IMPLEMENTATION

FUNCTION _MemoryBubbles::_MemoryBubbles
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR
  
  //Initialize the heap so that the Malloc method can be called immediately.
  InitHeaps();
    
	ret_code := C_OK;

END_FUNCTION

FUNCTION GLOBAL _MemoryBubbles::InitHeaps
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udCount : UDINT;
    pHeapEntry : ^t_st_MemHeapEntry;
  END_VAR

  //Assume Fail
  bOK := FALSE;
  
  //========================================================
  //Clear a previous session: If there are any heaps, free them
    
    if  Config.pHeapEntries &
        Config.udHeaps > 0  then
      
      pHeapEntry := Config.pHeapEntries;
      
      for udCount := 0 to Config.udMaxHeaps - 1 do
        
        if pHeapEntry^.pHeap then
        
          sigclib_heap_DTor(php0:=pHeapEntry^.pHeap);
          pHeapEntry^.pHeap       := NIL;
          pHeapEntry^.udUsedItems := 0;
          pHeapEntry^.udAvailable := 0;
          pHeapEntry^.pEnd        := NIL;
          
        end_if;
        
        pHeapEntry$UDINT += sizeof(t_st_MemHeapEntry);
        
      end_for;
      
      _StdLib.Free(mptr:=Config.pHeapEntries);
      Config.pHeapEntries := NIL;
      Config.udHeaps      := 0;
      
    end_if;
  
  //========================================================
  //Setup config values
    
    //Update the amount of maximum allowed heaps
    MaxBubbles := MaxBubbles.Read();
    
    if MaxBubbles < MEMORYHEAP_MIN_NUM then
      MaxBubbles := MEMORYHEAP_MIN_NUM;
      MaxBubbles.Write(input:=MaxBubbles);
    end_if;
    
    //Update the default size of the memory heaps
    DefaultSize := DefaultSize.Read();
    
    if DefaultSize < MEMORYHEAP_MIN_SIZE then
      DefaultSize := MEMORYHEAP_MIN_SIZE;
      DefaultSize.Write(input:=DefaultSize);
    end_if;
    
    //Update the default mark of the memory heaps
    DefaultMark := DefaultMark.Read();
    
    if DefaultMark > MEMORYHEAP_MAX_MARK then
      DefaultMark := MEMORYHEAP_MAX_MARK;
      DefaultMark.Write(input:=DefaultMark);
    end_if;
    
    //Update the AutoFree Configuration
    AutoFree := AutoFree.Read();
    Config.bAutoFree := (AutoFree = 1);
    
    Config.udMaxHeaps     := MaxBubbles;
    Config.udDefaultSize  := DefaultSize;
    Config.udDefaultMark  := DefaultMark;
  
  //========================================================
  //Allocate mem for the HeapEntry list
    
    Config.pHeapEntries$^void := _StdLib.MallocV1(  size0 :=  Config.udMaxHeaps * sizeof(t_st_MemHeapEntry), 
                                                    mark0 :=  to_usint(Config.udDefaultMark));
  
  //========================================================
  //Init the HeapEntry list and first heap
  
    if Config.pHeapEntries then
    
      _StdLib.MemSet( dest  :=  Config.pHeapEntries, 
                      value :=  0x00, 
                      size  :=  Config.udMaxHeaps * sizeof(t_st_MemHeapEntry));
      
      //Create the first heap entry
      pHeapEntry := FindHeapEntry_ByPointer(pAllocation:=NIL);
      
      if pHeapEntry then
        
        pHeapEntry^.pHeap := sigclib_heap_CTor(size:=Config.udDefaultSize + MEMORYHEAP_CHEAP_HEAP_HDR_SIZE);
        
        if pHeapEntry^.pHeap then
          
          Config.udHeaps += 1;
          
          pHeapEntry^.udSize      := Config.udDefaultSize;
          pHeapEntry^.udUsedItems := 0;
          pHeapEntry^.udAvailable := Config.udDefaultSize;
          pHeapEntry^.pEnd$UDINT  := pHeapEntry^.pHeap$UDINT + pHeapEntry^.udAvailable + MEMORYHEAP_CHEAP_HEAP_HDR_SIZE;
          
          sigclib_heap_used(php0:=pHeapEntry^.pHeap, pno:=#pHeapEntry^.udUsedItems, psize:=#udCount);
          
          bOK := TRUE;
                 
        end_if;
        
      end_if;

    end_if;

END_FUNCTION


FUNCTION GLOBAL _MemoryBubbles::Malloc
	VAR_INPUT
		size 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^void;
	END_VAR
  
  pUser := MallocIntern(size0 :=  size, 
                        mark0 :=  -1);

END_FUNCTION


FUNCTION GLOBAL _MemoryBubbles::MallocV1
	VAR_INPUT
		size0 	: UDINT;
		mark0 	: USINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^void;
	END_VAR
  
  pUser := MallocIntern(size0 :=  size0, 
                        mark0 :=  to_dint(mark0));
  
END_FUNCTION


FUNCTION _MemoryBubbles::MallocIntern
	VAR_INPUT
		size0 	: UDINT;
		mark0 	: DINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^void;
	END_VAR
  VAR
    pHeapEntry : ^t_st_MemHeapEntry;
    udCount : UDINT;
  END_VAR
  
  //Assume Fail
  pUser := NIL;
  
  if Config.pHeapEntries then
    
    //Adjust Size to be 4Byte Aligned (Allows use to calcuate the available memory without a sigclib_heap_used() call)
    while size0 AND 3 do
      size0 += 1;
    end_while;

    //Handle Mark
    if mark0 = -1 then
      mark0 := to_dint(Config.udDefaultMark);
    end_if;
    
    pHeapEntry := Config.pHeapEntries;
    
    //Find the first entry that has enough free size, attempt to malloc in it
    for udCount := 0 to Config.udMaxHeaps - 1 do
      
      if pHeapEntry^.pHeap                    &
         pHeapEntry^.udAvailable >= size0 + MEMORYHEAP_CHEAP_MALLOC_HDR_SIZE then
                
        pUser := sigclib_heap_malloc( php0  :=  pHeapEntry^.pHeap, 
                                      size  :=  size0, 
                                      id    :=  to_udint(mark0));
                
        if pUser <> NIL then
          exit;
        end_if;
        
      end_if;
      
      pHeapEntry$UDINT += sizeof(t_st_MemHeapEntry);
      
    end_for;
    
    //We found an entry with enough space to allocate within
    if pUser then
            
      pHeapEntry^.udAvailable -= (size0 + MEMORYHEAP_CHEAP_MALLOC_HDR_SIZE);
      pHeapEntry^.udUsedItems += 1;
    
    //There was no entry with enough space to allocate the user request, attempt to create a new one (//else there are already a maximum of Heaps assigned - Return nil)
    elsif Config.udHeaps < Config.udMaxHeaps then
    
      pHeapEntry := FindHeapEntry_ByPointer(pAllocation:=NIL);
      
      if pHeapEntry then
        
        //Limit the minimum entrysize to Default Heap Size
        pHeapEntry^.udSize := size0 + MEMORYHEAP_CHEAP_HEAP_HDR_SIZE;
        if pHeapEntry^.udSize < Config.udDefaultSize then
          pHeapEntry^.udSize := Config.udDefaultSize;
        end_if;

        pHeapEntry^.pHeap := sigclib_heap_CTor(size:=pHeapEntry^.udSize);
        
        if pHeapEntry^.pHeap then
          
          Config.udHeaps += 1;
          
          pHeapEntry^.udSize      -= MEMORYHEAP_CHEAP_HEAP_HDR_SIZE;
          pHeapEntry^.udUsedItems := 0;
          pHeapEntry^.udAvailable := pHeapEntry^.udSize;
          pHeapEntry^.pEnd$UDINT  := pHeapEntry^.pHeap$UDINT + pHeapEntry^.udAvailable + MEMORYHEAP_CHEAP_HEAP_HDR_SIZE;
          
          pUser := sigclib_heap_malloc( php0  :=  pHeapEntry^.pHeap, 
                                        size  :=  size0, 
                                        id    :=  to_udint(mark0));
          
          if pUser then
            
            pHeapEntry^.udAvailable -= size0;
            pHeapEntry^.udUsedItems += 1;
            
          end_if;
          
        end_if;
        
      end_if;
      
    end_if;

    
  end_if;

  
END_FUNCTION


FUNCTION GLOBAL _MemoryBubbles::ReAlloc
	VAR_INPUT
		mptr 	: ^void;
		newsize 	: UDINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^void;
	END_VAR
  VAR
  	pHeapEntry : ^t_st_MemHeapEntry;
    udUsed : UDINT;
  END_VAR
  
  //If the HeapList is initialized, find the heap to ReAllocate In
  if Config.pHeapEntries  &
     mptr                 then
    
    pHeapEntry := FindHeapEntry_ByPointer(pAllocation:=mptr);
    
    if pHeapEntry then
      
      pUser := sigclib_heap_realloc(php0  :=  pHeapEntry^.pHeap, 
                                    pt    :=  mptr, 
                                    size  :=  newsize);
      
      sigclib_heap_used(php0  :=  pHeapEntry^.pHeap, 
                        pno   :=  #pHeapEntry^.udUsedItems, 
                        psize :=  #udUsed);
      
      pHeapEntry^.udAvailable := pHeapEntry^.udSize - udUsed;
      
      //Automatically free the unused memoryheaps
      if Config.bAutoFree                   &
         pHeapEntry <> Config.pHeapEntries  &
         pHeapEntry^.udUsedItems = 0        then
        
        sigclib_heap_DTor(php0:=pHeapEntry^.pHeap);
        pHeapEntry^.pHeap       := NIL;
        pHeapEntry^.udSize      := 0;
        pHeapEntry^.udAvailable := 0;
        pHeapEntry^.pEnd        := NIL;
        Config.udHeaps          -= 1;
        
      end_if;
      
    end_if;
    
  end_if;

  
END_FUNCTION

#pragma warning(disable:73);
FUNCTION GLOBAL _MemoryBubbles::ReAllocV1
	VAR_INPUT
		mptr0 	: ^void;
		newsize 	: UDINT;
		mark0 	: USINT;
	END_VAR
	VAR_OUTPUT
		pUser 	: ^void;
	END_VAR
  
  pUser := ReAlloc( mptr    :=  mptr0, 
                    newsize :=  newsize);
  
END_FUNCTION
#pragma warning(default:73);

FUNCTION GLOBAL _MemoryBubbles::Free
	VAR_INPUT
		mptr 	: ^void;
	END_VAR
  VAR
  	pHeapEntry : ^t_st_MemHeapEntry;
    udUsed : UDINT;
  END_VAR
  
  //If the HeapList is initialized, find the heap to free from
  if Config.pHeapEntries  &
     mptr                 then
    
    pHeapEntry := FindHeapEntry_ByPointer(pAllocation:=mptr);
    
    if pHeapEntry then
      
      sigclib_heap_free(php0  :=  pHeapEntry^.pHeap, 
                        pt    :=  mptr);
      
      sigclib_heap_used(php0  :=  pHeapEntry^.pHeap, 
                        pno   :=  #pHeapEntry^.udUsedItems, 
                        psize :=  #udUsed);
      
      pHeapEntry^.udAvailable := pHeapEntry^.udSize - udUsed;
      
      //Automatically free the unused memoryheaps
      if Config.bAutoFree                   &
         pHeapEntry <> Config.pHeapEntries  &
         pHeapEntry^.udUsedItems = 0        then
        
        sigclib_heap_DTor(php0:=pHeapEntry^.pHeap);
        pHeapEntry^.pHeap       := NIL;
        pHeapEntry^.udSize      := 0;
        pHeapEntry^.udAvailable := 0;
        pHeapEntry^.pEnd        := NIL;
        Config.udHeaps          -= 1;
        
      end_if;
      
    end_if;
    
  end_if;
  
END_FUNCTION


FUNCTION _MemoryBubbles::FindHeapEntry_ByPointer
	VAR_INPUT
		pAllocation 	: ^void;
	END_VAR
	VAR_OUTPUT
		pHeapEntry 	: ^t_st_MemHeapEntry;
	END_VAR
  VAR
  	udCount : UDINT;
  END_VAR
    
  //Assume not found
  pHeapEntry := NIL;
  
  //Find the first available Heap
  if pAllocation = NIL then
    
    pHeapEntry := Config.pHeapEntries;
    
    for udCount := 0 to Config.udMaxHeaps - 1 do
      
      if  pHeapEntry^.pHeap = NIL then
        
        return;
        
      end_if;
      
      pHeapEntry$UDINT += sizeof(t_st_MemHeapEntry);
      
    end_for;
    
    //If this point is reached, the list must be full.
    pHeapEntry := NIL;
  
  //If there are any heaps, step through them to find the one that the allocation belongs to
  elsif Config.udHeaps > 0 then
    
    pHeapEntry := Config.pHeapEntries;
    
    for udCount := 0 to Config.udMaxHeaps - 1 do
      
      if  pHeapEntry^.pHeap                             & 
          pHeapEntry^.pHeap$UDINT <= pAllocation$UDINT  & 
          pHeapEntry^.pEnd$UDINT  >= pAllocation$UDINT  then
        
        return;
        
      end_if;
      
      pHeapEntry$UDINT += sizeof(t_st_MemHeapEntry);
      
    end_for;
    
    //If this point is reached, the allocation was not in the list
    pHeapEntry := NIL;
  
  //The user wanted to find a heap that does not exist
  else
    
    pHeapEntry := NIL;
  
  end_if;

  
END_FUNCTION
