//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES

#define MQTTTOPIC_SUBACK_ERRORCODE            16#80

#define MQTTTOPIC_PUBLISHDATA_CRCCALC_INITVAL 0

#define MQTTTOPIC_DEFAULT_SUBSCRIBE_TIMEOUT   15secs
#define MQTTTOPIC_DEFAULT_UNSUBSCRIBE_TIMEOUT 15secs
#define MQTTTOPIC_DEFAULT_PUBLISH_TIMEOUT     15secs

#define MQTTTOPIC_LOG_MSG_GROUP               0
#define MQTTTOPIC_LOG_MSG_NBR                 1

// -----------------------------------------------------------------Logging
#define MQTTTOPIC_LOGGING_LEVEL_INFO          2#00001
#define MQTTTOPIC_LOGGING_LEVEL_WARNING       2#00100
#define MQTTTOPIC_LOGGING_LEVEL_ERR           2#01000
#define MQTTTOPIC_LOGGING_LEVEL_DEBUG         2#10000
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\MQTTTopic\MQTTTopic_LogTexts.h"

(*!
<Class
	Name               = "MQTTTopic"
	Revision           = "1.14"
	GUID               = "{04E7B0A7-EAD9-4281-A165-FECA7026E8D4}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\MQTTTopic\mqtttopic.ico"
	SharedCommandTable = "true"
	Objectsize         = "(730,120)"
	Comment            = "This class serves as base class for subscribing to MQTT topics, or to publish data to a certain topic.&#13;&#10;&#13;&#10;Must be derived from the user.">
	<Channels>
		<Server Name="GrantedQoS" GUID="{E231FAED-743F-4C50-A376-B46EF8958B7C}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Only used in the topic type MT_Subscribe.&#13;&#10;Shows the granted &quot;Quality of Service&quot; from the Server."/>
		<Server Name="PublishInterval" GUID="{1B5E490C-509E-427E-8197-742FB369AC0E}" Visualized="true" Initialize="true" DefValue="10 sec" WriteProtected="false" Retentive="File" Comment="Define the publish interval for the Topic Type MT_Publish_Poll or MT_Publish_OnChange.&#13;&#10;&#13;&#10;[ms]"/>
		<Server Name="QoS" GUID="{85D58FB2-5D6E-4E87-9D88-321801651B1B}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File" Comment="Define the desired &quot;Quality of Service&quot; between the communication of client and server for this topic. &#13;&#10;&#13;&#10;0...at most once. Sending of data will be done only once. There is no guarantee of delivery. The recipient does not send an acknowledge.&#13;&#10;&#13;&#10;1...at least once.  This level guarantees that the message is delivered at least once. The sender waits for an acknowledge of the recipient and if this takes too long, the sender sends the same message again.&#13;&#10;It can happen that the same message gets send and delivered multiple times.&#13;&#10;&#13;&#10;2...exactly once. This level guarantees the delivery of the message to the recipient exactly once. This level is the safest and slowest quality of service. &#13;&#10;&#13;&#10;Note: A higher level, also results in a longer execution of the send and receive routine. "/>
		<Server Name="RetainData" GUID="{15E4D1CC-4B14-40DA-B815-B4DE893D5E39}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File" Comment="Defines if the published data will be stored in the server.&#13;&#10;&#13;&#10;0...data won&apos;t be stored in the server&#13;&#10;1...data will be stored in the server."/>
		<Server Name="TopicName" GUID="{1878CE84-190E-456E-B9BD-95B8BEB348A3}" Class="StringRAM" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="Define the topic name"/>
		<Server Name="TopicState" GUID="{E4DFBAA7-2EA6-4828-905A-F923D7F61495}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Interface for the object to call the global methods.&#13;&#10;Shows the current state of the internal routine."/>
		<Server Name="TopicType" GUID="{31F32996-94C2-4EE6-BF65-F07730F9B3D1}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="File" Comment="Set the topic type.&#13;&#10;&#13;&#10;MT_Deactivated...Class is deactivated. We are not subscribed nor are we publishing data.&#13;&#10;MT_Subscribe...subscribe to the defined topic&#13;&#10;MT_Publish_Poll...publish data in a set time interval&#13;&#10;MT_Publish_OnChange...Check data in the set time interval. If data has changed, publish it&#13;&#10;MT_Publish_Manual...publish data by user trigger"/>
		<Client Name="cAutoResetTime" Required="true" Internal="false" DefValue="MQTTTOPIC_DEFAULT_AUTORESET_TIME" Comment="If set, the class will automatically reset from the error state after this time delay."/>
		<Client Name="cPublishTimeout" Required="true" Internal="false" DefValue="MQTTTOPIC_DEFAULT_PUBLISH_TIMEOUT" Comment="Time to wait for the Publish to complete when sending a message before assuming that an error has occured, this value must be increased if larger packets are sent."/>
		<Client Name="cSubscribeTimeout" Required="true" Internal="false" DefValue="MQTTTOPIC_DEFAULT_SUBSCRIBE_TIMEOUT" Comment="Time to wait for the Subscribe Complete / Failed feedback from the MQTTClient before assuming an error has occurred."/>
		<Client Name="cUnsubscribeTimeout" Required="true" Internal="false" DefValue="MQTTTOPIC_DEFAULT_UNSUBSCRIBE_TIMEOUT" Comment="Time to wait for the Unsubscribe response from the MQTTClient before assuming an error."/>
		<Client Name="objTopicName" Required="true" Internal="true"/>
		<Client Name="ocMQTTClient_Interface" Required="true" Internal="false" Comment="Object channel to the class MQTTClient_Interface"/>
		<Client Name="ocSigCLib" Required="false" Internal="false" Comment="object channel to the class SigCLib. Must not be connected."/>
		<Client Name="RetVals" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\MQTTTopic\MQTTTopic_LogTexts.h" Include="true"/>
			<File Path=".\Class\MQTTTopic\MQTTTopic_de.pdf"/>
			<File Path=".\Class\MQTTTopic\MQTTTopic_en.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek"/>
		<Dokumentation Revision="1.14" Date="2021-06-01" Author="MehMar&#13;&#10;VelGer" Company="Sigmatek" Description="BugFix: The SessionPresent Information was not processed correctly, this has been corrected."/>
		<Dokumentation Revision="1.13" Date="2021-03-21" Author="VelGer" Company="Sigmatek" Description="1. BugFix: Payloads with a length of zero could not be published even though the MQTTClient and the MQTT Protocol allow for this, the limitaiton has been corrected.&#13;&#10;2. BugFix: In the case where the class is used to publish (TopicType = MT_Publish_XXX) The User_ClientDisconnected() call was only triggered if the client lost its connection whilst a publish message was inflight. This has been corrected."/>
		<Dokumentation Revision="1.12" Date="2020-08-12" Author="MehMar" Company="Sigmatek" Description="1. Bugfix: Some timeouts, which were not overtaken, are used now."/>
		<Dokumentation Revision="1.11" Date="2020-04-21" Author="VelGer" Company="Sigmatek" Description="1. BugFix: The Logging Texts were reworked to be uniform across the MQTTPackage.&#13;&#10;2. Special: The Comments and indentations were generally improved."/>
		<Dokumentation Revision="1.1" Date="2020-03-05" Author="VelGer" Company="Sigmatek" Description="1. BugFix: Timeout Handling Reworked.&#13;&#10;2. Improvement: CRC is now stored retentively.&#13;&#10;3. Improvement: Servers are now file retentive to save SRAM."/>
		<Dokumentation Revision="1.0" Date="2019-02-27" Author="SchMax" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
	<Network Name="MQTTTopic">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "objTopicName"
				GUID       = "{4CE40825-0DCC-4F9D-840F-A9AAD039F84D}"
				Class      = "StringRAM"
				Position   = "(210,240)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
					<Client Name="UseFile"/>
				</Channels>
			</Object>
			<Object
				Name       = "RetVals"
				GUID       = "{CC8F1DB1-F6DF-45F6-AF3A-B616602ECA7D}"
				Class      = "MQTTTopic_RetVals"
				Position   = "(210,510)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="udCRC" Value="-1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.objTopicName" Destination="objTopicName.Data"/>
			<Connection Source="this.TopicName" Destination="objTopicName.Data" Vertices="(968,330),(796,330),"/>
			<Connection Source="this.RetVals" Destination="RetVals.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
MQTTTopic : CLASS
	TYPE
	  t_e_ConfigParameters :  //! <Type Public="true" Name="t_e_ConfigParameters"/>
	  (
	    CP_SendAtStart  //! <Type Comment="When TopicType = MT_Publish_OnChange:&#13;&#10;This value indicates whether the Topic is sent at start regradless whether the value has changed between the time of the last transmission and start.&#13;&#10;This means, when active the data will always be sent when the topic reinitializes (also at Application restart), if not active the class waits for the first change before sending the data.&#13;&#10;&#13;&#10;0 = Inactive (Default)&#13;&#10;1 = Active" Name="t_e_ConfigParameters.CP_SendAtStart"/>
	  )$UDINT;
	  t_e_MQTT_TopicState :  //! <Type Public="true" Name="t_e_MQTT_TopicState"/>
	  (
	    MTS_Init,  //! <Type Comment="Initialisation of the topic." Name="t_e_MQTT_TopicState.MTS_Init"/>
	    MTS_WaitForConnection,  //! <Type Comment="Wait till the MQTT Client has established a connection to the server." Name="t_e_MQTT_TopicState.MTS_WaitForConnection"/>
	    MTS_Ready,  //! <Type Comment="Class is ready for the procedure defined in the Topic type." Name="t_e_MQTT_TopicState.MTS_Ready"/>
	    MTS_Subscribe,  //! <Type Comment="Subscription to the topic is executed." Name="t_e_MQTT_TopicState.MTS_Subscribe"/>
	    MTS_WaitForSubscribe,  //! <Type Comment="Waiting for the feedback of the subscribe procedure." Name="t_e_MQTT_TopicState.MTS_WaitForSubscribe"/>
	    MTS_Subscribed,  //! <Type Comment="Subscribed successfully" Name="t_e_MQTT_TopicState.MTS_Subscribed"/>
	    MTS_Unsubscribe,  //! <Type Comment="Unsubscribe procedure is executed." Name="t_e_MQTT_TopicState.MTS_Unsubscribe"/>
	    MTS_WaitForUnsubscribe,  //! <Type Comment="Wait for the feedback of the unsubscribe procedure." Name="t_e_MQTT_TopicState.MTS_WaitForUnsubscribe"/>
	    MTS_Unsubscribed,  //! <Type Comment="Successfully unsubscribed." Name="t_e_MQTT_TopicState.MTS_Unsubscribed"/>
	    MTS_WaitForPublishInterval,  //! <Type Comment="Wait for the time delay defined in the server PublishInterval, before publishing the data." Name="t_e_MQTT_TopicState.MTS_WaitForPublishInterval"/>
	    MTS_WaitForPublishDataChange,  //! <Type Comment="Wait for a change in the user specified data, before publishing it." Name="t_e_MQTT_TopicState.MTS_WaitForPublishDataChange"/>
	    MTS_WaitForPublishCommand,  //! <Type Comment="Wait for the manual trigger, before publishing the data." Name="t_e_MQTT_TopicState.MTS_WaitForPublishCommand"/>
	    MTS_Publish,  //! <Type Comment="Publish procedure is executed." Name="t_e_MQTT_TopicState.MTS_Publish"/>
	    MTS_WaitForPublishDone,  //! <Type Comment="Wait for a feedback of the publish procedure." Name="t_e_MQTT_TopicState.MTS_WaitForPublishDone"/>
	    MTS_Error,  //! <Type Comment="An error occured while executing the routine." Name="t_e_MQTT_TopicState.MTS_Error"/>
	    MTS_Error_WaitForReset  //! <Type Comment="Wait for the error reset from the user. " Name="t_e_MQTT_TopicState.MTS_Error_WaitForReset"/>
	  )$UDINT;
	  t_e_MQTT_TopicType :  //! <Type Public="true" Name="t_e_MQTT_TopicType"/>
	  (
	    MT_Deactivated,  //! <Type Comment="Class is deactivated. We are not subscribed nor are we publishing data to a topic." Name="t_e_MQTT_TopicType.MT_Deactivated"/>
	    MT_Subscribe,  //! <Type Comment="Subscribe to the defined topic" Name="t_e_MQTT_TopicType.MT_Subscribe"/>
	    MT_Publish_Poll,  //! <Type Comment="Publish data in a defined time interval" Name="t_e_MQTT_TopicType.MT_Publish_Poll"/>
	    MT_Publish_OnChange,  //! <Type Comment="Check the Data in the defined time interval for changes. If data have changed, publish it." Name="t_e_MQTT_TopicType.MT_Publish_OnChange"/>
	    MT_Publish_Manual  //! <Type Comment="Publish data on manual trigger." Name="t_e_MQTT_TopicType.MT_Publish_Manual"/>
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_MQTT_TopicConfig : STRUCT
	    TopicType : t_e_MQTT_TopicType;
	    TopicName : ARRAY [0..MQTTCLIENT_TOPIC_MAX_LEN] OF UINT;
	    TopicNameCRC : UDINT;
	    QoS : INT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_MQTT_TopicPublishData : STRUCT
	    pData : ^void;  //! <Type Comment="Pointer to the data which should be published." Name="t_s_MQTT_TopicPublishData.pData"/>
	    udLen : UDINT;  //! <Type Comment="Size of the data in byte, which should be published." Name="t_s_MQTT_TopicPublishData.udLen"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_MQTT_TopicTimeouts : STRUCT  //! <Type Public="true" Name="t_s_MQTT_TopicTimeouts"/>
	    udSubscribeTimeout : UDINT;  //! <Type Comment="Timeout for the subscribe procedure." Name="t_s_MQTT_TopicTimeouts.udSubscribeTimeout"/>
	    udUnsubscribeTimeout : UDINT;  //! <Type Comment="Timeout for the unsubscribe procedure." Name="t_s_MQTT_TopicTimeouts.udUnsubscribeTimeout"/>
	    udPublishTimeout : UDINT;  //! <Type Comment="Timeout for the publish procedure." Name="t_s_MQTT_TopicTimeouts.udPublishTimeout"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	TopicState 	: SvrChCmd_t_e_MQTT_TopicState_PTofCls_MQTTTopic;
	TopicType 	: SvrCh_t_e_MQTT_TopicType_PTofCls_MQTTTopic;
	TopicName 	: SvrChCmd_UDINT;
	PublishInterval 	: SvrCh_UDINT;
	RetainData 	: SvrCh_UDINT;
	QoS 	: SvrCh_DINT;
	GrantedQoS 	: SvrCh_DINT;
  //Clients:
	objTopicName 	: CltChCmd_StringRAM;
	ocMQTTClient_Interface 	: CltChCmd_MQTTClient_Interface;
	ocSigCLib 	: CltChCmd_SigCLib;
	cAutoResetTime 	: CltCh_UDINT;
	cSubscribeTimeout 	: CltCh_UDINT;
	cPublishTimeout 	: CltCh_UDINT;
	cUnsubscribeTimeout 	: CltCh_UDINT;
	RetVals 	: CltChCmd_MQTTTopic_RetVals;
  //Variables:
		MQTTTopicConfig 	: t_s_MQTT_TopicConfig;
		FlagList : BDINT
		[
		  1 Subscribed,
		  3 SubscribedFailed,
		  4 PublishDone,
		  5 ManualPublish,
		  6 ConfigChanged,
		  7 bSendAtStart,  //! <Variable Comment="If set and the MQTTTopic is configured to publish on change, the data is published once after restarting." Name="FlagList.bSendAtStart"/>
		  8 bInitialPublishCompleted,  //! <Variable Comment="When false and the MQTTTopic is set to publish on change the class will publish, this is used to realize the SendAtStart functionality." Name="FlagList.bInitialPublishCompleted"/>
		];

		TimeoutInfo 	: t_s_MQTT_TopicTimeouts;
		PublishData 	: t_s_MQTT_TopicPublishData;
		InitCounter 	: UDINT;
		ErrorOccuredState 	: t_e_MQTT_TopicState;
		Mid 	: DINT;
		ApplMsgId 	: UDINT;
		udTimestamp 	: UDINT;
		udPubTimestamp 	: UDINT;			//! <Variable Comment="This Timestamp is used to maintain the Publishing interval, the interval is managed decoupled from the actual publish procedure, this means the if the data should be published every 10 secs, and it takes 1 secs to publish, the actual interval will be 10 secs and not 11secs (as would be the simpler case)" Name="udPubTimestamp"/>
		BeforeDisconnectState 	: t_e_MQTT_TopicState;
  //Functions:
				//! <Function Comment="Initialisation of class. In the first init run, the timeouts for subscribe, unsubscribe and publish will be set." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Calls the internal routine." Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Will be called if the MQTT client establishes the connection to the MQTT server" Name="User_ClientConnected"/>
	FUNCTION VIRTUAL User_ClientConnected;
				//! <Function Comment="Will be called if the connection between MQTT Client and Server is closed. " Name="User_ClientDisconnected"/>
	FUNCTION VIRTUAL User_ClientDisconnected;
				//! <Function Comment="Will be called if an error occures during the internal routine" Name="User_ErrorOccured"/>
	FUNCTION VIRTUAL User_ErrorOccured;
				//! <Function Comment="Will be called if the Subscribtion procedure is finished." Name="User_SubscribedOK"/>
	FUNCTION VIRTUAL User_SubscribedOK;
				//! <Function Comment="Will be called if the unsubscribtion procedure is finished." Name="User_UnsubscribedOK"/>
	FUNCTION VIRTUAL User_UnsubscribedOK;
				//! <Function Comment="Must be overwritten by the user.&#13;&#10;&#13;&#10;Will be called to the get the data for publishing it to the defined topic." Name="User_GetPublishData"/>
	FUNCTION VIRTUAL User_GetPublishData
		VAR_OUTPUT
			PublishData 	: t_s_MQTT_TopicPublishData;			//! <Variable Comment="Return struct, which must be filled with the data that should be published." Name="User_GetPublishData.PublishData"/>
		END_VAR;
				//! <Function Comment="Will be called if the Publishing procedure is finished." Name="User_PublishDone"/>
	FUNCTION VIRTUAL User_PublishDone;
				//! <Function Comment="Must be overwritten by the user.&#13;&#10;&#13;&#10;Will be called if data from the subscribed topic was received.&#13;&#10;&#13;&#10;Note: the pointer to the data is only valid in the actual call of this method." Name="User_SubscribeData"/>
	FUNCTION VIRTUAL User_SubscribeData
		VAR_INPUT
			pData 	: ^void;			//! <Variable Comment="Pointer to the payload of the MQTT message, if data is available. Otherwise the pointer is NIL." Name="User_SubscribeData.pData"/>
			udLen 	: UDINT;			//! <Variable Comment="Size of the data in byte." Name="User_SubscribeData.udLen"/>
		END_VAR;
				//! <Function Comment="Internal routine." Name="DoRoutine"/>
	FUNCTION DoRoutine;
				//! <Function Comment="Will be called from the method PubSubData_Callback." Name="PubSubData"/>
	FUNCTION GLOBAL PubSubData
		VAR_INPUT
			MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes;			//! <Variable Comment="Type of message:&#13;&#10;&#13;&#10;PSRC_Subscribed...Feedback for subscribe&#13;&#10;PSRC_Unsubscribed...Feedback for unsubscribe&#13;&#10;PSRC_PublishReceived...Data from the subscribed topic are received&#13;&#10;PSRC_Published...Feedback for publish" Name="PubSubData.MsgType"/>
			iMid 	: INT;			//! <Variable Comment="Package ID" Name="PubSubData.iMid"/>
			iGrantedQoS 	: INT;			//! <Variable Comment="Granted QoS from the Server" Name="PubSubData.iGrantedQoS"/>
			pMessage 	: ^MQTTClient::t_s_MQTTMessage;			//! <Variable Comment="Pointer to the Message" Name="PubSubData.pMessage"/>
		END_VAR;
				//! <Function Comment="Get the actual configuration for the topic." Name="GetTopicConfig"/>
	FUNCTION GetTopicConfig
		VAR_OUTPUT
			outTopicConfig 	: t_s_MQTT_TopicConfig;
		END_VAR;
				//! <Function Comment="Check if the data, which should be published, have changed." Name="Publish_DataChanged"/>
	FUNCTION Publish_DataChanged
		VAR_INPUT
			Data 	: t_s_MQTT_TopicPublishData;
		END_VAR
		VAR_OUTPUT
			bChanged 	: BOOL;
		END_VAR;
				//! <Function Comment="Returns the new state, depending on the actual configuration and the actual state." Name="GetStateByActTopicConfig"/>
	FUNCTION GetStateByActTopicConfig
		VAR_INPUT
			inActState 	: t_e_MQTT_TopicState;
			inActTopicConfig 	: t_s_MQTT_TopicConfig;
		END_VAR
		VAR_OUTPUT
			outNewState 	: t_e_MQTT_TopicState;
		END_VAR;
				//! <Function Comment="By calling this function the publishing of the user specified data can be triggered.&#13;&#10;The topic type has to be MT_Publish_Manual." Name="DoManualPublish"/>
	FUNCTION GLOBAL DoManualPublish
		VAR_OUTPUT
			outSuccess 	: BOOL;			//! <Variable Comment="True...manual publish was triggered successfully&#13;&#10;False...manual publish coulnd&apos;t be triggered. Wrong Topic Type." Name="DoManualPublish.outSuccess"/>
		END_VAR;
				//! <Function Comment="Call function to set the timeouts for the subscribe, unsubscribe and publish execution." Name="SetTimeouts"/>
	FUNCTION GLOBAL SetTimeouts
		VAR_INPUT
			inTimeInfo 	: t_s_MQTT_TopicTimeouts;			//! <Variable Comment="Struct with the timeouts" Name="SetTimeouts.inTimeInfo"/>
		END_VAR;
				//! <Function Comment="If the state is MQTT_TopicState_Error_WaitForReset, the class can be reset with this function. " Name="ResetError"/>
	FUNCTION GLOBAL ResetError;
				//! <Function Comment="Check if the configuration has changed." Name="HasConfigChanged"/>
	FUNCTION HasConfigChanged
		VAR_OUTPUT
			outHasChanged 	: BOOL;
		END_VAR;
				//! <Function Comment="Call function to change the topic name." Name="WriteTopicName"/>
	FUNCTION GLOBAL WriteTopicName
		VAR_INPUT
			inPtrTopicString 	: ^UINT;			//! <Variable Comment="Pointer of string with the new topic name." Name="WriteTopicName.inPtrTopicString"/>
		END_VAR
		VAR_OUTPUT
			outSuccess 	: BOOL;			//! <Variable Comment="True...changing the topic name was successfull&#13;&#10;False...changing the topic name failed." Name="WriteTopicName.outSuccess"/>
		END_VAR;
				//! <Function Comment="Call function to get the topic name." Name="ReadTopicName"/>
	FUNCTION GLOBAL ReadTopicName
		VAR_INPUT
			inDstPtrTopicString 	: ^UINT;			//! <Variable Comment="Destination pointer to the string where the topic should be saved." Name="ReadTopicName.inDstPtrTopicString"/>
			inLenOfTopicString 	: UDINT;			//! <Variable Comment="Length of the destination string." Name="ReadTopicName.inLenOfTopicString"/>
		END_VAR
		VAR_OUTPUT
			outSuccess 	: BOOL;			//! <Variable Comment="True...topic name was copied&#13;&#10;False...topic name couln&apos;t be copied" Name="ReadTopicName.outSuccess"/>
		END_VAR;
				//! <Function Comment="Call function to get the length of the topic string, without 0-termination." Name="GetTopicNameLength"/>
	FUNCTION GLOBAL GetTopicNameLength
		VAR_OUTPUT
			outTopicLength 	: UDINT;			//! <Variable Comment="Length of the topic name without 0-termination." Name="GetTopicNameLength.outTopicLength"/>
		END_VAR;
				//! <Function Comment="This method can be used to set parameters realtive to the operation of the MQTTTopic class, for a description of each setting and the values that can be set see the comments on the Enumerations or the documentation therefor." Name="Config_SetParameter"/>
	FUNCTION GLOBAL Config_SetParameter
		VAR_INPUT
			Parameter 	: t_e_ConfigParameters;			//! <Variable Comment="The Parameter of which the value is to be set. For more information on each parameter see the comments on the enumeration / the documentation thereof." Name="Config_SetParameter.Parameter"/>
			Value 	: DINT;			//! <Variable Comment="The value to be set." Name="Config_SetParameter.Value"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;			//! <Variable Comment="Result of the operation." Name="Config_SetParameter.retCode"/>
		END_VAR;
				//! <Function Comment="This method is used to monitor the connection state of the MQTTClient_Interface and react when the connection was lost." Name="DoRoutine_ConnectionMonitor"/>
	FUNCTION DoRoutine_ConnectionMonitor;
	
	FUNCTION VIRTUAL GLOBAL TopicType::Write
		VAR_INPUT
			input (EAX) 	: MQTTTopic::t_e_MQTT_TopicType;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: MQTTTopic::t_e_MQTT_TopicType;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TopicName::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL TopicName::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL QoS::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using MQTTTopic_RetVals
#pragma using StringRAM
#pragma usingLtd MQTTClient_Interface
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MQTTTopic::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MQTTTOPIC
1$UINT, 14$UINT, (SIZEOF(::MQTTTopic))$UINT, 
7$UINT, 8$UINT, 0$UINT, 
TO_UDINT(3169546069), "MQTTTopic", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MQTTTopic.TopicState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3452100202), "TopicState", 
(::MQTTTopic.TopicType.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(3067355550), "TopicType", 
(::MQTTTopic.TopicName.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1680410801), "TopicName", 
(::MQTTTopic.PublishInterval.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(853642084), "PublishInterval", 
(::MQTTTopic.RetainData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(2361952253), "RetainData", 
(::MQTTTopic.QoS.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(398249489), "QoS", 
(::MQTTTopic.GrantedQoS.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3385627833), "GrantedQoS", 
//Clients:
(::MQTTTopic.objTopicName.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3166619062), "objTopicName", TO_UDINT(2408581120), "StringRAM", 1$UINT, 10$UINT, 
(::MQTTTopic.ocMQTTClient_Interface.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2507857669), "ocMQTTClient_Interface", TO_UDINT(2880242173), "MQTTClient_Interface", 1$UINT, 16$UINT, 
(::MQTTTopic.ocSigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(3653330470), "ocSigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::MQTTTopic.cAutoResetTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1255223870), "cAutoResetTime", 
(::MQTTTopic.cSubscribeTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(953818992), "cSubscribeTimeout", 
(::MQTTTopic.cPublishTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3482395436), "cPublishTimeout", 
(::MQTTTopic.cUnsubscribeTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2802426798), "cUnsubscribeTimeout", 
(::MQTTTopic.RetVals.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2326815482), "RetVals", TO_UDINT(930368637), "MQTTTopic_RetVals", 1$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_MQTTTopic 8

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MQTTTopic] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MQTTTopic::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_MQTTTopic, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #User_ClientConnected();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #User_ClientDisconnected();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #User_ErrorOccured();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #User_SubscribedOK();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #User_UnsubscribedOK();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #User_GetPublishData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #User_PublishDone();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #User_SubscribeData();

#pragma warning (default : 74)
	TopicState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF TopicState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	TopicType.pMeth			:= StoreMethod( #M_RD_DIRECT(), #TopicType::Write() );
	IF TopicType.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, TopicName.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #TopicName::Read();
	vmt.CmdTable.Write		:= #TopicName::Write();
	TopicName.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF TopicName.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PublishInterval.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF PublishInterval.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RetainData.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF RetainData.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	QoS.pMeth			:= StoreMethod( #M_RD_DIRECT(), #QoS::Write() );
	IF QoS.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION

//############################################################################################
//#                                        Init                                              #
//############################################################################################

FUNCTION VIRTUAL GLOBAL MQTTTopic::Init
  VAR
  	tmpTimeouts : t_s_MQTT_TopicTimeouts;
  END_VAR

  InitCounter += 1;
  
  if InitCounter = 1 then
    
    // initialize timeouts
    if IsClientConnected(#cSubscribeTimeout) then
      cSubscribeTimeout := cSubscribeTimeout.Read();
    end_if;
    if IsClientConnected(#cUnsubscribeTimeout) then
      cUnsubscribeTimeout := cUnsubscribeTimeout.Read();
    end_if;
    if IsClientConnected(#cPublishTimeout) then
      cPublishTimeout := cPublishTimeout.Read();
    end_if;
    
    tmpTimeouts.udSubscribeTimeout    := cSubscribeTimeout;
    tmpTimeouts.udUnsubscribeTimeout  := cUnsubscribeTimeout;
    tmpTimeouts.udPublishTimeout      := cPublishTimeout;
    SetTimeouts(inTimeInfo:=tmpTimeouts);
    
  end_if;

END_FUNCTION

//############################################################################################
//#                                   Cyclic Methods                                         #
//############################################################################################

FUNCTION VIRTUAL GLOBAL MQTTTopic::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	state := READY;
  DoRoutine();

END_FUNCTION

//############################################################################################
//#                                   Public Methods                                         #
//############################################################################################
FUNCTION GLOBAL MQTTTopic::PubSubData
	VAR_INPUT
		MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes;
		iMid 	: INT;
		iGrantedQoS 	: INT;
		pMessage 	: ^MQTTClient::t_s_MQTTMessage;
	END_VAR
  VAR
  	dParaTemp1, dParaTemp2, dParaTemp3 : DINT;
  END_VAR

  
  // *****************************************************************************************
  // **************** check for the message type *********************************************
  // *****************************************************************************************
  
  case MsgType of
    
    // we are subscribed to the topic
    // ---------------------------------------------------------------------------------------
    PSRC_Subscribed:
      
      GrantedQoS := iGrantedQoS;
      
      if GrantedQoS = MQTTTOPIC_SUBACK_ERRORCODE then
        FlagList.SubscribedFailed := TRUE;
      else
        FlagList.Subscribed := TRUE;
      end_if;
      
      dParaTemp1 := iMid;
      dParaTemp2 := GrantedQoS;
      dParaTemp3 := to_dint(ApplMsgId);
      
      ocMQTTClient_Interface.Logging_CreateLog( usLevel		:=	MQTT_LOG_INFO,
                                                dMsgGroup	:=	MQTOP_LOG_INFO_SUBSCRIBE_SUBSCRIBED_GRP,
                                                dMsgNbr		:=	MQTOP_LOG_INFO_SUBSCRIBE_SUBSCRIBED_MSG,
                                                pMsg			:=	MQTOP_LOG_INFO_SUBSCRIBE_SUBSCRIBED_TEXT,
                                                pPara1		:=	#dParaTemp1,
                                                pPara2		:=	#dParaTemp2,
                                                pPara3		:=	#dParaTemp3,
                                                pPara4		:=	NIL);
    
    // we are unsubscribed from the topic
    // ---------------------------------------------------------------------------------------
  	PSRC_Unsubscribed:
      
      FlagList.Subscribed := FALSE;
      
      dParaTemp1 := iMid;
      dParaTemp2 := to_dint(ApplMsgId);
      
      ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                                dMsgGroup	:=	MQTOP_LOG_INFO_UNSUBSCRIBE_UNSUBSCRIBED_GRP,
                                                dMsgNbr		:=	MQTOP_LOG_INFO_UNSUBSCRIBE_UNSUBSCRIBED_MSG,
                                                pMsg			:=	MQTOP_LOG_INFO_UNSUBSCRIBE_UNSUBSCRIBED_TEXT,
                                                pPara1		:=	#dParaTemp1,
                                                pPara2		:=	#dParaTemp2,
                                                pPara3		:=	NIL,
                                                pPara4		:=	NIL);

                                                    
    // we got data from the subscribed topic
    // ---------------------------------------------------------------------------------------
  	PSRC_PublishReceived:
    
      dParaTemp1 := iMid;
      dParaTemp2 := to_dint(ApplMsgId);
      
      ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                            dMsgGroup	:=	MQTOP_LOG_INFO_SUBSCRIBE_DATA_RX_GRP,
                                            dMsgNbr		:=	MQTOP_LOG_INFO_SUBSCRIBE_DATA_RX_MSG,
                                            pMsg			:=	MQTOP_LOG_INFO_SUBSCRIBE_DATA_RX_TEXT,
                                            pPara1		:=	#dParaTemp1,
                                            pPara2		:=	#dParaTemp2,
                                            pPara3		:=	NIL,
                                            pPara4		:=	NIL);

                                                
      if pMessage <> NIL then
      
        User_SubscribeData( pData :=  pMessage^.payload, 
                            udLen :=  pMessage^.payloadlen);

      end_if;
      
    // Our publish is done
    // ---------------------------------------------------------------------------------------
  	PSRC_Published:
      
      FlagList.PublishDone := TRUE;
      
      dParaTemp1 := iMid;
      dParaTemp2 := to_dint(ApplMsgId);
      
      ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                                dMsgGroup	:=	MQTOP_LOG_INFO_PUBLISH_PUBLISHED_GRP,
                                                dMsgNbr		:=	MQTOP_LOG_INFO_PUBLISH_PUBLISHED_MSG,
                                                pMsg			:=	MQTOP_LOG_INFO_PUBLISH_PUBLISHED_TEXT,
                                                pPara1		:=	#dParaTemp1,
                                                pPara2		:=	#dParaTemp2,
                                                pPara3		:=	NIL,
                                                pPara4		:=	NIL);

    
    //----------------------------------------------------------------
    //MQTT Client has disconnected
    //----------------------------------------------------------------
    MQTTClient_Interface::PSRC_Disconnected:
    
      // The Disconnect event is detected by polling the MQTTClient_Interface state to be able 
      // to deliver the User_Disconnected() call also when publishing:
      //   The MQTTClient relies on the PubSubList to deliver this callback and publish entries
      //   only live in the list whilst they are active, this means that if we are not actively
      //   publishing this (disconnected) call won't come and we will not be able to let the user know / react internally.
      
  end_case;

  // *****************************************************************************************
  // *****************************************************************************************

  Mid := iMid;
  
END_FUNCTION

FUNCTION GLOBAL MQTTTopic::SetTimeouts
	VAR_INPUT
		inTimeInfo 	: t_s_MQTT_TopicTimeouts;
	END_VAR
  
  TimeoutInfo := inTimeInfo;

END_FUNCTION

FUNCTION GLOBAL MQTTTopic::DoManualPublish
	VAR_OUTPUT
		outSuccess 	: BOOL;
	END_VAR
  
  outSuccess := FALSE;
  
  if MQTTTopicConfig.TopicType = MT_Publish_Manual then
    FlagList.ManualPublish := TRUE;
    outSuccess := TRUE;
  end_if;

END_FUNCTION

FUNCTION GLOBAL MQTTTopic::ResetError
VAR
	dParaTemp1 : DINT;
END_VAR

  if TopicState = MTS_Error_WaitForReset then
  
    TopicState := MTS_Init;
    
    dParaTemp1 := to_dint(ApplMsgId);
    
    ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_DEBUG,
                                              dMsgGroup	:=	MQTOP_LOG_DEBUG_FSM_ERR_RESET_GRP,
                                              dMsgNbr		:=	MQTOP_LOG_DEBUG_FSM_ERR_RESET_MSG,
                                              pMsg			:=	MQTOP_LOG_DEBUG_FSM_ERR_RESET_TEXT,
                                              pPara1		:=	#dParaTemp1,
                                              pPara2		:=	NIL,
                                              pPara3		:=	NIL,
                                              pPara4		:=	NIL);


  end_if;

END_FUNCTION

FUNCTION GLOBAL MQTTTopic::WriteTopicName
	VAR_INPUT
		inPtrTopicString 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		outSuccess 	: BOOL;
	END_VAR
  
  outSuccess := FALSE;
  
  if inPtrTopicString <> NIL then
    objTopicName.TxtSet(dstchrsize:=sizeof(inPtrTopicString^), psrc:=inPtrTopicString, srcchrsize:=sizeof(inPtrTopicString^));
    
    outSuccess := TRUE;
  end_if;

END_FUNCTION

FUNCTION GLOBAL MQTTTopic::ReadTopicName
	VAR_INPUT
		inDstPtrTopicString 	: ^UINT;
		inLenOfTopicString 	: UDINT;
	END_VAR
	VAR_OUTPUT
		outSuccess 	: BOOL;
	END_VAR
  
  outSuccess := FALSE;
  
  if inDstPtrTopicString <> NIL &
     inLenOfTopicString > 0 then
  
    objTopicName.TxtGet(pdst:=inDstPtrTopicString, dstsize:=inLenOfTopicString);
    outSuccess := TRUE;
  end_if;


END_FUNCTION

FUNCTION GLOBAL MQTTTopic::GetTopicNameLength
	VAR_OUTPUT
		outTopicLength 	: UDINT;
	END_VAR
  
  outTopicLength := objTopicName.StrLen();

END_FUNCTION

//############################################################################################
//#                                Server Read/Write                                         #
//############################################################################################

FUNCTION VIRTUAL GLOBAL MQTTTopic::TopicName::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	TopicName := objTopicName.Data.Read();
	output := TopicName;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTTopic::TopicName::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	TopicName := input;
	result := (objTopicName.Data.Write(TopicName))$UDINT;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTTopic::QoS::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	QoS := input;
	result := QoS;
  
  FlagList.ConfigChanged := TRUE;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTTopic::TopicType::Write
	VAR_INPUT
		input (EAX) 	: MQTTTopic::t_e_MQTT_TopicType;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: MQTTTopic::t_e_MQTT_TopicType;
	END_VAR

	TopicType := input;
	result := TopicType;
  
  FlagList.ConfigChanged := TRUE;

END_FUNCTION

//############################################################################################
//#                                  Private Methods                                         #
//############################################################################################

FUNCTION VIRTUAL MQTTTopic::User_ClientConnected
// must be derived
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_ErrorOccured
// must be derived
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_SubscribedOK
  #pragma warning(default:73);

// must be derived
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_UnsubscribedOK
  #pragma warning(default:73);
  
// must be derived
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_GetPublishData
	VAR_OUTPUT
		PublishData 	: t_s_MQTT_TopicPublishData;
	END_VAR
// must be derived

  PublishData.pData := NIL;
  PublishData.udLen := 0;
  
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_PublishDone
  #pragma warning(default:73);
  
// must be derived
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_SubscribeData
	#pragma warning(disable:73);
  VAR_INPUT
		pData 	: ^void;
		udLen 	: UDINT;
	END_VAR
  #pragma warning(default:73);
  
//must be derived
END_FUNCTION

FUNCTION VIRTUAL MQTTTopic::User_ClientDisconnected
// must be derived
END_FUNCTION

FUNCTION MQTTTopic::DoRoutine
  VAR
  	tmpRetcode, dParaTemp1, dParaTemp2 : DINT;
    tmpTopicConfig : t_s_MQTT_TopicConfig;
    tmpState : t_e_MQTT_TopicState;
    pData : ^void;
    udLen : UDINT;
  END_VAR
  
  if TopicState <> MTS_Error &
     TopicState <> MTS_Error_WaitForReset then
    ErrorOccuredState := TopicState;
  end_if;
  
  // Monitor the connection
  DoRoutine_ConnectionMonitor();

  // ********************************************************************************
  // ***************** case for the Topic handling **********************************
  // ********************************************************************************
  
  case TopicState of
    
    // init step
    // ------------------------------------------------------------------------------
  	MTS_Init:
      MQTTTopicConfig := GetTopicConfig();
      FlagList.SubscribedFailed := FALSE;
      TopicState := MTS_WaitForConnection;
    
    // Wait till the MQTT client is connected
    // ------------------------------------------------------------------------------
  	MTS_WaitForConnection:
      
      if ocMQTTClient_Interface.InterfaceState.Read() = MQTTClient_Interface::MCIS_Connected then
        if ocMQTTClient_Interface.SessionPresent.Read() = 1 &
           BeforeDisconnectState > MTS_WaitForConnection    &
           BeforeDisconnectState < MTS_Error                then
          TopicState := BeforeDisconnectState;
        else
          TopicState := MTS_Ready;
          FlagList.Subscribed               := FALSE;
          FlagList.SubscribedFailed         := FALSE;
          FlagList.bInitialPublishCompleted := FALSE;
        end_if;
        FlagList.bInitialPublishCompleted := (FlagList.bSendAtStart = FALSE);
        User_ClientConnected();
      end_if;

    // We are ready to start, check if the Topic is active
    // ------------------------------------------------------------------------------
  	MTS_Ready:
        
      // check for the topic type
      case MQTTTopicConfig.TopicType of
      
        MT_Deactivated:
          // do nothing
          if HasConfigChanged() = TRUE then
            MQTTTopicConfig := GetTopicConfig();
          end_if;

        MT_Subscribe: 
          if FlagList.Subscribed then
            TopicState := MTS_Subscribed;
          else
            TopicState := MTS_Subscribe;
          end_if;
        MT_Publish_Poll: 
          TopicState := MTS_WaitForPublishInterval;
        MT_Publish_OnChange: 
          TopicState := MTS_WaitForPublishDataChange;
        MT_Publish_Manual: 
          TopicState := MTS_WaitForPublishCommand;
        
      end_case;
      
      udPubTimestamp := ops.tAbsolute;
      
    // Subscribe to the defined Topic
    // ------------------------------------------------------------------------------
  	MTS_Subscribe:
      
      if FlagList.Subscribed = TRUE then
      
        TopicState := MTS_Subscribed;
        
      else
        
        tmpRetcode := ocMQTTClient_Interface.MQTT_Subscribe(pTopic      :=  #MQTTTopicConfig.TopicName[0], 
                                                            iQoS        :=  MQTTTopicConfig.QoS,
                                                            pThis       :=  this,
                                                            pCallback   :=  NIL,
                                                            pMid        :=  #Mid$INT,
                                                            pApplMsgID  :=  #ApplMsgId);
                                                 
        
        if tmpRetcode = MQTTClient::MQTT_ERR_SUCCESS$INT then
        
          TopicState := MTS_WaitForSubscribe;
          udTimestamp := ops.tAbsolute;
          FlagList.SubscribedFailed := FALSE;
          
        elsif tmpRetcode = MQTTClient::MQTT_ERR_ALREADY_SUB$INT then
        
          TopicState := MTS_Subscribed;
          udTimestamp := ops.tAbsolute;
          FlagList.SubscribedFailed := FALSE;
        
        else
          TopicState := MTS_Error;
          
          
          dParaTemp1 := to_dint(Mid);
          dParaTemp2 := to_dint(tmpRetcode);
          
          ocMQTTClient_Interface.Logging_CreateLog( usLevel		:=	MQTT_LOG_ERR,
                                                    dMsgGroup	:=	MQTOP_LOG_ERROR_SUBSCRIBE_CALL_SUB_FAIL_GRP,
                                                    dMsgNbr		:=	MQTOP_LOG_ERROR_SUBSCRIBE_CALL_SUB_FAIL_MSG,
                                                    pMsg			:=	MQTOP_LOG_ERROR_SUBSCRIBE_CALL_SUB_FAIL_TEXT,
                                                    pPara1		:=	#dParaTemp1,
                                                    pPara2		:=	#dParaTemp2,
                                                    pPara3		:=	NIL,
                                                    pPara4		:=	NIL);
        end_if;

      end_if;

    
    // wait for callback from the MQTT client, if the subscribe was OK
    // ------------------------------------------------------------------------------
  	MTS_WaitForSubscribe:
      
      if FlagList.Subscribed = TRUE then
        
        TopicState := MTS_Subscribed;
        User_SubscribedOK();
        
      elsif FlagList.SubscribedFailed = TRUE then
        
        FlagList.SubscribedFailed := FALSE;
        TopicState := MTS_Error;
        

        ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_ERR,
                                                  dMsgGroup	:=	MQTOP_LOG_ERROR_SUBSCRIBE_SUB_FAIL_GRP,
                                                  dMsgNbr		:=	MQTOP_LOG_ERROR_SUBSCRIBE_SUB_FAIL_MSG,
                                                  pMsg			:=	MQTOP_LOG_ERROR_SUBSCRIBE_SUB_FAIL_TEXT,
                                                  pPara1		:=	#dParaTemp1,
                                                  pPara2		:=	NIL,
                                                  pPara3		:=	NIL,
                                                  pPara4		:=	NIL);
      end_if;

    
    // We are subscribed to the Topic
    // ------------------------------------------------------------------------------
  	MTS_Subscribed:
      
      //If no longer subscribed, advance the state
      if FlagList.Subscribed = FALSE then
        
        TopicState := MTS_Unsubscribed;
        
      //If the config has changed
      elsif HasConfigChanged() = TRUE then
      
        tmpTopicConfig := GetTopicConfig();
        TopicState := GetStateByActTopicConfig(inActState:=TopicState, inActTopicConfig:=tmpTopicConfig);
      
      end_if;

    // unsubscribe from the defined Topic
    // ------------------------------------------------------------------------------
  	MTS_Unsubscribe:
    
      if FlagList.Subscribed = TRUE then

        tmpRetcode := ocMQTTClient_Interface.MQTT_Unsubscribe(pApplMsgID  :=  #ApplMsgId,
                                                              pTopic      :=  #MQTTTopicConfig.TopicName[0],
                                                              pMid        :=  #Mid$INT,
                                                              pThis       :=  this, 
                                                              pCallback   :=  NIL);
                                                 
        
        if tmpRetcode = MQTTClient::MQTT_ERR_SUCCESS$INT then
          TopicState := MTS_WaitForUnsubscribe;
          udTimestamp := ops.tAbsolute;
        else
          TopicState := MTS_Error;
          
          dParaTemp1 := tmpRetcode;
          dParaTemp2 := to_dint(ApplMsgId);
          
          ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_ERR,
                                                    dMsgGroup	:=	MQTOP_LOG_ERROR_UNSUBSCRIBE_CALL_UNSUB_FAIL_GRP,
                                                    dMsgNbr		:=	MQTOP_LOG_ERROR_UNSUBSCRIBE_CALL_UNSUB_FAIL_MSG,
                                                    pMsg			:=	MQTOP_LOG_ERROR_UNSUBSCRIBE_CALL_UNSUB_FAIL_TEXT,
                                                    pPara1		:=	#dParaTemp1,
                                                    pPara2		:=	#dParaTemp2,
                                                    pPara3		:=	NIL,
                                                    pPara4		:=	NIL);

        end_if;
      
      else
        TopicState := MTS_Unsubscribed;
      end_if;
    
    // wait for callback from the MQTT client, if the unsubscribe was OK
    // ------------------------------------------------------------------------------
  	MTS_WaitForUnsubscribe:
      
      if FlagList.Subscribed = FALSE then
        TopicState := MTS_Unsubscribed;
      end_if;

    // we are unsubscribed
    // ------------------------------------------------------------------------------
  	MTS_Unsubscribed:
    
      User_UnsubscribedOK();
      MQTTTopicConfig := GetTopicConfig();
      TopicState := MTS_Ready;
    
    // Wait for the Publish Interval
    // ------------------------------------------------------------------------------
  	MTS_WaitForPublishInterval:
      
      if HasConfigChanged() = TRUE then
      
        MQTTTopicConfig := GetTopicConfig();
        tmpState := GetStateByActTopicConfig(inActState:=TopicState, inActTopicConfig:=MQTTTopicConfig);
        
        if tmpState <> TopicState then
          TopicState := tmpState;
          return;
        end_if;
        
      end_if;

      if ops.tAbsolute - udPubTimestamp >= PublishInterval then
      
        TopicState := MTS_Publish;
        udPubTimestamp := ops.tAbsolute;
        PublishData := User_GetPublishData();

        ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                                  dMsgGroup	:=	MQTOP_LOG_INFO_PUBLISH_INTERVAL_GRP,
                                                  dMsgNbr		:=	MQTOP_LOG_INFO_PUBLISH_INTERVAL_MSG,
                                                  pMsg			:=	MQTOP_LOG_INFO_PUBLISH_INTERVAL_TEXT,
                                                  pPara1		:=	NIL,
                                                  pPara2		:=	NIL,
                                                  pPara3		:=	NIL,
                                                  pPara4		:=	NIL);

      end_if;

    // Check if data has changed to publish
    // ------------------------------------------------------------------------------
  	MTS_WaitForPublishDataChange:
      
      if HasConfigChanged() = TRUE then
      
        MQTTTopicConfig := GetTopicConfig();
        tmpState := GetStateByActTopicConfig(inActState:=TopicState, inActTopicConfig:=MQTTTopicConfig);
        
        if tmpState <> TopicState then
          TopicState := tmpState;
          return;
        end_if;
        
      end_if;
      
      // Check for change in the defined publish interval
      if ops.tAbsolute - udPubTimestamp >= PublishInterval |
         FlagList.bInitialPublishCompleted = FALSE         then
        
        udPubTimestamp := ops.tAbsolute;
        
        PublishData := User_GetPublishData();
        
        if Publish_DataChanged(Data:=PublishData) = TRUE |
           FlagList.bInitialPublishCompleted = FALSE     then
        
          TopicState := MTS_Publish;          

          ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                                    dMsgGroup	:=	MQTOP_LOG_INFO_PUBLISH_DATACHANGED_GRP,
                                                    dMsgNbr		:=	MQTOP_LOG_INFO_PUBLISH_DATACHANGED_MSG,
                                                    pMsg			:=	MQTOP_LOG_INFO_PUBLISH_DATACHANGED_TEXT,
                                                    pPara1		:=	NIL,
                                                    pPara2		:=	NIL,
                                                    pPara3		:=	NIL,
                                                    pPara4		:=	NIL);

        end_if;
        
      end_if;

    
    // check if manual publish command was triggered
    // ------------------------------------------------------------------------------
  	MTS_WaitForPublishCommand:
      
      if HasConfigChanged() = TRUE then
      
        MQTTTopicConfig := GetTopicConfig();
        tmpState := GetStateByActTopicConfig(inActState:=TopicState, inActTopicConfig:=MQTTTopicConfig);
        
        if tmpState <> TopicState then
          TopicState := tmpState;
          return;
        end_if;
        
      end_if;
      
      if FlagList.ManualPublish = TRUE then
        FlagList.ManualPublish := FALSE;
        
        TopicState := MTS_Publish;
        PublishData := User_GetPublishData();
        

        ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                                  dMsgGroup	:=	MQTOP_LOG_INFO_PUBLISH_TRIGGER_GRP,
                                                  dMsgNbr		:=	MQTOP_LOG_INFO_PUBLISH_TRIGGER_MSG,
                                                  pMsg			:=	MQTOP_LOG_INFO_PUBLISH_TRIGGER_TEXT,
                                                  pPara1		:=	NIL,
                                                  pPara2		:=	NIL,
                                                  pPara3		:=	NIL,
                                                  pPara4		:=	NIL);

      end_if;

    // Publish to the Topic
    // ------------------------------------------------------------------------------
  	MTS_Publish:
      
      if PublishData.udLen > 0    &
         PublishData.pData <> NIL then
        pData := PublishData.pData;
        udLen := PublishData.udLen;
      else
        pData := NIL;
        udLen := 0;         
      end_if;
      
      tmpRetcode := ocMQTTClient_Interface.MQTT_Publish(  pTopic        :=  #MQTTTopicConfig.TopicName[0],
                                                          iQoS          :=  MQTTTopicConfig.QoS,
                                                          pPayload      :=  pData,
                                                          udPayloadLen  :=  udLen,
                                                          bRetain       :=  to_bool(RetainData),
                                                          pThis         :=  this,
                                                          pCallback     :=  NIL,
                                                          pMid          :=  #Mid$INT,
                                                          pApplMsgID    :=  #ApplMsgId);
                               
                               
      if tmpRetcode = MQTTClient::MQTT_ERR_SUCCESS$INT then
        TopicState := MTS_WaitForPublishDone;
        udTimestamp := ops.tAbsolute;
        FlagList.PublishDone := FALSE;
      else
        TopicState := MTS_Error;
        
        dParaTemp1 := tmpRetcode;
        dParaTemp2 := to_dint(ApplMsgId);
        
        ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_ERR,
                                                  dMsgGroup	:=	MQTOP_LOG_ERROR_PUBLISH_CALL_PUB_FAIL_GRP,
                                                  dMsgNbr		:=	MQTOP_LOG_ERROR_PUBLISH_CALL_PUB_FAIL_MSG,
                                                  pMsg			:=	MQTOP_LOG_ERROR_PUBLISH_CALL_PUB_FAIL_TEXT,
                                                  pPara1		:=	#dParaTemp1,
                                                  pPara2		:=	#dParaTemp2,
                                                  pPara3		:=	NIL,
                                                  pPara4		:=	NIL);

      end_if;
            
    // wait for callback from the MQTT client, if the publish was OK
    // ------------------------------------------------------------------------------
  	MTS_WaitForPublishDone:
      
      if FlagList.PublishDone = TRUE then
        
        FlagList.bInitialPublishCompleted := TRUE;
        
        User_PublishDone();
        
        // check for the topic type
        case MQTTTopicConfig.TopicType of
        
          MT_Publish_Poll: 
            TopicState := MTS_WaitForPublishInterval;
          MT_Publish_OnChange: 
            TopicState := MTS_WaitForPublishDataChange;
          MT_Publish_Manual: 
            TopicState := MTS_WaitForPublishCommand;
          
        end_case;
       
      end_if;

    // An Error occured
    // ------------------------------------------------------------------------------
  	MTS_Error:
      User_ErrorOccured();
      udTimestamp := ops.tAbsolute;
      TopicState := MTS_Error_WaitForReset;
    
    // We are in error state, wait for the Reset
    // ------------------------------------------------------------------------------
    MTS_Error_WaitForReset:
      
      //If the AutoReset Time has been set and the timeout has occurred,
      //Call the reset method.
      if (cAutoResetTime <> 0)                            &
         (ops.tAbsolute - udTimestamp >= cAutoResetTime)  then
        
        ResetError();
        
      end_if;

    
  end_case;
  
  // ********************************************************************************
  // ********************************************************************************

END_FUNCTION

FUNCTION MQTTTopic::GetTopicConfig
	VAR_OUTPUT
		outTopicConfig 	: t_s_MQTT_TopicConfig;
	END_VAR
  VAR
  	tmpMaxSize : UDINT;
  END_VAR
  
  tmpMaxSize := sizeof(outTopicConfig.TopicName) - sizeof(outTopicConfig.TopicName[0]);
  
  objTopicName.ToUniCode();
  objTopicName.TxtGet(pdst:=#outTopicConfig.TopicName[0], dstsize:=tmpMaxSize);
  
  outTopicConfig.TopicNameCRC := objTopicName.TxtGetCRC();
  FlagList.ConfigChanged := FALSE;
  
  outTopicConfig.TopicType := TopicType;
  outTopicConfig.QoS := to_int(QoS);
    
END_FUNCTION

FUNCTION MQTTTopic::Publish_DataChanged
	VAR_INPUT
		Data 	: t_s_MQTT_TopicPublishData;
	END_VAR
	VAR_OUTPUT
		bChanged 	: BOOL;
	END_VAR
  VAR
  	tmpCRC : UDINT;
  END_VAR
  
  bChanged := FALSE;
  
  if Data.pData = NIL |
     Data.udLen = 0   then
  
    // NIL Pointer and zero length are treated as CRC = 0
    tmpCRC := 0;
  
  else
  
    tmpCRC := sigclib_crc32(initval :=  MQTTTOPIC_PUBLISHDATA_CRCCALC_INITVAL, 
                            psrc    :=  Data.pData, 
                            length  :=  Data.udLen);  
  end_if;
      
  if tmpCRC <> RetVals.udCRC.Read() then
    bChanged := TRUE;
    RetVals.udCRC.Write(input:=tmpCRC);
  end_if;

END_FUNCTION

FUNCTION MQTTTopic::GetStateByActTopicConfig
	VAR_INPUT
		inActState 	: t_e_MQTT_TopicState;
		inActTopicConfig 	: t_s_MQTT_TopicConfig;
	END_VAR
	VAR_OUTPUT
		outNewState 	: t_e_MQTT_TopicState;
	END_VAR
  
  // init value
  outNewState := inActState;
  
  case inActState of
  
  	MTS_Subscribed:
      
      if (inActTopicConfig.TopicNameCRC <> MQTTTopicConfig.TopicNameCRC) |
         (inActTopicConfig.TopicType <> MT_Subscribe) |
         (inActTopicConfig.QoS <> MQTTTopicConfig.QoS) then
        
        outNewState := MTS_Unsubscribe;
      end_if;
    
  	MTS_WaitForPublishInterval,
  	MTS_WaitForPublishDataChange,
  	MTS_WaitForPublishCommand:
      
      // check for the topic type
      case inActTopicConfig.TopicType of
      
        MT_Deactivated,
        MT_Subscribe: 
          outNewState := MTS_Ready;
        MT_Publish_Poll: 
          outNewState := MTS_WaitForPublishInterval;
        MT_Publish_OnChange: 
          outNewState := MTS_WaitForPublishDataChange;
        MT_Publish_Manual: 
          outNewState := MTS_WaitForPublishCommand;
        
      end_case;
    
  end_case;


END_FUNCTION

FUNCTION MQTTTopic::HasConfigChanged
	VAR_OUTPUT
		outHasChanged 	: BOOL;
	END_VAR
  VAR
  	tmpTopicNameCRC : UDINT;
    dParaTemp1 : DINT;
  END_VAR
  
  tmpTopicNameCRC := objTopicName.TxtGetCRC();
  
  if FlagList.ConfigChanged = TRUE                    |
     tmpTopicNameCRC <> MQTTTopicConfig.TopicNameCRC  then
    
    outHasChanged := TRUE;
    
    dParaTemp1 := to_dint(ApplMsgId);
        
    ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                              dMsgGroup	:=	MQTOP_LOG_INFO_FSM_CONFIG_CHANGE_GRP,
                                              dMsgNbr		:=	MQTOP_LOG_INFO_FSM_CONFIG_CHANGE_MSG,
                                              pMsg			:=	MQTOP_LOG_INFO_FSM_CONFIG_CHANGE_TEXT,
                                              pPara1		:=	#dParaTemp1,
                                              pPara2		:=	NIL,
                                              pPara3		:=	NIL,
                                              pPara4		:=	NIL);

  end_if;

END_FUNCTION

FUNCTION GLOBAL MQTTTopic::Config_SetParameter
	VAR_INPUT
		Parameter 	: t_e_ConfigParameters;
		Value 	: DINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //Assume OK
  retCode := 0;
  
  //===============================================================
  //Based on the selected Parameter, attempt to change the setting
  //===============================================================
  case Parameter of
  
    //-----------------------------------------------------
    // Sets whether the MQTTTopic always publishes at start 
    // or waits for the first change in the data
    //-----------------------------------------------------
  	t_e_ConfigParameters::CP_SendAtStart:
    
      //Valid
      if Value = 0 | Value = 1 then
        
        FlagList.bSendAtStart := (Value = 1);
        
      //Invalid
      else
        
        retCode := MQTTClient::MQTT_ERR_INVAL;
        
      end_if;
    
  end_case;
  
END_FUNCTION

//############################################################################################
//############################################################################################


FUNCTION MQTTTopic::DoRoutine_ConnectionMonitor
  VAR
  	dParaTemp1 : DINT;
  END_VAR

  //============================================================
  // Based on whether a connection is expected monitor the state
  // of the MQTTClient_Interface and react.
  //============================================================
  case TopicState of
  	
    //------------------------------------------------------
    // No Connection Expected - Nothing to do.
    //------------------------------------------------------
    MQTTTopic::t_e_MQTT_TopicState::MTS_Init,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForConnection:
      
    //------------------------------------------------------
    // Check if still Connected
    //------------------------------------------------------
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Ready,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Subscribe,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForSubscribe,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Subscribed,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Unsubscribe,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForUnsubscribe,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Unsubscribed,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForPublishInterval,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForPublishDataChange,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForPublishCommand,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Publish,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_WaitForPublishDone:
      
      if ocMQTTClient_Interface.InterfaceState.Read() <> MQTTClient_Interface::MCIS_Connected then
      
        // The connection was lost.
        
        User_ClientDisconnected();
        
        BeforeDisconnectState := TopicState;
        TopicState := MTS_WaitForConnection;
        
        dParaTemp1 := to_dint(ApplMsgId);
        ocMQTTClient_Interface.Logging_CreateLog(	usLevel		:=	MQTT_LOG_INFO,
                                                  dMsgGroup	:=	MQTOP_LOG_INFO_CONNECTION_CLI_DISCONN_GRP,
                                                  dMsgNbr		:=	MQTOP_LOG_INFO_CONNECTION_CLI_DISCONN_MSG,
                                                  pMsg			:=	MQTOP_LOG_INFO_CONNECTION_CLI_DISCONN_TEXT,
                                                  pPara1		:=	#dParaTemp1,
                                                  pPara2		:=	NIL,
                                                  pPara3		:=	NIL,
                                                  pPara4		:=	NIL);
      end_if;
      
    //------------------------------------------------------
    // No Connection Required - Nothing to do.
    //------------------------------------------------------
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Error,
  	MQTTTopic::t_e_MQTT_TopicState::MTS_Error_WaitForReset:
    
  end_case;


  
END_FUNCTION
