//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "WewoLogger"
	Revision           = "0.8"
	GUID               = "{2CD84D5A-2615-4BBC-A649-2BC9A7059639}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "1000 ms"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(1140,900)"
	Comment            = "Wewo Logger&#13;&#10;&#13;&#10;Central place to log messages and/or realtime data&#13;&#10;received from other classes.&#13;&#10;(see methodes SF_Base.WriteLogRtData() en SF_Base.WriteLogMessage())&#13;&#10;&#13;&#10;This class supports&#13;&#10;1) message logging &#13;&#10;2) Realtime data logging&#13;&#10;3) Create a chain of connected weowBase objects for logging&#13;&#10;&#13;&#10;Both loggings can be activated simultanuously.&#13;&#10;&#13;&#10;Message logging stores messages to either screen, file or Both screen and file.&#13;&#10;Filename for message logging is fixed EVENT01.LOG (defined by Lasal OS).&#13;&#10;&#13;&#10;Server p_WewoObjChain Points to start of chain of connected SFN_Base objects.&#13;&#10;&#13;&#10;Server MsgLogLevel we can select the message priority levels which should be logged.&#13;&#10;&#13;&#10;Server MsgLogTarget we can select the output to send the messages to.&#13;&#10;&#13;&#10;Server o_MsgLogCnt Show nr of messages logged&#13;&#10;&#13;&#10;Server RtLogMBufMode is used to select the buffer mode &#13;&#10;- cyclic overwrite buffer if it is full&#13;&#10;- once   write until buffer is full&#13;&#10;&#13;&#10;Server ip_RtLogFile a pointer to File name string for RealtIme data logging can be set.&#13;&#10;Note: Filename for message logging is controled by Lasal OS.&#13;&#10;&#13;&#10;Server o_RtLogDataCnt: Show nr of realtime data entries logged&#13;&#10;&#13;&#10;Server ip_LogData is the interface to other class objects. Via this server this class receives the logdata from other classes.&#13;&#10;&#13;&#10;Server InsertRtStartLogNr is used to insert a reference entry in the Realtime data log buffer&#13;&#10;&#13;&#10;Server command is used to send commands. &#13;&#10;&#13;&#10;With methode SetTriggerRtLog() a trigger condition can be set (Stored in  variable RtTriggerSetting).&#13;&#10;&#13;&#10;Message logging logs messages in an OS buffer. If buffer is full the content is send to File.&#13;&#10;Client flusTime is used to set the time to flush automtically messages to a file in case buffer is not full.&#13;&#10;&#13;&#10;Realtime Data Logging logs data into an internal RAM buffer.&#13;&#10;With Client c_RtNrOfLogEntries we can select the number of entries to be stored.&#13;&#10;Note: Size of buffer may exceed the limit of 64K which is used by Lasal for class objects&#13;&#10;&#13;&#10;With LogCommand LOGCMD_SENDFILE_RT_LOG the stored RtLogData can be stored in a File.&#13;&#10;">
	<Channels>
		<Server Name="Command" GUID="{9E8B59E0-2A63-40C7-9E3C-8741C29C73FF}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Log command&#13;&#10;Send a log command.&#13;&#10;(See gt_LogCmd for available commands)"/>
		<Server Name="InsertRtStartLogNr" GUID="{5613EC3D-5E50-46EF-950D-C083FD29C917}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Insert a RT data log entry with this server value.&#13;&#10;&#13;&#10;Can be used to identify a start of a new log action.&#13;&#10;"/>
		<Server Name="ip_LogData" GUID="{88708DC1-95EC-4EBF-96ED-1F94A509DD92}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Input Pointer to LogData&#13;&#10;&#13;&#10;Interface for other objects which sends logdata (Log messages or Realtime Data) &#13;&#10;to Safan logger&#13;&#10;"/>
		<Server Name="ip_RtLogFile" GUID="{CF57D162-A946-416C-85A6-44EE74F7FE5D}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Pointer to filename string for real datalogging. &#13;&#10;(Including drive letter and path)"/>
		<Server Name="MsgLogLevel" GUID="{C19A5892-EF6B-4E5D-BAA4-4ACDBC2F24C5}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="SRam" Comment="Configuration of Message loglevel.&#13;&#10;Only log messages of selected loglevel and higher levels.&#13;&#10;&#13;&#10;Note:&#13;&#10;LL_DEBUG_RT is reserved for realtime datalogging.&#13;&#10;Setting LL_DEBUG_RT will be changed into loglevel LL_DEBUG.&#13;&#10;&#13;&#10;&#13;&#10;Tip:&#13;&#10;To select temporary individual log levels for debug purpose,&#13;&#10;modify ActiveLogFlags by hand."/>
		<Server Name="MsgLogTarget" GUID="{9C544215-D5CB-4C09-AB67-750061B2C276}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="SRam" Comment="Configuration of target where to send log messages.&#13;&#10;&#13;&#10;"/>
		<Server Name="o_MsgLogCnt" GUID="{8136FAB9-0812-4C81-8B98-EEE901B9B6B7}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Counter of logged messages since last startup or reset cmd.&#13;&#10;&#13;&#10;To be sure message is stored in the log file &#13;&#10;execute command LOGCMD_FLUSH_MSG_LOG."/>
		<Server Name="o_rtLogDataCnt" GUID="{BF16B11F-514A-4B61-B735-6BCBD4CC1E45}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Counter for number of entries actual logged in realtime data buffer"/>
		<Server Name="op_sfnObjChain" GUID="{38436872-8F2E-4408-B2CD-79AAD14AEEC0}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Points to chain of all SFN_Base objects registrated to the Logger.&#13;&#10;Can be used to go through all objects."/>
		<Server Name="RtLogBufMode" GUID="{D673F089-0855-4304-860F-99C4DB063DA9}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="false" Comment="Buffer mode for Realtime data logging.&#13;&#10;&#13;&#10;- Log Cyclic  Continuous logging&#13;&#10;- Log Once    Until buffer is full"/>
		<Client Name="c_FlushTime" Required="false" Internal="false" Comment="Time to flush logging messages (write buffer to file)&#13;&#10;&#13;&#10;Unit: Miliseconds&#13;&#10;"/>
		<Client Name="c_RtNrOfLogEntries" Required="true" Internal="false" Comment="Nr of entries in Realtime LogData buffer"/>
		<Client Name="o_ErrorWarningEvent" Required="false" Internal="false" Comment="Event to indicate an Error or Warning occured.&#13;&#10;&#13;&#10;Only pass events for&#13;&#10; - Warning &#13;&#10; - application error&#13;&#10; - internal error&#13;&#10; - critical error &#13;&#10;&#13;&#10;Note:&#13;&#10;Event will always send even logging is disabled.&#13;&#10;&#13;&#10;"/>
		<Client Name="o_RtTriggerEvent" Required="false" Internal="false" Comment="Trigger found for Realtime data logging&#13;&#10;&#13;&#10;Generic interface is used &#13;&#10;so if wanted each object can use &#13;&#10;this event for debugging.&#13;&#10;"/>
		<Client Name="Obj_RtLogDataBuffer" Required="true" Internal="true"/>
		<Client Name="toEnumTranslator" Required="true" Internal="false" Comment="Translates enum id to textstrings"/>
		<Client Name="ToOsKernel" Required="false" Internal="false" Comment="To OS Kernel&#13;&#10;(Automatically connected to OS)"/>
		<Client Name="ToSysMsg" Required="false" Internal="false" Comment="To OS System Message&#13;&#10;(Automatically connected to OS)"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\WewoLogger\SFN_Logger.pdf"/>
			<File Path=".\Class\WewoLogger\Logging.vov"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Safan" Author="HenOdi"/>
		<Dokumentation Revision="0.8" Date="2012-06-07" Author="HenOdi" Company="Safan" Description="Take over retentive server values on startup before the first time Init() is called."/>
		<Dokumentation Revision="0.7" Date="2012-05-30" Author="HenOdi" Company="Safan" Description="Change servers below into retentive for SRAM&#13;&#10;MsgLogLevel&#13;&#10;MsgLogTarget&#13;&#10;&#13;&#10;After the application has started once the last used mode settings is still active &#13;&#10;also after restarting the application."/>
		<Dokumentation Revision="0.6" Date="2011-12-07" Author="HenOdi" Company="Safan" Description="Use correct baseclass init()"/>
		<Dokumentation Revision="0.5" Date="2011-10-13" Author="HenOdi" Company="Safan" Description="Initialise during initCnt=2; Use default init server values for new objects"/>
		<Dokumentation Revision="0.2" Date="11-11-2010" Author="HenOdi" Company="Safan" Description="Change SetTrigger and add  GetTrigger methodes"/>
		<Dokumentation Revision="0.1" Date="9-11-2010" Author="HenOdi" Company="Safan" Description="Do not support redfine buffersize. (avoid confusions)"/>
	</RevDoku>
	<Network Name="WewoLogger">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{C28C336F-5EF3-4CE8-A259-10B8CA6A1787}"
				Class      = "WewoFileBase"
				Position   = "(1388,120)"
				Visualized = "false">
				<Channels>
					<Server Name="m_Id"/>
					<Server Name="m_p_Name"/>
					<Server Name="o_ErrorWarningStatus"/>
					<Server Name="ObjectStatus"/>
					<Server Name="ToObject"/>
					<Client Name="c_Group"/>
					<Client Name="op_LogData"/>
					<Client Name="ToFileSys"/>
				</Channels>
			</Object>
			<Object
				Name       = "Obj_RtLogDataBuffer"
				GUID       = "{B7DE47D8-23AC-4905-A83E-474C8D733678}"
				Class      = "Wewo_DynamicBuffer"
				Position   = "(1020,540)"
				Visualized = "false">
				<Channels>
					<Server Name="BufferSize"/>
					<Server Name="FiFoBufMode"/>
					<Server Name="m_Id"/>
					<Server Name="o_ErrorWarningStatus"/>
					<Server Name="ObjectStatus"/>
					<Server Name="ToObject"/>
					<Client Name="c_Group"/>
					<Client Name="op_LogData"/>
					<Client Name="p_NextObject"/>
					<Client Name="toStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ToObject" Destination="_base.ToObject" Vertices="(2130,210),(1958,210),"/>
			<Connection Source="this.ObjectStatus" Destination="_base.ObjectStatus" Vertices="(2130,270),(1958,270),"/>
			<Connection Source="this.m_Id" Destination="_base.m_Id" Vertices="(2130,390),(1958,390),"/>
			<Connection Source="this.m_p_Name" Destination="_base.m_p_Name" Vertices="(2130,450),(1958,450),"/>
			<Connection Source="this.Obj_RtLogDataBuffer" Destination="Obj_RtLogDataBuffer.ToObject"/>
			<Connection Source="_base.op_LogData" Destination="this.op_LogData" Vertices="(1388,210),(38,210),"/>
			<Connection Source="Obj_RtLogDataBuffer.op_LogData" Destination="this.op_LogData" Vertices="(1020,630),(720,630),(720,210),(38,210),"/>
			<Connection Source="_base.c_Group" Destination="this.c_Group" Vertices="(1388,270),(38,270),"/>
			<Connection Source="this.o_ErrorWarningStatus" Destination="_base.o_ErrorWarningStatus" Vertices="(2130,330),(1958,330),"/>
			<Connection Source="Obj_RtLogDataBuffer.c_Group" Destination="this.c_Group" Vertices="(1020,690),(660,690),(660,270),(38,270),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using WewoFileBase

WewoLogger : CLASS
: WewoFileBase
	TYPE
	  t_LogFlags : BSINT  //! <Type Comment="Internal log flags&#13;&#10;&#13;&#10;To be able to make an own filter &#13;&#10;selection of data to be logged." Name="t_LogFlags"/>
	  [
	    1 LF_NONE,
	    2 LF_DEBUG_RT,
	    3 LF_DEBUG,
	    4 LF_INFO,
	    5 LF_WARNING,
	    6 LF_ERROR_APPLICATION,
	    7 LF_ERROR_INTERNAL,
	    8 LF_ERROR_CRITICAL,
	  ];
#pragma pack(push, 1)
	  t_RtLogData : STRUCT  //! <Type Comment="RealTime log data structure" Name="t_RtLogData"/>
	    RelLogTime : UDINT;
	    Id : UDINT;
	    Value : DINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_RtLogDataTable : ARRAY [0..5000] OF t_RtLogData;  //! <Type Comment="Define a table layout so we can view memory &#13;&#10;&#13;&#10;Be aware of table size in this structure. &#13;&#10;This is not the real used buffersize but just &#13;&#10;for debugging to view memory content &#13;&#10;&#13;&#10;The real size is allocated via RtNrOfLogEntries.&#13;&#10;&#13;&#10;We use &quot;extended allocated&quot; memory (Dynamic buffer) to be able using large memory (&gt; 64K) in a class" Name="t_RtLogDataTable"/>
	  t_RtLogState :  //! <Type Comment="States used for realtime datalogging" Name="t_RtLogState"/>
	  (
	    RT_LOG_IDLE,  //! <Type Comment="Wait for a command" Name="t_RtLogState.RT_LOG_IDLE"/>
	    RT_LOG_ERROR,
	    RT_LOG_ACTIVE,  //! <Type Comment="Realtime logging is active" Name="t_RtLogState.RT_LOG_ACTIVE"/>
	    RT_LOG_WAIT_FOR_STARTTRIGGER,  //! <Type Comment="Wait for specified trigger to start realtime logging" Name="t_RtLogState.RT_LOG_WAIT_FOR_STARTTRIGGER"/>
	    RT_LOG_WAIT_FOR_STOPTRIGGER,
	    RT_LOG_SAVE_TO_FILE  //! <Type Comment="Save realtime logging to file is active" Name="t_RtLogState.RT_LOG_SAVE_TO_FILE"/>
	  )$UDINT;
	END_TYPE
  //Servers:
	op_sfnObjChain 	: SvrCh_pVoid;
	MsgLogLevel 	: SvrCh_gt_LogLevel;
	MsgLogTarget 	: SvrCh_gt_LogTarget;
	o_MsgLogCnt 	: SvrCh_UDINT;
	RtLogBufMode 	: SvrCh_gt_FifoBufMode;
	ip_RtLogFile 	: SvrCh_pChar;
	o_rtLogDataCnt 	: SvrCh_UDINT;
	ip_LogData 	: SvrCh_gpt_LogData;
	InsertRtStartLogNr 	: SvrCh_DINT;
	Command 	: SvrCh_gt_LogCmd;
  //Clients:
	ToOsKernel 	: CltChCmd__OSKernel;
	ToSysMsg 	: CltChCmd__SysMsg;
	toEnumTranslator 	: CltChCmd_Wewo_EnumTranslator;
	c_FlushTime 	: CltCh_UDINT;
	c_RtNrOfLogEntries 	: CltCh_UDINT;
	Obj_RtLogDataBuffer 	: CltChCmd_Wewo_DynamicBuffer;
	o_RtTriggerEvent 	: CltCh_DINT;
	o_ErrorWarningEvent 	: CltCh_UDINT;
  //Variables:
		ActiveLogFlags 	: t_LogFlags;			//! <Variable Comment="Internal flags to select what should be logged.&#13;&#10;&#13;&#10;For debugging purpose we can change log bits also runtime to filter the specific messages&#13;&#10;" Name="ActiveLogFlags"/>
		timeLastNewMsg 	: UDINT;			//! <Variable Comment="Time of last received new message" Name="timeLastNewMsg"/>
		MsgInBuffer 	: BOOL;			//! <Variable Comment="Log message in message buffer" Name="MsgInBuffer"/>
		rtFlushDataCnt 	: UDINT;			//! <Variable Comment="Number of entries left to flush Realtime data logging to file" Name="rtFlushDataCnt"/>
		p_RtLogTable 	: ^t_RtLogDataTable;			//! <Variable Comment="Pointer to extended memory for storage of Realtime logdata.&#13;&#10;&#13;&#10;Be aware of table size in this structure. &#13;&#10;This is not the real used buffersize but just &#13;&#10;for debugging to view memory content &#13;&#10;&#13;&#10;The real size is allocated via RtNrOfLogEntries.&#13;&#10;&#13;&#10;We use &quot;extended allocated&quot; memory (Dynamic buffer) to be able using large memory (&gt; 64K) in a class" Name="p_RtLogTable"/>
		WrRtDataIdx 	: UDINT;			//! <Variable Comment="Actual entry index to write Realtime log data to buffer" Name="WrRtDataIdx"/>
		RdRtDataIdx 	: UDINT;			//! <Variable Comment="Actual entry index to Read Realtime log data from buffer" Name="RdRtDataIdx"/>
		RtLogState 	: t_RtLogState;			//! <Variable Comment="State of Real time data logging" Name="RtLogState"/>
		RtTriggerSetting 	: gt_RtLogTrigger;			//! <Variable Comment="Actual trigger setting used to determine a trigger event." Name="RtTriggerSetting"/>
		CmdRequest 	: gt_LogCmd;			//! <Variable Comment="Actual command/status request" Name="CmdRequest"/>
		StartDateRtLog 	: SYSDATE;
		StartTimeRtLog 	: SYSTIME;
		StartMsTimeRtLog 	: UDINT;			//! <Variable Comment="Abs time of first Rt message" Name="StartMsTimeRtLog"/>
		RtTaskMsgData 	: gt_LogData;			//! <Variable Comment="Temp. storage of message pointer.&#13;&#10;Message will be send to screen as soon as possible&#13;&#10;Note: if message string is not fixed but created by caller then the content could be overwritten.&#13;&#10;      So use only fixed message strings if called from a RealTime task." Name="RtTaskMsgData"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Constructor" Name="WewoLogger"/>
	FUNCTION WewoLogger
		VAR_OUTPUT
			ret_code 	: ConfStates;
		END_VAR;
	
	FUNCTION FlushLogMessage;
				//! <Function Comment="Handle state for Realtime logging." Name="HandleRtLogDataState"/>
	FUNCTION HandleRtLogDataState;
				//! <Function Comment="Handle received LogCommand" Name="HandleCommand"/>
	FUNCTION HandleCommand;
				//! <Function Comment="Set&apos;s the log level used to filter messages&#13;&#10;This can be either of the following ;&#13;&#10;- LL_NONE              ; no logging&#13;&#10;- LL_DEBUG             ; log debug, info, warning and error messages&#13;&#10;- LL_INFO              ; log information, warning and error messages&#13;&#10;- LL_WARNING           ; log warning and error messages&#13;&#10;- LL_ERROR APPLICATION : Log application error and other error messages&#13;&#10;- LL_ERROR INTERNAL    : log Internal and critical error messages &#13;&#10;- LL_ERROR CRITICAL    ; log only critical error messages&#13;&#10;                      &#13;&#10;Note: LL_DEBUG_RT will be modified to LL_DEBUG&#13;&#10;" Name="SetLogLevel"/>
	FUNCTION GLOBAL SetLogLevel
		VAR_INPUT
			NewLevel 	: gt_LogLevel;
		END_VAR;
				//! <Function Comment="Set target where to log." Name="SetMsgLogTarget"/>
	FUNCTION GLOBAL SetMsgLogTarget
		VAR_INPUT
			NewTarget 	: gt_LogTarget;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="Set flush time for message logging" Name="SetMsgLogFlushTime"/>
	FUNCTION GLOBAL SetMsgLogFlushTime
		VAR_INPUT
			NewFlushTime 	: UDINT;
		END_VAR;
				//! <Function Comment="Set Current File Path for Real time data logging" Name="SetRtLogFile"/>
	FUNCTION GLOBAL SetRtLogFile
		VAR_INPUT
			NewLogFile 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Reset logging message data &#13;&#10;Delete msglogfile and set all varibales &#13;&#10;and parameters to default" Name="ResetLogMsgData"/>
	FUNCTION VIRTUAL GLOBAL ResetLogMsgData;
				//! <Function Comment="Reset Realtime data logging, &#13;&#10;Delete file and set all varibales &#13;&#10;and parameters to default" Name="ResetLogRtData"/>
	FUNCTION VIRTUAL GLOBAL ResetLogRtData;
				//! <Function Comment="Install Log buffer for realtime logging" Name="InstallRealtimeLogBuffer"/>
	FUNCTION InstallRealtimeLogBuffer;
				//! <Function Comment="Set trigger condition for realtime data logging" Name="SetTriggerRtLog"/>
	FUNCTION GLOBAL SetTriggerRtLog
		VAR_INPUT
			p_SetTrigger 	: ^gt_RtLogTrigger;
		END_VAR;
				//! <Function Comment="Get actual Realtime log trigger settings" Name="GetTriggerRtLog"/>
	FUNCTION GLOBAL GetTriggerRtLog
		VAR_INPUT
			p_GetTrigger 	: ^gt_RtLogTrigger;
		END_VAR;
				//! <Function Comment="Increment log index for realtime LogDataBuffer and handle wrap around" Name="IncRtLogIdx"/>
	FUNCTION IncRtLogIdx
		VAR_INPUT
			p_Idx 	: ^UDINT;
		END_VAR;
				//! <Function Comment="Calculate first Index to read from realtime LogDataBuffer" Name="GetFirstStoredRtLogEntry"/>
	FUNCTION GetFirstStoredRtLogEntry
		VAR_OUTPUT
			FirstIdx 	: UDINT;
		END_VAR;
				//! <Function Comment="Write header of Realtime log file" Name="WriteHeaderRtLog"/>
	FUNCTION WriteHeaderRtLog;
	
	FUNCTION WriteHeaderVariableNames;
				//! <Function Comment="Log Message data to OS used by message logging." Name="_WriteMessageData"/>
	FUNCTION _WriteMessageData
		VAR_INPUT
			p_LogData 	: gpt_LogData;
		END_VAR;
				//! <Function Comment="Log Realtime data to internal RAM buffer&#13;&#10;If logging is not active yet, trigger must be &#13;&#10;found first&#13;&#10;" Name="_WriteRtLogData"/>
	FUNCTION _WriteRtLogData
		VAR_INPUT
			p_LogData 	: gpt_LogData;
		END_VAR;
				//! <Function Comment="Registrate SFN_Objects.&#13;&#10;- Add objects in chain" Name="RegistrateWewoObject"/>
	FUNCTION RegistrateWewoObject
		VAR_INPUT
			p_RegObj 	: ^WewoBase;			//! <Variable Comment="object to register" Name="RegistrateWewoObject.p_RegObj"/>
		END_VAR;
	
	FUNCTION WriteStringEnumValue
		VAR_INPUT
			enumTableId 	: UDINT;			//! <Variable Comment="Select enum table " Name="WriteStringEnumValue.enumTableId"/>
			enumValueId 	: DINT;			//! <Variable Comment="select enumValue to be translated" Name="WriteStringEnumValue.enumValueId"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MsgLogLevel::Write
		VAR_INPUT
			input (EAX) 	: gt_LogLevel;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: gt_LogLevel;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ip_LogData::Write
		VAR_INPUT
			input (EAX) 	: gpt_LogData;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: gpt_LogData;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL InsertRtStartLogNr::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Command::Write
		VAR_INPUT
			input (EAX) 	: gt_LogCmd;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: gt_LogCmd;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using Wewo_DynamicBuffer
#pragma usingLtd _OSKernel
#pragma usingLtd _SysMsg
#pragma usingLtd Wewo_EnumTranslator


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB WewoLogger::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_WEWOLOGGER
0$UINT, 8$UINT, (SIZEOF(::WewoLogger))$UINT, 
10$UINT, 8$UINT, 0$UINT, 
TO_UDINT(413350294), "WewoLogger", //Class
TO_UDINT(3477584769), "WewoFileBase", 0$UINT, 4$UINT, //Baseclass
//Servers:
(::WewoLogger.op_sfnObjChain.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3905252583), "op_sfnObjChain", 
(::WewoLogger.MsgLogLevel.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(3946555353), "MsgLogLevel", 
(::WewoLogger.MsgLogTarget.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(113374705), "MsgLogTarget", 
(::WewoLogger.o_MsgLogCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3341450102), "o_MsgLogCnt", 
(::WewoLogger.RtLogBufMode.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(494430632), "RtLogBufMode", 
(::WewoLogger.ip_RtLogFile.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1733228662), "ip_RtLogFile", 
(::WewoLogger.o_rtLogDataCnt.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3169142962), "o_rtLogDataCnt", 
(::WewoLogger.ip_LogData.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1378158118), "ip_LogData", 
(::WewoLogger.InsertRtStartLogNr.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1303040552), "InsertRtStartLogNr", 
(::WewoLogger.Command.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2978944206), "Command", 
//Clients:
(::WewoLogger.ToOsKernel.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(2889244023), "ToOsKernel", TO_UDINT(3045737964), "_OSKernel", 0$UINT, 5$UINT, 
(::WewoLogger.ToSysMsg.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1640010845), "ToSysMsg", TO_UDINT(792524216), "_SysMsg", 0$UINT, 0$UINT, 
(::WewoLogger.toEnumTranslator.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3842874503), "toEnumTranslator", TO_UDINT(195451389), "Wewo_EnumTranslator", 0$UINT, 0$UINT, 
(::WewoLogger.c_FlushTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(1421458372), "c_FlushTime", 
(::WewoLogger.c_RtNrOfLogEntries.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1178822798), "c_RtNrOfLogEntries", 
(::WewoLogger.Obj_RtLogDataBuffer.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3722184121), "Obj_RtLogDataBuffer", TO_UDINT(1418958529), "Wewo_DynamicBuffer", 0$UINT, 5$UINT, 
(::WewoLogger.o_RtTriggerEvent.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(544141059), "o_RtTriggerEvent", 
(::WewoLogger.o_ErrorWarningEvent.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3335315976), "o_ErrorWarningEvent", 
END_FUNCTION


#define USER_CNT_WewoLogger 14

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_WewoLogger] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION WewoLogger::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= WewoFileBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= WewoBase::ToObject.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, WewoBase::ToObject.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_WewoLogger;
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #ResetLogMsgData();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #ResetLogRtData();

#pragma warning (default : 74)
	WewoBase::ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF WewoBase::ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MsgLogLevel.pMeth			:= StoreMethod( #M_RD_DIRECT(), #MsgLogLevel::Write() );
	IF MsgLogLevel.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MsgLogTarget.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF MsgLogTarget.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	RtLogBufMode.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF RtLogBufMode.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ip_RtLogFile.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ip_RtLogFile.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ip_LogData.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ip_LogData::Write() );
	IF ip_LogData.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	InsertRtStartLogNr.pMeth			:= StoreMethod( #M_RD_DIRECT(), #InsertRtStartLogNr::Write() );
	IF InsertRtStartLogNr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Command.pMeth			:= StoreMethod( #M_RD_DIRECT(), #Command::Write() );
	IF Command.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ret_code	:= WewoLogger();

END_FUNCTION

#pragma usingLtd WewoBase

//{{LSL_IMPLEMENTATION
(***************************************************************
  CLASS              WewoLogger

  Description:       Handles data logging.
                     Connected classes can log their logdata via this class.
                     The target of the log data can be configured
                   
***************************************************************)

#define MESSAGE_LOG_STRING_SIZE         512                          // Maximum size of message string
#define UDINT_LOG_STRING_SIZE           12                           // Maximum size of udint string 

#define MSGLOG_FILENAME                 "C:\SYSMSG\EVENT01.LOG"      // Name and location is hardcoded defined in OS system
#define DEFAULT_RTLOG_FILENAME          "C:\SYSMSG\RT_DEBUG.LOG"     // WARNING Nr of rewrites to Flash area is limitted
                                                                     // Use a RAM drive in stead

#define DEFAULT_FLUSHTIME               60000                        // Defaulttime to flush Log Messages to file 
                                                                     // Unit: Miliseconds
#define HIGHEST_LEVEL                   LL_ERROR_CRITICAL

#define CONVERT_LOG_LEVEL_2_FLAG(lvl)   ( (1 ROL ((lvl) $ UDINT)) $ t_LogFlags )
#define GET_RT_LOGENTRY(idx)            ((p_RtLogTable+((idx) * sizeof(t_RtLogData)) ) $ ^t_RtLogData)


(***************************************************************
WewoLogger::WewoLogger

Description:       Constructor
                   
Parameter:         -
Return:            -
***************************************************************)
FUNCTION WewoLogger::WewoLogger
	VAR_OUTPUT
		ret_code 	: ConfStates;
	END_VAR

  o_MsgLogCnt   := 0;             // Restart counter on startup only
  op_sfnObjChain := NIL;
  
  // Read retentive server channels
  // (Channels which have stored the last used setting in SRAM)
  
  // General logsettings (also available on startup)
  MsgLogLevel := MsgLogLevel.Read();
  MsgLogLevel.Write(input:=MsgLogLevel); 

  MsgLogTarget := MsgLogTarget.Read();
  MsgLogTarget.Write(input:=MsgLogTarget);

	ret_code      := C_OK;

END_FUNCTION

(***************************************************************
WewoLogger::Init

Description:       Initialization of default file path
                   
Parameter:         -
Return:            -
***************************************************************)
FUNCTION VIRTUAL GLOBAL WewoLogger::Init
  VAR
  	BufSize : UDINT;
  END_VAR

  WewoFileBase::Init();
  
  ObjectStatus.DebugRtLogEnabled := 0;                         // Disable Realtime logging

  // Calculate buffersize 
  c_RtNrOfLogEntries := c_RtNrOfLogEntries.Read();
  
  if c_RtNrOfLogEntries = 0 then
    c_RtNrOfLogEntries := 1;
    
  end_if;
  
  BufSize            := c_RtNrOfLogEntries*sizeof(t_RtLogData) ;
  Obj_RtLogDataBuffer.BufferSize.Write(input:=BufSize);
  
  // Initialize only once just after Dynamic buffer is initialised
  if (initCnt = 3) then 
    
    // Get actual LogBuffer mode
    RtLogBufMode := RtLogBufMode.Read();
    RtLogBufMode.Write(input:=RtLogBufMode);
    
    // LogMessage buffer
    MsgInBuffer := FALSE;                                       // No log messages send to OS logger
    
    // Realtime LogDatabuffer
    ip_RtLogFile := ip_RtLogFile.Read();
    if ip_RtLogFile = NIL then
      ip_RtLogFile := DEFAULT_RTLOG_FILENAME;
      
    end_if;

    ip_RtLogFile.Write(input:=ip_RtLogFile);

    InstallRealtimeLogBuffer();

    RtTriggerSetting.Control := 0;
    RtTriggerSetting.Id      := 0;
    RtTriggerSetting.Value   := 0;

    // We don't write to client to avoid sending an event signal    
    o_RtTriggerEvent         := 0;
    o_ErrorWarningEvent      := MSGID_NONE;

    
    RtLogState               := RT_LOG_IDLE;
    
    c_FlushTime := c_FlushTime.Read();
    SetMsgLogFlushTime(NewFlushTime:=c_FlushTime);    

    Command := Command.Read();
    Command.Write(input:=Command);
    
  elsif (initCnt = 12) then
    toEnumTranslator := toEnumTranslator.Read();
  
  end_if;
  
END_FUNCTION



(***************************************************************
WewoLogger::Background

Description: Autmatic flush log messages to log file
                  
Parameter:   -
                   
Return:     -
***************************************************************)
FUNCTION VIRTUAL GLOBAL WewoLogger::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

  HandleCommand();

  // Handle Log messages
  if RtTaskMsgData.p_ObjName <> NIL then
    // Handled stored RT_logging
    _WriteMessageData(p_LogData:= #RtTaskMsgData);
    RtTaskMsgData.p_ObjName := NIL;
  end_if;

  if MsgInBuffer then
    // System msg available in OS msg buffer
    if ( (ops.tAbsolute - timeLastNewMsg) > c_FlushTime ) then
      // Flush timer has elapsed, Flush buffer (store in logfile)
      FlushLogMessage();
      
    end_If;
  
  end_if;

  // Handle Log Realtime Data
  HandleRtLogDataState();

	state := READY;

END_FUNCTION



FUNCTION WewoLogger::HandleRtLogDataState

  VAR
		p_RtLogEntry 	: ^t_RtLogData;
    
    str         : Array [0..50] of CHAR;
    CloseStr    : Array [0..10] of CHAR;
    blockCnt    : UDINT;
  END_VAR

  case RtLogState of
    RT_LOG_IDLE:
    RT_LOG_ERROR:                   
    
    RT_LOG_ACTIVE:                  // Statetransition handled in WriteRtData()
    RT_LOG_WAIT_FOR_STARTTRIGGER:   // Statetransition handled in WriteRtData()
    RT_LOG_WAIT_FOR_STOPTRIGGER:    // Statetransition handled in WriteRtData()
    
    
    RT_LOG_SAVE_TO_FILE:
      blockCnt    := 0;
      
      CloseStr[0] := cCR;
      CloseStr[1] := cLF;
      CloseStr[2] := 0;

      // Rt LogData
      while ( rtFlushDataCnt > 0 ) do
        // Data in Rt logtable
        
        p_RtLogEntry := GET_RT_LOGENTRY(RdRtDataIdx);

        _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=p_RtLogEntry^.RelLogTime);
        WriteString(p_String:=#str[0], Flush:=FALSE);
        WriteChar(c:=';', Flush:=FALSE);

        _ObjStr.ConvertUDintToAsciiDec(p_string:=#str[0], Value:=p_RtLogEntry^.Id);
        WriteString(p_String:=#str[0], Flush:=FALSE);
        WriteChar(c:=';', Flush:=FALSE);

        _ObjStr.ConvertDintToAsciiDec(p_string:=#str[0], Value:=p_RtLogEntry^.Value);
        WriteString(p_String:=#str[0], Flush:=FALSE);
        
        WriteChar(c:=';', Flush:=FALSE);
        WriteChar(c:=';', Flush:=FALSE);
        
        WriteStringEnumValue(enumTableId:=p_RtLogEntry^.Id, enumValueId:=p_RtLogEntry^.Value);
        
        WriteString(p_String:=#CloseStr[0], Flush:=FALSE);
                
        IncRtLogIdx(p_Idx := #RdRtDataIdx);
        rtFlushDataCnt -= 1;
        blockCnt       += 1;
        if blockCnt > 100 then
          // Temp stop writing to give other tasks resource time
          exit;
          
        end_if;

      end_while;

      // Flush prepared data to file
      FlushFileBuffer();
      
      If ( rtFlushDataCnt = 0 ) then
        // All entries flushed
        CloseFile();
        RtLogState    := RT_LOG_IDLE;
        CmdRequest    := LOGCMD_IDLE;

      end_if;
        
  end_case;

END_FUNCTION


FUNCTION WewoLogger::WriteStringEnumValue
	VAR_INPUT
		enumTableId 	: UDINT;
		enumValueId 	: DINT;
	END_VAR
  
  VAR
  	columnIdx : UDINT;
    p_string  : ^CHAR;
    str       : Array [0..50] of CHAR;
    
  END_VAR

  if enumTableId = RT_LOG_ID_INSERT_START_LOG_NR then
    // Entry contain RtStartLogNr
    WriteString(p_String:="StartLogNr", Flush:=FALSE);

  else
    // Other Entries
    
    // Write variable Id 
    p_string := toEnumTranslator.GetVarName(enumListId:=enumTableId);
    if p_string <> NIL then
      // Write Id as a variableName string 
      WriteString(p_String:=p_string, Flush:=FALSE);

    else
      // Write Id
      _ObjStr.ConvertUDintToAsciiDec(p_string:=#str[0], Value:=enumTableId);
      WriteString(p_String:=#str[0], Flush:=FALSE);
    
    end_if;
  end_if;

  WriteChar(c:=';', Flush:=FALSE);

  // Get pointer to enumstring and get columnIdx
  p_string := toEnumTranslator.TranslateEnumText(enumListId:=enumTableId, enumId:=enumValueId, p_columnIdx:=#columnIdx);
  if p_string <> NIL then
    // Msg value String found
    WriteString(p_String:=p_string, Flush:=FALSE);
  else
    // Write Id
    _ObjStr.ConvertDintToAsciiDec(p_string:=#str[0], Value:=enumValueId);
    WriteString(p_String:=#str[0], Flush:=FALSE);
  
  end_if;

  WriteChar(c:=';', Flush:=FALSE);
  
  // Write ';' until requested column is reached
  while (columnIdx > 0) do
    WriteChar(c:=';', Flush:=FALSE);
    columnIdx -= 1;
    
  end_while;

  p_string := toEnumTranslator.TranslateEnumText(enumListId:=enumTableId, enumId:=enumValueId, p_columnIdx:=#columnIdx);
  if p_string <> NIL then
    // String found
    WriteString(p_String:=p_string, Flush:=FALSE);
  end_if;

END_FUNCTION


FUNCTION WewoLogger::HandleCommand

  case CmdRequest of
  
    LOGCMD_IDLE:
      // No command running
      
    LOGCMD_BUSY:
      // Check if actual command is finished.

    LOGCMD_ERROR:
      // Previous command failed
    LOGCMD_TEST_MSG_LOG:
      WriteLogMessage(msgId:=0, LogLevel:=LL_ERROR_APPLICATION, p_msg:="Test Error log message", rtCall:= FALSE);
      CmdRequest                  := LOGCMD_IDLE;
    
    LOGCMD_FLUSH_MSG_LOG:
      WriteLogMessage(msgId:=0, LogLevel:=LL_INFO, p_msg:="Manual flush buffer", rtCall:= FALSE);
      FlushLogMessage();
      CmdRequest                  := LOGCMD_IDLE;
    
    LOGCMD_START_RT_LOG:
      RtLogState                  := RT_LOG_ACTIVE;
      ActiveLogFlags.LF_DEBUG_RT  := 1;
      ResetLogRtData();
      // use actual setting for RtLogBufMode 
      
      CmdRequest                  := LOGCMD_IDLE;
      
    LOGCMD_STARTTRIGGER_RT_LOG:
      RtLogState                  := RT_LOG_WAIT_FOR_STARTTRIGGER;
      RtLogBufMode                := FIFOBUFMODE_ONCE;
      ActiveLogFlags.LF_DEBUG_RT  := 1;
      ResetLogRtData();
      CmdRequest                  := LOGCMD_IDLE;
    
    LOGCMD_STOPTRIGGER_RT_LOG:
      RtLogState                  := RT_LOG_WAIT_FOR_STOPTRIGGER;
      RtLogBufMode                := FIFOBUFMODE_CYCLIC;
      ActiveLogFlags.LF_DEBUG_RT  := 1;
      ResetLogRtData();
      CmdRequest                  := LOGCMD_IDLE;
    
    LOGCMD_STOP_RT_LOG:
      RtLogState                  := RT_LOG_IDLE;
      ActiveLogFlags.LF_DEBUG_RT  := 0;
      CmdRequest                  := LOGCMD_IDLE;
    
    LOGCMD_SENDFILE_RT_LOG:
      if OpenFile(p_FileName:= ip_RtLogFile, FileMode:=ATT_CREATE) = PASSED then
        // File created successfully
        RdRtDataIdx               := GetFirstStoredRtLogEntry();
        rtFlushDataCnt            := o_rtLogDataCnt;
        RtLogState                := RT_LOG_SAVE_TO_FILE;
        CmdRequest                := LOGCMD_BUSY;
        
        WriteHeaderRtLog();
        
      else
        CmdRequest                := LOGCMD_ERROR;
      
      end_if;
      
    LOGCMD_RESET:
      ResetLogMsgData();
      ResetLogRtData();
      RtLogState                  := RT_LOG_IDLE;

      CmdRequest                  := LOGCMD_IDLE;
      
  else 
    CmdRequest                    := LOGCMD_ERROR;
  
  end_case;

  if CmdRequest <> Command then
    // Command request has been changed
    // Update command if it is a status 
    case CmdRequest of
    
      LOGCMD_IDLE, LOGCMD_BUSY, LOGCMD_ERROR:
        Command := CmdRequest;
    end_case;
  
  end_if;


END_FUNCTION


// Write header of Realtime log file
FUNCTION WewoLogger::WriteHeaderRtLog

  VAR
    str         : Array [0..50] of CHAR;
  END_VAR

  WriteString(p_String:="Wewo (c)", Flush:=FALSE);
  WriteChar(c:=cCr, Flush:=FALSE);
  WriteChar(c:=cLf, Flush:=FALSE);

  WriteString(p_String:="RealTime Data Logging", Flush:=FALSE);
  WriteChar(c:=cCr, Flush:=FALSE);
  WriteChar(c:=cLf, Flush:=FALSE);
  
  WriteString(p_String:="Start LogTime: ", Flush:=FALSE);

  // Start Write Date/time
  _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=to_Udint(StartDateRtLog.wYear));
  WriteString(p_String:=#str[0], Flush:=FALSE);
  WriteChar(c:=':', Flush:=FALSE);

  _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=to_Udint(StartDateRtLog.wMonth));
  WriteString(p_String:=#str[0], Flush:=FALSE);
  WriteChar(c:=':', Flush:=FALSE);
  
  _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=to_Udint(StartDateRtLog.wDay));
  WriteString(p_String:=#str[0], Flush:=FALSE);
  WriteChar(c:=' ', Flush:=FALSE);

  _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=to_Udint(StartTimeRtLog.wHour));
  WriteString(p_String:=#str[0], Flush:=FALSE);
  WriteChar(c:=':', Flush:=FALSE);

  _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=to_Udint(StartTimeRtLog.wMinute));
  WriteString(p_String:=#str[0], Flush:=FALSE);
  WriteChar(c:=':', Flush:=FALSE);
  
  _ObjStr.ConvertUdintToAsciiDec(p_string:=#str[0], Value:=to_Udint(StartTimeRtLog.wSecond));
  WriteString(p_String:=#str[0], Flush:=FALSE);
  WriteChar(c:=cCr, Flush:=FALSE);
  WriteChar(c:=cLf, Flush:=FALSE);
  
  WriteChar(c:=cCr, Flush:=FALSE);
  WriteChar(c:=cLf, Flush:=FALSE);
  // End Write Date/time
  
  WriteString(p_String:="RelTime; VarId; Value;;VarId;Value;", Flush:=FALSE);
  
  WriteHeaderVariableNames();
  
  WriteChar(c:=cCR, Flush:=FALSE);
  WriteChar(c:=cLF, Flush:=FALSE);


END_FUNCTION


FUNCTION WewoLogger::WriteHeaderVariableNames
  VAR
    idx : UDINT; 
    maxIdx : UDINT;
    p_string : ^CHAR;
  END_VAR 

  maxIdx := toEnumTranslator.o_NrOfObjectsInList.Read();

  idx := 1;
  while idx <= maxIdx do
    WriteChar(c:=';', Flush:=FALSE);

    p_string := toEnumTranslator.GetVarNameBasedOnColumnIdx(columnIdx:=idx);
    if p_string <> NIL then
      WriteString(p_String:=p_string, Flush:=FALSE);
      
    end_if;

    idx += 1;
    
  end_while;

END_FUNCTION




(***************************************************************
WewoLogger::SetLogLevel

Description:       Set's the log level used to filter messages
                   This can be either of the following ;
                      - LL_NONE              ; no logging
                      - LL_DEBUG             ; log debug, info, warning and error messages
                      - LL_INFO              ; log information, warning and error messages
                      - LL_WARNING           ; log warning and error messages
                      - LL_ERROR_APPLICATION : Log application error and other error messages
                      - LL_ERROR_INTERNAL    : log Internal and critical error messages 
                      - LL_ERROR_CRITICAL    ; log only critical error messages
                      
Note:              LL_DEBUG_RT will be modified to LL_DEBUG
                   
Parameter:         NewLevel is the new log priority to use


Return:            -
***************************************************************)
FUNCTION GLOBAL WewoLogger::SetLogLevel
	VAR_INPUT
		NewLevel 	: gt_LogLevel;
	END_VAR

  // set log priority
  MsgLogLevel.Write(NewLevel);  

END_FUNCTION


(***************************************************************
WewoLogger::SetMsgLogTarget

Description:       Set target where to log.
                   This can be a File and/or Screen
                   
Parameter:         NewTarget is the target to use for the next log action. 
Return:            Result is -1 when no file path has been set and Target is FILE
***************************************************************)
FUNCTION GLOBAL WewoLogger::SetMsgLogTarget
	VAR_INPUT
		NewTarget 	: gt_LogTarget;
	END_VAR
	VAR_OUTPUT
		Result 	: DINT;
	END_VAR
  
  Result := 0;
  
  // set log target
  MsgLogTarget.Write(NewTarget);
  
  
  if (MsgLogTarget <> NewTarget) then
    
    Result := -1;
  end_if;

END_FUNCTION


(***************************************************************
WewoLogger::SetRtLogFile

Description:       Set Current File Path for Real time data logging
                   
Parameter:         NewFilePath the file path to use
Return:            -
***************************************************************)
FUNCTION GLOBAL WewoLogger::SetRtLogFile
	VAR_INPUT
		NewLogFile 	: ^CHAR;
	END_VAR
 
  ip_RtLogFile.Write(input:=NewLogFile);

END_FUNCTION


(***************************************************************
WewoLogger::SetMsgLogFlushTime

Description:       Set flush time for message logging
                   
Parameter:         NewFilePath the file path to use
Return:            -
***************************************************************)
FUNCTION GLOBAL WewoLogger::SetMsgLogFlushTime
	VAR_INPUT
		NewFlushTime 	: UDINT;
	END_VAR

  c_FlushTime := NewFlushTime;

  if c_FlushTime = 0 then
    c_FlushTime := DEFAULT_FLUSHTIME;
    
  end_if;

END_FUNCTION


(***************************************************************
WewoLogger::ResetLogMsgData

Description:       Reset logging message data 
                   Delete msglogfile and set all varibales 
                   and parameters to default
                   
                   
Parameter:         -
Return:            -
***************************************************************)
FUNCTION VIRTUAL GLOBAL WewoLogger::ResetLogMsgData
  
  // set logger values, defaults: logging prio NONE, target SCREEN 
  o_MsgLogCnt := 0;
  
  // We don't write to client to avoid sending an event signal    
  o_ErrorWarningEvent:= MSGID_NONE;
  
  ToFileSys.FileDelete(filename:= MSGLOG_FILENAME);
  ///
END_FUNCTION

(***************************************************************
WewoLogger::ResetLogRtData

Description:       Reset Realtime data logging, 
                   Delete file and set all varibales and parameters to default.
                   
Parameter:         -
Return:            -
***************************************************************)
FUNCTION VIRTUAL GLOBAL WewoLogger::ResetLogRtData
 
  StartMsTimeRtLog   := 0;
  o_rtLogDataCnt     := 0;
  WrRtDataIdx        := 0;
  rtFlushDataCnt     := 0;

  // We don't write to client to avoid sending an event signal    
  o_RtTriggerEvent := 0;
  
  _memset(dest:=#StartDateRtLog, usByte:=0, cntr:=sizeof(StartDateRtLog));
  _memset(dest:=#StartTimeRtLog, usByte:=0, cntr:=sizeof(StartTimeRtLog));
  
  // Clear buffer
  Obj_RtLogDataBuffer.ResetBuffer();

  ToFileSys.FileDelete(filename:= ip_RtLogFile);

END_FUNCTION

(***************************************************************
WewoLogger::InstallRealtimeLogBuffer

Description:       Retrieve information of connected buffers
                   
Parameter:         -
Return:            -
***************************************************************)
FUNCTION WewoLogger::InstallRealtimeLogBuffer

  VAR
    ptr : pVoid;
  END_VAR

  ptr            := Obj_RtLogDataBuffer.GetBufferPointer();
  p_RtLogTable   := (ptr $ ^t_RtLogDataTable);

  if p_RtLogTable = NIL then
    WriteActiveErrorWarning(IntErrorWarningId:= MSGID_MEM_ALLOC,
                            LogLevel         := LL_ERROR_APPLICATION, 
                            p_msg            := "WewoLogger::InstallRealtimeLogBuffer Not enough memory for Realtime LogBuffer"
                           );
   
  end_if;
  
  ResetLogRtData();

END_FUNCTION



(***************************************************************
WewoLogger::ip_LogData::Write

Description:       Handles log requests.
                  
Parameter:         Pointer to LogData.
                   
Return:            -
***************************************************************)
FUNCTION VIRTUAL GLOBAL WewoLogger::ip_LogData::Write
	VAR_INPUT
		input (EAX) 	: gpt_LogData;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: gpt_LogData;
	END_VAR

  VAR
    flag      : t_LogFlags;
  END_VAR

	ip_LogData := input;
  
  if (ip_LogData  <> NIL) then
  
    if (ip_LogData^.LogLevel = LL_NONE) then
      // No Logging
      // Check if it is data for an object registration.
      if ( ip_LogData^.Id        = REGISTER_WEWO_OBJECT ) then
        // Registration message detected
        RegistrateWewoObject(p_RegObj:=ip_LogData^.dValue $^WewoBase);

      end_if;
    
    else
      // Logging Data
      flag := CONVERT_LOG_LEVEL_2_FLAG(ip_LogData^.LogLevel);
      
      if (flag.LF_DEBUG_RT  L_AND ActiveLogFlags.LF_DEBUG_RT) then
        // An active Realtime debug logging
        _WriteRtLogData(p_LogData := ip_LogData);
      
      elsif (flag B_AND ActiveLogFlags) then   
        // An active message logging
        
        if ip_LogData^.rtCall = FALSE then
          // Write Message is called outside a RT-task

          // Be sure first stored message is handled before 
          if RtTaskMsgData.p_ObjName <> NIL then
            TRACE("Delayed logged message from a RealTime task:");
            _WriteMessageData(p_LogData := #RtTaskMsgData);
            
            RtTaskMsgData.p_ObjName:=NIL;
          end_if;
          
          _WriteMessageData(p_LogData := ip_LogData);

        else
          // Write Message is called inside a RT-task
          // Store message and handle it as soon as possible outside RT-task
          // Note: if message string is not fixed but created by caller then 
          //       the content could be overwritten.
          //       So use only fixed message strings if called from a RealTime task.
          if RtTaskMsgData.p_ObjName = NIL then
            // One RT task message was logged, try to safe message to handle later.
            _memcpy(ptr1:=#RtTaskMsgData, ptr2:=ip_LogData, cntr:=sizeof(gt_LogData));
          
          else
            // Multiple RT-task messages received. Unfortunatly we have no mechanism 
            // to store all messages so we indicate this by showing this message.
            // Note: Other log data of first unhandled message is unchanged
            RtTaskMsgData.p_Msg := "WewoLogger: Missed multiple Realtime task log messages";
          
          end_if;
                   
        end_if;
                
        
      end_if;  
    
      if ip_LogData^.LogLevel > LL_WARNING then
        // Error detected, Send event
        o_ErrorWarningEvent := ip_LogData^.Id;
        o_ErrorWarningEvent.Write(input:=o_ErrorWarningEvent);
        
      end_if;

    end_if;
    
  end_if;
  
 	result := ip_LogData;

END_FUNCTION



(***************************************************************
WewoLogger::_WriteRtData

Description:       Log Realtime data to internal RAM buffer
                   If logging is not active yet, trigger must be 
                   found first
                   
Parameter:         Pointer to realtime LogData.
Return:            -
***************************************************************)
FUNCTION WewoLogger::_WriteRtLogData
	VAR_INPUT
		p_LogData 	: gpt_LogData;
	END_VAR

  VAR
    LogTime     : UDINT;  
    p_RtLogEntry: ^t_RtLogData;
    WrIdx       : UDINT;
    LogDataFlag : BOOL;           // LogData trigger flag
  END_VAR


  if (p_RtLogTable <> NIL) then
    // LogTable Available
    
    LogDataFlag := (    ( RtLogState = RT_LOG_ACTIVE )                // Realtime Logging is active, No Stop triggers condition is used
                   L_OR ( RtLogState = RT_LOG_WAIT_FOR_STOPTRIGGER )  // Realtime Logging is active, Stop trigger condition is used
                   );
    
    if ( RtLogState = RT_LOG_WAIT_FOR_STARTTRIGGER ) then
      // check for start trigger condition

      // Trigger condition LogId
      LogDataFlag := (    (RtTriggerSetting.Control.EnableId = 0)                     // Trigger not based on LogId
                     L_OR (p_LogData^.Id                     = RtTriggerSetting.Id)   // LogId matches the condition
                     );
      
      
      // Trigger condition LogValue
      if (      ( RtTriggerSetting.Control.EnableValueEqual  = 0 )
         L_AND  ( RtTriggerSetting.Control.EnableValueLower  = 0 )
         L_AND  ( RtTriggerSetting.Control.EnableValueHigher = 0 )
         ) then
         // No trigger condition based on LogValue
         
      else
        // Trigger condition also based on LogValue
        
        
        LogDataFlag := (     LogDataFlag
                       L_AND (    (RtTriggerSetting.Control.EnableValueEqual ) L_AND (p_LogData^.dValue = RtTriggerSetting.Value)
                             L_OR (RtTriggerSetting.Control.EnableValueLower ) L_AND (p_LogData^.dValue < RtTriggerSetting.Value)
                             L_OR (RtTriggerSetting.Control.EnableValueHigher) L_AND (p_LogData^.dValue > RtTriggerSetting.Value)
                             )
                       );
      
      end_if;
      
      if LogDataFlag then
        // Trigger active, change state to active logging logging
        RtLogState := RT_LOG_ACTIVE;
        
        // Send trigger event
        o_RtTriggerEvent := 1;
        o_RtTriggerEvent.Write(input:=o_RtTriggerEvent);
        
      end_if;

    end_if;

    if ( LogDataFlag ) then
      // Realtime Logging is active  
    
      if (      (o_rtLogDataCnt < c_RtNrOfLogEntries)   // BufferMode ONCE and table not full
           L_OR (RtLogBufMode = FIFOBUFMODE_CYCLIC)     // Buffermode Cyclic
         ) then
        // LogEntry available
        LogTime := OS_ReadMicroSec();
        
        if StartMsTimeRtLog = 0 then
          // Start logging
          StartMsTimeRtLog := LogTime;
          
          ToOsKernel.GetSystemDate(datestruct:=#StartDateRtLog);
          ToOsKernel.GetSystemTime(timestruct:=#StartTimeRtLog);
          
        end_if;

        // Allocate entry for this message
        WrIdx       := WrRtDataIdx;               
        IncRtLogIdx(p_Idx:= #WrRtDataIdx);                // Set entry for next RtLogData
        
        // Calculate entry memory location
        p_RtLogEntry        := GET_RT_LOGENTRY(WrIdx);
        
        // Copy entry data
        p_RtLogEntry^.Id    := p_LogData^.Id;
        p_RtLogEntry^.Value := p_LogData^.dValue;
        
        if ( LogTime >= StartMsTimeRtLog) then
          //  No wrap around detected in timer
          p_RtLogEntry^.RelLogTime := LogTime - StartMsTimeRtLog;
        else 
          // Wrap around detected in timer
          p_RtLogEntry^.RelLogTime := LogTime + (16#FFFFFFFF - StartMsTimeRtLog);
        end_if;
       
        // Data stored in buffer succesfully
        if o_rtLogDataCnt < c_RtNrOfLogEntries then
          // Limit max nr of entries to table size
          o_rtLogDataCnt += 1;
        
        end_if;

        if ( RtLogState = RT_LOG_WAIT_FOR_STOPTRIGGER ) then
          // check for stop trigger condition
          LogDataFlag := (    (RtTriggerSetting.Control.EnableId = 0) 
                         L_OR (p_LogData^.Id                  = RtTriggerSetting.Id)
                         );
          
          LogDataFlag := (     LogDataFlag
                         L_AND (    (RtTriggerSetting.Control.EnableValueEqual = 0) 
                               L_OR (p_LogData^.dValue                 = RtTriggerSetting.Value)
                               )
                         );
            
          if LogDataFlag then
            // Trigger active, Stop logging
            RtLogState := RT_LOG_IDLE;
            
            // Send trigger event
            o_RtTriggerEvent := 1;
            o_RtTriggerEvent.Write(input:=o_RtTriggerEvent);
            
          end_if;

        end_if;
      
      else
        // No more LogEntry available, Stop logging
        RtLogState := RT_LOG_IDLE;
          
      end_if;
    
    end_if;
  else
    WriteActiveErrorWarning(IntErrorWarningId:= MSGID_BUFFER,
                            LogLevel         := LL_ERROR_INTERNAL, 
                            p_msg            := "_WriteRtData: No Realtime logbuffer available"
                           );
    
  end_if;
  
END_FUNCTION


(***************************************************************
WewoLogger::_WriteMessageData

Description:       Log Message data to OS
                   
Parameter:         Pointer to realtime LogData.
Return:            -
Note:              Because we use 2 seperate log calls to write 
                   to file and screen the timestamp could differ  
                   a view ms.
***************************************************************)
FUNCTION WewoLogger::_WriteMessageData
	VAR_INPUT
		p_LogData 	: gpt_LogData;
	END_VAR
  
  VAR
    LogString   : array [0 .. MESSAGE_LOG_STRING_SIZE] of CHAR;
    udintString : array [0 .. 12] of CHAR;
  END_VAR

  // Log Id.
  // Format of (Error/Warning) Message Id =  0GGGLMMMMM   (decimal)
  //           M = Message id 
  //           L = Level = cirtical error, application error, internal error or warning
  //           G = Group = part of application object is used for.
  LogString[0] := 0;

  _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="MsgId: ",           DestSize:=MESSAGE_LOG_STRING_SIZE);
  _ObjStr.ConvertUdintToAsciiDec(p_string:=#udintString[0], Value:=p_LogData^.Id);
  _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:=#udintString[0],      DestSize:=MESSAGE_LOG_STRING_SIZE);
  _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:=": ",                 DestSize:=MESSAGE_LOG_STRING_SIZE);
  
  // Combine string. to get one log entry. 
  case p_LogData^.LogLevel of
    LL_DEBUG:             _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="DEBUG      : ", DestSize:=MESSAGE_LOG_STRING_SIZE);
    LL_INFO:              _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="INFO       : ", DestSize:=MESSAGE_LOG_STRING_SIZE);
    LL_WARNING:           _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="WARNING    : ", DestSize:=MESSAGE_LOG_STRING_SIZE);
    LL_ERROR_INTERNAL:    _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="ERROR INT  : ", DestSize:=MESSAGE_LOG_STRING_SIZE);
    LL_ERROR_APPLICATION: _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="ERROR APPL : ", DestSize:=MESSAGE_LOG_STRING_SIZE);
    LL_ERROR_CRITICAL:    _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:="CRITICAL   : ", DestSize:=MESSAGE_LOG_STRING_SIZE);
    
  else
    _strcpy(dest:=#LogString[0], src:="UKNOWN LEVEL:  ");
    
  end_case;

  _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:=p_LogData^.p_ObjName, DestSize:=MESSAGE_LOG_STRING_SIZE);
  _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:=": ",                 DestSize:=MESSAGE_LOG_STRING_SIZE);
  
  // HENODI CHECKEN 19-11-2012  WAS ip_LogData^.p_Msg
  _ObjStr.StringCatLimited(p_Dest:=#LogString[0], p_Add:=p_LogData^.p_Msg,     DestSize:=MESSAGE_LOG_STRING_SIZE);

  if ( MsgLogTarget = LT_FILE ) L_OR ( MsgLogTarget = LT_FILE_SCREEN ) then
    // Log message into OS user log file 

    ToSysMsg.ULPrintfln0(pMsg := #LogString[0]);

    timeLastNewMsg := ops.tAbsolute;
    MsgInBuffer    := TRUE;

  end_if;
  
  if ( MsgLogTarget = LT_SCREEN ) L_OR ( MsgLogTarget = LT_FILE_SCREEN ) then
    // Log to Lasal debug environment (tab "Logging" and tab "Debugger Trace")
    TRACE(#LogString[0]);

  end_if;
  
    // Message logdata logged
  o_MsgLogCnt += 1;

END_FUNCTION


(***************************************************************
WewoLogger::m_CurrentLogLevel::Write

Description:       Set log level
                   
Parameter:         loglevel to use

note:              Only loglevels for messagelogging are accepted.
                   If LL_DEBUG_RT is set it wil be changed into LL_DEBUG
                   
Return:            -
***************************************************************)
FUNCTION VIRTUAL GLOBAL WewoLogger::MsgLogLevel::Write
	VAR_INPUT
		input (EAX) 	: gt_LogLevel;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: gt_LogLevel;
	END_VAR

  VAR
  	LoopCnt   : USINT;
    nrOfBits  : USINT;        // note: same size as used for MsgLogLevel
    FirstBit  : t_LogFlags;
    StoreFlag : BOOL;
  END_VAR

	MsgLogLevel  := input;
  
  // Save RT flag
  StoreFlag := ActiveLogFlags.LF_DEBUG_RT;
  
  // Convert selected level to enabled log flags
  if MsgLogLevel <> LL_NONE then
    
    ActiveLogFlags := 0;  
    
    if MsgLogLevel = LL_DEBUG_RT then
      // Loglevel LL_DEBUG_RT is not used for message logging
      // Use LL_DEBUG.in stead.
      MsgLogLevel := LL_DEBUG;
      
    end_if;
    
    // Calculate nr of bits to set
    nrOfBits       := HIGHEST_LEVEL $ USINT - MsgLogLevel $ USINT;
    FirstBit       := CONVERT_LOG_LEVEL_2_FLAG(MsgLogLevel);
    ActiveLogFlags := FirstBit;
    
    LoopCnt := 0;
    while LoopCnt < nrOfBits do
      ActiveLogFlags := ActiveLogFlags ROL 1;                 // Shift bits to left
      ActiveLogFlags := ActiveLogFlags B_OR FirstBit;         // Set LS active bit
      LoopCnt        += 1;
    end_while;

  else
    ActiveLogFlags := t_LogFlags.LF_NONE;
  
  end_if;
  
  // Restore RT flag setting
  ActiveLogFlags.LF_DEBUG_RT := StoreFlag;
  
 	result := MsgLogLevel;

END_FUNCTION


(***************************************************************
WewoLogger::Command::Write

Description:       Log command
                   
Parameter:         Command
Return:            -
***************************************************************)

FUNCTION VIRTUAL GLOBAL WewoLogger::Command::Write
	VAR_INPUT
		input (EAX) 	: gt_LogCmd;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: gt_LogCmd;
	END_VAR

	Command := input;
  
  CmdRequest := Command;
  
 	result := Command;

END_FUNCTION


(***************************************************************
WewoLogger::SetTriggerRtLog

Description:       Set trigger condition for realtime data logging
                   
Parameter:         pointer to trigger settings
Return:            -
***************************************************************)
FUNCTION GLOBAL WewoLogger::SetTriggerRtLog
	VAR_INPUT
		p_SetTrigger 	: ^gt_RtLogTrigger;
	END_VAR

  if p_SetTrigger <> NIL then
    RtTriggerSetting := p_SetTrigger^;
  end_if;
  
END_FUNCTION


(***************************************************************
WewoLogger::GetTriggerRtLog

Description:       Get actual trigger settings
                   
Parameter:         pointer to storage location for trigger settings
Return:            -
***************************************************************)
FUNCTION GLOBAL WewoLogger::GetTriggerRtLog
	VAR_INPUT
		p_GetTrigger 	: ^gt_RtLogTrigger;
	END_VAR

  if p_GetTrigger <> NIL then
    p_GetTrigger^ := RtTriggerSetting;
  end_if;

END_FUNCTION


// Increment log index for realtime LogDataBuffer and handle wrap around
FUNCTION WewoLogger::IncRtLogIdx
	VAR_INPUT
		p_Idx 	: ^UDINT;
	END_VAR
  
  if ( p_Idx^ < (c_RtNrOfLogEntries-1) ) then    
    p_Idx^ += 1;                         // Set entry for next RtLogData
  
  else
    // Wrap around
    p_Idx^  := 0;
  
  end_if;
  
END_FUNCTION


// Calculate first Idx to read from realtime LogDataBuffer
FUNCTION WewoLogger::GetFirstStoredRtLogEntry
	VAR_OUTPUT
		FirstIdx 	: UDINT;
	END_VAR
  
  VAR
  	d_Idx   : DINT;
  END_VAR

  d_Idx := (WrRtDataIdx $ DINT) - (o_rtLogDataCnt $ DINT);
  
  if ( d_Idx < 0 ) then
    // In case of wrap around (cyclic buffer)
    d_Idx    := d_Idx * -1;
    FirstIdx := o_rtLogDataCnt - (d_Idx $ UDINT);
    
  else
    FirstIdx := (d_Idx $ UDINT);
    
  end_if;
  
END_FUNCTION


FUNCTION WewoLogger::RegistrateWewoObject
	VAR_INPUT
		p_RegObj 	: ^WewoBase;
	END_VAR

  if p_RegObj <> NIL then
    // Object available for registration
    if (op_sfnObjChain = NIL) then
      // First object to register
      p_RegObj^.SetNextWewoObject(p_Object:=NIL); // Be sure last object in chain is closed
      op_sfnObjChain := p_RegObj;
    
    else
      // Add object to chain.
      p_RegObj^.SetNextWewoObject(p_Object:=op_sfnObjChain $^WewoBase);
      op_sfnObjChain := p_RegObj;

    end_if;

  end_if;  

END_FUNCTION


FUNCTION WewoLogger::FlushLogMessage
  VAR
  	RcSysMsg      : DINT;           // Return codes from SysMgs methods
  END_VAR

  RcSysMsg := ToSysMsg.ULFlush( LogBuffID := LUSER_LOW_PRIO_ID, usNonBlocking  := 1);       // Return immediatly
//  RcSysMsg := ToSysMsg.ULFlush( LogBuffID := LUSER_LOW_PRIO_ID, usNonBlocking  := 0);     // Return after content buffer is flushed to file

  if ( RcSysMsg <> LUSER_BUSY ) then
    MsgInBuffer := FALSE;
    
  end_If;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL WewoLogger::InsertRtStartLogNr::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  VAR
  	RtLogFlag : BOOL;
    
  END_VAR

  // Backup DebugRtLog setting
  RtLogFlag := ObjectStatus.DebugRtLogEnabled;
  
	InsertRtStartLogNr := input;
  
  ObjectStatus.DebugRtLogEnabled:=1;
  WriteLogRtData(Id:=RT_LOG_ID_INSERT_START_LOG_NR, Value:=InsertRtStartLogNr);
  
  // Restore DebugRtLog setting
  ObjectStatus.DebugRtLogEnabled:=RtLogFlag;
  
  
 	result := InsertRtStartLogNr;

END_FUNCTION
