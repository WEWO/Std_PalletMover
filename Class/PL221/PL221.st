//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define DEVICE_ID_PL221 1091


#define PL221_ADDR_CONFIG_WRITE0      16#0000
#define PL221_ADDR_CONFIG_WRITE1      16#0080
#define PL221_ADDR_SEQUENZER_WRITE    16#0100
#define PL221_ADDR_PWMHIGHTIME_WRITE  16#0105
#define PL221_ADDR_STATEREG_READ      16#0107
#define PL221_ADDR_CONFIG_PIXEL_OUT   16#0110
#define PL221_PIXEL_LENGTH            16#0112

#define PL221_SDO_RESPONSE_TIMEOUT    (SDIAS_SDO_TIMEOUT *2)
#define PL221_SDO_RESPONSE_RETRYS     3

#define PL221_MAX_PWM_VALUE 100

//Data Transfer Time in ns
#define PL221_T0H_TYP0        420
#define PL221_T1H_TYP0        820
#define PL221_T0L_TYP0        820
#define PL221_T1L_TYP0        420
#define PL221_RESETTIME_TYP0  150

#define PL221_T0H_TYP1        380  
#define PL221_T1H_TYP1        880  
#define PL221_T0L_TYP1        880
#define PL221_T1L_TYP1        380
#define PL221_RESETTIME_TYP1  310

//scale the data transfer time in 20 ns 
#define PL221_SCALE 20
//maximum number of led strips
#define PL221_MAX_LED_STRIPES 2
//maximum bytes for SDO init
#define PL221_MAX_LED_DATA_BYTES 28
//last address in RAM used for color for whole stripe
#define PL221_LAST_RAM_ADDRESS 680



//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "PL221"
	Revision           = "1.5"
	GUID               = "{214B768F-5BDA-4146-91A1-3E2919309731}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\s-dias.ico"
	SharedCommandTable = "true"
	Objectsize         = "(686,120)"
	Comment            = "Class for PL221 hardware module (2x Pixel Led Outputs / 2x +24V PWM Outputs ">
	<Channels>
		<Server Name="ExternVoltageOK" GUID="{2834A11C-D56F-4456-94D7-C232925C94A5}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="This server show the state of the voltage supply for 24V and 5V.&#13;&#10;Bit0 ... Voltage 24V DC OK&#13;&#10;Bit1 ... Voltage   5V DC OK"/>
		<Server Name="LEDStripeOn" GUID="{A4B91AEB-8C3D-43C4-9F97-E28C3F1F25B4}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="switch on/off power supply from led stripes.&#13;&#10;0 ... off&#13;&#10;1 ... on"/>
		<Server Name="PWMOut1" GUID="{F570E199-1DE9-4B22-9FD1-4E4BFBF13E78}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set the pwm high time of the pwm output 1 in percent from 0 to 100%.&#13;&#10;0 ... off&#13;&#10;100 ... maximum"/>
		<Server Name="PWMOut2" GUID="{C6EECCE7-1FE4-4755-98FB-4B19F65704FF}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set the pwm high time of the pwm output 2 in percent from 0 to 100%.&#13;&#10;0 ... off&#13;&#10;100 ... maximum"/>
		<Server Name="Range" GUID="{E2E9475F-AC7C-49B2-8521-1F884E24450B}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="range detection:&#13;&#10;Bit 0 ... Overcurrent PWM&#13;&#10;Bit 1 ... Overcurrent LED&#13;&#10;Bit 2 ... Shortcircuit PWM&#13;&#10;Bit 3 ... Overtemperature PWM&#13;&#10;Bit 4 ... 5V supply overtemperature error&#13;&#10;&#13;&#10;a read call reset the server"/>
		<Server Name="SetAllLeds" GUID="{81D77BD9-9355-4CBC-8529-9D2E87DD0C60}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set whole led stripe to one color.&#13;&#10;Select the color on Server &quot;SetStripeColor&quot;.&#13;&#10;0 ... off&#13;&#10;1 ... stripe 1&#13;&#10;2 ... stripe 2&#13;&#10;3 ... both stripes"/>
		<Server Name="SetColorStripe1" GUID="{49B3E1B3-9003-4C37-8A5A-331AADCD8423}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set stripe 1 color for &quot;SetAllLeds&quot; server.&#13;&#10;for example: &#13;&#10;24bit ... 0xFFFFFF (RGB)&#13;&#10;16bit ... 0xFFFF&#13;&#10;8bit ... 0-255 (LUT)&#13;&#10;4bit ... 0-15 (LUT)"/>
		<Server Name="SetColorStripe2" GUID="{8BD7D12C-00E6-498F-BA41-F9861E677AC1}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set stripe 2 color for &quot;SetAllLeds&quot; server.&#13;&#10;for example: &#13;&#10;24bit ... 0xFFFFFF (RGB)&#13;&#10;16bit ... 0xFFFF&#13;&#10;8bit ... 0-255 (LUT)&#13;&#10;4bit ... 0-15 (LUT)"/>
		<Server Name="StartRollingAddrStripe1" GUID="{2CD4756A-F050-4A43-9A95-031D5C1F912E}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Start the rolling mode for the led stripe 1.&#13;&#10;on ... startaddress (0 - (Number of Leds-1))&#13;&#10;off ... -1"/>
		<Server Name="StartRollingAddrStripe2" GUID="{16B4BCD9-8E44-4F1A-959B-20E848BDBD02}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false" Comment="Start the rolling mode for the led stripe 2.&#13;&#10;on ... startaddress (0 - (Number of Leds-1))&#13;&#10;off ... -1"/>
		<Client Name="ColorTable" Required="false" Internal="false" Comment="This client can be connected to an object of the PL221ColorTab class (see class description PL221ColorTab).&#13;&#10;If the default color table is used, no PL221ColorTab object must be connected."/>
		<Client Name="PWM1Enable" Required="true" Internal="false" DefValue="1" Comment="The PWM Output 1 can be activated / deactivated with this client as init value.&#13;&#10;0 ... Output is deactivated.&#13;&#10;1 ... Output is activated."/>
		<Client Name="PWM1Periode" Required="true" Internal="false" DefValue="50" Comment="Set PWM Output 1 Period (50 - 1000) in 10 us steps&#13;&#10;50 ... 2kHz&#13;&#10;51 ... 1,96 kHz&#13;&#10;52 ... 1,96 kHz&#13;&#10;....&#13;&#10;....&#13;&#10;998 ... 100,2 Hz&#13;&#10;999 ... 100,1 Hz&#13;&#10;1000 ... 100,0 Hz"/>
		<Client Name="PWM2Enable" Required="true" Internal="false" DefValue="1" Comment="The PWM Output 2 can be activated / deactivated with this client as init value.&#13;&#10;0 ... Output is deactivated.&#13;&#10;1 ... Output is activated."/>
		<Client Name="PWM2Periode" Required="true" Internal="false" DefValue="50" Comment="Set PWM Output 2 Period (50 - 1000) in 10 us steps&#13;&#10;50 ... 2kHz&#13;&#10;51 ... 1,96 kHz&#13;&#10;52 ... 1,96 kHz&#13;&#10;....&#13;&#10;....&#13;&#10;998 ... 100,2 Hz&#13;&#10;999 ... 100,1 Hz&#13;&#10;1000 ... 100,0 Hz"/>
		<Client Name="Stripe1_Activate" Required="true" Internal="false" DefValue="1" Comment="The stripe 1 can be activated/ deactivated with this client as init value.&#13;&#10;0 ... Stripe is deactivated.&#13;&#10;1 ... Stripe is activated."/>
		<Client Name="Stripe1_ColorResolution" Required="true" Internal="false" DefValue="0" Comment="Set the color resolution of the transfer for stripe 1 as init value.&#13;&#10;0 ... 24bit&#13;&#10;1 ... 16bit&#13;&#10;2 ...   8bit (CLUT)&#13;&#10;3 ...   4bit (CLUT)&#13;&#10;&#13;&#10;CLUT: Color data is stored in a LookUp Table"/>
		<Client Name="Stripe1_NumOfLeds" Required="true" Internal="false" Comment="The number of LED&apos;s on the stripe 1 as init value.&#13;&#10;maximum ... 512 LED&apos;s"/>
		<Client Name="Stripe1_RefreshCycle" Required="true" Internal="false" DefValue="50" Comment="Specifies the frequency at which the LED strips are updated when WriteDataMode = 0 is selected. In order to maintain an even workload, the data is split up. &#13;&#10;The time must be a multiple of the bus cycle time. Setting as initial value!&#13;&#10;for example: 50Hz = 20 ms&#13;&#10;Default Value = 50 Hz"/>
		<Client Name="Stripe1_Type" Required="true" Internal="false" DefValue="0" Comment="Set the type of stripe 1 as init value.&#13;&#10;0 ... WS2812B&#13;&#10;1 ... WS2813&#13;&#10;2 ... Individual&#13;&#10;&#13;&#10;if type 2 has been selected, &#13;&#10;enter the values with the function IndividualStripeConfig"/>
		<Client Name="Stripe2_Activate" Required="true" Internal="false" DefValue="1" Comment="The stripe 2 can be activated/ deactivated with this client as init value.&#13;&#10;0 ... Stripe is deactivated&#13;&#10;1 ... Stripe is activated"/>
		<Client Name="Stripe2_ColorResolution" Required="true" Internal="false" DefValue="0" Comment="Set the color resolution of the transfer for stripe 2 as init value.&#13;&#10;0 ... 24bit&#13;&#10;1 ... 16bit&#13;&#10;2 ...   8bit (CLUT)&#13;&#10;3 ...   4bit (CLUT)&#13;&#10;&#13;&#10;CLUT: Color data is stored in a LookUp Table"/>
		<Client Name="Stripe2_NumOfLeds" Required="true" Internal="false" Comment="The number of LED&apos;s on the stripe 2 as init value.&#13;&#10;maximum ... 512 LED&apos;s"/>
		<Client Name="Stripe2_RefreshCycle" Required="true" Internal="false" DefValue="50" Comment="Specifies the frequency at which the LED strips are updated when WriteDataMode = 0 is selected. In order to maintain an even workload, the data is split up. &#13;&#10;The time must be a multiple of the bus cycle time. Setting as initial value!&#13;&#10;for example: 50Hz = 20 ms&#13;&#10;Default Value = 50 Hz"/>
		<Client Name="Stripe2_Type" Required="true" Internal="false" DefValue="0" Comment="Set the type of stripe 2 as init value.&#13;&#10;0 ... WS2812B&#13;&#10;1 ... WS2813&#13;&#10;2 ... Individual&#13;&#10;&#13;&#10;if type 2 has been selected, &#13;&#10;enter the values with the function IndividualStripeConfig"/>
		<Client Name="WriteDataMode" Required="true" Internal="false" DefValue="0" Comment="This client is used to select how the data transfer should be done.&#13;&#10;set as init value.&#13;&#10;0 ... write whole stripe&#13;&#10;1 ... change individual LED&apos;s"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="FurDom"/>
		<Dokumentation Revision="1.5" Date="12.08.2019" Author="LazJos" Company="Sigmatek" Description="Added support for HWAlarms. &#13;&#10;Changed DisplayGroup in PL221.lhd file from Analog to Special."/>
		<Dokumentation Revision="1.4" Date="23.04.2019" Author="FurDom" Company="Sigmatek" Description="change resettime for stripe type WS2812B&#13;&#10;corrected ram initializiation in InitModule"/>
		<Dokumentation Revision="1.3" Date="14.02.2019" Author="FurDom" Company="Sigmatek" Description="corr. UpdateCy methode, Cyclical sending of the SDO command by the read method of the server Range has been fixed."/>
		<Dokumentation Revision="1.2" Date="16.01.2019" Author="FurDom" Company="Sigmatek" Description="corr. description from parameter in SetWholeStripe();&#13;&#10;add numbers in comments from color table;&#13;&#10;corr. access error in ChangeAllLeds ();"/>
		<Dokumentation Revision="1.1" Date="09.01.2019" Author="FurDom" Company="Sigmatek" Description="Added function for Spi Write in SdiasBase class."/>
		<Dokumentation Revision="1.0" Date="01.08.2018" Author="FurDom" Company="Sigmatek" Description="First Library Version&#13;&#10;"/>
	</RevDoku>
	<Network Name="PL221">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{5D10966E-271B-46E0-AB6A-E4078C729814}"
				Class      = "SdiasBase"
				Position   = "(218,120)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassState"/>
					<Server Name="DeviceID"/>
					<Server Name="FPGAVersion"/>
					<Server Name="HwVersion"/>
					<Server Name="LEDControl" Value="0"/>
					<Server Name="RetryCounter"/>
					<Server Name="SDOState"/>
					<Server Name="SerialNo"/>
					<Client Name="Place" Value="0"/>
					<Client Name="Required" Value="1"/>
					<Client Name="SdiasIn"/>
					<Client Name="ToStdLib"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassState" Destination="_base.ClassState" Vertices="(804,210),(632,210),"/>
			<Connection Source="this.DeviceID" Destination="_base.DeviceID" Vertices="(804,270),(632,270),"/>
			<Connection Source="this.FPGAVersion" Destination="_base.FPGAVersion" Vertices="(804,330),(632,330),"/>
			<Connection Source="this.HwVersion" Destination="_base.HwVersion" Vertices="(804,390),(632,390),"/>
			<Connection Source="this.SerialNo" Destination="_base.SerialNo" Vertices="(804,450),(632,450),"/>
			<Connection Source="this.RetryCounter" Destination="_base.RetryCounter" Vertices="(804,510),(632,510),"/>
			<Connection Source="this.LEDControl" Destination="_base.LEDControl" Vertices="(804,570),(632,570),"/>
			<Connection Source="this.SDOState" Destination="_base.SDOState" Vertices="(804,630),(632,630),"/>
			<Connection Source="_base.SdiasIn" Destination="this.SdiasIn" Vertices="(218,210),(38,210),"/>
			<Connection Source="_base.Place" Destination="this.Place" Vertices="(218,270),(38,270),"/>
			<Connection Source="_base.Required" Destination="this.Required" Vertices="(218,330),(38,330),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using SdiasBase

PL221 : CLASS
: SdiasBase
	TYPE
#pragma pack(push, 1)
	  t_AccessControl : STRUCT
	    AccessHandle : UDINT;
	    pControlByte : t_SDIAS_pControlByte;
	    pStateByte : t_SDIAS_pStateByte;
	    ActLength : USINT;
	    LastDOLen : USINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_LEDChanges : ARRAY [0..127] OF USINT;
	  t_LEDChanges2 : ARRAY [0..127] OF USINT;
#pragma pack(push, 1)
	  t_PDOSequenzerConfig : STRUCT
	    Sequenzer1Config : BINT
	    [
	      1 StartAddrSeq1Bit0,
	      2 StartAddrSeq1Bit1,
	      3 StartAddrSeq1Bit2,
	      4 StartAddrSeq1Bit3,
	      5 StartAddrSeq1Bit4,
	      6 StartAddrSeq1Bit5,
	      7 StartAddrSeq1Bit6,
	      8 StartAddrSeq1Bit7,
	      9 StartAddrSeq1Bit8,
	      10 StartAddrSeq1Bit9,
	      16 AutoIncrStripe1,
	    ];
	    Sequenzer2Config : BINT
	    [
	      1 StartAddrSeq2Bit0,
	      2 StartAddrSeq2Bit1,
	      3 StartAddrSeq2Bit2,
	      4 StartAddrSeq2Bit3,
	      5 StartAddrSeq2Bit4,
	      6 StartAddrSeq2Bit5,
	      7 StartAddrSeq2Bit6,
	      8 StartAddrSeq2Bit7,
	      9 StartAddrSeq2Bit8,
	      10 StartAddrSeq2Bit9,
	      16 AutoIncrStripe2,
	    ];
	    SequenzerStart : BSINT
	    [
	      1 SequenzerOut1Start,
	      2 SequenzerOut2Start,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PDOPWMOutHighTime : STRUCT
	    PWMOut1HT : BSINT
	    [
	      1 HTPeriodPWM1Bit0,
	      2 HTPeriodPWM1Bit1,
	      3 HTPeriodPWM1Bit2,
	      4 HTPeriodPWM1Bit3,
	      5 HTPeriodPWM1Bit4,
	      6 HTPeriodPWM1Bit5,
	    ];
	    PWMOut2HT : BSINT
	    [
	      1 HTPeriodPWM2Bit0,
	      2 HTPeriodPWM2Bit1,
	      3 HTPeriodPWM2Bit2,
	      4 HTPeriodPWM2Bit3,
	      5 HTPeriodPWM2Bit4,
	      6 HTPeriodPWM2Bit5,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PDOReadModulInfo : STRUCT
	    StateRegister : BSINT
	    [
	      1 DC24VOK,
	      2 DC5VOK,
	      3 OvercurrentPWMLatched,
	      4 OvercurrentLEDsLatched,
	      5 ShortciruitPWMLatched,
	      6 OverTemperaturePWMLatched,
	      7 SupplyDisableOTErrorLatched,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_Accesses : STRUCT
	    pPDOWriteData : ^t_LEDChanges;
	    pPDOWriteDataStripe1 : ^t_LEDChanges;
	    pPDOWriteDataStripe2 : ^t_LEDChanges2;
	    pPDOSequenzerConfig : ^t_PDOSequenzerConfig;
	    pPDOPWMOutHighTime : ^t_PDOPWMOutHighTime;
	    pPDOReadModulInfo : ^t_PDOReadModulInfo;
	    sAccessPDOWriteData : t_AccessControl;
	    sAccessPDOWriteDataStripe1 : t_AccessControl;
	    sAccessPDOWriteDataStripe2 : t_AccessControl;
	    sAccessPDOSequenzerConfig : t_AccessControl;
	    sAccessPDOPWMOutHighTime : t_AccessControl;
	    sAccessPDOReadModulInfo : t_AccessControl;
	  END_STRUCT;
#pragma pack(pop)
	  t_eWait4ConfigSSW :
	  (
	    _IdleStep:=0,
	    _SendConfig:=1
	  )$UDINT;
	  t_PixelOrder :
	  (
	    RGB:=0,
	    RBG:=1,
	    GRB:=2,
	    GBR:=3,
	    BGR:=4,
	    BRG:=5
	  )$USINT;
#pragma pack(push, 1)
	  t_IndividualStripeConfig : STRUCT  //! <Type Comment="Pixel Order:&#13;&#10;0 .. RGB&#13;&#10;1 .. RBG&#13;&#10;2 .. GRB&#13;&#10;3 .. GBR&#13;&#10;4 .. BGR&#13;&#10;5 .. BRG&#13;&#10;&#13;&#10;LSBFirstOut as BOOL&#13;&#10;&#13;&#10;All Time values in us, values are scaled with 20 us" Name="t_IndividualStripeConfig"/>
	    PixelOrder : t_PixelOrder;
	    LSBFirstOut : BOOL;
	    PixelOutT0H : UINT;
	    PixelOutT1H : UINT;
	    PixelOutT0L : UINT;
	    PixelOutT1L : UINT;
	    ResetPixelTime : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_InitSSW :
	  (
	    _InitVariables:=0,
	    _SetMemoryZero:=1,
	    _WriteColorTable:=2,
	    _WritePixelLength:=3,
	    _WriteConfigModule:=4,
	    _SequenzerInit:=5,
	    _Finish:=6,
	    _InitError:=7
	  )$UDINT;
#pragma pack(push, 1)
	  t_PDOStripeConfig : STRUCT
	    StripeConfig : BINT
	    [
	      1 PixelAddrBit0,
	      2 PixelAddrBit1,
	      3 PixelAddrBit2,
	      4 PixelAddrBit3,
	      5 PixelAddrBit4,
	      6 PixelAddrBit5,
	      7 PixelAddrBit6,
	      8 PixelAddrBit7,
	      9 PixelAddrBit8,
	      10 PixelAddrBit9,
	      11 LedStripeSelectBit0,
	      12 LedStripeSelectBit1,
	      13 LedStripeSelectBit2,
	      14 PixelModeBit0,
	      15 PixelModeBit1,
	      16 PixelModeBit2,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_LEDStripeVars : STRUCT
	    pLEDDataHeader : ^t_PDOStripeConfig;
	    usColorSize : USINT;
	    uiRefreshCycleMs : UINT;
	    uiNumOfCopyLeds : UINT;
	    usStripeNum : USINT;
	    usColorResolution : USINT;
	    uiPixelStartAddr : UINT;
	    pHelpCopyData : ^USINT;
	    uiLedDataPerCycle : UINT;
	    pLedPixelData : pVoid;
	    bStartCopyData : BOOL;
	    bOneCycle : BOOL;
	    uiNextPixelAddr : UINT;
	    uiWholeLedData : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_PDOChangeDataConfig : STRUCT
	    StripeConfig : BINT
	    [
	      1 PixelAddrBit0,
	      2 PixelAddrBit1,
	      3 PixelAddrBit2,
	      4 PixelAddrBit3,
	      5 PixelAddrBit4,
	      6 PixelAddrBit5,
	      7 PixelAddrBit6,
	      8 PixelAddrBit7,
	      9 PixelAddrBit8,
	      10 PixelAddrBit9,
	      11 LedStripeSelectBit0,
	      12 LedStripeSelectBit1,
	      13 LedStripeSelectBit2,
	      14 PixelModeBit0,
	      15 PixelModeBit1,
	      16 PixelModeBit2,
	    ];
	    NumberOfPixelChange : BSINT
	    [
	      1 ChangePixelBit0,
	      2 ChangePixelBit1,
	      3 ChangePixelBit2,
	      4 ChangePixelBit3,
	      5 ChangePixelBit4,
	      6 ChangePixelBit5,
	      7 ChangePixelBit6,
	      8 NextConfig,
	    ];
	  END_STRUCT;
#pragma pack(pop)
	  t_ResponseState :
	  (
	    _idle:=0,
	    _wait:=1,
	    _valid:=2
	  )$UDINT;
#pragma pack(push, 1)
	  t_SDOHardwareControl : STRUCT
	    PixelOutputConfig : BSINT
	    [
	      1 PixelOutput1Config,
	      2 PixelOutput2Config,
	      3 PixelOutput1EndAddrEnable,
	      4 PixelOutput2EndAddrEnable,
	      5 PixelOutput1Enable,
	      6 PixelOutput2Enable,
	      7 Bit7,
	      8 Bit8,
	    ];
	    ControlRegister : BSINT
	    [
	      1 Bit1,
	      2 Bit2,
	      3 Bit3,
	      4 Bit4,
	      5 Bit5,
	      6 Bit6,
	      7 Bit7,
	      8 DC5VEnable,
	    ];
	    PixelOutput1Length : UINT;
	    PixelOutput2Length : UINT;
	    PixelOrderConfig : BSINT
	    [
	      1 PixelOutput1OrderBit0,
	      2 PixelOutput1OrderBit1,
	      3 PixelOutput1OrderBit2,
	      4 LSBFirstOut1,
	      5 PixelOutput2OrderBit0,
	      6 PixelOutput2OrderBit1,
	      7 PixelOutput2OrderBit2,
	      8 LSBFirstOut2,
	    ];
	    res : USINT;
	    PixelOut1T0H : USINT;
	    PixelOut1T1H : USINT;
	    PixelOut1T0L : USINT;
	    PixelOut1T1L : USINT;
	    PixelOut2T0H : USINT;
	    PixelOut2T1H : USINT;
	    PixelOut2T0L : USINT;
	    PixelOut2T1L : USINT;
	    ResetPixelOut1 : UINT;
	    ResetPixelOut2 : UINT;
	    PWMOut1Period : UINT;
	    PWMOut2Period : UINT;
	    Sequencer1EndAdress : UINT;
	    Sequencer2EndAdress : UINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_SendConfigSSW :
	  (
	    DoNothing,
	    SwitchStripe
	  )$UDINT;
	  t_StripeSwitchChange : BSINT
	  [
	    1 LEDStripe,
	    2 Bit2,
	    3 Bit3,
	    4 Bit4,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	  ];
	END_TYPE
  //Servers:
	PWMOut1 	: SvrCh_DINT;
	PWMOut2 	: SvrCh_DINT;
	LEDStripeOn 	: SvrCh_DINT;
	SetAllLeds 	: SvrCh_DINT;
	SetColorStripe1 	: SvrCh_UDINT;
	SetColorStripe2 	: SvrCh_UDINT;
	StartRollingAddrStripe1 	: SvrCh_DINT;
	StartRollingAddrStripe2 	: SvrCh_DINT;
	Range 	: SvrCh_BDINT;
	ExternVoltageOK 	: SvrCh_BDINT;
  //Clients:
	Stripe1_Activate 	: CltCh_DINT;
	Stripe1_NumOfLeds 	: CltCh_DINT;
	Stripe1_Type 	: CltCh_DINT;
	Stripe1_ColorResolution 	: CltCh_DINT;
	Stripe1_RefreshCycle 	: CltCh_DINT;
	Stripe2_Activate 	: CltCh_DINT;
	Stripe2_NumOfLeds 	: CltCh_DINT;
	Stripe2_Type 	: CltCh_DINT;
	Stripe2_ColorResolution 	: CltCh_DINT;
	Stripe2_RefreshCycle 	: CltCh_DINT;
	ColorTable 	: CltCh_DINT;
	PWM1Enable 	: CltCh_DINT;
	PWM2Enable 	: CltCh_DINT;
	PWM1Periode 	: CltCh_DINT;
	PWM2Periode 	: CltCh_DINT;
	WriteDataMode 	: CltCh_DINT;
  //Variables:
		sAccesses 	: t_Accesses;
		eInitSSW 	: t_InitSSW;
		eResponseState 	: t_ResponseState;
		sSDOHardwareControlWrite 	: t_SDOHardwareControl;
		udSDOTimeout 	: UDINT;
		eInitSSWErrorStep 	: t_InitSSW;
		sOutputValuesSequenzerConfig 	: t_PDOSequenzerConfig;
		sOutputValuesPWM 	: t_PDOPWMOutHighTime;
		eWait4ConfigSSW 	: t_eWait4ConfigSSW;
		bSettingsChanged 	: t_StripeSwitchChange;
		aLedChanges 	: t_LEDChanges;
		aLedChanges2 	: t_LEDChanges2;
		pLedHeader 	: ^t_PDOChangeDataConfig;
		usColorSize 	: USINT;
		pLastHeader 	: ^t_PDOChangeDataConfig;
		usRemainingDOLength 	: USINT;
		usEntrySize 	: USINT;
		pCopyData 	: pVoid;
		usCopyStripeNum 	: USINT;
		uiCopyPixelStartAddr 	: UINT;
		bStartCopyData 	: BOOL;
		bRangeErrorReadLatch 	: BOOL;
		bOneCycle 	: BOOL;
		aStripes : ARRAY [0..PL221_MAX_LED_STRIPES-1] OF t_LEDStripeVars;

		ActIndex 	: USINT;
		usNumOfCopyLeds 	: USINT;
		aMemoryInitColor : ARRAY [0..29] OF USINT;

		pStripeInit 	: ^t_LEDStripeVars;
		bCopyInitValueFinish 	: BOOL;
		bSDIASSingleRun 	: BOOL;
		udTablength 	: UDINT;
		aTableData : ARRAY [0..32] OF USINT;

		pTableentry 	: ^USINT;
		uiTableOffset 	: UINT;
		bCopyColorTable 	: BOOL;
		bTablerReadFinish 	: BOOL;
		uiPixelStartAddr 	: UINT;
		bStopRollingStripe1 	: BOOL;
		bStopRollingStripe2 	: BOOL;
		IndividualStripeCon1 	: t_IndividualStripeConfig;
		IndividualStripeCon2 	: t_IndividualStripeConfig;
		dStartOffsetStripe1 	: DINT;
		dStartOffsetStripe2 	: DINT;
  //Functions:
				//! <Function Comment="Realtime Update Methode which runs in PreScan." Name="UpdateRt"/>
	FUNCTION VIRTUAL GLOBAL UpdateRt;
				//! <Function Comment="Realtime Update Methode which runs in PostScan." Name="UpdateRtPostScan"/>
	FUNCTION VIRTUAL GLOBAL UpdateRtPostScan;
				//! <Function Comment="Cyclic Update Methode which runs in PostScan." Name="UpdateCy"/>
	FUNCTION VIRTUAL GLOBAL UpdateCy;
	
	FUNCTION VIRTUAL GLOBAL AddAccesses
		VAR_OUTPUT
			eModuleInitState 	: iprStates;
		END_VAR;
				//! <Function Comment="Methode is called if this Module gets connected." Name="ConnectEvent"/>
	FUNCTION VIRTUAL GLOBAL ConnectEvent;
				//! <Function Comment="Methode is called if this Module gets disconnected." Name="DisconnectEvent"/>
	FUNCTION VIRTUAL GLOBAL DisconnectEvent;
				//! <Function Comment="Methode should be used to run a Statemachine to Initialize the Module." Name="InitModule"/>
	FUNCTION VIRTUAL GLOBAL InitModule
		VAR_OUTPUT
			eModuleInitState 	: iprStates;			//! <Variable Comment="Return BUSY until the Initialisation is finished." Name="InitModule.eModuleInitState"/>
		END_VAR;
				//! <Function Comment="This Methode should be used, to check the DeviceID of the Module." Name="CheckDeviceID"/>
	FUNCTION VIRTUAL GLOBAL CheckDeviceID
		VAR_INPUT
			udID2Check 	: UDINT;			//! <Variable Comment="Device ID of connected Module." Name="CheckDeviceID.udID2Check"/>
		END_VAR
		VAR_OUTPUT
			bIsOK 	: BOOL;			//! <Variable Comment="FALSE = Wrong DeviceID for Module&#13;&#10;TRUE  = DeviceID of Module is correct" Name="CheckDeviceID.bIsOK"/>
		END_VAR;
				//! <Function Comment="Methode to receive the Response in case of SDO-Communication." Name="ReceiveSDOResponse"/>
	FUNCTION VIRTUAL ReceiveSDOResponse
		VAR_INPUT
			eCommand 	: t_SDIAS_SDO_Cmd;			//! <Variable Comment="Type of SDO-Command" Name="ReceiveSDOResponse.eCommand"/>
			hOffset 	: HINT;			//! <Variable Comment="Address-Offset in Module." Name="ReceiveSDOResponse.hOffset"/>
			usLength 	: USINT;			//! <Variable Comment="Length of Data." Name="ReceiveSDOResponse.usLength"/>
			eResult 	: iprStates;			//! <Variable Comment="State of SDO-Communication." Name="ReceiveSDOResponse.eResult"/>
			pResponseBuffer 	: ^USINT;			//! <Variable Comment="Pointer of ResponseBuffer, where the SDO-Data is located." Name="ReceiveSDOResponse.pResponseBuffer"/>
			ResponseLength 	: USINT;			//! <Variable Comment="Size of the ResponseBuffer." Name="ReceiveSDOResponse.ResponseLength"/>
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;			//! <Variable Comment="Indicates if the Methode was successful." Name="ReceiveSDOResponse.ret_code"/>
		END_VAR;
	
	FUNCTION VIRTUAL GetTaskCfg
		VAR_OUTPUT
			TaskCfg 	: BDINT;			//! <Variable Comment="Select which tasks will be available for this module:&#13;&#10;Bit1..Realtime PreScan&#13;&#10;Bit2..Realtime PostScan&#13;&#10;Bit3..Cyclic&#13;&#10;&#13;&#10;e.g. if only realtime postscan is needed:&#13;&#10;2#010" Name="GetTaskCfg.TaskCfg"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDeviceID
		VAR_OUTPUT
			output 	: UDINT;
		END_VAR;
				//! <Function Comment="This function is used to change individual LEDs on both strips. &#13;&#10;Only changes of up to 125 bytes are possible.&#13;&#10;This function is only be used if the client WriteDataMode = 1 !" Name="ChangeIndividualLED"/>
	FUNCTION GLOBAL ChangeIndividualLED
		VAR_INPUT
			usStripeNumber 	: USINT;			//! <Variable Comment="Selects the LED strip that is written with the data." Name="ChangeIndividualLED.usStripeNumber"/>
			uiPixelStartAddr 	: UINT;			//! <Variable Comment="Specifies the address to which the data is written in the RAM." Name="ChangeIndividualLED.uiPixelStartAddr"/>
			usNumberOfLed 	: USINT;			//! <Variable Comment="Specifies how many LEDs are to be changed." Name="ChangeIndividualLED.usNumberOfLed"/>
			pData 	: pVoid;			//! <Variable Comment="Pointer to the array in which the pixel data is stored." Name="ChangeIndividualLED.pData"/>
			dStartOffset 	: DINT := 0;			//! <Variable Comment="The stored color pattern can be moved to another position of the LED strip. &#13;&#10;This does not affect the color pattern in the RAM.&#13;&#10;dStartOffset cannot be larger than the specified number of LEDs." Name="ChangeIndividualLED.dStartOffset"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="0... data has been copied&#13;&#10;-1... entry is more than 125 bytes large&#13;&#10;-2... entry is too large for remaining DO size&#13;&#10;-3... wrong WriteData mode selected&#13;&#10;-4... dStartOffset is higher than the number of used LEDs.&#13;&#10;-5... ClassState not ok&#13;&#10;-6... invalid pointer of colordata&#13;&#10;-8... invalid strip selection" Name="ChangeIndividualLED.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function is used to write a whole strip of RAM. &#13;&#10;The LED data will be copied in a given time, split up to achieve an even load.&#13;&#10;This function is only be used if the client WriteDataMode = 0 !" Name="ChangeAllLEDs"/>
	FUNCTION GLOBAL ChangeAllLEDs
		VAR_INPUT
			usStripeNumber 	: USINT;			//! <Variable Comment="Selects the LED strip that is written with the data." Name="ChangeAllLEDs.usStripeNumber"/>
			uiPixelStartAddr 	: UINT;			//! <Variable Comment="Specifies the address to which the data is written in RAM." Name="ChangeAllLEDs.uiPixelStartAddr"/>
			uiNumberOfLed 	: UINT;			//! <Variable Comment="Specifies how many LEDs are to be described." Name="ChangeAllLEDs.uiNumberOfLed"/>
			pLedData 	: pVoid;			//! <Variable Comment="Pointer to the array in which the pixel data is stored." Name="ChangeAllLEDs.pLedData"/>
			dStartOffset 	: DINT := 0;			//! <Variable Comment="The stored color pattern can be moved to another position of the LED strip. &#13;&#10;This does not affect the color pattern in the RAM.&#13;&#10;dStartOffset cannot be larger than the specified number of LEDs." Name="ChangeAllLEDs.dStartOffset"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="0... data has been copied&#13;&#10;-1... wrong WriteData mode selected&#13;&#10;-4... dStartOffset is higher than the number of used LEDs.&#13;&#10;-5... ClassState not ok&#13;&#10;-6... invalid pointer of colordata&#13;&#10;-8... invalid strip selection" Name="ChangeAllLEDs.dRetCode"/>
		END_VAR;
				//! <Function Comment="This function is used to set one or both LED strips to a uniform color." Name="SetWholeStripe"/>
	FUNCTION GLOBAL SetWholeStripe
		VAR_INPUT
			usSelectStripe 	: USINT;			//! <Variable Comment="which stripe should be set&#13;&#10;1 ... stripe 1&#13;&#10;2 ... stripe 2&#13;&#10;" Name="SetWholeStripe.usSelectStripe"/>
			pColorData 	: ^void;			//! <Variable Comment="Pointer to the array in which the pixel data is stored.&#13;&#10;Only one color has to be transferred on which the strip is set." Name="SetWholeStripe.pColorData"/>
			bEnable 	: BOOL := 1;			//! <Variable Comment="activates / deactivates the function.&#13;&#10;1 ... activated (default)&#13;&#10;0 ... deactivated&#13;&#10;Deactivate is used to set the LED strip back to the color pattern in the Ram." Name="SetWholeStripe.bEnable"/>
		END_VAR
		VAR_OUTPUT
			dRetCode 	: DINT;			//! <Variable Comment="WriteDataMode =1:&#13;&#10;0... data has been copied&#13;&#10;-1... entry is larger than 125 bytes (+3 byte header)&#13;&#10;-2... entry is too large for remaining DO size&#13;&#10;-6... invalid pointer of the color data&#13;&#10;&#13;&#10;WriteDataMode = 0:&#13;&#10;0... data has been copied&#13;&#10;-6... invalid pointer of the color data&#13;&#10;&#13;&#10;-5... ClassState not OK&#13;&#10;-8... invalid strip selection" Name="SetWholeStripe.dRetCode"/>
		END_VAR;
	
	FUNCTION ChangeDO
		VAR_INPUT
			AccessHandle 	: UDINT;
			NewOffset 	: HDINT := SDIAS_UNCHANGED_DYNAMIC_PARA;
			NewLength 	: UDINT := SDIAS_UNCHANGED_DYNAMIC_PARA;
		END_VAR;
				//! <Function Comment="Default Color Table with 256 Colors" Name="DefaultColorTable"/>
	FUNCTION TAB DefaultColorTable;
				//! <Function Comment="Use methode to set individual stripe config.&#13;&#10;required settings: &#13;&#10;PixelOrder&#13;&#10;LSBFirstOut  &#13;&#10;PixelOutT0H   &#13;&#10;PixelOutT1H   &#13;&#10;PixelOutT0L    &#13;&#10;PixelOutT1L    &#13;&#10;ResetPixelTime &#13;&#10;For detailed information please refer to the documentation" Name="IndividualStripeConfig"/>
	FUNCTION VIRTUAL IndividualStripeConfig;
	
	FUNCTION VIRTUAL GLOBAL PWMOut1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL PWMOut2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LEDStripeOn::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SetAllLeds::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StartRollingAddrStripe1::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StartRollingAddrStripe2::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Range::Read
		VAR_OUTPUT
			output (EAX) 	: BDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB PL221::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_PL221
1$UINT, 5$UINT, (SIZEOF(::PL221))$UINT, 
10$UINT, 16$UINT, 0$UINT, 
TO_UDINT(3031612134), "PL221", //Class
TO_UDINT(3175101883), "SdiasBase", 1$UINT, 60$UINT, //Baseclass
//Servers:
(::PL221.PWMOut1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(693677604), "PWMOut1", 
(::PL221.PWMOut2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2958163870), "PWMOut2", 
(::PL221.LEDStripeOn.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(259486138), "LEDStripeOn", 
(::PL221.SetAllLeds.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(851561786), "SetAllLeds", 
(::PL221.SetColorStripe1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1165801888), "SetColorStripe1", 
(::PL221.SetColorStripe2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3698714650), "SetColorStripe2", 
(::PL221.StartRollingAddrStripe1.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2574539887), "StartRollingAddrStripe1", 
(::PL221.StartRollingAddrStripe2.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(8195541), "StartRollingAddrStripe2", 
(::PL221.Range.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1691588857), "Range", 
(::PL221.ExternVoltageOK.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2634085790), "ExternVoltageOK", 
//Clients:
(::PL221.Stripe1_Activate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1367076201), "Stripe1_Activate", 
(::PL221.Stripe1_NumOfLeds.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3277338614), "Stripe1_NumOfLeds", 
(::PL221.Stripe1_Type.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2599961495), "Stripe1_Type", 
(::PL221.Stripe1_ColorResolution.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3452251850), "Stripe1_ColorResolution", 
(::PL221.Stripe1_RefreshCycle.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(4018722759), "Stripe1_RefreshCycle", 
(::PL221.Stripe2_Activate.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3125565034), "Stripe2_Activate", 
(::PL221.Stripe2_NumOfLeds.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1522160119), "Stripe2_NumOfLeds", 
(::PL221.Stripe2_Type.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(476852537), "Stripe2_Type", 
(::PL221.Stripe2_ColorResolution.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2657056078), "Stripe2_ColorResolution", 
(::PL221.Stripe2_RefreshCycle.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2481582620), "Stripe2_RefreshCycle", 
(::PL221.ColorTable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(3712276774), "ColorTable", 
(::PL221.PWM1Enable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1119556940), "PWM1Enable", 
(::PL221.PWM2Enable.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1934823377), "PWM2Enable", 
(::PL221.PWM1Periode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(530664157), "PWM1Periode", 
(::PL221.PWM2Periode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2435730750), "PWM2Periode", 
(::PL221.WriteDataMode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(521013481), "WriteDataMode", 
END_FUNCTION


#define USER_CNT_PL221 26

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_PL221] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION PL221::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= SdiasBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= SdiasBase::ClassState.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, SdiasBase::ClassState.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_PL221;
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #UpdateRt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #UpdateRtPostScan();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #UpdateCy();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #AddAccesses();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #ConnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DisconnectEvent();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #InitModule();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #CheckDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #ReceiveSDOResponse();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #GetTaskCfg();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #GetDeviceID();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[25]		:= #IndividualStripeConfig();

#pragma warning (default : 74)
	SdiasBase::ClassState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF SdiasBase::ClassState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PWMOut1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PWMOut1::Write() );
	IF PWMOut1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	PWMOut2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #PWMOut2::Write() );
	IF PWMOut2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	LEDStripeOn.pMeth			:= StoreMethod( #M_RD_DIRECT(), #LEDStripeOn::Write() );
	IF LEDStripeOn.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetAllLeds.pMeth			:= StoreMethod( #M_RD_DIRECT(), #SetAllLeds::Write() );
	IF SetAllLeds.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetColorStripe1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SetColorStripe1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SetColorStripe2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF SetColorStripe2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StartRollingAddrStripe1.pMeth			:= StoreMethod( #M_RD_DIRECT(), #StartRollingAddrStripe1::Write() );
	IF StartRollingAddrStripe1.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	StartRollingAddrStripe2.pMeth			:= StoreMethod( #M_RD_DIRECT(), #StartRollingAddrStripe2::Write() );
	IF StartRollingAddrStripe2.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Range.pMeth			:= StoreMethod( #Range::Read(), #M_NO_F() );
	IF Range.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL PL221::ConnectEvent
  
  if Stripe1_Activate | Stripe2_Activate then
    if WriteDataMode = 0 then      
      if Stripe1_Activate then
        //change DO Length
        sAccesses.sAccessPDOWriteDataStripe1.ActLength := sizeof(aLedChanges);
        //INFO: Do not copy! Use corresponding functions (ChangeDynAccess) from SdiasBase! 
        ChangeDO(AccessHandle:=sAccesses.sAccessPDOWriteDataStripe1.AccessHandle, NewLength:=sAccesses.sAccessPDOWriteDataStripe1.ActLength);
        sAccesses.sAccessPDOWriteDataStripe1.LastDOLen := sAccesses.sAccessPDOWriteDataStripe1.ActLength;
        
        if sAccesses.sAccessPDOWriteDataStripe1.pControlByte then
          sAccesses.sAccessPDOWriteDataStripe1.pControlByte^.EnableDO := TRUE;
          // Reset output memory area
          _memset(sAccesses.pPDOWriteDataStripe1, 0, sizeof(t_LEDChanges));
        else
          eInitState := _DOHandleInvalid;
          return;
        end_if;        
      end_if;

      if Stripe2_Activate then
        sAccesses.sAccessPDOWriteDataStripe2.ActLength := sizeof(aLedChanges2);
        //INFO: Do not copy! Use corresponding functions (ChangeDynAccess) from SdiasBase!         
        ChangeDO(AccessHandle:=sAccesses.sAccessPDOWriteDataStripe2.AccessHandle, NewLength:=sAccesses.sAccessPDOWriteDataStripe2.ActLength);
        sAccesses.sAccessPDOWriteDataStripe2.LastDOLen := sAccesses.sAccessPDOWriteDataStripe2.ActLength;      

        if sAccesses.sAccessPDOWriteDataStripe2.pControlByte then
          sAccesses.sAccessPDOWriteDataStripe2.pControlByte^.EnableDO := TRUE;
          // Reset output memory area
          _memset(sAccesses.pPDOWriteDataStripe2, 0, sizeof(t_LEDChanges2));
        else
          eInitState := _DOHandleInvalid;
          return;
        end_if;      
      end_if;
    end_if;  
    
    if sAccesses.sAccessPDOSequenzerConfig.pControlByte then
      sAccesses.sAccessPDOSequenzerConfig.pControlByte^.EnableDO := TRUE;
      // Reset output memory area
      _memset(sAccesses.pPDOSequenzerConfig, 0, sizeof(t_PDOSequenzerConfig));
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;
  end_if;

  if PWM1Enable | PWM2Enable then
    if sAccesses.sAccessPDOPWMOutHighTime.pControlByte then
      sAccesses.sAccessPDOPWMOutHighTime.pControlByte^.EnableDO := TRUE;
      // Reset output memory area
      _memset(sAccesses.pPDOPWMOutHighTime, 0, sizeof(t_PDOPWMOutHighTime));
    else
      eInitState := _DOHandleInvalid;
      return;
    end_if;  
  end_if;  

  if sAccesses.sAccessPDOReadModulInfo.pControlByte then
    sAccesses.sAccessPDOReadModulInfo.pControlByte^.EnableDO := TRUE;
  else
    eInitState := _DOHandleInvalid;
    return;
  end_if;
  
  eInitSSW        := _InitVariables;
  eResponseState  := _idle;
  eInitState      := _NotInitialized;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::AddAccesses
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	MyPara    : CmdStruct;
    MyResult  : results;
  END_VAR


  Stripe1_Activate  := Stripe1_Activate.Read() <> 0;
  Stripe2_Activate  := Stripe2_Activate.Read() <> 0;
  PWM1Enable        := PWM1Enable.Read() <> 0;
  PWM2Enable        := PWM2Enable.Read() <> 0;
  WriteDataMode     := WriteDataMode.Read() <> 0;
  
  if Stripe1_Activate | Stripe2_Activate then
    if WriteDataMode then
      
      //INFO: Do not copy! Use corresponding functions (AddDynWrAccess; AddDynRdAccess) from SdiasBase!       
      //create DO for individual changes
      MyPara.uiCmd    := SDIAS_CMD_ADD_DYN_WR_ACCESS;
      MyPara.aPara[0] := this$DINT;
      MyPara.aPara[1] := Place$DINT;
      MyPara.aPara[2] := Required; 
      MyPara.aPara[3] := PL221_ADDR_CONFIG_WRITE1;
      MyPara.aPara[4] := sizeof(aLedChanges);
      MyPara.aPara[5] := (#sAccesses.pPDOWriteData)$DINT;
      MyPara.aPara[6] := (#sAccesses.sAccessPDOWriteData.pStateByte)$DINT;
      MyPara.aPara[7] := (#sAccesses.sAccessPDOWriteData.pControlByte)$DINT;
      MyPara.aPara[8] := (#sAccesses.sAccessPDOWriteData.AccessHandle)$DINT;
      MyPara.aPara[9] := 0; // wait for access handle;
      MyPara.aPara[10] := 0;// it's a memory access;
      
      eModuleInitState := ClassState.NewInst(#MyPara, #MyResult);
      
      if eModuleInitState <> READY then
#ifdef HWC_LOGVALUE1
          HWC_LOGVALUE1(this, "@00DD (PL221::AddAccesses) Failed to add Access for Module at Place 0x{0}",MyPara.aPara[2]$UDINT);
#endif
        return;
      end_if;
    else
      if Stripe1_Activate then      
        //INFO: Do not copy! Use corresponding functions (AddDynWrAccess; AddDynRdAccess) from SdiasBase!             
        //create DO for stripe 1
        MyPara.uiCmd    := SDIAS_CMD_ADD_DYN_WR_ACCESS;
        MyPara.aPara[0] := this$DINT;
        MyPara.aPara[1] := Place$DINT;
        MyPara.aPara[2] := Required; 
        MyPara.aPara[3] := PL221_ADDR_CONFIG_WRITE0;
        MyPara.aPara[4] := sizeof(aLedChanges);
        MyPara.aPara[5] := (#sAccesses.pPDOWriteDataStripe1)$DINT;
        MyPara.aPara[6] := (#sAccesses.sAccessPDOWriteDataStripe1.pStateByte)$DINT;
        MyPara.aPara[7] := (#sAccesses.sAccessPDOWriteDataStripe1.pControlByte)$DINT;
        MyPara.aPara[8] := (#sAccesses.sAccessPDOWriteDataStripe1.AccessHandle)$DINT;
        MyPara.aPara[9] := 0; // wait for access handle;
        MyPara.aPara[10] := 0;// it's a memory access;
        
        eModuleInitState := ClassState.NewInst(#MyPara, #MyResult);
        
        if eModuleInitState <> READY then
#ifdef HWC_LOGVALUE1
          HWC_LOGVALUE1(this, "@00DD (PL221::AddAccesses) Failed to add Access for Module at Place 0x{0}",MyPara.aPara[2]$UDINT);
#endif
          return;
        end_if;      
      end_if;
      
      if Stripe2_Activate then
        //INFO: Do not copy! Use corresponding functions (AddDynWrAccess; AddDynRdAccess) from SdiasBase!             
        //create DO for stripe 2
        MyPara.uiCmd    := SDIAS_CMD_ADD_DYN_WR_ACCESS;
        MyPara.aPara[0] := this$DINT;
        MyPara.aPara[1] := Place$DINT;
        MyPara.aPara[2] := Required; 
        MyPara.aPara[3] := PL221_ADDR_CONFIG_WRITE0;
        MyPara.aPara[4] := sizeof(aLedChanges2);
        MyPara.aPara[5] := (#sAccesses.pPDOWriteDataStripe2)$DINT;
        MyPara.aPara[6] := (#sAccesses.sAccessPDOWriteDataStripe2.pStateByte)$DINT;
        MyPara.aPara[7] := (#sAccesses.sAccessPDOWriteDataStripe2.pControlByte)$DINT;
        MyPara.aPara[8] := (#sAccesses.sAccessPDOWriteDataStripe2.AccessHandle)$DINT;
        MyPara.aPara[9] := 0; // wait for access handle;
        MyPara.aPara[10] := 0;// it's a memory access;
        
        eModuleInitState := ClassState.NewInst(#MyPara, #MyResult);
        
        if eModuleInitState <> READY then
#ifdef HWC_LOGVALUE1
          HWC_LOGVALUE1(this, "@00DD (PL221::AddAccesses) Failed to add Access for Module at Place 0x{0}",MyPara.aPara[2]$UDINT);
#endif        
        return;
        end_if;      
      end_if;
    end_if;
 
    if AddWrAccess(hOffset              := PL221_ADDR_SEQUENZER_WRITE
                 , uLength              := sizeof(t_PDOSequenzerConfig)
                 , ppData               := #sAccesses.pPDOSequenzerConfig
                 , ppStateByte          := #sAccesses.sAccessPDOSequenzerConfig.pStateByte
                 , ppControlByte        := #sAccesses.sAccessPDOSequenzerConfig.pControlByte
                 , pAccessHandle        := #sAccesses.sAccessPDOSequenzerConfig.AccessHandle
                 ) <> READY then
#ifdef HWC_LogError
          HWC_LogError(this, "@00DE (PL221::AddAccesses) Failed adding write access for Sequenzer Config failed");
#endif   
    end_if;    
  end_if;
  
  if PWM1Enable | PWM2Enable then
    if AddWrAccess(hOffset              := PL221_ADDR_PWMHIGHTIME_WRITE
                 , uLength              := sizeof(t_PDOPWMOutHighTime)
                 , ppData               := #sAccesses.pPDOPWMOutHighTime
                 , ppStateByte          := #sAccesses.sAccessPDOPWMOutHighTime.pStateByte
                 , ppControlByte        := #sAccesses.sAccessPDOPWMOutHighTime.pControlByte
                 , pAccessHandle        := #sAccesses.sAccessPDOPWMOutHighTime.AccessHandle
                 ) <> READY then
#ifdef HWC_LogError
          HWC_LogError(this, "@00DF (PL221::AddAccesses) Failed adding write access for PWM OUTPUT HIGH TIME");
#endif  
    end_if;     
  end_if;

  if AddRdAccess(hOffset              := PL221_ADDR_STATEREG_READ
               , uLength              := sizeof(t_PDOReadModulInfo)
               , ppData               := #sAccesses.pPDOReadModulInfo
               , ppStateByte          := #sAccesses.sAccessPDOReadModulInfo.pStateByte
               , ppControlByte        := #sAccesses.sAccessPDOReadModulInfo.pControlByte
               , pAccessHandle        := #sAccesses.sAccessPDOReadModulInfo.AccessHandle
               ) <> READY then
               
#ifdef HWC_LogError
          HWC_LogError(this, "@00E0 (PL221::AddAccesses) Failed adding read access for State Register");
#endif
  end_if;
  
  eModuleInitState := READY;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::InitModule
	VAR_OUTPUT
		eModuleInitState 	: iprStates;
	END_VAR
  VAR
  	TmpRetcode    : iprStates;
    i             : USINT;   
    tmpOffset     : USINT;
    tmpOffset2    : USINT;
  END_VAR
  
  eModuleInitState := BUSY;
  
  case eInitSSW of
    //******************************************************************************************************************************************
  	_InitVariables:
    
      //init Flag
      bCopyInitValueFinish := FALSE; 
      
      //Stripe 1
      Stripe1_Type              := Stripe1_Type.Read();       
      Stripe1_NumOfLeds         := Stripe1_NumOfLeds.Read();  
      Stripe1_ColorResolution   := Stripe1_ColorResolution.Read();
      Stripe1_RefreshCycle      := Stripe1_RefreshCycle.Read();
      
      //Stripe 2
      Stripe2_Type              := Stripe2_Type.Read();
      Stripe2_NumOfLeds         := Stripe2_NumOfLeds.Read();   
      Stripe2_ColorResolution   := Stripe2_ColorResolution.Read();
      Stripe2_RefreshCycle      := Stripe2_RefreshCycle.Read(); 
      
      //PWM
      PWM1Periode               := PWM1Periode.Read();
      PWM2Periode               := PWM2Periode.Read();
      
      //check invalid config
      if Stripe1_Type < 0 then
        Stripe1_Type := 0;
      elsif Stripe1_Type > 2 then
        Stripe1_Type := 2;
      end_if;
      
      if Stripe2_Type < 0 then
        Stripe2_Type := 0;
      elsif Stripe2_Type > 2 then
        Stripe2_Type := 2;
      end_if;
      
      if Stripe1_ColorResolution < 0 then
        Stripe1_ColorResolution := 0;
      elsif Stripe1_ColorResolution > 3 then
        Stripe1_ColorResolution := 3;
      end_if;
      
      if Stripe2_ColorResolution < 0 then
        Stripe2_ColorResolution := 0;
      elsif Stripe2_ColorResolution > 3 then
        Stripe2_ColorResolution := 3;
      end_if;      
      
      if Stripe1_NumOfLeds < 0 then
        Stripe1_NumOfLeds := 1;
      elsif Stripe1_NumOfLeds > 512 then
        Stripe1_NumOfLeds := 512;
      end_if;

      if Stripe2_NumOfLeds < 0 then
        Stripe2_NumOfLeds := 1;
      elsif Stripe2_NumOfLeds > 512 then
        Stripe2_NumOfLeds := 512;
      end_if;      
       
      if Stripe1_RefreshCycle <= 0 | ((Stripe1_RefreshCycle > 83) & (Stripe1_NumOfLeds = 512)) then
        Stripe1_RefreshCycle := 50;
      end_if;
      
      if Stripe2_RefreshCycle <= 0 | ((Stripe2_RefreshCycle > 83) & (Stripe2_NumOfLeds = 512)) then
        Stripe2_RefreshCycle := 50;
      end_if; 
      
      if PWM1Periode < 50 then
        PWM1Periode := 50;
      elsif PWM1Periode > 1000 then
        PWM1Periode := 1000;
      end_if;
      
      if PWM2Periode < 50 then
        PWM2Periode := 50;
      elsif PWM2Periode > 1000 then
        PWM2Periode := 1000;
      end_if;
      
      //***********************Stripe 1*****************************************
      //Type WS2812B
      if Stripe1_Type = 0 then
        //Pixel Order GRB
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput1OrderBit0 := FALSE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput1OrderBit1 := TRUE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput1OrderBit2 := FALSE;
        
        //LSB
        sSDOHardwareControlWrite.PixelOrderConfig.LSBFirstOut1 := 0;
        
        //Data Transfer Time
        sSDOHardwareControlWrite.PixelOut1T0H :=  (PL221_T0H_TYP0 / PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut1T1H :=  (PL221_T1H_TYP0 / PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut1T0L :=  (PL221_T0L_TYP0 / PL221_SCALE); 
        sSDOHardwareControlWrite.PixelOut1T1L :=  (PL221_T1L_TYP0 / PL221_SCALE);
        
        //Resetcode
        sSDOHardwareControlWrite.ResetPixelOut1 := PL221_RESETTIME_TYP0;
      
      //Type WS2813
      elsif Stripe1_Type = 1 then
        //Pixel Order GRB
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput1OrderBit0 := FALSE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput1OrderBit1 := TRUE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput1OrderBit2 := FALSE;  
        
        //LSB
        sSDOHardwareControlWrite.PixelOrderConfig.LSBFirstOut1 := 0;        
        
        //Data Transfer Time
        sSDOHardwareControlWrite.PixelOut1T0H :=  (PL221_T0H_TYP1/PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut1T1H :=  (PL221_T1H_TYP1/PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut1T0L :=  (PL221_T0L_TYP1/PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut1T1L :=  (PL221_T1L_TYP1/PL221_SCALE);
        
        //Resetcode
        sSDOHardwareControlWrite.ResetPixelOut1 := PL221_RESETTIME_TYP1;
      
      //individual Type
      elsif Stripe1_Type = 2 then
        
        IndividualStripeConfig();
         
         //Pixel Order 
        sSDOHardwareControlWrite.PixelOrderConfig := (sSDOHardwareControlWrite.PixelOrderConfig) 
                                                  OR (IndividualStripeCon1.PixelOrder$USINT AND 0x07); 
        
        //LSB
        sSDOHardwareControlWrite.PixelOrderConfig.LSBFirstOut1 := IndividualStripeCon1.LSBFirstOut;        
        
        //Data Transfer Time
        sSDOHardwareControlWrite.PixelOut1T0H :=  (IndividualStripeCon1.PixelOutT0H/PL221_SCALE)$USINT;
        sSDOHardwareControlWrite.PixelOut1T1H :=  (IndividualStripeCon1.PixelOutT1H/PL221_SCALE)$USINT;
        sSDOHardwareControlWrite.PixelOut1T0L :=  (IndividualStripeCon1.PixelOutT0L/PL221_SCALE)$USINT;
        sSDOHardwareControlWrite.PixelOut1T1L :=  (IndividualStripeCon1.PixelOutT1L/PL221_SCALE)$USINT;
        
        //Resetcode
        sSDOHardwareControlWrite.ResetPixelOut1 := IndividualStripeCon1.ResetPixelTime;        
      end_if;
      
      //***********************Stripe 2*****************************************
      //Type WS2812B      
      if Stripe2_Type = 0 then
        //Pixel Order GRB
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput2OrderBit0 := FALSE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput2OrderBit1 := TRUE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput2OrderBit2 := FALSE;
        
        //LSB
        sSDOHardwareControlWrite.PixelOrderConfig.LSBFirstOut2 := 0;
        
        //Data Transfer Time
        sSDOHardwareControlWrite.PixelOut2T0H :=  (PL221_T0H_TYP0 / PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut2T1H :=  (PL221_T1H_TYP0 / PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut2T0L :=  (PL221_T0L_TYP0 / PL221_SCALE); 
        sSDOHardwareControlWrite.PixelOut2T1L :=  (PL221_T1L_TYP0 / PL221_SCALE);
        
        //Resetcode
        sSDOHardwareControlWrite.ResetPixelOut2 := PL221_RESETTIME_TYP0;
      
      //Type WS2813      
      elsif Stripe2_Type = 1 then
        //Pixel Order GRB
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput2OrderBit0 := FALSE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput2OrderBit1 := TRUE;
        sSDOHardwareControlWrite.PixelOrderConfig.PixelOutput2OrderBit2 := FALSE;  
        
        //LSB
        sSDOHardwareControlWrite.PixelOrderConfig.LSBFirstOut2 := 0;
        
        //Data Transfer Time
        sSDOHardwareControlWrite.PixelOut2T0H :=  (PL221_T0H_TYP1/PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut2T1H :=  (PL221_T1H_TYP1/PL221_SCALE);
        sSDOHardwareControlWrite.PixelOut2T0L :=  (PL221_T0L_TYP1/PL221_SCALE); 
        sSDOHardwareControlWrite.PixelOut2T1L :=  (PL221_T1L_TYP1/PL221_SCALE);   
        
        //Resetcode
        sSDOHardwareControlWrite.ResetPixelOut2 := PL221_RESETTIME_TYP1;
      
      //individual Type  
      elsif Stripe2_Type = 2 then
        
        IndividualStripeConfig();
        
        //Pixel Order 
        sSDOHardwareControlWrite.PixelOrderConfig := (sSDOHardwareControlWrite.PixelOrderConfig) 
                                                  OR ((IndividualStripeCon2.PixelOrder$USINT SHL 4) AND 0x70);                                                
        
        //LSB
        sSDOHardwareControlWrite.PixelOrderConfig.LSBFirstOut2 := IndividualStripeCon2.LSBFirstOut;        
        
        //Data Transfer Time
        sSDOHardwareControlWrite.PixelOut2T0H :=  (IndividualStripeCon2.PixelOutT0H/PL221_SCALE)$USINT;
        sSDOHardwareControlWrite.PixelOut2T1H :=  (IndividualStripeCon2.PixelOutT1H/PL221_SCALE)$USINT;
        sSDOHardwareControlWrite.PixelOut2T0L :=  (IndividualStripeCon2.PixelOutT0L/PL221_SCALE)$USINT;
        sSDOHardwareControlWrite.PixelOut2T1L :=  (IndividualStripeCon2.PixelOutT1L/PL221_SCALE)$USINT;
        
        //Resetcode
        sSDOHardwareControlWrite.ResetPixelOut2 := IndividualStripeCon2.ResetPixelTime;      
      end_if;
            
      //Number of LED's
      sSDOHardwareControlWrite.PixelOutput1Length := Stripe1_NumOfLeds$UINT;
      sSDOHardwareControlWrite.PixelOutput2Length := Stripe2_NumOfLeds$UINT;
      
      //Refresh Mode (continous Run) 

      sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput1Config := TRUE;
      sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput2Config := TRUE;
      
      //LED's on/ off
      if Stripe1_Activate = 0 & Stripe2_Activate = 0 then
        LEDStripeOn :=0;
      end_if;

      if Stripe1_Activate then
        sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput1Enable := LEDStripeOn <> 0;
        sSDOHardwareControlWrite.ControlRegister.DC5VEnable           := LEDStripeOn <> 0;
      end_if;
      
      if Stripe2_Activate then
        sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput2Enable := LEDStripeOn <> 0;
        sSDOHardwareControlWrite.ControlRegister.DC5VEnable           := LEDStripeOn <> 0;
      end_if;

      //Set Color Resolution
      if Stripe1_ColorResolution = 0 then     //24bit mode
        aStripes[0].usColorSize := 3;
      elsif Stripe1_ColorResolution = 1 then  //16bit mode
        aStripes[0].usColorSize := 2;
      elsif Stripe1_ColorResolution = 2 then  //8bit mode
        aStripes[0].usColorSize := 1;
      elsif Stripe1_ColorResolution = 3 then  //4bit mode
        aStripes[0].usColorSize := 1; 
      end_if;

      if Stripe2_ColorResolution = 0 then
        aStripes[1].usColorSize := 3;
      elsif Stripe2_ColorResolution = 1 then
        aStripes[1].usColorSize := 2;
      elsif Stripe2_ColorResolution = 2 then
        aStripes[1].usColorSize := 1;
      elsif Stripe2_ColorResolution = 3 then
        aStripes[1].usColorSize := 1; 
      end_if;   
      
      //Set PWM Period
      sSDOHardwareControlWrite.PWMOut1Period := (PWM1Periode AND 0x3FF)$UINT;
      sSDOHardwareControlWrite.PWMOut2Period := (PWM2Periode AND 0x3FF)$UINT;
      
      //Sequencer Endaddress
      sSDOHardwareControlWrite.Sequencer1EndAdress := ((Stripe1_NumOfLeds - 1) AND 0x3FF)$UINT;      
      sSDOHardwareControlWrite.Sequencer2EndAdress := ((Stripe2_NumOfLeds - 1) AND 0x3FF)$UINT;
      //Sequencer Endaddress activate
      sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput1EndAddrEnable := TRUE;
      sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput2EndAddrEnable := TRUE;    
  
      if WriteDataMode then
        //Set pointer to start of datamemory
        pLedHeader$^USINT := #aLedChanges[0];
        pLastHeader       := pLedHeader;      
      else
        //init stripe config      
        aStripes[0].pLEDDataHeader$^USINT  := #aLedChanges[0];
        aStripes[1].pLEDDataHeader$^USINT  := #aLedChanges2[0];
        
        aStripes[0].pLEDDataHeader^.StripeConfig := ((0 SHL 10) AND 0x1C00);
        aStripes[1].pLEDDataHeader^.StripeConfig := ((1 SHL 10) AND 0x1C00);        
      end_if;

      //Set DO'size
      usRemainingDOLength := sizeof(aLedChanges);
        
      //Init stripe for "_SetMemoryZero" Set all Leds to value 0 after Reset/Run
      pStripeInit                     := #aStripes[0];
      ActIndex                        := 0;
      pStripeInit^.uiPixelStartAddr   := 0;
      aStripes[0].usStripeNum         := 2#000;
      aStripes[1].usStripeNum         := 2#001;
      aStripes[0].uiNumOfCopyLeds     := Stripe1_NumOfLeds$UINT; 
      aStripes[1].uiNumOfCopyLeds     := Stripe2_NumOfLeds$UINT;
      
      //calculate whole LED Data byte for init reset 
      aStripes[0].uiWholeLedData      := (Stripe1_NumOfLeds * aStripes[0].usColorSize)$UINT;
      aStripes[1].uiWholeLedData      := (Stripe2_NumOfLeds * aStripes[1].usColorSize)$UINT;
      
      //Color Array for "_SetMemoryZero" with color "black"
      for i:= 2 to 29 do
        aMemoryInitColor[i] := 0;
      end_for;
      
      //If a LUT is required, the data is written to the Ram in the init. 
      if Stripe1_ColorResolution = 2 |
      Stripe1_ColorResolution = 3 |
      Stripe2_ColorResolution = 2 |
      Stripe2_ColorResolution = 3 then
        eInitSSW  := _WriteColorTable;      
      else
        eInitSSW  :=_SetMemoryZero;
      end_if;
    
    //******************************************************************************************************************************************   
  	_SetMemoryZero:

        case eResponseState of
                        
          _idle:
            //copy Stripe header in Array
            aMemoryInitColor[0]$BINT := (pStripeInit^.uiPixelStartAddr AND 0x7FF) 
                                     OR ((pStripeInit^.usStripeNum SHL 10) AND 0x1C00)
                                     OR ((1 SHL 13) AND 0xE000);
                                  
            
            pStripeInit^.pLedPixelData := #aMemoryInitColor;
              
            //send always 30 Byte Data (2 Byte Header/28 Byte LED Data)
            TmpRetcode  :=StartWriteSDO(hOffset:=PL221_ADDR_CONFIG_WRITE0, usLength:=sizeof(aMemoryInitColor), pWriteBuffer:=(#aMemoryInitColor)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);        
            
            if TmpRetcode =READY then
              udSDOTimeout    := ops.tAbsolute;
              eResponseState  := _wait;            
            elsif TmpRetcode = ERROR then
              eModuleInitState  := ERROR;
#ifdef HWC_LogError
                HWC_LogError(this, "@00E1 (PL221::InitModule) Failed to write SDO for Set Memory to zero");
#endif              
              eInitState        := _NoMem;          
            end_if;            
          //*****************************************************
          _wait:
            //Wait for response
            if ((ops.tAbsolute - udSDOTimeout) > PL221_SDO_RESPONSE_TIMEOUT) then
#ifdef HWC_LogError
                HWC_LogError(this, "@00E2 (PL221::InitModule) SDO Response timeout write set memory to zero");
#endif  
              eInitSSWErrorStep := eInitSSW;
              eInitSSW          := _InitError;          
            end_if;
          //*****************************************************            
          _valid:
            
            //last run, less than 28 led bytes
            if pStripeInit^.uiWholeLedData <= PL221_MAX_LED_DATA_BYTES then
            
              //set PixelAdress to last address in Ram to reset LED color for init PDO
              if bCopyInitValueFinish & pStripeInit^.uiPixelStartAddr <> PL221_LAST_RAM_ADDRESS then                
                eResponseState                := _idle;
                eInitSSW                      := _SetMemoryZero;
                pStripeInit^.uiPixelStartAddr := PL221_LAST_RAM_ADDRESS;
                
              //stripe 1 finish with init, change to second stripe
              elsif bCopyInitValueFinish & pStripeInit^.uiPixelStartAddr = PL221_LAST_RAM_ADDRESS then
                pStripeInit += sizeof(t_LEDStripeVars);              
                ActIndex    += 1;
                
                //init finish
                if ActIndex >= PL221_MAX_LED_STRIPES then
                  eInitSSW        := _WritePixelLength;
                  eResponseState  := _idle;
                else
                  //reset for second stripe
                  pStripeInit^.uiPixelStartAddr   := 0;
                  bCopyInitValueFinish            := FALSE;              
                  eInitSSW                        := _SetMemoryZero;
                  eResponseState                  := _idle;
                end_if;
              else
                //send last LED Data 
                eResponseState                := _idle;
                eInitSSW                      := _SetMemoryZero;                                
                pStripeInit^.uiWholeLedData   -= pStripeInit^.uiWholeLedData;
                pStripeInit^.uiPixelStartAddr += (PL221_MAX_LED_DATA_BYTES / 2); 
                bCopyInitValueFinish          := TRUE;              
              end_if;              
                
            elsif pStripeInit^.uiWholeLedData > PL221_MAX_LED_DATA_BYTES then
              //send next 28 bytes
              //28 Byte = 14 LED*s
              //set Pixeladress to next position
              eResponseState                := _idle;
              eInitSSW                      := _SetMemoryZero;
              pStripeInit^.uiWholeLedData   -= PL221_MAX_LED_DATA_BYTES;
              pStripeInit^.uiPixelStartAddr += (PL221_MAX_LED_DATA_BYTES / 2);             
            end_if;
            
        end_case;    
    //******************************************************************************************************************************************
    _WriteColorTable:
    
      case eResponseState of
      	_idle:
          //read Table
         if bTablerReadFinish = FALSE then
            //check if Usertable is connect
           if IsClientConnected(#ColorTable) then                           
              pTableentry$DINT := ColorTable.Read();
              if pTableentry <> NIL then
                //Tablelength
                udTablength := pTableentry^$UDINT;
                //get pointer without Tableheader
                pTableentry += sizeof(UDINT);             
              end_if;

              bTablerReadFinish := TRUE;
              uiTableOffset     := 0;
              uiPixelStartAddr  := 0;
              
            else
              //Default tabelle
              pTableentry := (#DefaultColorTable())$^USINT;
              //Tablelength
              udTablength  := pTableentry^$UDINT;
              //get pointer without Tableheader
              pTableentry += sizeof(UDINT);
              
              bTablerReadFinish := TRUE;   
              uiTableOffset     := 0;
              uiPixelStartAddr  := 0;              
            end_if;        
          end_if;
          
          //copy Stripe header in Array
          aTableData[0]$BINT      := (uiPixelStartAddr AND 0x7FF) 
                                   OR ((2#111 SHL 10) AND 0x1C00)
                                   OR ((0 SHL 13) AND 0xE000);        
          
          tmpOffset   := 0;
          tmpOffset2  := 0;
          //copy Tabledata into Array
          for i:= 0 to 9 do
            _memcpy(ptr1:=#aTableData[2 + tmpOffset], ptr2:=pTableentry + uiTableOffset + tmpOffset2, cntr:=3);
            tmpOffset += 3;
            tmpOffset2 += 4;
          end_for;
          //write Array with 10 Leddata
          TmpRetcode  :=StartWriteSDO(hOffset:=PL221_ADDR_CONFIG_WRITE0, usLength:=sizeof(aTableData), pWriteBuffer:=(#aTableData)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          
          if TmpRetcode = READY then
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := _wait;
          elsif TmpRetcode = ERROR then
            eModuleInitState  := ERROR;
#ifdef HWC_LogError
              HWC_LogError(this, "@00E3 (PL221::InitModule) Failed to add write SDO for LUT RAM");
#endif 
            eInitState        := _NoMem;
          end_if;
        //*****************************************************          
      	_wait:
          //Wait for response
          if ((ops.tAbsolute - udSDOTimeout) > PL221_SDO_RESPONSE_TIMEOUT) then
#ifdef HWC_LogError
              HWC_LogError(this, "@00E2 (PL221::InitModule) SDO Response timeout write set memory to zero");
#endif  
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;          
          end_if;
        //*****************************************************  
      	_valid:
          if udTablength > 40 then
            eResponseState  := _idle;
            eInitSSW        := _WriteColorTable;
            
            //40 byte = 10 LEDS
            udTablength         -= 40;
            uiPixelStartAddr    += 10;            
            uiTableOffset       += 40;
              
          elsif (udTablength <= 10) & (bCopyColorTable = FALSE) then
            bCopyColorTable := TRUE;
            eResponseState  := _idle;
            eInitSSW        := _WriteColorTable;
          else
            //write table finish
            eResponseState  := _idle;
            eInitSSW        := _SetMemoryZero;              
          end_if;
        //*****************************************************
      end_case;
      
    //******************************************************************************************************************************************  
    _WritePixelLength:
      case eResponseState of
      	//*************************************************
        _idle:                    
          TmpRetcode  :=StartWriteSDO(hOffset:=PL221_PIXEL_LENGTH, usLength:=sizeof(DINT), pWriteBuffer:=(#sSDOHardwareControlWrite.PixelOutput1Length)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := _wait;
          elsif TmpRetcode = ERROR then
            eModuleInitState  := ERROR;
#ifdef HWC_LogError
              HWC_LogError(this, "@00E4 (PL221::InitModule) Failed to add write SDO for HardwareControl");
#endif              
            eInitState        := _NoMem;
          end_if;        
      	//*************************************************        
      	_wait:
          //Wait for response
          if ((ops.tAbsolute - udSDOTimeout) > PL221_SDO_RESPONSE_TIMEOUT) then
#ifdef HWC_LogError
              HWC_LogError(this, "@00E2 (PL221::InitModule) SDO Response timeout write set memory to zero");
#endif 
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;          
          end_if;       
      	//*************************************************        
      	_valid:
          eInitSSW        := _WriteConfigModule;
          eResponseState  := _idle;
        //*************************************************        
      end_case;    
      
      
    //******************************************************************************************************************************************  
    _WriteConfigModule:
      case eResponseState of
      	//*************************************************
        _idle:                    
          TmpRetcode  :=StartWriteSDO(hOffset:=PL221_ADDR_CONFIG_PIXEL_OUT, usLength:=sizeof(t_SDOHardwareControl), pWriteBuffer:=(#sSDOHardwareControlWrite)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          if TmpRetcode = READY then
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := _wait;
          elsif TmpRetcode = ERROR then
            eModuleInitState  := ERROR;
#ifdef HWC_LogError
              HWC_LogError(this, "@00E4 (PL221::InitModule) Failed to add write SDO for HardwareControl");
#endif              
            eInitState        := _NoMem;
          end_if;        
      	//*************************************************        
      	_wait:
          //Wait for response
          if ((ops.tAbsolute - udSDOTimeout) > PL221_SDO_RESPONSE_TIMEOUT) then
#ifdef HWC_LogError
              HWC_LogError(this, "@00E2 (PL221::InitModule) SDO Response timeout write set memory to zero");
#endif 
            eInitSSWErrorStep := eInitSSW;
            eInitSSW          := _InitError;          
          end_if;       
      	//*************************************************        
      	_valid:
          eInitSSW        := _SequenzerInit;
          eResponseState  := _idle;  

        //*************************************************        
      end_case;
      
    //****************************************************************************************************************************************** 
    _SequenzerInit:
                
      //set sequenzer to last RAM address      
      
      //set sequenzer address "and 0x7FF" because only 10 Bit are used
      sOutputValuesSequenzerConfig.Sequenzer1Config                 := (PL221_LAST_RAM_ADDRESS AND 0x7FF);
      //autoincrement set 0. take the same coloraddress for all led
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 0;
      //set sequenzer address "and 0x7FF" because only 10 Bit are used
      sOutputValuesSequenzerConfig.Sequenzer2Config                 := (PL221_LAST_RAM_ADDRESS AND 0x7FF);
      //autoincrement set 0. take the same coloraddress for all led
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 0;
      
      eInitSSW        := _Finish;      
        
    //******************************************************************************************************************************************
  	_Finish:
      eInitSSW          := _InitVariables;
      eModuleInitState  := READY;
      eInitState        := _ClassOk;
    
    //******************************************************************************************************************************************
  	_InitError:
      eModuleInitState  := ERROR;
      if (eInitState <> _InvalidConfguration) then
        eInitState      := _ClientNotready;
      end_if;

  end_case;
    
END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::CheckDeviceID
	VAR_INPUT
		udID2Check 	: UDINT;
	END_VAR
	VAR_OUTPUT
		bIsOK 	: BOOL;
	END_VAR
  
  //look if it is right hardware
  if ( udID2Check <> DEVICE_ID_PL221 ) then
    bIsOK := FALSE;
  else
    bIsOK := TRUE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::DisconnectEvent

  if sAccesses.pPDOSequenzerConfig then
    //reset output memory area
    _memset(sAccesses.pPDOSequenzerConfig, 0, sizeof(t_PDOSequenzerConfig));
  end_if; 
  
  if WriteDataMode = 0 then
    if sAccesses.pPDOWriteDataStripe1 then
      //reset output memory area
      _memset(sAccesses.pPDOWriteDataStripe1, 0, sizeof(t_LEDChanges));
    end_if;
    
    if sAccesses.pPDOWriteDataStripe2 then
      //reset output memory area
      _memset(sAccesses.pPDOWriteDataStripe2, 0, sizeof(t_LEDChanges2));
    end_if;  
  end_if;
  
  if sAccesses.pPDOPWMOutHighTime then
    _memset(sAccesses.pPDOPWMOutHighTime, 0, sizeof(t_PDOPWMOutHighTime));
  end_if;
  
  SdiasBase::DisconnectEvent();

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::GetDeviceID
	VAR_OUTPUT
		output 	: UDINT;
	END_VAR

  output := DEVICE_ID_PL221;
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::UpdateRt
  VAR
  	TmpReadData : t_PDOReadModulInfo;
  END_VAR
  
  TmpReadData       := sAccesses.pPDOReadModulInfo^;
  ExternVoltageOK   := TmpReadData.StateRegister AND 0x03;  
  
  //check for latched bits
  if ((TmpReadData.StateRegister SHR 2) AND 0x1F) | bRangeErrorReadLatch then
  
    Range.1 := TmpReadData.StateRegister.OvercurrentPWMLatched;
    Range.2 := TmpReadData.StateRegister.OvercurrentLEDsLatched;
    Range.3 := TmpReadData.StateRegister.ShortciruitPWMLatched;
    Range.4 := TmpReadData.StateRegister.OverTemperaturePWMLatched;
    Range.5 := TmpReadData.StateRegister.SupplyDisableOTErrorLatched;
    bRangeErrorReadLatch  := FALSE;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::UpdateRtPostScan
  VAR
    i       : UINT;
  	pStripe : ^t_LEDStripeVars;    
  END_VAR

  if WriteDataMode then
    //disable DO if not needed
    if bSDIASSingleRun then
      bSDIASSingleRun := FALSE;
      if sAccesses.sAccessPDOWriteData.pControlByte then
        sAccesses.sAccessPDOWriteData.pControlByte^.EnableDO  := FALSE;
      end_if;
    end_if; 
    
    //enable DO when new data send
    if sAccesses.sAccessPDOWriteData.ActLength <> 0 then
      //only change the DO if the length of the access has changed    
      if sAccesses.sAccessPDOWriteData.ActLength <> sAccesses.sAccessPDOWriteData.LastDOLen then  
        //INFO: Do not copy! Use corresponding functions (ChangeDynAccess) from SdiasBase!         
        ChangeDO(AccessHandle:= sAccesses.sAccessPDOWriteData.AccessHandle
               , NewLength:= sAccesses.sAccessPDOWriteData.ActLength);
        sAccesses.sAccessPDOWriteData.LastDOLen := sAccesses.sAccessPDOWriteData.ActLength;         
      end_if;        
      
      if sAccesses.pPDOWriteData <> NIL then
        //send Data 
        _memcpy(sAccesses.pPDOWriteData, #aLedChanges[0], sAccesses.sAccessPDOWriteData.ActLength);
        sAccesses.sAccessPDOWriteData.pControlByte^.EnableDO := TRUE;
        bSDIASSingleRun := TRUE;        
      end_if;
      
      //Data finished. set memory to start again
      pLedHeader$^USINT   := #aLedChanges[0];
      pLastHeader         := pLedHeader;
      usRemainingDOLength := sizeof(aLedChanges);           
      sAccesses.sAccessPDOWriteData.ActLength := 0;
    end_if;
    
  else
    pStripe := #aStripes[0];
    for i := 0  to PL221_MAX_LED_STRIPES-1 do
      //copy data  each cycle in the size of uiLedDataPerCylce
      if pStripe^.bStartCopyData then
        //check if copy is finish
        if pStripe^.uiWholeLedData > 0 then
          
          if pStripe^.uiWholeLedData <= pStripe^.uiLedDataPerCycle then
            pStripe^.uiLedDataPerCycle := pStripe^.uiWholeLedData;
          end_if;  
          
          _memcpy(ptr1:=pStripe^.pHelpCopyData, ptr2:=pStripe^.pLedPixelData, cntr:=pStripe^.uiLedDataPerCycle);
          
          if pStripe^.bOneCycle = FALSE then
            //set pointer on next data entry
            pStripe^.pLedPixelData += pStripe^.uiLedDataPerCycle;
          end_if;
          
          pStripe^.uiWholeLedData -= pStripe^.uiLedDataPerCycle;  

        else
          //copy finished
          pStripe^.bStartCopyData := FALSE;
        end_if;
      end_if;
      //copy data from next stripe
      pStripe += sizeof(aStripes[0]);
    end_for;
    
    if Stripe1_Activate  then
      if sAccesses.pPDOWriteDataStripe1 <> NIL then
        //send Data stripe 1
        sAccesses.pPDOWriteDataStripe1^ := aLedChanges;          
        
        //only change the DO if the length of the access has changed    
        if sAccesses.sAccessPDOWriteDataStripe1.ActLength <> sAccesses.sAccessPDOWriteDataStripe1.LastDOLen then
          //INFO: Do not copy! Use corresponding functions (ChangeDynAccess) from SdiasBase!           
          ChangeDO(AccessHandle:= sAccesses.sAccessPDOWriteDataStripe1.AccessHandle
                  , NewLength:= sAccesses.sAccessPDOWriteDataStripe1.ActLength);
          sAccesses.sAccessPDOWriteDataStripe1.LastDOLen := sAccesses.sAccessPDOWriteDataStripe1.ActLength;         
        end_if;         
      end_if;       
    end_if;
    
    if Stripe2_Activate then
      if sAccesses.pPDOWriteDataStripe2 <> NIL then
        //send Data stripe 2
        sAccesses.pPDOWriteDataStripe2^ := aLedChanges2;  
        
        //only change the DO if the length of the access has changed    
        if sAccesses.sAccessPDOWriteDataStripe2.ActLength <> sAccesses.sAccessPDOWriteDataStripe2.LastDOLen then 
          //INFO: Do not copy! Use corresponding functions (ChangeDynAccess) from SdiasBase!           
          ChangeDO(AccessHandle:= sAccesses.sAccessPDOWriteDataStripe2.AccessHandle
                  , NewLength:= sAccesses.sAccessPDOWriteDataStripe2.ActLength);
          sAccesses.sAccessPDOWriteDataStripe2.LastDOLen := sAccesses.sAccessPDOWriteDataStripe2.ActLength;         
        end_if;          
      end_if;       
    end_if;
 
    pStripe := #aStripes[0];
    for i := 0 to PL221_MAX_LED_STRIPES-1 do
      if pStripe^.bStartCopyData then          
        if pStripe^.bOneCycle = FALSE & (pStripe^.uiWholeLedData > 0) then
          //set Pixeladdress to next place
          pStripe^.pLEDDataHeader^.StripeConfig += ((pStripe^.uiNextPixelAddr) AND 0x7FF);
        else
          pStripe^.bStartCopyData := FALSE;
        end_if;         
      end_if;
      pStripe += sizeof(aStripes[0]);
    end_for;
  end_if;
  
  if sAccesses.pPDOSequenzerConfig <> NIL then
    sAccesses.pPDOSequenzerConfig^  := sOutputValuesSequenzerConfig;    
  end_if;  
  
  if PWM1Enable | PWM2Enable then
    if sAccesses.pPDOPWMOutHighTime <> NIL then
      sAccesses.pPDOPWMOutHighTime^   := sOutputValuesPWM;    
    end_if;
  end_if;
  

END_FUNCTION


FUNCTION GLOBAL PL221::ChangeIndividualLED
	VAR_INPUT
		usStripeNumber 	: USINT;
		uiPixelStartAddr 	: UINT;
		usNumberOfLed 	: USINT;
		pData 	: pVoid;
		dStartOffset 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
  	pHelp : ^USINT;
    usColorResolution : USINT;
    b4BitMode : BOOL;
  END_VAR

  if ClassState <> _ClassOk then
    dRetCode := -5;
    return;
  end_if;
  
  //check valid stripe number
  if usStripeNumber <> 1 & usStripeNumber <> 2 then
    dRetCode := -8;
    return;
  end_if;  

  //check pointer of LED Data
  if pData = NIL then
    dRetCode := -6;
    return;
  end_if;

  dRetCode  := 0;
  b4BitMode := FALSE;
  
  if WriteDataMode = 1 then    
    
    usNumOfCopyLeds       := usNumberOfLed;
    pCopyData             := pData;
    usCopyStripeNum       := usStripeNumber;
    uiCopyPixelStartAddr  := uiPixelStartAddr;

    //select right stripe and colorresolution
    if usCopyStripeNum = 1 then
      usCopyStripeNum   := 2#000;
      usColorResolution := Stripe1_ColorResolution$USINT;
      usColorSize       := aStripes[0].usColorSize;
      
      if dStartOffset < Stripe1_NumOfLeds then  //Offset is larger than used LED's
        dStartOffsetStripe1 := dStartOffset;
      else
        dRetCode := -4;
        return;
      end_if;
      
      sOutputValuesSequenzerConfig.Sequenzer1Config                 := (dStartOffsetStripe1 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 1;
      
      //if 4bit mode, data must be halved
      if usColorResolution = 3 then
        b4BitMode := TRUE;
      end_if;

    elsif usCopyStripeNum = 2 then
      usCopyStripeNum   := 2#001;
      usColorResolution := Stripe2_ColorResolution$USINT;
      usColorSize       := aStripes[1].usColorSize;
      
      if dStartOffset < Stripe2_NumOfLeds then //Offset is larger than used LED's
        dStartOffsetStripe2 := dStartOffset;
      else
        dRetCode := -4;
        return;
      end_if;
      
      sOutputValuesSequenzerConfig.Sequenzer2Config                 := (dStartOffsetStripe2 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 1;
      //if 4bit mode, data must be halved
      if usColorResolution = 3 then
        b4BitMode := TRUE;
      end_if;
    end_if;
        
    //length of entry to copy
    if b4BitMode = FALSE then
      usEntrySize := sizeof(t_PDOChangeDataConfig) + (usNumOfCopyLeds * usColorSize);
    else
      usEntrySize := sizeof(t_PDOChangeDataConfig) + (((usNumOfCopyLeds * usColorSize) + 1)/2);
    end_if;
    
    if usEntrySize <= sizeof(aLedChanges) then      
      if usEntrySize <= usRemainingDOLength then      
        //check if it's the first entry 
        if pLedHeader <> pLastHeader then
          pLastHeader^.NumberOfPixelChange.NextConfig := TRUE;
        end_if;
        
        //write header
        pLedHeader^.StripeConfig := (uiCopyPixelStartAddr AND 0x7FF) 
                                    OR ((usCopyStripeNum SHL 10) AND 0x1C00) 
                                    OR ((usColorResolution SHL 13) AND 0xE000);
                                    
        pLedHeader^.NumberOfPixelChange := usNumOfCopyLeds AND 0x7F;        
        
        pHelp := pLedHeader + sizeof(pLedHeader^);
        //copy data        
        if b4BitMode = FALSE then
          _memcpy(ptr1:=pHelp, ptr2:=pCopyData, cntr:= (usNumOfCopyLeds * usColorSize));
        else
          _memcpy(ptr1:=pHelp, ptr2:=pCopyData, cntr:= (((usNumOfCopyLeds * usColorSize) + 1)/2));
        end_if;
       
        pLastHeader := pLedHeader;
        //set pointer on next entry
        if b4BitMode = FALSE then
          pLedHeader := pHelp + (usNumOfCopyLeds * usColorSize); 
        else
          pLedHeader := pHelp + (((usNumOfCopyLeds * usColorSize) + 1)/2);
        end_if;

        usRemainingDOLength -= usEntrySize;
        //change DO length
        sAccesses.sAccessPDOWriteData.ActLength := sizeof(aLedChanges) - usRemainingDOLength;     
                
      else
        //entry too large for remaining DO size
        dRetCode := -2;
      end_if;      
    else
      //entry larger than 128 Byte
      dRetCode := -1;
    end_if;    
  else
    //wrong WriteDataMode
    dRetCode := -3;
  end_if;
 
END_FUNCTION


FUNCTION GLOBAL PL221::ChangeAllLEDs
	VAR_INPUT
		usStripeNumber 	: USINT;
		uiPixelStartAddr 	: UINT;
		uiNumberOfLed 	: UINT;
		pLedData 	: pVoid;
		dStartOffset 	: DINT;(* := 0 *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  VAR
  	pStripe : ^t_LEDStripeVars;
    pDOLength : ^USINT;
    b4BitMode : BOOL;
  END_VAR
   
  dRetCode := 0;
  
  if ClassState <> _ClassOk then
    dRetCode := -5;
    return;
  end_if;
  
  //check valid stripe number
  if usStripeNumber <> 1 & usStripeNumber <> 2 then
    dRetCode := -8;
    return;
  end_if;  
  
  //check pointer of LED Data
  if pLedData = NIL then
    dRetCode := -6;
    return;
  end_if;

  b4BitMode := FALSE;
   
  if WriteDataMode = 0 then
    //select stripe and init variables
    if usStripeNumber = 1 then      
      aStripes[0].usStripeNum         := 2#000;
      aStripes[0].usColorResolution   := Stripe1_ColorResolution$USINT;
      aStripes[0].uiRefreshCycleMs    := (1000/Stripe1_RefreshCycle)$UINT;
      
      if dStartOffset < Stripe1_NumOfLeds then //Offset is larger than used LED's
        dStartOffsetStripe1 := dStartOffset;
      else
        dRetCode := -4;
        return;
      end_if;
      
      pStripe := #aStripes[0];
      sOutputValuesSequenzerConfig.Sequenzer1Config                 := (dStartOffsetStripe1 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 1;
      pDOLength := #sAccesses.sAccessPDOWriteDataStripe1.ActLength;
      //if 4bit mode, data must be halved
      if aStripes[0].usColorResolution = 3 then
        b4BitMode := TRUE;
      end_if;
      
    elsif usStripeNumber = 2 then
      aStripes[1].usStripeNum         := 2#001;
      aStripes[1].usColorResolution   := Stripe2_ColorResolution$USINT;
      aStripes[1].uiRefreshCycleMs    := (1000/Stripe2_RefreshCycle)$UINT; 
      
      if dStartOffset < Stripe2_NumOfLeds then //Offset is larger than used LED's
        dStartOffsetStripe2 := dStartOffset;
      else
        dRetCode := -4;
        return;
      end_if;
      
      pStripe := #aStripes[1];
      sOutputValuesSequenzerConfig.Sequenzer2Config                 := (dStartOffsetStripe2 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 1;
      pDOLength := #sAccesses.sAccessPDOWriteDataStripe2.ActLength;
      //if 4bit mode, data must be halved
      if aStripes[1].usColorResolution = 3 then
        b4BitMode := TRUE;
      end_if;
    end_if;      

    pStripe^.uiNumOfCopyLeds    := uiNumberOfLed;
    pStripe^.uiPixelStartAddr   := uiPixelStartAddr;
    
    //calc whole Led Data
    if b4BitMode = FALSE then
      pStripe^.uiWholeLedData     := (pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize);
    else
      pStripe^.uiWholeLedData     := (((pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize) +1) /2);
    end_if;

    //calculate how much Led's have to be copied per cycle
    if (pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize) < pStripe^.uiRefreshCycleMs then
      //data can be copied in one cycle
      if b4BitMode = FALSE then
        pStripe^.uiLedDataPerCycle  := pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize;            
      else
        pStripe^.uiLedDataPerCycle  := (((pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize) + 1)/2);             
      end_if;
      pStripe^.bOneCycle            := TRUE; 
    else
      if b4BitMode = FALSE then
        pStripe^.uiLedDataPerCycle  := ((pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize) / pStripe^.uiRefreshCycleMs)$UINT;      
      else
        pStripe^.uiLedDataPerCycle  := ((((pStripe^.uiNumOfCopyLeds * pStripe^.usColorSize) +1) /2) / pStripe^.uiRefreshCycleMs)$UINT;      
      end_if;
      pStripe^.bOneCycle            := FALSE;        
      //increase memory, up to a value, which could be divided by usColorSize
      if (pStripe^.uiLedDataPerCycle MOD pStripe^.usColorSize) then
        pStripe^.uiLedDataPerCycle := pStripe^.uiLedDataPerCycle + (pStripe^.usColorSize - (pStripe^.uiLedDataPerCycle MOD pStripe^.usColorSize)); 
      end_if;    
    end_if;
      
    //remember Led Data
    pStripe^.pLedPixelData := pLedData;

    //write header
    pStripe^.pLEDDataHeader^.StripeConfig := (pStripe^.uiPixelStartAddr AND 0x7FF)
                                        OR ((pStripe^.usStripeNum SHL 10) AND 0x1C00)
                                        OR ((pStripe^.usColorResolution SHL 13) AND 0xE000);
                                      
    pStripe^.pHelpCopyData := (pStripe^.pLEDDataHeader + sizeof(pStripe^.pLEDDataHeader^))$^USINT;
    
    //calculate next pixeladdress
    if b4BitMode = FALSE then
      pStripe^.uiNextPixelAddr := pStripe^.uiLedDataPerCycle / pStripe^.usColorSize;    
    else
      pStripe^.uiNextPixelAddr := (((pStripe^.uiLedDataPerCycle / pStripe^.usColorSize) + 1) /2);     
    end_if;
    //change DO to correct length
    pDOLength^  := (pStripe^.uiLedDataPerCycle$USINT + sizeof(t_PDOStripeConfig));
    //copy data in RT
    pStripe^.bStartCopyData := TRUE; 
          
  else
    //wrong WriteDataMode
    dRetCode := -1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::UpdateCy
  VAR
    TmpRetCode  : iprStates;
  END_VAR
  
  case eWait4ConfigSSW of
//**********************************************************************************************************************************************************
  	_IdleStep:  //nothing to do
    
      if bSettingsChanged.LEDStripe then
        //switch LED stripes on/off
        if Stripe1_Activate then
          sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput1Enable := LEDStripeOn <> 0;
          sSDOHardwareControlWrite.ControlRegister.DC5VEnable           := TO_BOOL(LEDStripeOn AND 16#01);
        end_if;
        
        if Stripe2_Activate then
          sSDOHardwareControlWrite.PixelOutputConfig.PixelOutput2Enable := LEDStripeOn <> 0;
          sSDOHardwareControlWrite.ControlRegister.DC5VEnable           := TO_BOOL(LEDStripeOn AND 16#01);
        end_if;    

        bSettingsChanged  := 0;
        eWait4ConfigSSW   := _SendConfig;
      end_if;
    
//**********************************************************************************************************************************************************    
  	_SendConfig:  //send the actual firmware config
      case eResponseState of
        //**********************************************************************************************
      	_idle:
          //Send only 2 Byte for changes of PixelOutputConfig and Control Register
          TmpRetCode := StartWriteSDO(hOffset:=PL221_ADDR_CONFIG_PIXEL_OUT, usLength:=sizeof(UINT), pWriteBuffer:=(#sSDOHardwareControlWrite)$^USINT, eCommand:=SDIAS_SDO_CMD_MEM_WRITE);
          
          //if writing the SDO to the send buffer succeeded
          if TmpRetCode = READY then
            //remember the time and wait for an answer
            udSDOTimeout    := ops.tAbsolute;
            eResponseState  := _wait;
          elsif TmpRetCode = ERROR then
            //otherwise we have an error
#ifdef HWC_LogError
              HWC_LogError(this, "@00E5 (PL221::UpdateCy) Failed to add write SDO for HardwareControl changes");
#endif             
            eWait4ConfigSSW := _IdleStep;
            ClassState      := _NoMem;
          end_if;
          
        //**********************************************************************************************
      	_wait:
          //wait for response
          if ((ops.tAbsolute - udSDOTimeout) > PL221_SDO_RESPONSE_TIMEOUT) then
#ifdef HWC_LogError
              HWC_LogError(this, "@00E6 (PL221::UpdateCy) SDO Response timeout config module");
#endif            
            eWait4ConfigSSW := _IdleStep;
            ClassState      := _TimeoutInInit;                       
          end_if;  
        
        //**********************************************************************************************
      	_valid:
          eResponseState  := _idle;
          eWait4ConfigSSW := _IdleStep;
      end_case;    
  end_case;
  
END_FUNCTION


FUNCTION VIRTUAL PL221::ReceiveSDOResponse
	VAR_INPUT
		eCommand 	: t_SDIAS_SDO_Cmd;
		hOffset 	: HINT;
		usLength 	: USINT;
		eResult 	: iprStates;
		pResponseBuffer 	: ^USINT;
		ResponseLength 	: USINT;
	END_VAR
	VAR_OUTPUT
		ret_code 	: iprStates;
	END_VAR
  
  ret_code  := SdiasBase::ReceiveSDOResponse(eCommand, hOffset, usLength, eResult, pResponseBuffer, ResponseLength);
  
  // spi access from baseclass                                         
  if bSDOResponseHandle = TRUE then
    return;
  end_if;   
  
  if eResult = READY then
    
    case eCommand of
//*************************************************************************************************************************************
    	SDIAS_SDO_CMD_MEM_WRITE:
        case hOffset of
        //***********************************************
          PL221_ADDR_CONFIG_WRITE0:
            if eResponseState = _wait then
              eResponseState := _valid;
            end_if;
        //***********************************************
        end_case;  
 
        case hOffset of
        //***********************************************
        PL221_ADDR_CONFIG_PIXEL_OUT:
          if eResponseState = _wait then
            eResponseState := _valid;
          end_if;
        //***********************************************
        PL221_PIXEL_LENGTH:
          if eResponseState = _wait then
            eResponseState := _valid;
          end_if;

      end_case;
    end_case;
//*************************************************************************************************************************************
    // if the access is not covered by the code above or there is an error in the parameters    
    if eResponseState <> _valid then
      #ifdef HWC_LogError
        HWC_LogError(this, "@00E7 (PL221::ReceiveSDOResponse) Error in response data of SDO");
      #endif     
      eInitSSW := _InitError;
    end_if;
  else
    // if the SDO failed check which command failed
    case eCommand of
    	SDIAS_SDO_CMD_MEM_WRITE:
#ifdef HWC_LogError
          HWC_LogError(this, "@00E8 (PL221::ReceiveSDOResponse) Error while writing the firmware configuration");
#endif   	
    end_case;
    eInitSSW := _InitError;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::LEDStripeOn::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  //switch power of LED Stripes on/off
  if (input <> LEDStripeOn) & ((Stripe1_Activate <> 0) | (Stripe2_Activate <> 0))  then
    LEDStripeOn                 := input;
    bSettingsChanged.LEDStripe  := TRUE;
	  result                      := LEDStripeOn;  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL PL221::PWMOut1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
	if PWM1Enable <> 0 then
    if input > PL221_MAX_PWM_VALUE  then
      //set to maximum pwm value
      PWMOut1 := PL221_MAX_PWM_VALUE;
    elsif input < 0 then
      PWMOut1 := 0;
    else
      PWMOut1 := input;
    end_if;
       
    sOutputValuesPWM.PWMOut1HT := PWMOut1$USINT;    
    result := PWMOut1;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::PWMOut2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	if PWM2Enable <> 0 then
    if input > PL221_MAX_PWM_VALUE  then
      //set to maximum pwm value
      PWMOut2 := PL221_MAX_PWM_VALUE;
    elsif input < 0 then
      PWMOut2 := 0;
    else
      PWMOut2 := input;
    end_if;
       
    sOutputValuesPWM.PWMOut2HT := PWMOut2$USINT;    
    result := PWMOut2;
  end_if;
  
END_FUNCTION
FUNCTION PL221::ChangeDO
	VAR_INPUT
		AccessHandle 	: UDINT;
		NewOffset 	  : HDINT;(* := SDIAS_UNCHANGED_DYNAMIC_PARA *)
		NewLength 	  : UDINT;(* := SDIAS_UNCHANGED_DYNAMIC_PARA *)
	END_VAR
  VAR
  	MyPara    : CmdStruct;
    MyResult  : results;
  END_VAR

  MyPara.uiCmd := SDIAS_CMD_CHANGE_DYN_ACCESS;
  MyPara.aPara[0] := AccessHandle$DINT;
  MyPara.aPara[1] := NewOffset$DINT;
  MyPara.aPara[2] := NewLength$DINT;
  ClassState.NewInst(#MyPara, #MyResult);

END_FUNCTION

FUNCTION GLOBAL PL221::SetWholeStripe
	VAR_INPUT
		usSelectStripe 	: USINT;
		pColorData 	    : ^void;
		bEnable 	      : BOOL;(* := 1 *)
	END_VAR
	VAR_OUTPUT
		dRetCode 	: DINT;
	END_VAR
  
  dRetCode := 0;

  if ClassState <> _ClassOk then
    dRetCode := -5;
    return;
  end_if; 
  
  //check valid stripe number
  if usSelectStripe <> 1 & usSelectStripe <> 2 then
    dRetCode := -8;
    return;
  end_if;
  
  if bEnable = TRUE then
    //set whole stripe to one color.  
    if usSelectStripe = 1 then    
      //copy color to address 680.
      if WriteDataMode then
        dRetCode := ChangeIndividualLED(usStripeNumber:=usSelectStripe, uiPixelStartAddr:=PL221_LAST_RAM_ADDRESS, usNumberOfLed:=1, pData:=pColorData, dStartOffset:= dStartOffsetStripe1);        
      else
        dRetCode := ChangeAllLEDs(usStripeNumber:=usSelectStripe, uiPixelStartAddr:=PL221_LAST_RAM_ADDRESS, uiNumberOfLed:=1, pLedData:=pColorData, dStartOffset:= dStartOffsetStripe1);
      end_if;
      //set sequenzer address "and 0x7FF" because only 10 Bit are used
      sOutputValuesSequenzerConfig.Sequenzer1Config                 := (PL221_LAST_RAM_ADDRESS AND 0x7FF);
      //autoincrement set 0. take the same coloraddress for all led
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 0;

    elsif usSelectStripe = 2  then
      //copy color to address 680.
      if WriteDataMode then
        dRetCode := ChangeIndividualLED(usStripeNumber:=usSelectStripe, uiPixelStartAddr:=PL221_LAST_RAM_ADDRESS, usNumberOfLed:=1, pData:=pColorData, dStartOffset:= dStartOffsetStripe2);        
      else    
        dRetCode := ChangeAllLEDs(usStripeNumber:=usSelectStripe, uiPixelStartAddr:=PL221_LAST_RAM_ADDRESS, uiNumberOfLed:=1, pLedData:=pColorData ,dStartOffset:= dStartOffsetStripe2);
      end_if;
      //set sequenzer address "and 0x7FF" because only 10 Bit are used
      sOutputValuesSequenzerConfig.Sequenzer2Config                 := (PL221_LAST_RAM_ADDRESS AND 0x7FF);
      //autoincrement set 0. take the same coloraddress for all led
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 0;
    end_if;  
  else  
  
    if usSelectStripe = 1 then
      //set stripe to colorsheme in RAM
      sOutputValuesSequenzerConfig.Sequenzer1Config                 := (dStartOffsetStripe1 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 1;
    elsif usSelectStripe = 2 then
      //set stripe to colorsheme in RAM
      sOutputValuesSequenzerConfig.Sequenzer2Config                 := (dStartOffsetStripe2 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 1;      
    end_if;

  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::SetAllLeds::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  
  if LEDStripeOn = 1 then
    SetAllLeds := input;
      
    if input = 1 then       
      if Stripe1_Activate then
        //set stripe 1 to one color
        SetWholeStripe(usSelectStripe:=1, pColorData:=#SetColorStripe1$^void, bEnable:=1);
        //set other stripe to normal mode        
        sOutputValuesSequenzerConfig.Sequenzer2Config                 := (dStartOffsetStripe2 AND 0x7FF)$BINT;
        sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 1;
      else
        SetAllLeds := 0;
      end_if;     
    elsif input = 2 then  
      if Stripe2_Activate then    
        //set stripe 2 to one color
        SetWholeStripe(usSelectStripe:= 2, pColorData:= #SetColorStripe2$^void);
        //set other stripe to normal mode
        sOutputValuesSequenzerConfig.Sequenzer1Config                 := (dStartOffsetStripe1 AND 0x7FF)$BINT;
        sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 1;
      else
        SetAllLeds := 0;
      end_if;      
    elsif input = 3 then
      if Stripe1_Activate & Stripe2_Activate then
        //set both stripes to one color
        SetWholeStripe(usSelectStripe:= 2, pColorData:= #SetColorStripe2$^void);
        SetWholeStripe(usSelectStripe:= 1, pColorData:= #SetColorStripe1$^void);         
      end_if;
    else
      //set both stripes to normal mode
      sOutputValuesSequenzerConfig.Sequenzer1Config                 := (dStartOffsetStripe1 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1 := 1;
      sOutputValuesSequenzerConfig.Sequenzer2Config                 := (dStartOffsetStripe2 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2 := 1;
    end_if;

    result := SetAllLeds;
    
  end_if;
 
END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::StartRollingAddrStripe1::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  StartRollingAddrStripe1 := input;
  //start runninglight
  if (input >= 0 & input <= 681) then
    if Stripe1_Activate then
      //set startaddress
      bStopRollingStripe1 := TRUE;
      sOutputValuesSequenzerConfig.Sequenzer1Config                   := (StartRollingAddrStripe1$USINT AND 0x7FF);
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1   := 1;      
    end_if;
  else
    //stop running light
    if bStopRollingStripe1 = TRUE then
      sOutputValuesSequenzerConfig.Sequenzer1Config                   := (dStartOffsetStripe1 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer1Config.AutoIncrStripe1   := 1; 
      bStopRollingStripe1 := FALSE;
    end_if;
  end_if;
 
	result := StartRollingAddrStripe1;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL PL221::StartRollingAddrStripe2::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

  StartRollingAddrStripe2 := input;
  //start runninglight
  if (input >= 0 & input <= 681) then
    if Stripe2_Activate then
      //set startaddress
      bStopRollingStripe2 := TRUE;
      sOutputValuesSequenzerConfig.Sequenzer2Config                   := (StartRollingAddrStripe2$USINT AND 0x7FF);
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2   := 1;       
    end_if;   
  else
    //stop running light
    if bStopRollingStripe2 = TRUE then
      sOutputValuesSequenzerConfig.Sequenzer2Config                   := (dStartOffsetStripe2 AND 0x7FF)$BINT;
      sOutputValuesSequenzerConfig.Sequenzer2Config.AutoIncrStripe2   := 1;       
      bStopRollingStripe2 := FALSE;
    end_if;
  end_if;
 
	result := StartRollingAddrStripe2;

END_FUNCTION


FUNCTION VIRTUAL PL221::GetTaskCfg
	VAR_OUTPUT
		TaskCfg 	: BDINT;
	END_VAR

  TaskCfg := SDIAS_TASK_MASK_RT_PRE OR SDIAS_TASK_MASK_CY OR SDIAS_TASK_MASK_RT_POST ;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL PL221::Range::Read
	VAR_OUTPUT
		output (EAX) 	: BDINT;
	END_VAR

	output := Range;
  
  //reset Latch in next rt-run
  bRangeErrorReadLatch := TRUE;
    
END_FUNCTION

FUNCTION TAB PL221::DefaultColorTable
16#000000 $UDINT   // 0   black
16#800000 $UDINT   // 1   maroon
16#008000 $UDINT   // 2   green
16#808000 $UDINT   // 3   olive
16#000080 $UDINT   // 4   navy
16#800080 $UDINT   // 5   purple
16#008080 $UDINT   // 6   teal
16#C0C0C0 $UDINT   // 7   silver
16#808080 $UDINT   // 8   grey
16#FF0000 $UDINT   // 9   red
16#00FF00 $UDINT   // 10  lime
16#FFFF00 $UDINT   // 11  yellow
16#0000FF $UDINT   // 12  blue
16#FF00FF $UDINT   // 13  fuchsia
16#00FFFF $UDINT   // 14  Aqua
16#FFFFFF $UDINT   // 15  white  ---first 16 colors
16#000000 $UDINT   // 16  grey0
16#00005F $UDINT   // 17  NavyBlue
16#000087 $UDINT   // 18  DarkBlue
16#0000af $UDINT   // 19  blue3
16#0000D7 $UDINT   // 20  blue2
16#0000FF $UDINT   // 21  blue
16#005F00 $UDINT   // 22  darkgreen
16#005F5F $UDINT   // 23  deepskyblue3
16#005F87 $UDINT   // 24  deepskyblue3
16#005FAF $UDINT   // 25  deepskyblue3
16#005FD7 $UDINT   // 26  DogerBlue3
16#005FFF $UDINT   // 27  DogerBlue2
16#008700 $UDINT   // 28  green4
16#00875F $UDINT   // 29  springgreen4
16#008787 $UDINT   // 30  turquoise4
16#0087AF $UDINT   // 31  DeepSkyBlue3
16#0087D7 $UDINT   // 32  Deepskyblue3
16#0087FF $UDINT   // 33  DodgerBlue1
16#00AF00 $UDINT   // 34  green 3
16#00AF5F $UDINT   // 35  spring green 3
16#00AF87 $UDINT   // 36  DarkCyan
16#00AFAF $UDINT   // 37  LightSeaGreen
16#00AFD7 $UDINT   // 38  DeepSkyBlue2
16#00AFFF $UDINT   // 39  DeepSkyBlue1
16#00D700 $UDINT   // 40  Green 3
16#00D75F $UDINT   // 41  spring green 3
16#00D787 $UDINT   // 42  springgreen2
16#00D7AF $UDINT   // 43  Cyan3
16#00D7D7 $UDINT   // 44  DarkTurquoise
16#00D7ff $UDINT   // 45  Turquoise
16#00FF00 $UDINT   // 46  Green 1
16#00FF5F $UDINT   // 47  Springgreen2
16#00FF87 $UDINT   // 48  Springgreen1
16#00FFAF $UDINT   // 49  MediumSpringgreen
16#00FF7D $UDINT   // 50  Cyan2
16#00FFFF $UDINT   // 51  Cyan1
16#5F0000 $UDINT   // 52  Darkred
16#5F005F $UDINT   // 53 DeepPink4
16#5F0087 $UDINT   // 54  Purple4
16#5F00AF $UDINT   // 55  Purple4
16#5F00D7 $UDINT   // 56  Purple3
16#5F00FF $UDINT   // 57  BlueViolet
16#5F5F00 $UDINT   // 58  Orange4
16#5F5F5F $UDINT   // 59  Grey37
16#5F5F87 $UDINT   // 60  mediumPurple4
16#5F5FAF $UDINT   // 61  slateblue3
16#5F5FD7 $UDINT   // 62  slateblue3
16#5F5FFF $UDINT   // 63  royalblue1
16#5F8700 $UDINT   // 64  chartreuse4
16#5F875F $UDINT   // 65  Darkseagreen4
16#5F8787 $UDINT   // 66  paleturquoise4
16#5F87AF $UDINT   // 67  steelblue
16#5F87D7 $UDINT   // 68  Steelblue3
16#5F87FF $UDINT   // 69  cornflowerblue
16#5FAF00 $UDINT   // 70  Chartreuse3
16#5faf5f $UDINT   // 71  DarkSeaGreen4
16#5faf87 $UDINT   // 72  CadetBlue
16#5fafaf $UDINT   // 73  CadetBlue
16#5fafd7 $UDINT   // 74  SkyBlue3
16#5fafff $UDINT   // 75  SteelBlue1
16#5fd700 $UDINT   // 76  Chartreuse3
16#5fd75f $UDINT   // 77  PaleGreen3
16#5fd787 $UDINT   // 78  SeaGreen3
16#5fd7af $UDINT   // 79  Aquamarine3
16#5fd7d7 $UDINT   // 80  MediumTurquoise
16#5fd7ff $UDINT   // 81  SteelBlue1
16#5fff00 $UDINT   // 82  Chartreuse2
16#5fff5f $UDINT   // 83  SeaGreen2
16#5fff87 $UDINT   // 84  SeaGreen1
16#5fffaf $UDINT   // 85  SeaGreen1
16#5fffd7 $UDINT   // 86  Aquamarine1
16#5fffff $UDINT   // 87  DarkSlateGray2
16#870000 $UDINT   // 88  DarkRed
16#87005f $UDINT   // 89  DeepPink4
16#870087 $UDINT   // 90  DarkMagenta
16#8700af $UDINT   // 91  DarkMagenta
16#8700d7 $UDINT   // 92  DarkViolet
16#8700ff $UDINT   // 93  Purple
16#875f00 $UDINT   // 94  Orange4
16#875f5f $UDINT   // 95  LightPink4
16#875f87 $UDINT   // 96  Plum4
16#875faf $UDINT   // 97  MediumPurple3
16#875fd7 $UDINT   // 98  MediumPurple3
16#875fff $UDINT   // 99  SlateBlue1
16#878700 $UDINT   // 100 Yellow4
16#87875f $UDINT   // 101 Wheat4
16#878787 $UDINT   // 102 Grey53
16#8787AF $UDINT   // 103 LightSlateGrey
16#8787D7 $UDINT   // 104 MediumPurple
16#8787FF $UDINT   // 105 LightSlateBlue
16#87AF00 $UDINT   // 106 Yellow4
16#87af5f $UDINT   // 107 DarkOlive
16#87af87 $UDINT   // 108 DarkSeaGreen
16#87afaf $UDINT   // 109 LightSkyBlue3
16#87afd7 $UDINT   // 110 LightSkyBlue3
16#87afff $UDINT   // 111 SkyBlue2
16#87d700 $UDINT   // 112 Chartreuse2
16#87d75f $UDINT   // 113 DarkOliveGreen3
16#87d787 $UDINT   // 114 PaleGreen3
16#87d7af $UDINT   // 115 DarkSeaGreen3
16#87d7d7 $UDINT   // 116 DarkSlateGray3
16#87d7ff $UDINT   // 117 SkyBlue1
16#87ff00 $UDINT   // 118 Chartreuse1
16#87ff5f $UDINT   // 119 LightGreen
16#87ff87 $UDINT   // 120 LightGreen
16#87ffaf $UDINT   // 121 PaleGreen1
16#87ffd7 $UDINT   // 122 Aquamarine1
16#87ffff $UDINT   // 123 DarkSlateGray1
16#af0000 $UDINT   // 124 Red3
16#af005f $UDINT   // 125 DeepPink4
16#af0087 $UDINT   // 126 MediumVioletRed
16#af00af $UDINT   // 127 Magenta3
16#af00d7 $UDINT   // 128 DarkViolet
16#af00ff $UDINT   // 129 Purple
16#af5f00 $UDINT   // 130 DarkOrange3
16#af5f5f $UDINT   // 131 IndianRed
16#af5f87 $UDINT   // 132 HotPink3
16#af5faf $UDINT   // 133 MediumOrchid3
16#af5fd7 $UDINT   // 134 MediumOrchid
16#af5fff $UDINT   // 135 MediumPurple2
16#af8700 $UDINT   // 136 DarkGoldenrod
16#af875f $UDINT   // 137 LightSalmon3
16#af8787 $UDINT   // 138 RosyBrown
16#af87af $UDINT   // 139 Grey63
16#af87d7 $UDINT   // 140 MediumPurple2
16#af87ff $UDINT   // 141 MediumPurple1
16#afaf00 $UDINT   // 142 Gold3
16#afaf5f $UDINT   // 143 DarkKhaki
16#afaf87 $UDINT   // 144 NavajoWhite3
16#afafaf $UDINT   // 145 Grey69
16#afafd7 $UDINT   // 146 LightSteelBlue3
16#afafff $UDINT   // 147 LightSteelBlue
16#afd700 $UDINT   // 148 Yellow3
16#afd75f $UDINT   // 149 DarkOliveGreen3
16#afd787 $UDINT   // 150 DarkSeaGreen3
16#afd7af $UDINT   // 151 DarkSeaGreen2
16#afd7d7 $UDINT   // 152 LightCyan3
16#afd7ff $UDINT   // 153 LightSkyBlue1
16#afff00 $UDINT   // 154 GreenYellow
16#afff5f $UDINT   // 155 DarkOliveGreen2
16#afff87 $UDINT   // 156 PaleGreen1
16#afffaf $UDINT   // 157 DarkSeaGreen2
16#afffd7 $UDINT   // 158 DarkSeaGreen1
16#afffff $UDINT   // 159 PaleTurquoise1
16#d70000 $UDINT   // 160 Red3
16#d7005f $UDINT   // 161 DeepPink3
16#d70087 $UDINT   // 162 DeepPink3
16#d700af $UDINT   // 163 Magenta3
16#d700d7 $UDINT   // 164 Magenta3
16#d700ff $UDINT   // 165 Magenta2
16#d75f00 $UDINT   // 166 DarkOrange3
16#d75f5f $UDINT   // 167 IndianRed
16#d75f87 $UDINT   // 168 HotPink3
16#d75faf $UDINT   // 169 HotPink2
16#d75fd7 $UDINT   // 170 Orchid
16#d75fff $UDINT   // 171 MediumOrchid1
16#d78700 $UDINT   // 172 Orange3
16#d7875f $UDINT   // 173 LightSalmon3
16#d78787 $UDINT   // 174 LightPink3
16#d787af $UDINT   // 175 Pink3
16#d787d7 $UDINT   // 176 Plum3
16#d787ff $UDINT   // 177 Violet
16#d7af00 $UDINT   // 178 Gold3
16#d7af5f $UDINT   // 179 LightGoldenrod3
16#d7af87 $UDINT   // 180 Tan
16#d7afaf $UDINT   // 181 MistyRose3
16#d7afd7 $UDINT   // 182 Thistle3
16#d7afff $UDINT   // 183 Plum2
16#d7d700 $UDINT   // 184 Yellow3
16#d7d75f $UDINT   // 185 Khaki3
16#d7d787 $UDINT   // 186 LightGoldenrod2
16#d7d7af $UDINT   // 187 LightYellow3
16#d7d7d7 $UDINT   // 188 Grey84
16#d7d7ff $UDINT   // 189 LightSteelBlue1
16#d7ff00 $UDINT   // 190 Yellow2
16#d7ff5f $UDINT   // 191 DarkOliveGreen1
16#d7ff87 $UDINT   // 192 DarkOliveGreen1
16#d7ffaf $UDINT   // 193 DarkSeaGreen1
16#d7ffd7 $UDINT   // 194 Honeydew2
16#d7ffff $UDINT   // 195 LightCyan1
16#ff0000 $UDINT   // 196 Red1
16#ff005f $UDINT   // 197 DeepPink2
16#ff0087 $UDINT   // 198 DeepPink1
16#ff00af $UDINT   // 199 DeepPink1
16#ff00d7 $UDINT   // 200 Magenta2
16#ff00ff $UDINT   // 201 Magenta1
16#ff5f00 $UDINT   // 202 OrangeRed1
16#ff5f5f $UDINT   // 203 IndianRed1
16#ff5f87 $UDINT   // 204 IndianRed1
16#ff5faf $UDINT   // 205 HotPink
16#ff5fd7 $UDINT   // 206 HotPink
16#ff5fff $UDINT   // 207 MediumOrchid1
16#ff8700 $UDINT   // 208 DarkOrange
16#ff875f $UDINT   // 209 Salmon1
16#ff8787 $UDINT   // 210 LightCoral
16#ff87af $UDINT   // 211 PaleVioletRed1
16#ff87d7 $UDINT   // 212 Orchid2
16#ff87ff $UDINT   // 213 Orchid1
16#ffaf00 $UDINT   // 214 Orange1
16#ffaf5f $UDINT   // 215 SandyBrown
16#ffaf87 $UDINT   // 216 LightSalmon1
16#ffafaf $UDINT   // 217 LightPink1
16#ffafd7 $UDINT   // 218 Pink1
16#ffafff $UDINT   // 219 Plum1
16#ffd700 $UDINT   // 220 Gold1
16#ffd75f $UDINT   // 221 LightGoldenrod2
16#ffd787 $UDINT   // 222 LightGoldenrod2
16#ffd7af $UDINT   // 223 NavajoWhite1
16#ffd7d7 $UDINT   // 224 MistyRose1
16#ffd7ff $UDINT   // 225 Thistle1
16#ffff00 $UDINT   // 226 Yellow1
16#ffff5f $UDINT   // 227 LightGoldenrod1
16#ffff87 $UDINT   // 228 Khaki1
16#ffffaf $UDINT   // 229 Wheat1
16#ffffd7 $UDINT   // 230 Cornsilk1
16#ffffff $UDINT   // 231 Grey1000
16#080808 $UDINT   // 232 Grey3
16#121212 $UDINT   // 233 Grey7
16#1c1c1c $UDINT   // 234 Grey11
16#262626 $UDINT   // 235 Grey15
16#303030 $UDINT   // 236 Grey19
16#3a3a3a $UDINT   // 237 Grey23
16#444444 $UDINT   // 238 Grey27
16#4e4e4e $UDINT   // 239 Grey30
16#585858 $UDINT   // 240 Grey35
16#626262 $UDINT   // 241 Grey39
16#6c6c6c $UDINT   // 242 Grey42
16#767676 $UDINT   // 243 Grey46
16#808080 $UDINT   // 244 Grey50
16#8a8a8a $UDINT   // 245 Grey54
16#949494 $UDINT   // 246 Grey58
16#9e9e9e $UDINT   // 247 Grey62
16#a8a8a8 $UDINT   // 248 Grey66
16#b2b2b2 $UDINT   // 249 Grey70
16#bcbcbc $UDINT   // 250 Grey74
16#c6c6c6 $UDINT   // 251 Grey78
16#d0d0d0 $UDINT   // 252 Grey82
16#dadada $UDINT   // 253 Grey85
16#e4e4e4 $UDINT   // 254 Grey89
16#eeeeee $UDINT   // 255 Grey93

//https://jonasjacek.github.io/colors/

END_FUNCTION

FUNCTION VIRTUAL PL221::IndividualStripeConfig

//Example for Stripe Type WS2813

//  IndividualStripeCon1.PixelOrder      := GRB;     
//  IndividualStripeCon1.LSBFirstOut     := FALSE; // BOOL
//  IndividualStripeCon1.PixelOutT0H     := 400;   //value in ns
//  IndividualStripeCon1.PixelOutT1H     := 900;   //value in ns
//  IndividualStripeCon1.PixelOutT0L     := 800;   //value in ns
//  IndividualStripeCon1.PixelOutT1L     := 800;   //value in ns
//  IndividualStripeCon1.ResetPixelTime  := 310;   //value in ns

  
END_FUNCTION
