//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "CanOpenBase"
	Revision           = "1.6"
	GUID               = "{9FA7C397-3C72-4042-BB8C-A51596C8D866}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(540,240)"
	Comment            = "****************************************************************************************&#13;&#10;CANOPENBase driver to communicate with one CANOPEN device&#13;&#10;****************************************************************************************&#13;&#10;&#13;&#10;Server Server0 :  0 = Ok.&#13;&#10;   -1 = Alive timeout.&#13;&#10;   -2 = SDO timeout.&#13;&#10;   -3 = PDO timeout.&#13;&#10;   -4 = SDO and/or PDO timeout and retries.&#13;&#10;   -5 = Config table is empty.&#13;&#10;   -6 = Can&apos;t read a config message.&#13;&#10;   -7 = Poll buffer is empty.&#13;&#10;   -8 = Sdo gives an unknown Error command code as responce.&#13;&#10;   -9 = Sending&#13;&#10;                -10 = &#13;&#10;                -11 = Bussy.&#13;&#10;                -101 = Toggle bit not alternated&#13;&#10;                -102 = SDO protocol timed out&#13;&#10;                -103 = Client/Server command specifier not valid or unknown&#13;&#10;                -104 = Invalid block size (Block Transfer mode only)&#13;&#10;                -105 = Invalid sequence number (Block Transfer mode only)&#13;&#10;                -106 = CRC error (Block Transfer mode only)&#13;&#10;                -107 = Out of memory&#13;&#10;                -108 = Unsupported access to an object&#13;&#10;                -109 = Attempt to read a write-only object&#13;&#10;                -110 = Attempt to write a read-only object&#13;&#10;                -111 = Object does not exist in the Object Dictionary&#13;&#10;                -112 Object can not be mapped to the PDO&#13;&#10;                -113 = The number and length of the objects to be mapped would exceed PDO length&#13;&#10;                -114 = General parameter incompatibility reason&#13;&#10;                -115 = General internal incompatibility in the device&#13;&#10;                -116 = Object access failed due to a hardware error&#13;&#10;                -117 = Data type does not match, lengh of service parameter does not match&#13;&#10;                -118 = Data type does not match, lengh of service parameter is too high&#13;&#10;                -119 = Data type does not match, lengh of service parameter is too low&#13;&#10;                -120 = Sub-index does not exist&#13;&#10;                -121 = Value range of parameter exceeded (only for write access)&#13;&#10;                -122 = Value of parameter written too high&#13;&#10;                -123 = Value of parameter written too low&#13;&#10;                -124 = Maximum value is less than minimum value&#13;&#10;                -125 = General error&#13;&#10;                -126 = Data can not be transferred or stored to the application&#13;&#10;                -127 = Data can not be transferred or stored to the application because of local control&#13;&#10;                -128 = Data can not be transferred or stored to the application because of the present device state&#13;&#10;                -129 = Object Dictionary dynamic generation fails or no Object Dictionary is present (e.g. OD&#13;&#10;&#13;&#10;Client Driver  : Connection to _CanDriverBase class for interface with the hardware&#13;&#10; cNode  : Nodenumber of this device.&#13;&#10; ConfigData : Config data table.&#13;&#10;&#13;&#10;****************************************************************************************&#13;&#10;Created  : JE  : Wk 48/04 | Lasal V00:61f    |&#13;&#10;Tested   : JE  : Wk 01/05 | Lasal V01.01.003 | c-IPC - 2.2 x1.8 -1.1.11 1.00.3.0&#13;&#10;Rev00:00 : JE  : Wk mm/yy | Lasal V        | c-IPC - &#13;&#10;   01:00 : AJM : Wk 24/11 | Lasal V02.02.066  | Added responce error codes -101 to -129&#13;&#10;****************************************************************************************">
	<Channels>
		<Client Name="cNode" Required="true" Internal="false"/>
		<Client Name="ConfigData" Required="false" Internal="false"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\CanOpenBase\CanOpenBaseGl.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="SigmaControl" Author="Johan Embregts"/>
		<Dokumentation Revision="1.6" Date="2020-12-15" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="- Add support for getting sync time"/>
		<Dokumentation Revision="1.5" Date="2020-11-26" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="- Correct reading of config table and virtual PDO&apos;s"/>
		<Dokumentation Revision="1.4" Date="2020-10-27" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="- Better handling of virtual PDO&apos;s after testing"/>
		<Dokumentation Revision="1.3" Date="2020-06-18" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="- Correct handling of virtual PDO&apos;s after testing"/>
		<Dokumentation Revision="1.2" Date="2020-06-11" Author="Rick Hofsink" Company="Riwo Engineering B.V." Description="Added virtual PDO mapping"/>
		<Dokumentation Revision="1.1" Date="2015-03-27" Author="RA" Company="Riwo Engineering B.V." Description="Added Result -3 to ReadPoll()"/>
		<Dokumentation Revision="1.0" Date="2011-06-16" Author="André Mensink (AJM)" Company="Riwo Engineering B.V." Description="Added responce error codes -101 to -129"/>
		<Dokumentation Revision="0.4" Date="2010-12-24" Author="Johan Embregts" Company="SigmaControl" Description="BuildNmtNg had a TypeO.&#13;&#10;Server0 is set to Hex."/>
		<Dokumentation Revision="0.3" Date="09/09/2010" Author="JE" Company="SigmaControl" Description="Extra NMT messages for NodeGuarding and HeartBeat."/>
		<Dokumentation Revision="0.2" Date="29/04/2010" Author="JE" Company="SigmaControl" Description="Standaard classes imported from new librarie strucrure.&#13;&#10;NMT message changed to new style."/>
	</RevDoku>
	<Network Name="CanOpenBase">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{6E02ADFA-C291-40B1-8EC2-D5314DB6358B}"
				Class      = "CanBase"
				Position   = "(240,120)"
				Visualized = "true"
				CyclicTime = "10 ms">
				<Channels>
					<Server Name="Server0"/>
					<Client Name="Driver"/>
					<Client Name="System"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.Server0" Destination="_base.Server0" Vertices="(712,210),(540,210),"/>
			<Connection Source="_base.Driver" Destination="this.Driver" Vertices="(240,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using CanBase

CanOpenBase : CLASS
: CanBase
	TYPE
	  CanDeviceState :  //! <Type Public="true" Name="CanDeviceState"/>
	  (
	    cds_Initialising,
	    cds_Disconnected,
	    cds_Connecting,
	    cds_Preparing,
	    cds_Prepared,
	    cds_Operational,
	    cds_PreOperational:=127,
	    cds_Idle:=255
	  )$DINT;
	  ConfStr : STRUCT
	    ActNr : DINT;  //! <Type Comment="Active config number" Name="ConfStr.ActNr"/>
	    MaxNr : DINT;  //! <Type Comment="Maximal config number" Name="ConfStr.MaxNr"/>
	    RespDelta : UDINT;  //! <Type Comment="Delta between send and recieve ID&apos;s" Name="ConfStr.RespDelta"/>
	    RespID : UDINT;  //! <Type Comment="Responce ID " Name="ConfStr.RespID"/>
	    Record : SDOStr;  //! <Type Comment="SDO record" Name="ConfStr.Record"/>
	  END_STRUCT;
	  ConnStr : STRUCT
	    ConfigConnected : BOOL;  //! <Type Comment="0= Not connected, 1= Connected" Name="ConnStr.ConfigConnected"/>
	  END_STRUCT;
	  eCanOpenBaseMapType :
	  (
	    COBMT_Rpdo,
	    COBMT_Tpdo
	  )$UDINT;
	  PollStr : STRUCT
	    Mode : DINT;  //! <Type Comment="Poll timebase/mode" Name="PollStr.Mode"/>
	    tLastPoll : UDINT;  //! <Type Comment="time the last poll has taken place" Name="PollStr.tLastPoll"/>
	    TimeBase : DINT;  //! <Type Comment="Poll timebase" Name="PollStr.TimeBase"/>
	    ActNr : DINT;  //! <Type Comment="Active poll number" Name="PollStr.ActNr"/>
	    FirstNr : DINT;  //! <Type Comment="First poll number" Name="PollStr.FirstNr"/>
	    LastNr : DINT;  //! <Type Comment="Last poll number" Name="PollStr.LastNr"/>
	    RespDelta : UDINT;  //! <Type Comment="Delta between send and recieve ID&apos;s" Name="PollStr.RespDelta"/>
	    RespID : UDINT;  //! <Type Comment="Responce ID " Name="PollStr.RespID"/>
	    Buffer : ARRAY [0..cPollBufferSize] OF SDOStr;  //! <Type Comment="Poll buffer" Name="PollStr.Buffer"/>
	  END_STRUCT;
	  RespStr : STRUCT
	    Id : HINT;
	    Ptr : ^CanObjStr;
	    Sdo : SDOStr;
	  END_STRUCT;
	  StepperState :
	  (
	    eIdle,  //! <Type Comment="Ìdle" Name="StepperState.eIdle"/>
	    eStartConfig,  //! <Type Comment="Start sending config data" Name="StepperState.eStartConfig"/>
	    eConfigSend,  //! <Type Comment="Send a config parameter" Name="StepperState.eConfigSend"/>
	    eConfigRecieve,  //! <Type Comment="Recieve a config responce" Name="StepperState.eConfigRecieve"/>
	    eStartPoll,  //! <Type Comment="Start sending poll data" Name="StepperState.eStartPoll"/>
	    ePollSend,  //! <Type Comment="Send a poll command" Name="StepperState.ePollSend"/>
	    ePollRecieve,  //! <Type Comment="Recieve a poll responce" Name="StepperState.ePollRecieve"/>
	    eNmtSend,  //! <Type Comment="Send Enable Network" Name="StepperState.eNmtSend"/>
	    eSdoSend,  //! <Type Comment="Send a SDO command" Name="StepperState.eSdoSend"/>
	    eSdoRecieve,  //! <Type Comment="Recieve a SDO command" Name="StepperState.eSdoRecieve"/>
	    eError  //! <Type Comment="Communication error" Name="StepperState.eError"/>
	  )$UDINT;
#pragma pack(push, 1)
	  tCanOpenBasePdoMap : STRUCT
	    NumberOfItems : DINT;
	    Config : ARRAY [0..5] OF DINT;
	    ItemValues : ARRAY [1..4] OF DINT;
	  END_STRUCT;
#pragma pack(pop)
	  tCanOpenBasePdo : ARRAY [0..3] OF tCanOpenBasePdoMap;  //! <Type Public="true" Name="tCanOpenBasePdo"/>
	END_TYPE
  //Servers:
  //Clients:
	cNode 	: CltCh_DINT;
	ConfigData 	: CltChCmd_ConfigDefBase;
  //Variables:
		Stepper 	: StepperState;			//! <Variable Comment="Program state" Name="Stepper"/>
		ReqStep 	: StepperState;			//! <Variable Comment="Request an action" Name="ReqStep"/>
		ErrStep 	: StepperState;			//! <Variable Comment="The action whome caused the error" Name="ErrStep"/>
		Conn 	: ConnStr;			//! <Variable Comment="Connected clients" Name="Conn"/>
		Conf 	: ConfStr;			//! <Variable Comment="Internal Configure data" Name="Conf"/>
		Poll 	: PollStr;			//! <Variable Comment="Internal Poll data" Name="Poll"/>
		tSdoSend 	: UDINT;			//! <Variable Comment="Starttime sending SDO object." Name="tSdoSend"/>
		tPdoSend 	: UDINT;			//! <Variable Comment="Starttime sending PDO object." Name="tPdoSend"/>
		Retries 	: UDINT;			//! <Variable Comment="Retries counter" Name="Retries"/>
		vReturn 	: DINT;			//! <Variable Comment="Return value" Name="vReturn"/>
		NGFlag 	: CanDeviceState;
		NGFlagSync 	: DINT;
		Resp 	: RespStr;
		RespError 	: HDINT;
		_virtualTpdoMapping 	: tCanOpenBasePdo;
		_virtualRpdoMapping 	: tCanOpenBasePdo;
		_index1 	: DINT;
		_index2 	: DINT;
  //Functions:
				//! <Function Comment="&#13;&#10;" Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT := EAX;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildSync"/>
	FUNCTION VIRTUAL GLOBAL BuildSync
		VAR_INPUT
			SyncId 	: HINT;			//! <Variable Comment="Number of Synd ID. If bigger than cMaxCanMem (16#7FF) dan then def ID is &apos;cSync&apos; ( 16#080)." Name="BuildSync.SyncId"/>
		END_VAR
		VAR_OUTPUT
			State 	: DINT;			//! <Variable Comment="0= Ok, -1= ID error, -2= Size error, -11= Bussy." Name="BuildSync.State"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ================================================================================================&#13;&#10; Build a CAN Open SDO COB ID message and send it.&#13;&#10; If State is 0 then sending the SDO COB ID message has been success full.&#13;&#10; ================================================================================================&#13;&#10;" Name="BuildSDO"/>
	FUNCTION VIRTUAL GLOBAL BuildSDO
		VAR_INPUT
			SdoId 	: HINT;			//! <Variable Comment="SDO COB ID" Name="BuildSDO.SdoId"/>
			Cmnd 	: BSINT;			//! <Variable Comment="Action command" Name="BuildSDO.Cmnd"/>
			Index 	: UINT;			//! <Variable Comment="Index number defined by CANOPEN device." Name="BuildSDO.Index"/>
			SIndex 	: USINT;			//! <Variable Comment="Sub index number" Name="BuildSDO.SIndex"/>
			Value 	: DINT;			//! <Variable Comment="Value written to poll buffer." Name="BuildSDO.Value"/>
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ================================================================================================&#13;&#10; Test if a SDO COB ID has been recieved&#13;&#10; If State is 0 than a responce COB ID is recieved&#13;&#10; If State.CommErr is 0 than value is valid&#13;&#10;                     1 than value is not valid&#13;&#10; ================================================================================================&#13;&#10;" Name="DecoSDO"/>
	FUNCTION VIRTUAL GLOBAL DecoSDO
		VAR_INPUT
			SdoId 	: HINT;
			CmndState 	: ^BSINT;			//! <Variable Comment="Command responce" Name="DecoSDO.CmndState"/>
			Index 	: ^UINT;
			SIndex 	: ^USINT;
			Value 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ================================================================================================&#13;&#10; Build a CAN Open PDO message and send it.&#13;&#10; If State is 0 then sending the PDO message has been success full.&#13;&#10; ================================================================================================&#13;&#10;" Name="BuildPDO"/>
	FUNCTION VIRTUAL GLOBAL BuildPDO
		VAR_INPUT
			PdoId 	: HINT;			//! <Variable Comment="PDO ID number" Name="BuildPDO.PdoId"/>
			Value1 	: INT;			//! <Variable Comment="Value 1" Name="BuildPDO.Value1"/>
			Value2 	: INT;			//! <Variable Comment="Value 2" Name="BuildPDO.Value2"/>
			Value3 	: INT;			//! <Variable Comment="Value 3" Name="BuildPDO.Value3"/>
			Value4 	: INT;			//! <Variable Comment="Value 4" Name="BuildPDO.Value4"/>
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10; ================================================================================================&#13;&#10; Test if a PDO COB ID has been recieved&#13;&#10; If State is 0 than a responce COB ID is recieved&#13;&#10; If State.CommErr is 0 than value is valid&#13;&#10;                     1 than value is not valid&#13;&#10; ================================================================================================&#13;&#10;" Name="DecoPDO"/>
	FUNCTION VIRTUAL GLOBAL DecoPDO
		VAR_INPUT
			PdoId 	: HINT;
			Value1 	: ^INT;
			Value2 	: ^INT;
			Value3 	: ^INT;
			Value4 	: ^INT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildNmt"/>
	FUNCTION VIRTUAL GLOBAL BuildNmt
		VAR_INPUT
			NmtId 	: HINT;			//! <Variable Comment="Number of NMT ID. If bigger than cMaxCanMem (16#7FF) dan then def ID is &apos;cNmt&apos; ( 16#000)." Name="BuildNmt.NmtId"/>
			Cmnd 	: DINT;
			Node 	: DINT;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DecoNMT
		VAR_INPUT
			NmtId 	: HINT;
			DeviceState 	: ^CanOpenBase::CanDeviceState;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL BuildHeartbeat
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL DecoHeartbeat
		VAR_INPUT
			DeviceState 	: ^CanOpenBase::CanDeviceState;
		END_VAR
		VAR_OUTPUT
			State 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="StartConfig"/>
	FUNCTION VIRTUAL GLOBAL StartConfig
		VAR_OUTPUT
			Result 	: DINT;			//! <Variable Comment="0= Ok, -1= Not a valid record number." Name="StartConfig.Result"/>
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="StartPoll"/>
	FUNCTION VIRTUAL GLOBAL StartPoll
		VAR_INPUT
			Mode 	: DINT;			//! <Variable Comment="0= Continue, nnn= Every nnn mSec." Name="StartPoll.Mode"/>
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="BuildPoll"/>
	FUNCTION VIRTUAL GLOBAL BuildPoll
		VAR_INPUT
			Nr 	: DINT;			//! <Variable Comment="error number" Name="BuildPoll.Nr"/>
			Channel 	: HINT;			//! <Variable Comment="Can object ID (cSdoTx1)." Name="BuildPoll.Channel"/>
			Command 	: DINT;			//! <Variable Comment="Read/Write and Size ( cWrReq4)." Name="BuildPoll.Command"/>
			Index 	: DINT;
			SubIndex 	: DINT;			//! <Variable Comment="SubIndex number defined by CANOPEN device." Name="BuildPoll.SubIndex"/>
			Value 	: DINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="ReadPoll"/>
	FUNCTION VIRTUAL GLOBAL ReadPoll
		VAR_INPUT
			Nr 	: DINT;
			Value 	: ^DINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="WritePoll"/>
	FUNCTION VIRTUAL GLOBAL WritePoll
		VAR_INPUT
			Nr 	: DINT;
			Value 	: DINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="ClearPoll"/>
	FUNCTION VIRTUAL GLOBAL ClearPoll
		VAR_INPUT
			Nr 	: DINT;
		END_VAR
		VAR_OUTPUT
			Result 	: DINT;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="Sdo2CanObj"/>
	FUNCTION VIRTUAL GLOBAL Sdo2CanObj
		VAR_INPUT
			SdoRec 	: ^SDOStr;			//! <Variable Comment="SDO record data" Name="Sdo2CanObj.SdoRec"/>
			CanObj 	: ^CanObjStr;			//! <Variable Comment="CAN object data" Name="Sdo2CanObj.CanObj"/>
		END_VAR;
	
	FUNCTION TimeOutScan;
	
	FUNCTION Stepper;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="Can2SdoObj"/>
	FUNCTION VIRTUAL GLOBAL Can2SdoObj
		VAR_INPUT
			CanObj 	: ^CanObjStr;
			SdoRec 	: ^SDOStr;
		END_VAR;
				//! <Function Comment="[#ENGLISH]&#13;&#10;" Name="ErrStep"/>
	FUNCTION ErrStep
		VAR_INPUT
			Nr 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CommandDone
		VAR_OUTPUT
			State 	: DINT;			//! <Variable Comment="0= Done 1= Busy." Name="CommandDone.State"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetNodeNr
		VAR_OUTPUT
			NodeNr 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL GetVirtualPdoMapping
		VAR_INPUT
			typeMapping 	: eCanOpenBaseMapType;
		END_VAR
		VAR_OUTPUT
			virtualPdoMapping 	: ^tCanOpenBasePdo;
		END_VAR;
	
	FUNCTION GLOBAL GetSyncTime
		VAR_OUTPUT
			syncTime 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd ConfigDefBase


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB CanOpenBase::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_CANOPENBASE
1$UINT, 6$UINT, (SIZEOF(::CanOpenBase))$UINT, 
0$UINT, 2$UINT, 0$UINT, 
TO_UDINT(4284412609), "CanOpenBase", //Class
TO_UDINT(472728498), "CanBase", 1$UINT, 2$UINT, //Baseclass
//Servers:
//Clients:
(::CanOpenBase.cNode.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1272909673), "cNode", 
(::CanOpenBase.ConfigData.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(4098266793), "ConfigData", TO_UDINT(3828351829), "ConfigDefBase", 0$UINT, 0$UINT, 
END_FUNCTION


#define USER_CNT_CanOpenBase 21

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_CanOpenBase] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION CanOpenBase::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= CanBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= CanBase::Server0.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, CanBase::Server0.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_CanOpenBase;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #BuildSync();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #BuildSDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #DecoSDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[5]		:= #BuildPDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[6]		:= #DecoPDO();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[7]		:= #BuildNmt();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[8]		:= #DecoNMT();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[9]		:= #BuildHeartbeat();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[10]		:= #DecoHeartbeat();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[11]		:= #StartConfig();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[12]		:= #StartPoll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[13]		:= #BuildPoll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[14]		:= #ReadPoll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[15]		:= #WritePoll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[16]		:= #ClearPoll();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[17]		:= #Sdo2CanObj();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[18]		:= #Can2SdoObj();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[19]		:= #CommandDone();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[20]		:= #GetNodeNr();

#pragma warning (default : 74)
	CanBase::Server0.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CanBase::Server0.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


#pragma using CanDriverBase


//[#ENGLISH]
(*	****************************************************************************************
	CANOPENBase	driver to communicate with one CANOPEN device
	****************************************************************************************

	Server	Server0		: 0		= Ok.
						  -1	= Alive timeout.
						  -2	= SDO timeout.
						  -3	= PDO timeout.
						  -4	= SDO and/or PDO timeout and retries.
						  -5	= Config table is empty.
						  -6	= Can't read a config message.
						  -7	= Poll buffer is empty.
						  -8	= Sdo gives an unknown Error command code as responce.
						  -9	= Sending
              -10 = 
              -11 = Bussy.
              -101 = Toggle bit not alternated
              -102 = SDO protocol timed out
              -103 = Client/Server command specifier not valid or unknown
              -104 = Invalid block size (Block Transfer mode only)
              -105 = Invalid sequence number (Block Transfer mode only)
              -106 = CRC error (Block Transfer mode only)
              -107 = Out of memory
              -108 = Unsupported access to an object
              -109 = Attempt to read a write-only object
              -110 = Attempt to write a read-only object
              -111 = Object does not exist in the Object Dictionary
              -112 Object can not be mapped to the PDO
              -113 = The number and length of the objects to be mapped would exceed PDO length
              -114 = General parameter incompatibility reason
              -115 = General internal incompatibility in the device
              -116 = Object access failed due to a hardware error
              -117 = Data type does not match, lengh of service parameter does not match
              -118 = Data type does not match, lengh of service parameter is too high
              -119 = Data type does not match, lengh of service parameter is too low
              -120 = Sub-index does not exist
              -121 = Value range of parameter exceeded (only for write access)
              -122 = Value of parameter written too high
              -123 = Value of parameter written too low
              -124 = Maximum value is less than minimum value
              -125 = General error
              -126 = Data can not be transferred or stored to the application
              -127 = Data can not be transferred or stored to the application because of local control
              -128 = Data can not be transferred or stored to the application because of the present device state
              -129 = Object Dictionary dynamic generation fails or no Object Dictionary is present

	Client	Driver		: Connection to _CanDriverBase class for interface with the hardware
			cNode		: Nodenumber of this device.
			ConfigData	: Config data table.

	****************************************************************************************
	Created  : JE  : Wk 48/04 | Lasal V00:61f		  |
	Tested   : JE  : Wk 01/05 | Lasal V01.01.003	| c-IPC	- 2.2 x1.8	-1.1.11 1.00.3.0
	Rev00:00 : JE  : Wk mm/yy | Lasal V				    | c-IPC	- 
     01:00 : AJM : Wk 24/11 | Lasal V02.02.066  | Added responce error codes -101 to -129
	****************************************************************************************)
//[#DEUTSCH]
(*	****************************************************************************************

	****************************************************************************************


	****************************************************************************************)

FUNCTION VIRTUAL GLOBAL CanOpenBase::Init

ReqStep	:= eIdle;
Stepper	:= eIdle;
ErrStep	:= eIdle;
cNode := cNode.Read();

// CAN OPEN settings
Conf.RespDelta	:= cSdoTx1- cSdoRx1;
Poll.RespDelta	:= cSdoTx1- cSdoRx1;

// Config buffer
If IsClientConnected( #ConfigData) Then
	Conn.ConfigConnected	:= 1;
	If _FirstScan= 1 Then
		ConfigData.Read();
	End_If;
End_IF;
// Poll buffer
Poll.Mode	:= -1;
Poll.TimeBase	:= to_Dint( Intr.ObjInformation.OrgPeriod* 10);
ClearPoll( Nr	:= 0);	// Clear Poll buffer

CanBase::Init();
END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::Init

FUNCTION VIRTUAL GLOBAL CanOpenBase::CyWork
VAR_INPUT
	EAX		: UDINT;
END_VAR
VAR_OUTPUT
	state		: UDINT;
END_VAR

Stepper();
TimeOutScan();
CanBase::CyWork();
State:= READY;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::CyWork
//[#ENGLISH]
// ================================================================================================
// Build a CAN Open SDO COB ID message and send it.
// If State is 0 then sending the SDO COB ID message has been success full.
// ================================================================================================
//[>SdoId]SDO ID number
//[>Cmnd]Action command
//[>Index]Index number
//[>SIndex]Sub index number
//[>Value]Value
//[<State]0= Ok, -1= ID error, -2= Size error, -11= Bussy.
FUNCTION VIRTUAL GLOBAL CanOpenBase::BuildSDO
VAR_INPUT
	SdoId		: HINT;
	Cmnd		: BSINT;
	Index		: UINT;
	SIndex		: USINT;
	Value		: DINT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

Case Stepper Of
eStartPoll, ePollRecieve:
	State	:= -11;
Else
	// send object
	TxData.Id			:= SdoId+ To_Uint( cNode);
	TxData.Size			:= 8;
	TxData.Data[1]		:= Cmnd;
	TxData.Data[2]$UInt	:= Index;
	TxData.Data[4]		:= SIndex;
	TxData.Data[5]$DInt	:= To_Dint( Value);

	Resp.Id	:= SdoId- to_Uint( Conf.RespDelta);

	State	:= SendCanObj( #TxData);
	If State>= 0 Then
		tSdoSend	:= Ops.tAbsolute;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::BuildSDO



//[#ENGLISH]
// ================================================================================================
// Test if a SDO COB ID has been recieved
// If State is 0 than a responce COB ID is recieved
// If State.CommErr is 0 than value is valid
//                     1 than value is not valid
// ================================================================================================
//[>SdoId]SDO COB ID
//[>CmndState]Command responce
//[>Index]Index number
//[>SIndex]Sub index number
//[>Value]Value
//[<State]0= Ok, -1= Nok, -2=Error message recieved
FUNCTION VIRTUAL GLOBAL CanOpenBase::DecoSDO
VAR_INPUT
	SdoId		: HINT;
	CmndState		: ^BSINT;
	Index		: ^UINT;
	SIndex		: ^USINT;
	Value		: ^DINT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

Resp.Ptr	:= GetCanObj( ObjNr:= SdoId+ To_Uint( cNode));
IF Resp.Ptr	<> Nil Then						// There is an object recieved
	Retries		:= 0;
	IF Resp.Ptr^.Data[1] <> cErrRsp Then		// Responce code is no err
   		// OK
		CmndState^	:= Resp.Ptr^.Data[1]$BSint;
		Index^		:= Resp.Ptr^.Data[2]$Uint;
		SIndex^		:= Resp.Ptr^.Data[4]$USint;
		State		:= 0;
		Case CmndState^ of
		cWrRsp1, cRdRsp1:	// Read/Write responce 1 Byte
			Value^		:= Resp.Ptr^.Data[5]$SInt;
		cWrRsp2, cRdRsp2:	// Read/Write responce 2 Byte
			Value^		:= Resp.Ptr^.Data[5]$Int;
		cWrRsp3, cRdRsp3:	// Read/Write responce 3 Byte
			Value^		:= Resp.Ptr^.Data[5]$DInt shr 8;
		cWrRsp4, cRdRsp4:	// Read/Write responce 4 Byte
			Value^		:= Resp.Ptr^.Data[5]$DInt;
		End_Case;
	Else
   		// NOK
		CmndState^	:= 0;
		Index^		:= 0;
		SIndex^		:= 0;
		Value^		:= 0;
		State		:= -2;	// CanObject recieved correct but can't comply 
	End_if;
Else
	State		:= -1;	// Nothing recieved
End_if;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::DecoSDO

//[#ENGLISH]
// ================================================================================================
// Build a CAN Open PDO message and send it.
// If State is 0 then sending the PDO message has been success full.
// ================================================================================================
//[>PdoId]PDO ID number
//[>Value1]Value 1.
//[>Value2]Value 2.
//[>Value3]Value 3.
//[>Value4]Value 4.
//[<State]0= Ok, -1= ID error, -2= Size error, -11= Bussy.

FUNCTION VIRTUAL GLOBAL CanOpenBase::BuildPDO
VAR_INPUT
	PdoId		: HINT;
	Value1		: INT;
	Value2		: INT;
	Value3		: INT;
	Value4		: INT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

Case Stepper Of
eConfigSend, ePollSend, eSdoSend:
	State	:= -11;
Else
	// send object
	TxData.Id			:= PdoId + To_Uint( cNode);
	TxData.Size			:= 8;
	TxData.Data[1]$Int	:= Value1;
	TxData.Data[3]$Int	:= Value2;
	TxData.Data[5]$Int	:= Value3;
	TxData.Data[7]$Int	:= Value4;

	State	:= SendCanObj( #TxData);
	If State>= 0 Then
		tPdoSend	:= Ops.tAbsolute;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::BuildPDO

//[#ENGLISH]
// ================================================================================================
// Build a CAN Open PDO message of 2 bytes and send it.
// If State is 0 then sending the PDO message has been success full.
// ================================================================================================
//[>PdoId]PDO ID number
//[>Value1]Value 1.
//[>Value2]Value 2.
//[<State]0= Ok, -1= ID error, -2= Size error, -11= Bussy.
 //VIRTUAL GLOBAL CanOpenBase::BuildPDO2Bytes


//[#ENGLISH]
// ================================================================================================
// Test if a PDO COB ID has been recieved
// If State is 0 than a responce COB ID is recieved
// If State.CommErr is 0 than value is valid
//                     1 than value is not valid
// ================================================================================================
//[>PdoId]PDO ID number
//[>Value1]Value 1
//[>Value2]Value 2
//[>Value3]Value 3
//[>Value4]Value 4
//[<State]0= Ok, -1= No object receinved. 
FUNCTION VIRTUAL GLOBAL CanOpenBase::DecoPDO
VAR_INPUT
	PdoId		: HINT;
	Value1		: ^INT;
	Value2		: ^INT;
	Value3		: ^INT;
	Value4		: ^INT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

Resp.Ptr	:= GetCanObj( ObjNr:=( PdoId + To_Uint( cNode)));
IF Resp.Ptr	<> Nil Then						// There is an object recieved
	Value1^		:= Resp.Ptr^.Data[1]$Int;
	Value2^		:= Resp.Ptr^.Data[3]$Int;
	Value3^		:= Resp.Ptr^.Data[5]$Int;
	Value4^		:= Resp.Ptr^.Data[7]$Int;
	State	:= 0;
Else
	State	:= -1;
End_If;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::DecoPDO


//[#ENGLISH]
//[>NmtId]Number of NMT ID. If bigger than cMaxCanMem (16#7FF) dan then def ID is 'cNmt' ( 16#000).
//[<State]0= Ok, -1= ID error, -2= Size error, -11= Bussy.
FUNCTION VIRTUAL GLOBAL CanOpenBase::BuildNmt
	VAR_INPUT
		NmtId 	: HINT;
		Cmnd 	: DINT;
		Node 	: DINT;
	END_VAR
	VAR_OUTPUT
		State 	: DINT;
	END_VAR

If Stepper= eIdle Then
	// send object
	If NmtId> cMaxCanMem Then
		TxData.Id			:= cNmt;
	Else
		TxData.Id			:= NmtId;
	End_If;

	TxData.Size			:= 2;
	TxData.Data[1]	:= to_usint( Cmnd);
  case Node of
  000..127:
    TxData.Data[2]	:= to_Usint( Node);
  else
    TxData.Data[2]	:= to_Usint( cNode);
  end_case;
	TxData.Data[3]$Int	:= 0;
	TxData.Data[5]$DInt	:= 0;

	State	:= SendCanObj( #TxData);
Else
	State	:= -11;
End_If;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::BuildNmt


//[#ENGLISH]
//[>NmtId]Number of NMT ID.
//[<State]0= Ok, -1= ID error, -2= Size error, -11= Bussy.
FUNCTION VIRTUAL GLOBAL CanOpenBase::BuildHeartbeat
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  
If Stepper= eIdle Then
	// send object
  TxData.Id			:= 16#700 + To_Uint( cNode);
	TxData.Size			:= 1;
	TxData.Data[1]$DInt	:= 0x0E;
	TxData.Data[5]$DInt	:= 0;

	State	:= SendCanObj( #TxData);
Else
	State	:= -11;
End_If;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL CanOpenBase::DecoHeartbeat
	VAR_INPUT
		DeviceState 	: ^CanOpenBase::CanDeviceState;
	END_VAR
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  VAR
  	IntDevState : CanOpenBase::CanDeviceState;
  END_VAR

  Resp.Ptr	:= GetCanObj( ObjNr:=( 16#700 + To_Uint( cNode)));
  IF Resp.Ptr	<> Nil Then						// There is an object recieved
    IntDevState$DINT:=0;
    IntDevState$Usint   := Resp.Ptr^.Data[1] And 2#01111111;
    DeviceState^  := 0;
    DeviceState^  := IntDevState;
    // Toggel Byte
    if NGFlagSync= 0 then
      NGFlagSync  := 1;
      NGFlag      := IntDevState;
    else
      if NGFlag<> IntDevState then
        NGFlag    := IntDevState;
      else
        State	:= -10;
      end_if;
    end_if;
    State	:= 0;
  Else
    State	:= -1;
  End_If;

END_FUNCTION


//[#ENGLISH]
//[>NmtId]Number of NMT ID.
//[>DeviceState]0= initialising, 1= Disconnecting, 2= Connecting, 3= Preparing, 4= Stopped, 5= Operational, 127= Pre-Operational
//[<State]0= Ok, -1= No object receinved. 
FUNCTION VIRTUAL GLOBAL CanOpenBase::DecoNMT
	VAR_INPUT
		NmtId 	: HINT;
		DeviceState 	: ^CanOpenBase::CanDeviceState;
	END_VAR
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  VAR
  	IntDevState : CanOpenBase::CanDeviceState;
  END_VAR

  Resp.Ptr	:= GetCanObj( ObjNr:=( NmtId + To_Uint( cNode)));
  IF Resp.Ptr	<> Nil Then						// There is an object recieved
    IntDevState$DINT:=0;
    IntDevState$Usint   := Resp.Ptr^.Data[1] And 2#01111111;
    DeviceState^  := 0;
    DeviceState^  := IntDevState;
    // Toggel Byte
    if NGFlagSync= 0 then
      NGFlagSync  := 1;
      NGFlag      := IntDevState;
    else
      if NGFlag<> IntDevState then
        NGFlag    := IntDevState;
      else
        State	:= -10;
      end_if;
    end_if;
    State	:= 0;
  Else
    State	:= -1;
  End_If;

END_FUNCTION


//[#ENGLISH]
//[>SyncId]Number of Synd ID. If bigger than cMaxCanMem (16#7FF) dan then def ID is 'cSync' ( 16#080).
//[<State]0= Ok, -1= ID error, -2= Size error, -11= Bussy.
FUNCTION VIRTUAL GLOBAL CanOpenBase::BuildSync
VAR_INPUT
	SyncId		: HINT;
END_VAR
VAR_OUTPUT
	State		: DINT;
END_VAR

If Stepper= eIdle Then
	// send object
	If SyncId> cMaxCanMem Then
		TxData.Id			:= cSync;
	Else
		TxData.Id			:= SyncId;
	End_If;
	TxData.Size			:= 0;
	TxData.Data[1]$DInt	:= 0;
	TxData.Data[5]$DInt	:= 0;
	State	:= SendCanObj( #TxData);
Else
	State	:= -11;
End_If;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::BuildSync
//[#ENGLISH]
//[<Result]0= Ok, -1= Busy, -2= No Config table.
FUNCTION VIRTUAL GLOBAL CanOpenBase::StartConfig
VAR_OUTPUT
	Result		: DINT;
END_VAR

Result	:= 0;
If ReqStep<> eIdle Then 
	Result	:= -1;
Else
	If Conn.ConfigConnected	= 0 Then
		Result	:= -2;
	Else
		ReqStep	:= eStartConfig;
	End_If;
End_If;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::StartConfig
//[#ENGLISH]
//[>Mode]0= Continue, nnn= Every nnn mSec.
//[<Result]0= Ok, -1= Bussy, -2= No valid Poll record.
FUNCTION VIRTUAL GLOBAL CanOpenBase::StartPoll
VAR_INPUT
	Mode		: DINT;
END_VAR
VAR_OUTPUT
	Result		: DINT;
END_VAR
VAR
	i		: DINT;
END_VAR;

Result	:= -2;
Case Stepper Of
eStartPoll, ePollSend, ePollRecieve:
	// Busy polling
	Result	:= -1;
Else
	Poll.Mode	:= -1;
	If ReqStep= eIdle Then
		Poll.ActNr		:= 0;
		Poll.FirstNr	:= 0;
		Poll.LastNr		:= 0;
	 	For i:= 1 to cPollBufferSize Do
			If Poll.Buffer[i].SdoId		<> 0
			 & Poll.Buffer[i].CmndCode	<> 0 Then
			 	If Poll.FirstNr= 0 Then
					Poll.FirstNr	:= i;
				End_If;
				Poll.LastNr	:= i;
			End_If;
		End_For;
		If Poll.LastNr> 0 Then
			Poll.Mode	:= Mode;
			Result	:= 0;
			ReqStep	:= eStartPoll;
		Else
			Server0	:= -7;
		End_If;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::StartPoll
//[#ENGLISH]
//[>Nr]Poll Record number.
//[>Channel]Can object ID (cSdoTx1).
//[>Command]Read/Write and Size ( cWrReq4).
//[>Index]Index number defined by CANOPEN device.
//[>SubIndex]SubIndex number defined by CANOPEN device.
//[>Value]Value to be writen to device or 0 if a read command.
//[<Result]0= 0k, -1= Busy -2= Not a valid record number.
FUNCTION VIRTUAL GLOBAL CanOpenBase::BuildPoll
VAR_INPUT
	Nr		: DINT;
	Channel		: HINT;
	Command		: DINT;
	Index		: DINT;
	SubIndex	: DINT;
	Value		: DINT;
END_VAR
VAR_OUTPUT
	Result		: DINT;
END_VAR

Result	:= 0;
Case Stepper Of
eStartPoll, ePollSend, ePollRecieve:
	Result	:= -1;
Else
	If Nr> 0 & Nr<= cPollBufferSize Then
		Poll.Buffer[Nr].SdoId		:= To_UINT(  Channel);
		Poll.Buffer[Nr].CmndCode	:= To_USINT( Command);
		Poll.Buffer[Nr].Index		:= To_UINT(  Index);
		Poll.Buffer[Nr].SIndex		:= To_USINT( SubIndex);
		Poll.Buffer[Nr].Value		:= To_DINT(  Value);
	Else
		Result	:= -2;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::BuildPoll
//[#ENGLISH]
//[>Nr]Poll Record number.
//[>Value]Pointer to copy value read from poll buffer.
//[<Result]0= 0k, -1= Busy, -2= Not a valid record number.
FUNCTION VIRTUAL GLOBAL CanOpenBase::ReadPoll
VAR_INPUT
	Nr		: DINT;
	Value	: ^DINT;
END_VAR
VAR_OUTPUT
	Result	: DINT;
END_VAR

Result	:= 0;
Case Stepper Of
eStartPoll, ePollSend, ePollRecieve:
	Result	:= -1;
eError:
  Result  := -3;
Else
	If Nr> 0 & Nr<= cPollBufferSize Then
		Value^	:= To_DINT( Poll.Buffer[Nr].Value); 
	Else
		Result	:= -2;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::ReadPoll

//[#ENGLISH]
//[>Nr]Poll Record number.
//[>Value]Value written to poll buffer.
//[<Result]0= 0k, -1= Busy, -2= Not a valid record number.
FUNCTION VIRTUAL GLOBAL CanOpenBase::WritePoll
VAR_INPUT
	Nr		: DINT;
	Value		: DINT;
END_VAR
VAR_OUTPUT
	Result		: DINT;
END_VAR

//If Nr<> Poll.ActNr Then
	If Nr> 0 & Nr<= cPollBufferSize Then
		Poll.Buffer[Nr].Value	:= Value;
	Else
		Result	:= -2;
	End_If;
//Else
//	Result	:= -1;
//End_If;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::WritePoll
//[#ENGLISH]
//[>Nr]0= Clear whole buffer, nnn= Clear one buffer
//[<Result]0= Ok, -1= Not a valid record number.
FUNCTION VIRTUAL GLOBAL CanOpenBase::ClearPoll
VAR_INPUT
	Nr		: DINT;
END_VAR
VAR_OUTPUT
	Result	: DINT;
END_VAR
VAR
	i		: DINT;
END_VAR;

Result	:= 0;
Case Stepper Of
eStartPoll, ePollSend, ePollRecieve:
	Result	:= -1;
Else
	If Nr= 0 Then
		// Clear whole buffer
	 	For i:= 1 to cPollBufferSize Do
			Poll.Buffer[i].SdoId	:= 0;
			Poll.Buffer[i].CmndCode	:= 0;
			Poll.Buffer[i].Index	:= 0;
			Poll.Buffer[i].SIndex	:= 0;
			Poll.Buffer[i].Value	:= 0;
		End_For;
	ElsIf Nr> 0 & Nr<= cPollBufferSize Then
		// Clear one buffer
		Poll.Buffer[Nr].SdoId		:= 0;
		Poll.Buffer[Nr].CmndCode	:= 0;
		Poll.Buffer[Nr].Index		:= 0;
		Poll.Buffer[Nr].SIndex		:= 0;
		Poll.Buffer[Nr].Value		:= 0;
	Else
		Result	:= -2;
	End_If;
End_Case;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::ClearPoll
//[#ENGLISH]
//[>SdoRec]SDO record data
//[>CanObj]CAN object data
FUNCTION VIRTUAL GLOBAL CanOpenBase::Sdo2CanObj
VAR_INPUT
	SdoRec		: ^SdoStr;
	CanObj		: ^CanObjStr;
END_VAR

CanObj^.ID				:= To_UDint( SdoRec^.SdoId)+ To_UDint( cNode);
CanObj^.Size			:= 8;
CanObj^.Data[1]$Dint	:= SdoRec^.CmndCode$Dint;
CanObj^.Data[5]$Dint	:= SdoRec^.Value$Dint;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::Sdo2CanObj
//[#ENGLISH]
//[>CanObj]CAN object data
//[>SdoRec]SDO record data
FUNCTION VIRTUAL GLOBAL CanOpenBase::Can2SdoObj
VAR_INPUT
	CanObj		: ^CanObjStr;
	SdoRec		: ^SdoStr;
END_VAR

SdoRec^.SdoId		:= To_UINT( CanObj^.ID)- To_UInt( cNode);
SdoRec^.CmndCode	:= CanObj^.Data[1]$BSInt;
SdoRec^.Index		:= CanObj^.Data[2]$UInt;
SdoRec^.SIndex		:= CanObj^.Data[4]$USInt;
SdoRec^.Value		:= CanObj^.Data[5]$DInt;

END_FUNCTION //VIRTUAL GLOBAL CanOpenBase::Can2SdoObj


FUNCTION  CanOpenBase::TimeOutScan

// Timeout test for SDO communication 
Case Stepper Of			// Wait for responce from a
eConfigRecieve,			// config command
ePollRecieve,			// poll command
eSdoRecieve:			// SDO command
	// Test for max number of retries
	If Ops.tAbsolute- tSdoSend> cCanOpenTOTime Then
		Retries	+= 1;
		If Retries< cCanOpenMaxRetries Then
			Server0	:= -2;
			ErrStep	:= Stepper;
			Stepper$Dint	-= 1;
		Else
			Server0	:= -4;

			ErrStep	:= Stepper;
			ReqStep	:= eIdle;
			Stepper	:= eError;
		End_If;
	End_If;
End_Case;
(*
// Timeout test for PDO communication 
If Ops.tAbsolute- tPdoSend> cCanOpenTOTime Then
	Retries	+= 1;
	If Retries< cCanOpenMaxRetries Then
		Server0	:= -3;
	Else
		Server0	:= -4;
	End_If;
End_If;
*)

END_FUNCTION // CanOpenBase::TimeOutScan



FUNCTION  CanOpenBase::Stepper
  Var
    i	      : DINT;
  End_Var;

  // Communication stepper
  Case Stepper Of

    eIdle:
      If ReqStep<> eIdle Then
        Stepper	:= ReqStep;
        ReqStep	:= eIdle;
      ElsIf Poll.Mode> 0 Then
        If Ops.tAbsolute- Poll.tLastPoll> PollStr.Mode Then
          Stepper	:= eStartPoll;
        End_If;
      End_If;



    eStartConfig:
      If Conn.ConfigConnected= 1 Then
        Conf.ActNr	:= 1;
        Conf.MaxNr	:= ConfigData.Read();
        If Conf.MaxNr> 0 Then
          Retries	:= 0;
          Stepper	:= eConfigSend;
        Else
          ErrStep( -5);
        End_If;
      Else
        Stepper	:= eIdle;
      End_If;



    eConfigSend:
      If ConfigData.ReadRecord( Nr:= Conf.ActNr, DestSDO:= #Conf.Record)= 1 Then

        // Get TPDO
        if (Conf.Record.Index >= (TpdoMapIndex + 0)) & (Conf.Record.Index <= (TpdoMapIndex + 3)) then
          _index1 := TO_DINT(Conf.Record.Index) - TpdoMapIndex;
          _index2 := TO_DINT(Conf.Record.SIndex);

          if (_index1 >= 0) & (_index1 <= 3) & (_index2 >= 0) & (_index2 <= 4) then

            case _index2 of
              0:        _virtualTpdoMapping[_index1].NumberOfItems := Conf.Record.Value;
              1,2,3,4:  _virtualTpdoMapping[_index1].ItemValues[_index2] := Conf.Record.Value;
            end_case;

          end_if;



        // Get config TPDO
        elsif (Conf.Record.Index >= (TpdoConfigIndex + 0)) & (Conf.Record.Index <= (TpdoConfigIndex + 3)) then
          _index1 := TO_DINT(Conf.Record.Index) - TpdoConfigIndex;
          _index2 := TO_DINT(Conf.Record.SIndex);

          if (_index1 >= 0) & (_index1 <= 3) & (_index2 >= 0) & (_index2 <= 5) then
            _virtualTpdoMapping[_index1].Config[_index2] := Conf.Record.Value;
          end_if;



        // Get RPDO
        elsif (Conf.Record.Index >= (RpdoMapIndex + 0)) & (Conf.Record.Index <= (RpdoMapIndex + 3)) then
          _index1 := TO_DINT(Conf.Record.Index) - RpdoMapIndex;
          _index2 := TO_DINT(Conf.Record.SIndex);

          if (_index1 >= 0) & (_index1 <= 3) & (_index2 >= 0) & (_index2 <= 4) then

            case _index2 of
              0:        _virtualRpdoMapping[_index1].NumberOfItems := Conf.Record.Value;
              1,2,3,4:  _virtualRpdoMapping[_index1].ItemValues[_index2] := Conf.Record.Value;
            end_case;

          end_if;



        // Get config RPDO
        elsif (Conf.Record.Index >= (RpdoConfigIndex + 0)) & (Conf.Record.Index <= (RpdoConfigIndex + 3)) then
          _index1 := TO_DINT(Conf.Record.Index) - RpdoConfigIndex;
          _index2 := TO_DINT(Conf.Record.SIndex);

          if (_index1 >= 0) & (_index1 <= 3) & (_index2 >= 0) & (_index2 <= 5) then
            _virtualTpdoMapping[_index1].Config[_index2] := Conf.Record.Value;
          end_if;
        end_if;

        Sdo2CanObj( SdoRec:= #Conf.Record, CanObj:= #TxData);
        Conf.RespID	:= TxData.ID- Conf.RespDelta;
        vReturn	:= SendCanObj( #TxData);
        If vReturn>= 0 Then
          tSdoSend	:= Ops.tAbsolute;
        End_If;
        Stepper	:= eConfigRecieve;
      Else
        ErrStep( -6);
      End_If;



    eConfigRecieve:
      Resp.Ptr	:= GetCanObj(ObjNr:= Conf.RespID);
      If Resp.Ptr<> Nil Then
        Can2SdoObj( Resp.Ptr, #Resp.Sdo);
        If Resp.Sdo.CmndCode.8= 0 Then
          If Conf.ActNr< Conf.MaxNr Then
            Conf.ActNr	+= 1;
            Stepper	:= eConfigSend;
          Else
            Stepper	:= eIdle;
          End_If;
        Else
          RespError := Resp.Sdo.Value$HDINT;        // #AJM Rev1.0
          case RespError of
            16#05030000: // Toggle bit not alternated
              ErrStep(-101);
            16#05040000: // SDO protocol timed out
              ErrStep(-102);
            16#05040001: // Client/Server command specifier not valid or unknown
              ErrStep(-103);
            16#05040002: // Invalid block size (Block Transfer mode only)
              ErrStep(-104);
            16#05040003: // Invalid sequence number (Block Transfer mode only)
              ErrStep(-105);
            16#05030004: // CRC error (Block Transfer mode only)
              ErrStep(-106);
            16#05030005: // Out of memory
              ErrStep(-107);
            16#06010000: // Unsupported access to an object
              ErrStep(-108);
            16#06010001: // Attempt to read a write-only object
              ErrStep(-109);
            16#06010002: // Attempt to write a read-only object
              ErrStep(-110);
            16#06020000: // Object does not exist in the Object Dictionary
              ErrStep(-111);
            16#06040041: // Object can not be mapped to the PDO
              ErrStep(-112);
            16#06040042: // The number and length of the objects to be mapped would exceed PDO length
              ErrStep(-113);
            16#06040043: // General parameter incompatibility reason
              ErrStep(-114);
            16#06040047: // General internal incompatibility in the device
              ErrStep(-115);
            16#06060000: // Object access failed due to a hardware error
              ErrStep(-116);
            16#06060010: // Data type does not match, lengh of service parameter does not match
              ErrStep(-117);
            16#06060012: // Data type does not match, lengh of service parameter is too high
              ErrStep(-118);
            16#06060013: // Data type does not match, lengh of service parameter is too low
              ErrStep(-119);
            16#06090011: // Sub-index does not exist
              ErrStep(-120);
            16#06090030: // Value range of parameter exceeded (only for write access)
              ErrStep(-121);
            16#06090031: // Value of parameter written too high
              ErrStep(-122);
            16#06090032: // Value of parameter written too low
              ErrStep(-123);
            16#06090036: // Maximum value is less than minimum value
              ErrStep(-124);
            16#08000000: // General error
              ErrStep(-125);
            16#08000020: // Data can not be transferred or stored to the application
              ErrStep(-126);
            16#08000021: // Data can not be transferred or stored to the application because of local control
              ErrStep(-127);
            16#08000022: // Data can not be transferred or stored to the application because of the present device state
              ErrStep(-128);
            16#08000023: // Object Dictionary dynamic generation fails or no Object Dictionary is present
              ErrStep(-129);
          else
            ErrStep( -8);
          end_case;
          
        End_If;
      End_If;



    eStartPoll:
      If Poll.FirstNr> 0 Then
        Poll.ActNr	:= Poll.FirstNr;
        Retries	:= 0;
        Stepper	:= ePollSend;
      Else
        ErrStep( -7);
      End_If;



    ePollSend:
      BuildSDO( SdoId	:= Poll.Buffer[ Poll.ActNr].SdoId
          , Cmnd	:= Poll.Buffer[ Poll.ActNr].CmndCode
          , Index	:= Poll.Buffer[ Poll.ActNr].Index
          , SIndex:= Poll.Buffer[ Poll.ActNr].SIndex
          , Value	:= Poll.Buffer[ Poll.ActNr].Value );
      Poll.RespID	:= TxData.Id- Conf.RespDelta;
      Stepper	:= ePollRecieve;



    ePollRecieve:
      If DecoSDO( SdoId	:= Resp.Id
          , CmndState	:= #Resp.Sdo.CmndCode
            , Index	:= #Resp.Sdo.Index
          , SIndex	:= #Resp.Sdo.SIndex
            , Value	:= #Resp.Sdo.Value)>= 0 Then
        // Ok?
        If Resp.Sdo.CmndCode.8= 0 Then
          Case Resp.Sdo.CmndCode Of 
          cRdRsp1, cRdRsp2, cRdRsp3, cRdRsp4: 
            Poll.Buffer[ Poll.ActNr].Value	:= Resp.Sdo.Value;
          End_Case;
          // Next
          Stepper	:= eIdle;
          If Poll.ActNr= Poll.LastNr Then
            Poll.tLastPoll	:= Ops.tAbsolute;
            Stepper	:= eIdle;
          ElsIf Poll.ActNr< Poll.LastNr Then
            Poll.ActNr	+= 1;
            For i:= Poll.ActNr to Poll.LastNr Do
              If Poll.Buffer[ i].SdoId<> 0
               & Poll.Buffer[ i].CmndCode <> 0 Then
                Poll.ActNr	:= i;
                i	:= Poll.LastNr;
                Stepper	:= ePollSend;
              End_If;
            End_For;
          End_If;
        End_If;
      End_If;



    eNmtSend:
      // Do nothing



    eSdoSend:
      // Do nothing



    eSdoRecieve:
      // Do nothing



    eError:
      If ReqStep<> eIdle Then
        Stepper	:= ReqStep;
        ReqStep	:= eIdle;
        ErrStep	:= eIdle;
        Trace("'CanOpenBase::CyWork' a jump to error is has forgotten to reset ReqStep to eIdle");
      End_If;

  End_Case;

END_FUNCTION // CanOpenBase::Stepper



//[#ENGLISH]
//[>Nr]error number
FUNCTION  CanOpenBase::ErrStep
VAR_INPUT
	Nr		: DINT;
END_VAR
	Server0	:= Nr;
	ErrStep	:= Stepper;
	ReqStep	:= eIdle;
	Stepper	:= eError;
END_FUNCTION // CanOpenBase::ErrStep


FUNCTION VIRTUAL GLOBAL CanOpenBase::CommandDone
	VAR_OUTPUT
		State 	: DINT;
	END_VAR
  
  If Stepper<> eIdle Then
    State := 1;
  Else
    State := 0;
  End_If;
END_FUNCTION


FUNCTION VIRTUAL GLOBAL CanOpenBase::GetNodeNr
	VAR_OUTPUT
		NodeNr 	: DINT;
	END_VAR

  NodeNr  := cNode;

END_FUNCTION



FUNCTION GLOBAL CanOpenBase::GetVirtualPdoMapping
	VAR_INPUT
		typeMapping 	: eCanOpenBaseMapType;
	END_VAR
	VAR_OUTPUT
		virtualPdoMapping 	: ^tCanOpenBasePdo;
	END_VAR

  case typeMapping of
    COBMT_Rpdo: virtualPdoMapping := #_virtualRpdoMapping;
    COBMT_Tpdo: virtualPdoMapping := #_virtualTpdoMapping;
  end_case;

END_FUNCTION



FUNCTION GLOBAL CanOpenBase::GetSyncTime
	VAR_OUTPUT
		syncTime 	: UDINT;
	END_VAR

  syncTime := Driver.GetSyncTime();

END_FUNCTION