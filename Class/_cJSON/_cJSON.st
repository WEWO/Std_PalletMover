//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define cJSON_BOOL DINT
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "_cJSON"
	Revision           = "1.1"
	GUID               = "{9A5304A2-74BC-440C-BB78-7AD58610B11F}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(444,120)"
	Comment            = "This class is a C Wrapper for the cJSON Library which allows the creation, parsing and manipulation of JSON Strings.&#13;&#10;The contents of the library have only been modified in as far as is necessary to enable the functionality in the LASAL Environment.&#13;&#10;&#13;&#10;The software is used under the MIT License as is described on the project page: https://github.com/DaveGamble/cJSON&#13;&#10;&#13;&#10;Important Notes:&#13;&#10;--------------------&#13;&#10;&#13;&#10;Thread Safety:&#13;&#10;cJSON is thread safe under the following conditions:&#13;&#10;- GetErrorPtr is never used (the return_parse_end parameter of cJSON_ParseWithOpts can be used instead.)&#13;&#10;- setlocale is never called before all calls to cJSON functions have returned.&#13;&#10;&#13;&#10;Character Encoding:&#13;&#10;cJSON only supports UTF-8 encoded input, in most cases it doesn&apos;t reject invalid UTF-8 as input though, it just propagates it through as is. &#13;&#10;As long as the input doesn&apos;t contain invalid UTF-8, the output will always be valid UTF-8.&#13;&#10;&#13;&#10;Deep Nesting Of Arrays And Objects:&#13;&#10;cJSON does not support arrays and objects that are nested too deeply because this would result in a stack overflow. &#13;&#10;To prevent this cJSON limits the depth to CJSON_NESTING_LIMIT which is 1000 by default but can be changed at compile time.&#13;&#10;&#13;&#10;Case Sensitivity:&#13;&#10;When cJSON was originally created, it did not follow the JSON standard and did not make a distinction between uppercase and lowercase letters. &#13;&#10;If you want the correct, standard compliant, behavior, you need to use the CaseSensitive functions where available.&#13;&#10;&#13;&#10;Duplicate Object Members:&#13;&#10;cJSON supports parsing and printing JSON that contains objects that have multiple members with the same name.&#13;&#10;cJSON_GetObjectItemCaseSensitive however will always only return the first one.">
	<Channels>
		<Server Name="ClassSvr" GUID="{FA48466B-3FA2-4CA6-B1DB-D629F99DFF1C}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="The global methods can be accessed over this Object Channel.&#13;&#10;"/>
		<Server Name="LibraryVersion" GUID="{DC0E2C7B-F679-4E14-9647-02E1B7A70277}" Class="String" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="The embeded cJSON Library version is shown on this Server, the value is read and set once during the _firstscan cycle."/>
		<Client Name="cJSONVersion" Required="true" Internal="true"/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="OSInterface to SigCLib, this is required for the underlying cJSON functions to function properly."/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\_cJSON\cJSON.h" Include="false"/>
			<File Path=".\Class\_cJSON\cJSON.c"/>
			<File Path=".\Class\_cJSON\cJSON_LasalPort.h" Include="false"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="VelGer"/>
		<Dokumentation Revision="1.1" Date="2021-05-02" Author="VelGer" Company="Sigmatek" Description="1. BugFix: The wrapper behaved differently between x86 and ARM systems as the packing of the transfer parameters is handled differently under the two systems, this could cause unexepected issues as the C-Functions could be executed with incorrect transfer parameters. (On x86 systems, parameters with fewer than 4 bytes are always transferred as 4 byte values, sometimes unintentionally copying past the allowed memory area). This has been corrected so that the methods receives the expected values by normalizing all transfer parameters so that their size equals a multiple of 4."/>
		<Dokumentation Revision="1.0" Date="2021-01-29" Author="VelGer" Company="Sigmatek" Description="1. Initial Creation of the wrapper containing cJSON V1.7.14 (Release: 03.09.2020)"/>
	</RevDoku>
	<Network Name="_cJSON">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "cJSONVersion"
				GUID       = "{985B8132-9FF0-4EED-926E-A6AE698A2A44}"
				Class      = "String"
				Position   = "(150,300)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.cJSONVersion" Destination="cJSONVersion.Data"/>
			<Connection Source="this.LibraryVersion" Destination="cJSONVersion.Data" Vertices="(1058,270),(540,270),(510,300),(510,360),(480,390),(886,390),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
_cJSON : CLASS
	TYPE
#pragma pack(push, 1)
	  t_s_cJSON : STRUCT  //! <Type Public="true" Comment="This structure describes a single entity in the JSON Structure, the tree can be navigated using the t_s_cJSON.Next, t_s_cJSON.Prev and t_s_cJSON.Child pointers.&#13;&#10;The tree is manipulated and interrogated using the functions provided in the _cJSON class." Name="t_s_cJSON"/>
	    Next : ^t_s_cJSON;  //! <Type Comment="Pointer to the next element in the JSON Structure." Name="t_s_cJSON.Next"/>
	    Prev : ^t_s_cJSON;  //! <Type Comment="Pointer to the previous element in the JSON Structure." Name="t_s_cJSON.Prev"/>
	    Child : ^t_s_cJSON;  //! <Type Comment="Pointer to the first child of this element in the JSON Structure." Name="t_s_cJSON.Child"/>
	    JType : DINT;  //! <Type Comment="Bitfield which represents the JSON Type of this entity." Name="t_s_cJSON.JType"/>
	    Val_String : ^CHAR;  //! <Type Comment="Pointer to the value of this entity if the relevant value is stored as string." Name="t_s_cJSON.Val_String"/>
	    Val_Int : DINT;  //! <Type Comment="The value of this entity if the relevant value is stored as Integer." Name="t_s_cJSON.Val_Int"/>
	    Val_Double : LREAL;  //! <Type Comment="The value of this entity if the relevant value is stored as LREAL." Name="t_s_cJSON.Val_Double"/>
	    String : ^CHAR;  //! <Type Comment="This entities&apos; name string." Name="t_s_cJSON.String"/>
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	LibraryVersion 	: SvrChCmd_UDINT;
  //Clients:
	cJSONVersion 	: CltChCmd_String;
	SigCLib 	: CltChCmd_SigCLib;
  //Variables:
  //Functions:
				//! <Function Comment="The Firstscan cycle is used to set the Library Version String." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="This method returns the version of cJSON as a string." Name="Version"/>
	FUNCTION GLOBAL Version
		VAR_OUTPUT
			retString 	: ^CHAR;			//! <Variable Comment="Version String." Name="Version.retString"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON, the method then returns a cJSON object that can be interrogated." Name="Parse"/>
	FUNCTION GLOBAL Parse
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="Parse.value"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="Parse.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with a data length, the method then returns a cJSON object that can be interrogated." Name="ParseWithLength"/>
	FUNCTION GLOBAL ParseWithLength
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithLength.value"/>
			buffer_length 	: UDINT;			//! <Variable Comment="Length of the string to be parsed." Name="ParseWithLength.buffer_length"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithLength.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with a data length and some options to help verify that the JSON string is terminated OK, the method then returns a cJSON object that can be interrogated and in the case of failure the pointer to where the error was found in the JSON string." Name="ParseWithLengthOpts"/>
	FUNCTION GLOBAL ParseWithLengthOpts
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithLengthOpts.value"/>
			buffer_length 	: UDINT;			//! <Variable Comment="Length of the string to be parsed." Name="ParseWithLengthOpts.buffer_length"/>
			return_parse_end 	: ^pChar;			//! <Variable Comment="If the parsing of the JSON string fails, the pointer to where the error was detected in the String is passed back over this pointer.&#13;&#10;This value matches that which is delivered by the GetErrorPtr() method and can be used to ensure that the class remains thread safe." Name="ParseWithLengthOpts.return_parse_end"/>
			require_null_terminated 	: BOOL;			//! <Variable Comment="When set the parser ensures that the string passed to the method was null terminated." Name="ParseWithLengthOpts.require_null_terminated"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithLengthOpts.json"/>
		END_VAR;
				//! <Function Comment="This method parses a JSON String.&#13;&#10;Using this method, the user can supply a block of JSON along with some options to help verify that the JSON string is terminated OK, the method then returns a cJSON object that can be interrogated and in the case of failure the pointer to where the error was found in the JSON string." Name="ParseWithOpts"/>
	FUNCTION GLOBAL ParseWithOpts
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="Pointer to the JSON String to be parsed." Name="ParseWithOpts.value"/>
			return_parse_end 	: ^pChar;			//! <Variable Comment="If the parsing of the JSON string fails, the pointer to where the error was detected in the String is passed back over this pointer.&#13;&#10;This value matches that which is delivered by the GetErrorPtr() method and can be used to ensure that the class remains thread safe." Name="ParseWithOpts.return_parse_end"/>
			require_null_terminated 	: BOOL;			//! <Variable Comment="When set the parser ensures that the string passed to the method was null terminated." Name="ParseWithOpts.require_null_terminated"/>
		END_VAR
		VAR_OUTPUT
			json 	: ^t_s_cJSON;			//! <Variable Comment="The Interpreted JSON Structure." Name="ParseWithOpts.json"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON entity (see _cJSON::t_s_cJSON) can be rendered to string." Name="Print"/>
	FUNCTION GLOBAL Print
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="Print.item"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="Print.string"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON entity (see _cJSON::t_s_cJSON) can be rendered to string whilst ignoring any formatting." Name="PrintUnformatted"/>
	FUNCTION GLOBAL PrintUnformatted
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintUnformatted.item"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintUnformatted.string"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON entity can be printed to string using a prebuffered strategy, this means that the required memory is allocated beforehand and reallocation is thereby reduced.&#13;&#10;As opposed to the unbuffered strategy the user must supply an initial guess describing how large the JSON string will be, if this is exceeded whilst rendering a reallocation is made." Name="PrintBuffered"/>
	FUNCTION GLOBAL PrintBuffered
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintBuffered.item"/>
			prebuffer 	: INT;			//! <Variable Comment="Size of the buffer memory to be allocated initially. See the method comment for a further description of this functionality." Name="PrintBuffered.prebuffer"/>
			fmt 	: BOOL;			//! <Variable Comment="Whether the string is to be printed formatted or not:&#13;&#10;True = Formatted&#13;&#10;False = Unformatted" Name="PrintBuffered.fmt"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintBuffered.string"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON entity can be printed to string using a preallocated strategy, this means that the required memory is allocated by the user and the location and size provided to the class.&#13;&#10;If rendering the JSON string requires more memory than was initially allocated by the user the process will fail." Name="PrintPreallocated"/>
	FUNCTION GLOBAL PrintPreallocated
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The item to be rendered." Name="PrintPreallocated.item"/>
			buffer 	: ^CHAR;			//! <Variable Comment="A pointer to the memory that the user has allocated for the rendering of the string." Name="PrintPreallocated.buffer"/>
			length 	: INT;			//! <Variable Comment="The length of the memory allocated (how far the class is allowed to write)." Name="PrintPreallocated.length"/>
			format 	: BOOL;			//! <Variable Comment="Whether the string is to be printed formatted or not:&#13;&#10;True = Formatted&#13;&#10;False = Unformatted" Name="PrintPreallocated.format"/>
		END_VAR
		VAR_OUTPUT
			string 	: ^CHAR;			//! <Variable Comment="The rendered string and in case of failure, null." Name="PrintPreallocated.string"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Structure (see _cJSON::t_s_cJSON) can be deleted (freed) from memory, all subentities to this structure are also freed." Name="Delete"/>
	FUNCTION GLOBAL Delete
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="JSON Structure to free." Name="Delete.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the number of items in a JSON Array or JSON object." Name="GetArraySize"/>
	FUNCTION GLOBAL GetArraySize
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="JSON Array or Object of which the item count is to be returned." Name="GetArraySize.item"/>
		END_VAR
		VAR_OUTPUT
			size 	: INT;			//! <Variable Comment="The number of items found." Name="GetArraySize.size"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the pointer to the item at the position and in the JSON Array provided." Name="GetArrayItem"/>
	FUNCTION GLOBAL GetArrayItem
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The JSON Array in which the item is to be found." Name="GetArrayItem.item"/>
			index 	: UDINT;			//! <Variable Comment="The zero-indexed index number from which the item is to be found." Name="GetArrayItem.index"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^t_s_cJSON;			//! <Variable Comment="The pointer to the item found at the index position, if an error occurs, null." Name="GetArrayItem.entry"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the pointer to the item of which the key value matches the string provided, the search is case-insensitive." Name="GetObjectItem"/>
	FUNCTION GLOBAL GetObjectItem
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="GetObjectItem.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-insentive string value matching the key to be found." Name="GetObjectItem.string"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^t_s_cJSON;			//! <Variable Comment="The JSON entity of which the key was found in the object provided, if not found, null." Name="GetObjectItem.entry"/>
		END_VAR;
				//! <Function Comment="This method operates in the same way as the _cJSON::GetObjectItem() method, the only difference is that the key search is case-sensitive.&#13;&#10;The user can find the pointer to the item of which the key value matches the string provided." Name="GetObjectItemCaseSensitive"/>
	FUNCTION GLOBAL GetObjectItemCaseSensitive
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="GetObjectItemCaseSensitive.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-sensitive string value matching the key to be found." Name="GetObjectItemCaseSensitive.string"/>
		END_VAR
		VAR_OUTPUT
			entry 	: ^t_s_cJSON;			//! <Variable Comment="The JSON entity of which the key was found in the object provided, if not found, null." Name="GetObjectItemCaseSensitive.entry"/>
		END_VAR;
				//! <Function Comment="Using this method the user can search through a JSON object to determine whether the object contains the key value provided." Name="HasObjectItem"/>
	FUNCTION GLOBAL HasObjectItem
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The JSON object in which the item is to be searched for." Name="HasObjectItem.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The case-insentive string value matching the key to be found." Name="HasObjectItem.string"/>
		END_VAR
		VAR_OUTPUT
			hasItem 	: BOOL;			//! <Variable Comment="A bool indicating whether the item searched for was found.&#13;&#10;True = The object contains an item with the key value as provided.&#13;&#10;False = The object does not contain an item with the key value provided." Name="HasObjectItem.hasItem"/>
		END_VAR;
				//! <Function Comment="Using this method the user can retrieve the pointer to the position where the last error occurred in any JSON operation.&#13;&#10;Special care must be taken as the method does not ensure thread-safety, if multiple threads can call functions in the class, it cannot be ensured that the retrieved pointer points to the expected error.&#13;&#10;As opposed to using this method the user can use the thread-safe _cJSON::ParseWithOpts() / _cJSON::ParseWithLengthOpts() to receive the pointer to where a parsing error occured immediately." Name="GetErrorPtr"/>
	FUNCTION GLOBAL GetErrorPtr
		VAR_OUTPUT
			errPtr 	: ^CHAR;			//! <Variable Comment="Pointer to where the last error occured." Name="GetErrorPtr.errPtr"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the string value of the supplied JSON entity.&#13;&#10;If the entity is not valid or not of type string, null is returned." Name="GetStringValue"/>
	FUNCTION GLOBAL GetStringValue
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The JSON string entity of which the value is to be returned." Name="GetStringValue.item"/>
		END_VAR
		VAR_OUTPUT
			value 	: ^CHAR;			//! <Variable Comment="If the entity is of type JSON String, a pointer to the string, if not, null." Name="GetStringValue.value"/>
		END_VAR;
				//! <Function Comment="Using this method the user can find the number (LREAL) value of the supplied JSON entity." Name="GetNumberValue"/>
	FUNCTION GLOBAL GetNumberValue
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The JSON number entity of which the value is to be returned." Name="GetNumberValue.item"/>
		END_VAR
		VAR_OUTPUT
			value 	: LREAL;			//! <Variable Comment="If the provided item is of type JSON number, the value, if not, NAN." Name="GetNumberValue.value"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is invalid." Name="IsInvalid"/>
	FUNCTION GLOBAL IsInvalid
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsInvalid.item"/>
		END_VAR
		VAR_OUTPUT
			isInvalid 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Invalid:&#13;&#10;True = Invalid&#13;&#10;False = Not Invalid" Name="IsInvalid.isInvalid"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is False." Name="IsFalse"/>
	FUNCTION GLOBAL IsFalse
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsFalse.item"/>
		END_VAR
		VAR_OUTPUT
			isFalse 	: BOOL;			//! <Variable Comment="Value indicating whether the type is False.&#13;&#10;True = Value is False&#13;&#10;False = Value is not False" Name="IsFalse.isFalse"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is True." Name="IsTrue"/>
	FUNCTION GLOBAL IsTrue
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsTrue.item"/>
		END_VAR
		VAR_OUTPUT
			isTrue 	: BOOL;			//! <Variable Comment="Value indicating whether the type is True.&#13;&#10;True = Value is True&#13;&#10;False = Value is not True" Name="IsTrue.isTrue"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type bool." Name="IsBool"/>
	FUNCTION GLOBAL IsBool
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsBool.item"/>
		END_VAR
		VAR_OUTPUT
			isBool 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Bool.&#13;&#10;True = Value is of tye Bool&#13;&#10;False = Value is not of type Bool" Name="IsBool.isBool"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is null." Name="IsNull"/>
	FUNCTION GLOBAL IsNull
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsNull.item"/>
		END_VAR
		VAR_OUTPUT
			isNull 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Null.&#13;&#10;True = Value is Null&#13;&#10;False = Value is not Null" Name="IsNull.isNull"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type number." Name="IsNumber"/>
	FUNCTION GLOBAL IsNumber
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsNumber.item"/>
		END_VAR
		VAR_OUTPUT
			isNumber 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Number.&#13;&#10;True = Value is of type Number&#13;&#10;False = Value is not of type Number" Name="IsNumber.isNumber"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type string." Name="IsString"/>
	FUNCTION GLOBAL IsString
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsString.item"/>
		END_VAR
		VAR_OUTPUT
			isString 	: BOOL;			//! <Variable Comment="Value indicating whether the type is String.&#13;&#10;True = Value is of type String&#13;&#10;False = Value is not of type String" Name="IsString.isString"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is a JSON Array." Name="IsArray"/>
	FUNCTION GLOBAL IsArray
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsArray.item"/>
		END_VAR
		VAR_OUTPUT
			isArray 	: BOOL;			//! <Variable Comment="Value indicating whether the type is JSON Array.&#13;&#10;True = Value is a JSON Array&#13;&#10;False = Value is not a JSON Array" Name="IsArray.isArray"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is a JSON Object." Name="IsObject"/>
	FUNCTION GLOBAL IsObject
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsObject.item"/>
		END_VAR
		VAR_OUTPUT
			isObject 	: BOOL;			//! <Variable Comment="Value indicating whether the type is a JSON Object.&#13;&#10;True = Value is a JSON Object&#13;&#10;False = Value is not a JSON Object" Name="IsObject.isObject"/>
		END_VAR;
				//! <Function Comment="Using this method the user can determine whether the JSON Entiity provided is of type Raw." Name="IsRaw"/>
	FUNCTION GLOBAL IsRaw
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the type is to be tested." Name="IsRaw.item"/>
		END_VAR
		VAR_OUTPUT
			isRaw 	: BOOL;			//! <Variable Comment="Value indicating whether the type is Raw.&#13;&#10;True = Value is of type Raw&#13;&#10;False = Value is not of type Raw" Name="IsRaw.isRaw"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Null." Name="CreateNull"/>
	FUNCTION GLOBAL CreateNull
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateNull.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type True." Name="CreateTrue"/>
	FUNCTION GLOBAL CreateTrue
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateTrue.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type False." Name="CreateFalse"/>
	FUNCTION GLOBAL CreateFalse
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateFalse.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Bool." Name="CreateBool"/>
	FUNCTION GLOBAL CreateBool
		VAR_INPUT
			value 	: BOOL;			//! <Variable Comment="The value to be set in the created item." Name="CreateBool.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateBool.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Number." Name="CreateNumber"/>
	FUNCTION GLOBAL CreateNumber
		VAR_INPUT
			value 	: LREAL;			//! <Variable Comment="The value to be set in the created item." Name="CreateNumber.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateNumber.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type String." Name="CreateString"/>
	FUNCTION GLOBAL CreateString
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="The value to be set in the created item." Name="CreateString.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateString.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type Raw." Name="CreateRaw"/>
	FUNCTION GLOBAL CreateRaw
		VAR_INPUT
			value 	: ^CHAR;			//! <Variable Comment="The value to be set in the created item." Name="CreateRaw.value"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateRaw.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type JSON Array." Name="CreateArray"/>
	FUNCTION GLOBAL CreateArray
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new Json entity (see _cJSON::t_s_cJSON) of type JSON Object." Name="CreateObject"/>
	FUNCTION GLOBAL CreateObject
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The created item." Name="CreateObject.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON entity (see _cJSON::t_s_cJSON) of type string where the string is referenced, this means that the string will not be freed when the returned item is deleted (freed)." Name="CreateStringReference"/>
	FUNCTION GLOBAL CreateStringReference
		VAR_INPUT
			string 	: ^CHAR;			//! <Variable Comment="The string to be referenced in the newly created JSON entity." Name="CreateStringReference.string"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="CreateStringReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON Object entity (see _cJSON::t_s_cJSON) containing the child entity provided where the child is referenced, this means that the child will not be freed when the returned item is deleted (freed)." Name="CreateObjectReference"/>
	FUNCTION GLOBAL CreateObjectReference
		VAR_INPUT
			child 	: ^t_s_cJSON;			//! <Variable Comment="JSON Entity to reference in the newly created JSON Object Entity." Name="CreateObjectReference.child"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created JSON Object entity." Name="CreateObjectReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method the user can create a new JSON Array entity (see _cJSON::t_s_cJSON) containing the child entity provided where the child is referenced, this means that the child will not be freed when the returned Array item is deleted (freed)." Name="CreateArrayReference"/>
	FUNCTION GLOBAL CreateArrayReference
		VAR_INPUT
			child 	: ^t_s_cJSON;			//! <Variable Comment="JSON Entity to reference in the newly created JSON Array Entity." Name="CreateArrayReference.child"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created JSON Array entity." Name="CreateArrayReference.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type INT can be created containing the provided values." Name="CreateIntArray"/>
	FUNCTION GLOBAL CreateIntArray
		VAR_INPUT
			numbers 	: ^INT;			//! <Variable Comment="Pointer to the first item in the array of integers to be added in the newly created JSON Array item." Name="CreateIntArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateIntArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateIntArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type REAL can be created containing the provided values." Name="CreateFloatArray"/>
	FUNCTION GLOBAL CreateFloatArray
		VAR_INPUT
			numbers 	: ^REAL;			//! <Variable Comment="Pointer to the first item in the array of REALs to be added in the newly created JSON Array item." Name="CreateFloatArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateFloatArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateFloatArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type LREAL can be created containing the provided values." Name="CreateDoubleArray"/>
	FUNCTION GLOBAL CreateDoubleArray
		VAR_INPUT
			numbers 	: ^LREAL;			//! <Variable Comment="Pointer to the first item in the array of LREALs to be added in the newly created JSON Array item." Name="CreateDoubleArray.numbers"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateDoubleArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateDoubleArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Array of type String can be created containing the provided values." Name="CreateStringArray"/>
	FUNCTION GLOBAL CreateStringArray
		VAR_INPUT
			strings 	: ^CHAR;			//! <Variable Comment="Pointer to the first item in the array of Strings to be added in the newly created JSON Array item." Name="CreateStringArray.strings"/>
			count 	: INT;			//! <Variable Comment="The number of items to be added to the newly created JSON Array Item, if this number exceeds the amount of values in the provided array, the class will read past the the array bounds." Name="CreateStringArray.count"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created JSON Array Item." Name="CreateStringArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Array Entity." Name="AddItemToArray"/>
	FUNCTION GLOBAL AddItemToArray
		VAR_INPUT
			arr 	: ^t_s_cJSON;			//! <Variable Comment="The Array entity to which the provided entity is to be added." Name="AddItemToArray.arr"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The JSON Entity to add to the Array Entity." Name="AddItemToArray.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the procedure succeeded or not.&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Object Entity where the key-string provided is defined in user memory and should be freed when the object is deleted (freed).&#13;&#10;Before using this method compare this to and ensure a good understanding of the purpose of the method: _cJSON::AddItemToObjectCS()" Name="AddItemToObject"/>
	FUNCTION GLOBAL AddItemToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="Obect entity to which the item is to be added." Name="AddItemToObject.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be stored in the object.&#13;&#10;This key value string will be freed along with the object when it is deleted (freed) - ensure not to pass a constant (#define) string or a string that is to outlive the JSON object to this value." Name="AddItemToObject.string"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity to store in the object." Name="AddItemToObject.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be added to a JSON Object Entity where the key-string provided is constant and should not be freed when the object is deleted (freed).&#13;&#10;Before using this method compare this to and ensure a good understanding of the purpose of the method: _cJSON::AddItemToObject()" Name="AddItemToObjectCS"/>
	FUNCTION GLOBAL AddItemToObjectCS
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="Obect entity to which the item is to be added." Name="AddItemToObjectCS.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be stored in the object.&#13;&#10;This key value string will not be freed along with the object when it is deleted (freed)." Name="AddItemToObjectCS.string"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity to store in the object." Name="AddItemToObjectCS.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemToObjectCS.result"/>
		END_VAR;
				//! <Function Comment="This method can be used to append a reference to a JSON Entity to a JSON Array, this can be used when the JSON entity should not be modified by the operation." Name="AddItemReferenceToArray"/>
	FUNCTION GLOBAL AddItemReferenceToArray
		VAR_INPUT
			arr 	: ^t_s_cJSON;			//! <Variable Comment="JSON Array to which the reference to the JSON Entity is to be added." Name="AddItemReferenceToArray.arr"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity to reference in the JSON Array." Name="AddItemReferenceToArray.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemReferenceToArray.result"/>
		END_VAR;
				//! <Function Comment="This method can be used to add a reference to a JSON Entity to a JSON Object, this can be used when the JSON entity should not be modified by the operation." Name="AddItemReferenceToObject"/>
	FUNCTION GLOBAL AddItemReferenceToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="JSON Object to which the reference to the JSON Entity is to be added." Name="AddItemReferenceToObject.object"/>
			string 	: ^CHAR;			//! <Variable Comment="The key value with which the entity is to be referenced in the object." Name="AddItemReferenceToObject.string"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The entity to reference in the JSON Object." Name="AddItemReferenceToObject.item"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="AddItemReferenceToObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from another JSON Entity without deleting (freeing) either." Name="DetachItemViaPointer"/>
	FUNCTION GLOBAL DetachItemViaPointer
		VAR_INPUT
			parent 	: ^t_s_cJSON;			//! <Variable Comment="The parent item from which the child item is to be detached." Name="DetachItemViaPointer.parent"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The Child item which is to be detached from the parent item provided." Name="DetachItemViaPointer.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^t_s_cJSON;			//! <Variable Comment="Pointer to the detached item." Name="DetachItemViaPointer.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from JSON Array without deleting (freeing) either." Name="DetachItemFromArray"/>
	FUNCTION GLOBAL DetachItemFromArray
		VAR_INPUT
			arr 	: ^t_s_cJSON;			//! <Variable Comment="Array from which the item is to be detached." Name="DetachItemFromArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index of the item in the array to be detached." Name="DetachItemFromArray.index"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="Pointer to the detached item." Name="DetachItemFromArray.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be removed and deleted from a JSON Array Entity." Name="DeleteItemFromArray"/>
	FUNCTION GLOBAL DeleteItemFromArray
		VAR_INPUT
			arr 	: ^t_s_cJSON;			//! <Variable Comment="Array from which the item is to be deleted (freed)." Name="DeleteItemFromArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index of the item to be deleted (removed)." Name="DeleteItemFromArray.index"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from a JSON Object without deleting (freeing) either.&#13;&#10;The key value search is non-case-sensitive." Name="DetachItemFromObject"/>
	FUNCTION GLOBAL DetachItemFromObject
		VAR_INPUT
			parent 	: ^t_s_cJSON;			//! <Variable Comment="Object from which the item is to be detached." Name="DetachItemFromObject.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be detached from the parent provided." Name="DetachItemFromObject.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^t_s_cJSON;			//! <Variable Comment="The detached item if the operation succeeded, else null." Name="DetachItemFromObject.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be detached from a JSON Object without deleting (freeing) either.&#13;&#10;The key value search is case-sensitive." Name="DetachItemFromObjectCaseSensitive"/>
	FUNCTION GLOBAL DetachItemFromObjectCaseSensitive
		VAR_INPUT
			parent 	: ^t_s_cJSON;			//! <Variable Comment="Object from which the item is to be detached." Name="DetachItemFromObjectCaseSensitive.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be detached from the parent provided." Name="DetachItemFromObjectCaseSensitive.item"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^t_s_cJSON;			//! <Variable Comment="The detached item if the operation succeeded, else null." Name="DetachItemFromObjectCaseSensitive.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be deleted (freed) from a JSON Object.&#13;&#10;The key value search is non-case-sensitive." Name="DeleteItemFromObject"/>
	FUNCTION GLOBAL DeleteItemFromObject
		VAR_INPUT
			parent 	: ^t_s_cJSON;			//! <Variable Comment="Object from which the item is to be deleted." Name="DeleteItemFromObject.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be deleted from the parent provided." Name="DeleteItemFromObject.item"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON Entity (see _cJSON::t_s_cJSON) can be deleted (freed) from a JSON Object.&#13;&#10;The key value search is case-sensitive." Name="DeleteItemFromObjectCaseSensitive"/>
	FUNCTION GLOBAL DeleteItemFromObjectCaseSensitive
		VAR_INPUT
			parent 	: ^t_s_cJSON;			//! <Variable Comment="Object from which the item is to be deleted." Name="DeleteItemFromObjectCaseSensitive.parent"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be deleted from the parent provided." Name="DeleteItemFromObjectCaseSensitive.item"/>
		END_VAR;
				//! <Function Comment="Using this method an item can be inserted in a JSON Array at the index provided, the pre-existing items in the array are shifted to the right." Name="InsertItemInArray"/>
	FUNCTION GLOBAL InsertItemInArray
		VAR_INPUT
			arr 	: ^t_s_cJSON;			//! <Variable Comment="The JSON Array in which item is to be added." Name="InsertItemInArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index at which the item should be added in the array." Name="InsertItemInArray.index"/>
			newItem 	: ^t_s_cJSON;			//! <Variable Comment="The item to be added to the array." Name="InsertItemInArray.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="InsertItemInArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Entity can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation." Name="ReplaceItemViaPointer"/>
	FUNCTION GLOBAL ReplaceItemViaPointer
		VAR_INPUT
			parent 	: ^t_s_cJSON;			//! <Variable Comment="JSON Entity in which the item is to be replaced." Name="ReplaceItemViaPointer.parent"/>
			item 	: ^t_s_cJSON;			//! <Variable Comment="The Item to be replaced and deleted (freed)." Name="ReplaceItemViaPointer.item"/>
			newItem 	: ^t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Entity (parent)." Name="ReplaceItemViaPointer.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemViaPointer.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Array can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation." Name="ReplaceItemInArray"/>
	FUNCTION GLOBAL ReplaceItemInArray
		VAR_INPUT
			arr 	: ^t_s_cJSON;			//! <Variable Comment="The JSON Array in which item is to be replaced." Name="ReplaceItemInArray.arr"/>
			index 	: INT;			//! <Variable Comment="Zero-indexed index at which the item that is to be replaced can be found." Name="ReplaceItemInArray.index"/>
			newItem 	: ^t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Array at the index provided." Name="ReplaceItemInArray.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInArray.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Object can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation.&#13;&#10;The key value search is non-case-sensitive." Name="ReplaceItemInObject"/>
	FUNCTION GLOBAL ReplaceItemInObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="JSON Object in which the item is to be replaced." Name="ReplaceItemInObject.object"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the non-case-sensitive key value of the item to be replaced in the parent provided." Name="ReplaceItemInObject.item"/>
			newItem 	: ^t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Object under the key provided." Name="ReplaceItemInObject.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInObject.result"/>
		END_VAR;
				//! <Function Comment="Using this method an existing item in a JSON Object can be replaced by the provided item.&#13;&#10;The replaced item is deleted (freed) by this operation.&#13;&#10;The key value search is case-sensitive." Name="ReplaceItemInObjectCaseSensitive"/>
	FUNCTION GLOBAL ReplaceItemInObjectCaseSensitive
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="JSON Object in which the item is to be replaced." Name="ReplaceItemInObjectCaseSensitive.object"/>
			item 	: ^CHAR;			//! <Variable Comment="Pointer to a string containing the case-sensitive key value of the item to be replaced in the parent provided." Name="ReplaceItemInObjectCaseSensitive.item"/>
			newItem 	: ^t_s_cJSON;			//! <Variable Comment="The new item that should be inserted in the JSON Object under the key provided." Name="ReplaceItemInObjectCaseSensitive.newItem"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Whether the operation succeeded or not&#13;&#10;True = Succeeded&#13;&#10;False = Failed" Name="ReplaceItemInObjectCaseSensitive.result"/>
		END_VAR;
				//! <Function Comment="Using this method the provided JSON Entity can be duplicated, optionally the children can be copied as well (deep-copy) or the pointers to the original children left in place (shallow-copy)." Name="Duplicate"/>
	FUNCTION GLOBAL Duplicate
		VAR_INPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The item to be duplicated." Name="Duplicate.item"/>
			recurse 	: BOOL;			//! <Variable Comment="Value indicating whether to recurse down the tree or not.&#13;&#10;True = Deep-Copy&#13;&#10;False = Shallow-Copy" Name="Duplicate.recurse"/>
		END_VAR
		VAR_OUTPUT
			retItem 	: ^t_s_cJSON;			//! <Variable Comment="The duplicated JSON Entity." Name="Duplicate.retItem"/>
		END_VAR;
				//! <Function Comment="Using this method two JSON Entities can be compared, the comparison is performed down the entire tree and case-sensitivity can optionally be checked or ignored." Name="Compare"/>
	FUNCTION GLOBAL Compare
		VAR_INPUT
			compareA 	: ^t_s_cJSON;			//! <Variable Comment="The first JSON Entity to be used for the comparison." Name="Compare.compareA"/>
			compareB 	: ^t_s_cJSON;			//! <Variable Comment="The second JSON Entity to be used for the comparison." Name="Compare.compareB"/>
			case_sensitive 	: BOOL;			//! <Variable Comment="Whether case-sensitivity should be considered or not.&#13;&#10;True = Character-Case is considered in the comparison.&#13;&#10;False = Character-Case is ignored in the comparison." Name="Compare.case_sensitive"/>
		END_VAR
		VAR_OUTPUT
			result 	: BOOL;			//! <Variable Comment="Result of the operation.&#13;&#10;True = The provided JSON Entities are identical.&#13;&#10;False = The provided JSON Entities differ." Name="Compare.result"/>
		END_VAR;
				//! <Function Comment="Using this method a JSON String can be minified, this means that all unnecessary whitespace (&apos; &apos;, &apos;\t&apos;, &apos;\r&apos;, &apos;\n&apos;) is removed." Name="Minify"/>
	FUNCTION GLOBAL Minify
		VAR_INPUT
			json 	: ^CHAR;			//! <Variable Comment="The JSON String to be minified.&#13;&#10;This value cannot point to a constant memory area, this will cause an access error." Name="Minify.json"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Null to the object specified." Name="AddNullToObject"/>
	FUNCTION GLOBAL AddNullToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddNullToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddNullToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddNullToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type True to the object specified." Name="AddTrueToObject"/>
	FUNCTION GLOBAL AddTrueToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddTrueToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddTrueToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddTrueToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type False to the object specified." Name="AddFalseToObject"/>
	FUNCTION GLOBAL AddFalseToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddFalseToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddFalseToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddFalseToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Bool to the object specified." Name="AddBoolToObject"/>
	FUNCTION GLOBAL AddBoolToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddBoolToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddBoolToObject.name"/>
			boolean 	: BOOL;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddBoolToObject.boolean"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddBoolToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Number to the object specified." Name="AddNumberToObject"/>
	FUNCTION GLOBAL AddNumberToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddNumberToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddNumberToObject.name"/>
			number 	: LREAL;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddNumberToObject.number"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddNumberToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type String to the object specified." Name="AddStringToObject"/>
	FUNCTION GLOBAL AddStringToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddStringToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddStringToObject.name"/>
			string 	: ^CHAR;			//! <Variable Comment="The value to assign to the newly created entity. &#13;&#10;This string will be copied from the dereferenced pointer location provided." Name="AddStringToObject.string"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddStringToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type Raw to the object specified." Name="AddRawToObject"/>
	FUNCTION GLOBAL AddRawToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddRawToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddRawToObject.name"/>
			raw 	: ^CHAR;			//! <Variable Comment="The value to assign to the newly created entity." Name="AddRawToObject.raw"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddRawToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type JSON Object to the object specified." Name="AddObjectToObject"/>
	FUNCTION GLOBAL AddObjectToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddObjectToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddObjectToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddObjectToObject.item"/>
		END_VAR;
				//! <Function Comment="This method can be used to create and add a JSON Entity (see _cJSON::t_s_cJSON) of type JSON Array to the object specified." Name="AddArrayToObject"/>
	FUNCTION GLOBAL AddArrayToObject
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The object to add the newly created entity to." Name="AddArrayToObject.object"/>
			name 	: ^CHAR;			//! <Variable Comment="The string containing the key value to assign to the newly created entity when being added to the object provided." Name="AddArrayToObject.name"/>
		END_VAR
		VAR_OUTPUT
			item 	: ^t_s_cJSON;			//! <Variable Comment="The newly created entity." Name="AddArrayToObject.item"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the number value of an Entity (see _cJSON::t_s_cJSON) to the value provided." Name="SetNumber"/>
	FUNCTION GLOBAL SetNumber
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the value is to be modified." Name="SetNumber.object"/>
			number 	: LREAL;			//! <Variable Comment="The value to set the entity value to." Name="SetNumber.number"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: LREAL;			//! <Variable Comment="The value that the entity was set to." Name="SetNumber.retVal"/>
		END_VAR;
				//! <Function Comment="This method allows the user to change the String value of an Entity (see _cJSON::t_s_cJSON) to the string provided." Name="SetValuestring"/>
	FUNCTION GLOBAL SetValuestring
		VAR_INPUT
			object 	: ^t_s_cJSON;			//! <Variable Comment="The entity of which the string value is to be modified." Name="SetValuestring.object"/>
			valueString 	: ^CHAR;			//! <Variable Comment="The String value to set the entity to, the string will be copied from the dereferenced pointer location provided here." Name="SetValuestring.valueString"/>
		END_VAR
		VAR_OUTPUT
			retVal 	: ^CHAR;			//! <Variable Comment="Pointer to the copied string that was added to the entity." Name="SetValuestring.retVal"/>
		END_VAR;
	
	FUNCTION GetCJSONBool
		VAR_INPUT
			boolIn 	: BOOL;
		END_VAR
		VAR_OUTPUT
			boolOut 	: DINT;
		END_VAR;
	
	FUNCTION GetBool
		VAR_INPUT
			boolIn 	: DINT;
		END_VAR
		VAR_OUTPUT
			boolOut 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL LibraryVersion::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using String
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB _cJSON::@CT_
0$UINT,
2#0100000000000000$UINT, //TY__CJSON
1$UINT, 1$UINT, (SIZEOF(::_cJSON))$UINT, 
2$UINT, 2$UINT, 0$UINT, 
TO_UDINT(798961397), "_cJSON", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::_cJSON.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::_cJSON.LibraryVersion.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(115726070), "LibraryVersion", 
//Clients:
(::_cJSON.cJSONVersion.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2061840865), "cJSONVersion", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::_cJSON.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
END_FUNCTION


#define USER_CNT__cJSON 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT__cJSON] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION _cJSON::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT__cJSON, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, LibraryVersion.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #LibraryVersion::Read();
	LibraryVersion.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF LibraryVersion.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
// ===================================================================
// ========================== C DEFINITIONS===========================
// ===================================================================

FUNCTION GLOBAL __cdecl cJSON_Version
  VAR_OUTPUT
    ret : ^CHAR;
  END_VAR;

FUNCTION GLOBAL __cdecl cJSON_Parse
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ParseWithOpts
	VAR_INPUT
		value 	: ^CHAR;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: DINT;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ParseWithLength
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ParseWithLengthOpts
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: DINT;
	END_VAR
	VAR_OUTPUT
		json 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_Print
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_PrintUnformatted
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_PrintBuffered
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		prebuffer 	: DINT;
		fmt 	: DINT;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_PrintPreallocated
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		buffer 	: ^CHAR;
		length 	: DINT;
		format 	: DINT;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_Delete
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetArraySize
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		size 	: INT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetArrayItem
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetObjectItem
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetObjectItemCaseSensitive
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_HasObjectItem
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		hasItem 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetErrorPtr
	VAR_OUTPUT
		errPtr 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetStringValue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_GetNumberValue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: LREAL;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsInvalid
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isInvalid 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsFalse
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isFalse 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsTrue
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isTrue 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsBool
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isBool 	: DINT;
	END_VAR;


FUNCTION GLOBAL __cdecl cJSON_IsNull
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNull 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsNumber
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNumber 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsString
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isString 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsArray
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isArray 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsObject
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isObject 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_IsRaw
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isRaw 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateNull
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateTrue
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;


FUNCTION GLOBAL __cdecl cJSON_CreateFalse
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateBool
	VAR_INPUT
		value 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateNumber
	VAR_INPUT
		value 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateString
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateRaw
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;


FUNCTION GLOBAL __cdecl cJSON_CreateArray
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateObject
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateStringReference
	VAR_INPUT
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateObjectReference
	VAR_INPUT
		child 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateArrayReference
	VAR_INPUT
		child 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;


FUNCTION GLOBAL __cdecl cJSON_CreateIntArray
	VAR_INPUT
		numbers 	: ^INT;
		count 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateFloatArray
	VAR_INPUT
		numbers 	: ^REAL;
		count 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateDoubleArray
	VAR_INPUT
		numbers 	: ^LREAL;
		count 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_CreateStringArray
	VAR_INPUT
		strings 	: ^CHAR;
		count 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddItemToArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddItemToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
    string : ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddItemToObjectCS
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddItemReferenceToArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddItemReferenceToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DetachItemViaPointer
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DetachItemFromArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DeleteItemFromArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DetachItemFromObject
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DetachItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DeleteItemFromObject
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_DeleteItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_InsertItemInArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: DINT;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ReplaceItemViaPointer
	VAR_INPUT
		parent 	: ^_cJSON::t_s_cJSON;
		item 	: ^_cJSON::t_s_cJSON;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ReplaceItemInArray
	VAR_INPUT
		arr 	: ^_cJSON::t_s_cJSON;
		index 	: DINT;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ReplaceItemInObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_ReplaceItemInObjectCaseSensitive
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^_cJSON::t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_Duplicate
	VAR_INPUT
		item 	: ^_cJSON::t_s_cJSON;
		recurse 	: DINT;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_Compare
	VAR_INPUT
		compareA 	: ^_cJSON::t_s_cJSON;
		compareB 	: ^_cJSON::t_s_cJSON;
		case_sensitive 	: DINT;
	END_VAR
	VAR_OUTPUT
		result 	: DINT;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_Minify
	VAR_INPUT
		json 	: ^CHAR;
	END_VAR;


FUNCTION GLOBAL __cdecl cJSON_AddNullToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddTrueToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddFalseToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddBoolToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		boolean 	: DINT;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddNumberToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddStringToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddRawToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
		raw 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddObjectToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_AddArrayToObject
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^_cJSON::t_s_cJSON;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_SetNumberHelper
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		retVal 	: LREAL;
	END_VAR;

FUNCTION GLOBAL __cdecl cJSON_SetValuestring
	VAR_INPUT
		object 	: ^_cJSON::t_s_cJSON;
		valueString 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retVal 	: ^CHAR;
	END_VAR;

// ===================================================================
// ======================= END OF C DEFINITIONS=======================
// ===================================================================

FUNCTION GLOBAL _cJSON::Version
	VAR_OUTPUT
		retString 	: ^CHAR;
	END_VAR
  
  retString := cJSON_Version();
  
END_FUNCTION

FUNCTION GLOBAL _cJSON::Parse
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		json 	: ^t_s_cJSON;
	END_VAR
  
  json := cJSON_Parse(value := value);

END_FUNCTION

FUNCTION GLOBAL _cJSON::ParseWithOpts
	VAR_INPUT
		value 	: ^CHAR;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: BOOL;
	END_VAR
	VAR_OUTPUT
		json 	: ^t_s_cJSON;
	END_VAR

  json := cJSON_ParseWithOpts(value                   :=  value, 
                              return_parse_end        :=  return_parse_end, 
                              require_null_terminated :=  GetCJSONBool(require_null_terminated));

END_FUNCTION

FUNCTION GLOBAL _cJSON::ParseWithLength
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
	END_VAR
	VAR_OUTPUT
		json 	: ^t_s_cJSON;
	END_VAR

  json := cJSON_ParseWithLength(value         :=  value, 
                                buffer_length :=  buffer_length);

END_FUNCTION


FUNCTION GLOBAL _cJSON::ParseWithLengthOpts
	VAR_INPUT
		value 	: ^CHAR;
		buffer_length 	: UDINT;
		return_parse_end 	: ^pChar;
		require_null_terminated 	: BOOL;
	END_VAR
	VAR_OUTPUT
		json 	: ^t_s_cJSON;
	END_VAR
  
  json := cJSON_ParseWithLengthOpts(value                   :=  value, 
                                    buffer_length           :=  buffer_length, 
                                    return_parse_end        :=  return_parse_end, 
                                    require_null_terminated :=  GetCJSONBool(require_null_terminated));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::Print
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := cJSON_Print(item := item);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::PrintUnformatted
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := cJSON_PrintUnformatted(item := item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::PrintBuffered
	VAR_INPUT
		item 	: ^t_s_cJSON;
		prebuffer 	: INT;
		fmt 	: BOOL;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := cJSON_PrintBuffered(item      :=  item, 
                                prebuffer :=  to_dint(prebuffer), 
                                fmt       :=  GetCJSONBool(fmt));

END_FUNCTION


FUNCTION GLOBAL _cJSON::PrintPreallocated
	VAR_INPUT
		item 	: ^t_s_cJSON;
		buffer 	: ^CHAR;
		length 	: INT;
		format 	: BOOL;
	END_VAR
	VAR_OUTPUT
		string 	: ^CHAR;
	END_VAR
  
  string := cJSON_PrintPreallocated(item    :=  item, 
                                    buffer  :=  buffer, 
                                    length  :=  to_dint(length), 
                                    format  :=  GetCJSONBool(format));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::Delete
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR

  cJSON_Delete(item := item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::GetArraySize
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		size 	: INT;
	END_VAR

  size := cJSON_GetArraySize(item := item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::GetArrayItem
	VAR_INPUT
		item 	: ^t_s_cJSON;
		index 	: UDINT;
	END_VAR
	VAR_OUTPUT
		entry 	: ^t_s_cJSON;
	END_VAR
  
  entry := cJSON_GetArrayItem(item  :=  item, 
                              index :=  index);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::GetObjectItem
	VAR_INPUT
		object 	: ^t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^t_s_cJSON;
	END_VAR
  
  entry := cJSON_GetObjectItem( object  :=  object, 
                                string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::GetObjectItemCaseSensitive
	VAR_INPUT
		object 	: ^t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		entry 	: ^t_s_cJSON;
	END_VAR
  
  entry := cJSON_GetObjectItemCaseSensitive(object  :=  object, 
                                            string  :=  string);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::HasObjectItem
	VAR_INPUT
		object 	: ^t_s_cJSON;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		hasItem 	: BOOL;
	END_VAR
  
  hasItem := GetBool(cJSON_HasObjectItem( object  :=  object, 
                                          string  :=  string));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::GetErrorPtr
	VAR_OUTPUT
		errPtr 	: ^CHAR;
	END_VAR
  
  errPtr := cJSON_GetErrorPtr();
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::GetStringValue
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: ^CHAR;
	END_VAR
  
  value := cJSON_GetStringValue(item := item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::GetNumberValue
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		value 	: LREAL;
	END_VAR
  
  value := cJSON_GetNumberValue(item := item);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::IsInvalid
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isInvalid 	: BOOL;
	END_VAR
  
  isInvalid := GetBool(cJSON_IsInvalid(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsFalse
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isFalse 	: BOOL;
	END_VAR
  
  isFalse := GetBool(cJSON_IsFalse(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsTrue
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isTrue 	: BOOL;
	END_VAR
  
  isTrue := GetBool(cJSON_IsTrue(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsBool
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isBool 	: BOOL;
	END_VAR
  
  isBool := GetBool(cJSON_IsBool(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsNull
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNull 	: BOOL;
	END_VAR
  
  isNull := GetBool(cJSON_IsNull(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsNumber
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isNumber 	: BOOL;
	END_VAR
 
  isNumber := GetBool(cJSON_IsNumber(item := item));  
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::IsString
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isString 	: BOOL;
	END_VAR
  
  isString := GetBool(cJSON_IsString(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsArray
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isArray 	: BOOL;
	END_VAR
  
  isArray := GetBool(cJSON_IsArray(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsObject
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isObject 	: BOOL;
	END_VAR
  
  isObject := GetBool(cJSON_IsObject(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::IsRaw
	VAR_INPUT
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		isRaw 	: BOOL;
	END_VAR
  
  isRaw := GetBool(cJSON_IsRaw(item := item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateNull
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateNull();
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateTrue
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateTrue();

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateFalse
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateFalse();

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateBool
	VAR_INPUT
		value 	: BOOL;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateBool(value := GetCJSONBool(value));

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateNumber
	VAR_INPUT
		value 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_CreateNumber(value := value);

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateString
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_CreateString(value := value);

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateRaw
	VAR_INPUT
		value 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_CreateRaw(value := value);

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateArray
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_CreateArray();

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateObject
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_CreateObject();

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateStringReference
	VAR_INPUT
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateStringReference(string := string);

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateObjectReference
	VAR_INPUT
		child 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateObjectReference(child := child);

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateArrayReference
	VAR_INPUT
		child 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_CreateArrayReference(child := child);

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateIntArray
	VAR_INPUT
		numbers 	: ^INT;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateIntArray( numbers := numbers, 
                                count   := to_dint(count));

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateFloatArray
	VAR_INPUT
		numbers 	: ^REAL;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateFloatArray( numbers :=  numbers, 
                                  count   :=  to_dint(count));

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateDoubleArray
	VAR_INPUT
		numbers 	: ^LREAL;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateDoubleArray(numbers :=  numbers, 
                                  count   :=  to_dint(count));

END_FUNCTION


FUNCTION GLOBAL _cJSON::CreateStringArray
	VAR_INPUT
		strings 	: ^CHAR;
		count 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_CreateStringArray(strings :=  strings, 
                                  count   :=  to_dint(count));

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddItemToArray
	VAR_INPUT
		arr 	: ^t_s_cJSON;
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_AddItemToArray( arr   :=  arr, 
                                          item  :=  item));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::AddItemToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
    string : ^CHAR;
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_AddItemToObject(object  :=  object,   
                                          string  :=  string, 
                                          item    :=  item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddItemToObjectCS
	VAR_INPUT
		object 	: ^t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_AddItemToObjectCS(object  :=  object, 
                                            string  :=  string, 
                                            item    :=  item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddItemReferenceToArray
	VAR_INPUT
		arr 	: ^t_s_cJSON;
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_AddItemReferenceToArray(arr   :=  arr, 
                                                  item  :=  item));

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddItemReferenceToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		string 	: ^CHAR;
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_AddItemReferenceToObject( object  :=  object, 
                                                    string  :=  string, 
                                                    item    :=  item));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::DetachItemViaPointer
	VAR_INPUT
		parent 	: ^t_s_cJSON;
		item 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^t_s_cJSON;
	END_VAR
  
  retItem := cJSON_DetachItemViaPointer(parent  :=  parent, 
                                        item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::DetachItemFromArray
	VAR_INPUT
		arr 	: ^t_s_cJSON;
		index 	: INT;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_DetachItemFromArray(arr   :=  arr, 
                                    index :=  to_dint(index));

END_FUNCTION


FUNCTION GLOBAL _cJSON::DeleteItemFromArray
	VAR_INPUT
		arr 	: ^t_s_cJSON;
		index 	: INT;
	END_VAR
  
  cJSON_DeleteItemFromArray(arr   :=  arr, 
                            index :=  to_dint(index));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::DetachItemFromObject
	VAR_INPUT
		parent 	: ^t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^t_s_cJSON;
	END_VAR
  
  retItem := cJSON_DetachItemFromObject(parent  :=  parent, 
                                        item    :=  item);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::DetachItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^t_s_cJSON;
	END_VAR
  
  retItem := cJSON_DetachItemFromObjectCaseSensitive(parent  :=  parent, 
                                                     item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::DeleteItemFromObject
	VAR_INPUT
		parent 	: ^t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
  
  cJSON_DeleteItemFromObject(parent  :=  parent, 
                             item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::DeleteItemFromObjectCaseSensitive
	VAR_INPUT
		parent 	: ^t_s_cJSON;
		item 	: ^CHAR;
	END_VAR
  
  cJSON_DeleteItemFromObjectCaseSensitive(parent  :=  parent, 
                                          item    :=  item);

END_FUNCTION


FUNCTION GLOBAL _cJSON::InsertItemInArray
	VAR_INPUT
		arr 	: ^t_s_cJSON;
		index 	: INT;
		newItem 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_InsertItemInArray(arr     :=  arr, 
                                            index   :=  to_dint(index), 
                                            newItem :=  newItem));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::ReplaceItemViaPointer
	VAR_INPUT
		parent 	: ^t_s_cJSON;
		item 	: ^t_s_cJSON;
		newItem 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_ReplaceItemViaPointer(parent  :=  parent, 
                                                item    :=  item, 
                                                newItem :=  newItem));

END_FUNCTION


FUNCTION GLOBAL _cJSON::ReplaceItemInArray
	VAR_INPUT
		arr 	: ^t_s_cJSON;
		index 	: INT;
		newItem 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_ReplaceItemInArray( arr     :=  arr, 
                                              index   :=  to_dint(index), 
                                              newItem :=  newItem));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::ReplaceItemInObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_ReplaceItemInObject(object  :=  object, 
                                              item    :=  item, 
                                              newItem :=  newItem));

END_FUNCTION


FUNCTION GLOBAL _cJSON::ReplaceItemInObjectCaseSensitive
	VAR_INPUT
		object 	: ^t_s_cJSON;
		item 	: ^CHAR;
		newItem 	: ^t_s_cJSON;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_ReplaceItemInObjectCaseSensitive( object  :=  object, 
                                                            item    :=  item, 
                                                            newItem :=  newItem));

END_FUNCTION


FUNCTION GLOBAL _cJSON::Duplicate
	VAR_INPUT
		item 	: ^t_s_cJSON;
		recurse 	: BOOL;
	END_VAR
	VAR_OUTPUT
		retItem 	: ^t_s_cJSON;
	END_VAR
    
  retItem := cJSON_Duplicate( item    :=  item, 
                              recurse :=  GetCJSONBool(recurse));

END_FUNCTION


FUNCTION GLOBAL _cJSON::Compare
	VAR_INPUT
		compareA 	: ^t_s_cJSON;
		compareB 	: ^t_s_cJSON;
		case_sensitive 	: BOOL;
	END_VAR
	VAR_OUTPUT
		result 	: BOOL;
	END_VAR
  
  result := GetBool(cJSON_Compare(compareA        :=  compareA, 
                                  compareB        :=  compareB, 
                                  case_sensitive  :=  GetCJSONBool(case_sensitive)));

END_FUNCTION


FUNCTION GLOBAL _cJSON::Minify
	VAR_INPUT
		json 	: ^CHAR;
	END_VAR
  
  cJSON_Minify(json := json);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::AddNullToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddNullToObject(object  :=  object, 
                                name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddTrueToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddTrueToObject(object  :=  object, 
                                name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddFalseToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddFalseToObject( object  :=  object, 
                                  name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddBoolToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
		boolean 	: BOOL;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddBoolToObject(object  :=  object, 
                                name    :=  name, 
                                boolean :=  GetCJSONBool(boolean));
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::AddNumberToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR

  item := cJSON_AddNumberToObject(object  :=  object, 
                                  name    :=  name, 
                                  number  :=  number);

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddStringToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
		string 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddStringToObject(object  :=  object, 
                                  name    :=  name, 
                                  string  :=  string);

END_FUNCTION


FUNCTION GLOBAL _cJSON::AddRawToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
		raw 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddRawToObject( object  :=  object, 
                                name    :=  name, 
                                raw     :=  raw);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::AddObjectToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddObjectToObject(object  :=  object, 
                                  name    :=  name);
  
END_FUNCTION


FUNCTION GLOBAL _cJSON::AddArrayToObject
	VAR_INPUT
		object 	: ^t_s_cJSON;
		name 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		item 	: ^t_s_cJSON;
	END_VAR
  
  item := cJSON_AddArrayToObject( object  :=  object, 
                                  name    :=  name);

END_FUNCTION


FUNCTION GLOBAL _cJSON::SetNumber
	VAR_INPUT
		object 	: ^t_s_cJSON;
		number 	: LREAL;
	END_VAR
	VAR_OUTPUT
		retVal 	: LREAL;
	END_VAR
  
  retVal := cJSON_SetNumberHelper(object  :=  object, 
                                  number  :=  number);

END_FUNCTION


FUNCTION GLOBAL _cJSON::SetValuestring
	VAR_INPUT
		object 	: ^t_s_cJSON;
		valueString 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		retVal 	: ^CHAR;
	END_VAR
  
  retVal := cJSON_SetValuestring( object      :=  object, 
                                  valueString :=  valueString);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _cJSON::LibraryVersion::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	LibraryVersion := cJSONVersion.Data.Read();
	output := LibraryVersion;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL _cJSON::Init
  VAR
  	tmpStr : ARRAY[0..10] of CHAR;
  END_VAR

  // Read and set the Version of the cJSON Library to the Internal String Object:
  if _FirstScan then
    
    sigclib_strcpy( dst0  :=  #tmpStr[0], 
                    src0  :=  Version());
    
    cJSONVersion.WriteDataOff(udLen :=  sigclib_strlen(str := #tmpStr[0]), 
                              udOff :=  0, 
                              pData :=  #tmpStr[0]);
    
  end_if;
  
END_FUNCTION


FUNCTION _cJSON::GetCJSONBool
	VAR_INPUT
		boolIn 	: BOOL;
	END_VAR
	VAR_OUTPUT
		boolOut 	: DINT;
	END_VAR
  
  if boolIn then
    boolOut := 1;
  else
    boolOut := 0; 
  end_if;
  
END_FUNCTION


FUNCTION _cJSON::GetBool
	VAR_INPUT
		boolIn 	: DINT;
	END_VAR
	VAR_OUTPUT
		boolOut 	: BOOL;
	END_VAR
  
  boolOut := (boolIn <> 0);
  
END_FUNCTION
