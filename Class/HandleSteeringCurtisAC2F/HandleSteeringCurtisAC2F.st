//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define AUTOTIMERLIMIT 3 SEC
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "HandleSteeringCurtisAC2F"
	Revision           = "0.0"
	GUID               = "{1FEBECD7-410F-4135-A6AE-9CFE264EC7F4}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(630,120)">
	<Channels>
		<Server Name="CorrectedActual" GUID="{FF545DC4-E256-40F3-8BD5-DAA348EBAD01}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="ReferenceOffset" GUID="{9FCE1047-BB28-497E-A7C8-8AE480858E19}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="SRam"/>
		<Server Name="ScalingFactor" GUID="{36B1E271-657B-465F-ADF2-EA0C5FD1124D}" Visualized="false" Initialize="true" WriteProtected="false" Retentive="File" Comment="Scaling factor between local setpoint/actual and drive setpoint/actual.&#13;&#10;&#13;&#10;PLC Setpoint * ScalingFactor = Drive Setpoint&#13;&#10;Drive Actual / ScalingFactor = PLC Actual"/>
		<Server Name="STARTREF" GUID="{5143B266-504E-4B47-9968-44A5FE94CB43}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="ActualRaw" Required="true" Internal="false"/>
		<Client Name="objCurtisAC2F" Required="true" Internal="false"/>
		<Client Name="SafetyEncoderValue" Required="true" Internal="false"/>
		<Client Name="SetpointRaw" Required="true" Internal="false"/>
	</Channels>
	<Network Name="HandleSteeringCurtisAC2F">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{D4863811-530D-410D-80D3-9690385F6755}"
				Class      = "HandleSteering"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="Actual"/>
					<Server Name="BusyReferencing"/>
					<Server Name="ClassSvr"/>
					<Server Name="IsReferenced"/>
					<Server Name="Setpoint"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ClassSvr" Destination="_base.ClassSvr" Vertices="(968,210),(796,210),"/>
			<Connection Source="this.Actual" Destination="_base.Actual" Vertices="(968,330),(796,330),"/>
			<Connection Source="this.Setpoint" Destination="_base.Setpoint" Vertices="(968,270),(796,270),"/>
			<Connection Source="this.IsReferenced" Destination="_base.IsReferenced" Vertices="(968,390),(796,390),"/>
			<Connection Source="this.BusyReferencing" Destination="_base.BusyReferencing" Vertices="(968,450),(796,450),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using HandleSteering

HandleSteeringCurtisAC2F : CLASS
: HandleSteering
  //Servers:
	ReferenceOffset 	: SvrCh_REAL;
	CorrectedActual 	: SvrCh_REAL;
	ScalingFactor 	: SvrCh_REAL;
	STARTREF 	: SvrCh_DINT;
  //Clients:
	objCurtisAC2F 	: CltChCmd_Curtis_AC2F;
	SafetyEncoderValue 	: CltCh_REAL;
	ActualRaw 	: CltCh_DINT;
	SetpointRaw 	: CltCh_DINT;
  //Variables:
		_initCounter 	: DINT;
		_init 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetReferenced
		VAR_OUTPUT
			returnValue 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL GetDriveStatus
		VAR_OUTPUT
			returnValue 	: tDriveStatus;
		END_VAR;
	
	FUNCTION VIRTUAL _forwardSetpoint
		VAR_INPUT
			inputSetpoint 	: REAL;
		END_VAR;
	
	FUNCTION VIRTUAL _getActual
		VAR_OUTPUT
			returnValue 	: REAL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL StartReferencing;
	
	FUNCTION _readClients;
	
	FUNCTION VIRTUAL GLOBAL STARTREF::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd Curtis_AC2F


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB HandleSteeringCurtisAC2F::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_HANDLESTEERINGCURTISAC2F
0$UINT, 0$UINT, (SIZEOF(::HandleSteeringCurtisAC2F))$UINT, 
4$UINT, 4$UINT, 0$UINT, 
TO_UDINT(1916796469), "HandleSteeringCurtisAC2F", //Class
TO_UDINT(934856050), "HandleSteering", 0$UINT, 0$UINT, //Baseclass
//Servers:
(::HandleSteeringCurtisAC2F.ReferenceOffset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000001000$UINT, TO_UDINT(1719534335), "ReferenceOffset", 
(::HandleSteeringCurtisAC2F.CorrectedActual.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3988549595), "CorrectedActual", 
(::HandleSteeringCurtisAC2F.ScalingFactor.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000011000$UINT, TO_UDINT(201457005), "ScalingFactor", 
(::HandleSteeringCurtisAC2F.STARTREF.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(3592461892), "STARTREF", 
//Clients:
(::HandleSteeringCurtisAC2F.objCurtisAC2F.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2226698551), "objCurtisAC2F", TO_UDINT(883538238), "Curtis_AC2F", 0$UINT, 0$UINT, 
(::HandleSteeringCurtisAC2F.SafetyEncoderValue.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2038653895), "SafetyEncoderValue", 
(::HandleSteeringCurtisAC2F.ActualRaw.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3291432117), "ActualRaw", 
(::HandleSteeringCurtisAC2F.SetpointRaw.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3258795445), "SetpointRaw", 
END_FUNCTION


#define USER_CNT_HandleSteeringCurtisAC2F 5

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_HandleSteeringCurtisAC2F] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION HandleSteeringCurtisAC2F::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= HandleSteering::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= HandleSteering::ClassSvr.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, HandleSteering::ClassSvr.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_HandleSteeringCurtisAC2F;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #GetReferenced();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[1]		:= #GetDriveStatus();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[2]		:= #_forwardSetpoint();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[3]		:= #_getActual();

#pragma warning (default : 74)
#pragma warning (disable : 74)
	vmt.UserFcts[4]		:= #StartReferencing();

#pragma warning (default : 74)
	HandleSteering::ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF HandleSteering::ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ReferenceOffset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ReferenceOffset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ScalingFactor.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF ScalingFactor.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	STARTREF.pMeth			:= StoreMethod( #M_RD_DIRECT(), #STARTREF::Write() );
	IF STARTREF.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL HandleSteeringCurtisAC2F::Init
  _initCounter += 1;

  if (_initCounter = 10) then
    _init := TRUE;
  end_if;
  
END_FUNCTION




FUNCTION VIRTUAL GLOBAL HandleSteeringCurtisAC2F::GetDriveStatus
	VAR_OUTPUT
		returnValue 	: tDriveStatus;
	END_VAR
  VAR
  	tmpDriveMode  : Curtis_Base::eCurtisDriveMode;
  END_VAR

  tmpDriveMode := objCurtisAC2F.DriveMode.Read();
  
  if tmpDriveMode = Curtis_Base::cdm_Auto then
    returnValue.ds_DriveMode := HandleSteering::dm_Auto;
  elsif tmpDriveMode = Curtis_Base::cdm_Manual then
    returnValue.ds_DriveMode := HandleSteering::dm_Manual;
  elsif tmpDriveMode = Curtis_Base::cdm_Referencing then
    returnValue.ds_DriveMode := HandleSteering::dm_Referencing;
  elsif tmpDriveMode = Curtis_Base::cdm_EmergencyStop then
    returnValue.ds_DriveMode := HandleSteering::dm_EmergencyStop;
  else
    returnValue.ds_DriveMode := HandleSteering::dm_Idle;
  end_if;
 
  returnValue.ds_Referenced := objCurtisAC2F.Referenced.Read();
  returnValue.ds_Setpoint := SetpointRaw.Read();
  returnValue.ds_Actual := _getActual();
  returnValue.ds_FaultCode := objCurtisAC2F.FaultCode.Read();
  returnValue.ds_CommunicationOK := objCurtisAC2F.CommunicationOk.Read();
  returnValue.ds_EstopOK := objCurtisAC2F.EmStopOk;
  
END_FUNCTION


FUNCTION VIRTUAL HandleSteeringCurtisAC2F::_forwardSetpoint
	VAR_INPUT
		inputSetpoint 	: REAL;
	END_VAR
  VAR
  	tempSet : REAL;
  END_VAR

  tempSet := ScalingFactor * (inputSetpoint - ReferenceOffset);
  SetpointRaw.Write(to_dint(tempSet));

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HandleSteeringCurtisAC2F::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR  
  
  _readClients();
  
  if _init = TRUE & SafetyEncoderValue <> 0 then
    //StartReferencing();
     ReferenceOffset.Write(input:=SafetyEncoderValue.Read());
    _init := FALSE;
    IsReferenced := TRUE;
  end_if;
  
  
  if BusyReferencing = TRUE then
    if ActualRaw <> 0 | objCurtisAC2F.BusyReferencing = FALSE then
      objCurtisAC2F.StartReferencing();
    end_if;
    
    if objCurtisAC2F.BusyReferencing = 1 & BusyReferencing = TRUE then 
      if objCurtisAC2F.Referenced = 1 & objCurtisAc2F.EncoderValue = 0 then
        if ReferenceOffset <> SafetyEncoderValue.Read() then
          ReferenceOffset.Write(input:=SafetyEncoderValue.Read());
        end_if;  
        objCurtisAC2F.StopReferencing();
        BusyReferencing := FALSE;
        IsReferenced := TRUE;
      end_if;
    end_if;
  end_if;
  
  Actual := to_real(ActualRaw)/ScalingFactor;
  CorrectedActual := Actual + ReferenceOffset;  

END_FUNCTION


FUNCTION VIRTUAL HandleSteeringCurtisAC2F::_getActual
	VAR_OUTPUT
		returnValue 	: REAL;
	END_VAR
  
  if IsReferenced = TRUE | BusyReferencing = FALSE then
    returnValue := CorrectedActual;
  else
    returnValue := 0;
  end_if;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HandleSteeringCurtisAC2F::StartReferencing

  BusyReferencing := TRUE;
  IsReferenced := FALSE;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL HandleSteeringCurtisAC2F::STARTREF::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	STARTREF := input;
  if STARTREF = 1 then
    StartReferencing();
  end_if;
	result := STARTREF;

END_FUNCTION


FUNCTION HandleSteeringCurtisAC2F::_readClients
  
  SafetyEncoderValue := SafetyEncoderValue.Read();
  ActualRaw := ActualRaw.Read();
  SetpointRaw := SetpointRaw.Read();
  
END_FUNCTION


FUNCTION VIRTUAL GLOBAL HandleSteeringCurtisAC2F::GetReferenced
	VAR_OUTPUT
		returnValue 	: DINT;
	END_VAR
  
  returnValue := objCurtisAC2F.Referenced;

END_FUNCTION

