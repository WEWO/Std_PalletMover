//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MQTTBackgroundWorker"
	Revision           = "1.2"
	GUID               = "{4F6531F3-F761-4B51-89D9-605BAA092101}"
	RealtimeTask       = "false"
	CyclicTask         = "false"
	BackgroundTask     = "true"
	DefBackground      = "100 ms"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\MQTTClient\mqtt.ico"
	SharedCommandTable = "true"
	Objectsize         = "(570,180)"
	Comment            = "This class takes care of long lasting synchronous functions like requesting the IP from a DNS server. This is currently the only functionality of this task but it might be extended by any function which is synchronously called.">
	<Channels>
		<Server Name="CurrentState" GUID="{29C5079C-4A7E-4C07-8403-D134F5631002}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Holds the current state of the worker task. For further descriptions of the states, please see the corresponding documentation of the enum.&#13;&#10;"/>
		<Client Name="SigCLib" Required="false" Internal="false"/>
	</Channels>
	<RevDoku>
		<Owner Company="Sigmatek" Author="Mehmar"/>
		<Dokumentation Revision="1.2" Date="2021-03-16" Author="Mehmar" Company="Sigmatek" Description="- Bugfix: Fallback on RTK to synchronous call for resolving hostname. "/>
		<Dokumentation Revision="1.1" Date="2021-02-22" Author="Mehmar" Company="Sigmatek" Description="- Bugfix: Reconnect can hang if host is an IP address."/>
		<Dokumentation Revision="1.0" Date="2020-05-19" Author="Mehmar" Company="Sigmatek" Description="- Initial version"/>
	</RevDoku>
</Class>
*)
MQTTBackgroundWorker : CLASS
	TYPE
	  t_e_WorkerState :  //! <Type Public="true" Comment="The enum represents the possible state of the worker task." Name="t_e_WorkerState"/>
	  (
	    WS_Init,  //! <Type Comment="The worker thread is currently initializing and cannot be asked for any work to perform." Name="t_e_WorkerState.WS_Init"/>
	    WS_Ready,  //! <Type Comment="The worker thread is idle and waiting for work to do." Name="t_e_WorkerState.WS_Ready"/>
	    WS_ResolvingHostname,  //! <Type Comment="The worker thread is currently trying to resolve a hostname to it&apos;s IP address. The OS function cannot be canceled but it returns in any case so it is not necessary to implement a timeout functionality here." Name="t_e_WorkerState.WS_ResolvingHostname"/>
	    WS_WaitForResolving  //! <Type Comment="The worker thread is waiting for the answer from the OS to the async string to ulong call." Name="t_e_WorkerState.WS_WaitForResolving"/>
	  )$UDINT;
	  t_pMQTTClient : ^MQTTClient;  //! <Type Comment="Pointer definition to the MQTTClient to call the callback funktion from the worker task." Name="t_pMQTTClient"/>
	END_TYPE
  //Servers:
	CurrentState 	: SvrChCmd_t_e_WorkerState_PTofCls_MQTTBackgroundWorker;
  //Clients:
	SigCLib 	: CltChCmd_SigCLib;
  //Variables:
		pDNSLookupThis 	: ^void;			//! <Variable Comment="A pointer to the object which likes to be called as soon as the DNS request returns from the OS. The object as to be of type MQTTClient (which is not checked). On that object &apos;Callback_DNS_Lookup_Async&apos; is called." Name="pDNSLookupThis"/>
		hostnameToConvert : ARRAY [0..255] OF CHAR;
			//! <Variable Comment="Contains the hostname to look up on the DNS. The passed hostname is copied to this array." Name="hostnameToConvert"/>
		lsl_tcp_user 	: ^LSL_TCP_USER;			//! <Variable Comment="Pointer to the TCP User Interface, set in the Init() method." Name="lsl_tcp_user"/>
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Background function which is called periodically by the task.&#13;&#10;In this function the synchron calls (TCP) are processed to not block the cyclic task from working in case the TCP calls take more time than expected." Name="Background"/>
	FUNCTION VIRTUAL GLOBAL Background
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="Function to convert an IP address or a hostname to its UDINT representation. If a hostname is given, the DNS and gateway should be set correctly in order to allow the OS to resolve the hostname to its IP address. &#13;&#10;In case the hostname cannot be resolved, the returned address is 0xFFFFFFFF." Name="ConvertHostToIP"/>
	FUNCTION GLOBAL ConvertHostToIP
		VAR_INPUT
			hostName 	: ^CHAR;			//! <Variable Comment="The hostname which should be used to resolve the IP address. The maximum length is 255 characters. In case this parameter is invalid, an error code &lt; 0 is returned by this function. If everything was okay, the function returns 0." Name="ConvertHostToIP.hostName"/>
			pThis 	: ^void;			//! <Variable Comment="A pointer to the object which tries to resolve a hostname to an IP address." Name="ConvertHostToIP.pThis"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: DINT;			//! <Variable Comment="In case the call was successful, the function returns 0. In case of error, the following return values are defined:&#13;&#10;-1: Copying the hostname to the local member failed for any reason.&#13;&#10;-2: The state of the worker is currently not ready.&#13;&#10;-3: The given hostname was either not given or it was too long (maximum length is 255 characters).&#13;&#10;-4: The pointer to the calling object is invalid.&#13;&#10;-5: The TCP interface is not ready." Name="ConvertHostToIP.retCode"/>
		END_VAR;
				//! <Function Comment="This function is called as soon as the conversion of the IP or hostname is done." Name="StrToUlongCallback"/>
	FUNCTION __CDECL GLOBAL StrToUlongCallback
		VAR_INPUT
			pUserPara 	: pVoid;			//! <Variable Comment="The this-pointer of the object which requested the conversion." Name="StrToUlongCallback.pUserPara"/>
			IPAddress 	: UDINT;			//! <Variable Comment="The UDINT representation of the resolved and converted hostname or IP address. In case of an error this value is 0xFFFFFFFF." Name="StrToUlongCallback.IPAddress"/>
			retCode 	: DINT;			//! <Variable Comment="A status code from the OS which is not used with this function." Name="StrToUlongCallback.retCode"/>
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MQTTBackgroundWorker::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MQTTBACKGROUNDWORKER
1$UINT, 2$UINT, (SIZEOF(::MQTTBackgroundWorker))$UINT, 
1$UINT, 1$UINT, 0$UINT, 
TO_UDINT(2139750182), "MQTTBackgroundWorker", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MQTTBackgroundWorker.CurrentState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2755101334), "CurrentState", 
//Clients:
(::MQTTBackgroundWorker.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
END_FUNCTION


#define USER_CNT_MQTTBackgroundWorker 1

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MQTTBackgroundWorker] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MQTTBackgroundWorker::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_MQTTBackgroundWorker, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
#pragma warning (disable : 74)
	vmt.UserFcts[0]		:= #Background();

#pragma warning (default : 74)
	CurrentState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF CurrentState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd MQTTClient

//{{LSL_IMPLEMENTATION
// retCode is not used here. If something went wrong, the IP is 0xFFFFFFFF
#pragma warning(disable:73);
FUNCTION __CDECL GLOBAL MQTTBackgroundWorker::StrToUlongCallback
	VAR_INPUT
		pUserPara 	: pVoid;
		IPAddress 	: UDINT;
		retCode 	: DINT;
	END_VAR

  this := pUserPara$^MQTTBackgroundWorker;
  pDNSLookupThis$t_pMQTTClient^.Callback_DNS_Lookup_Async(IPAddress);
  CurrentState := WS_Ready;
  
END_FUNCTION
#pragma warning(default:73);

FUNCTION VIRTUAL GLOBAL MQTTBackgroundWorker::Init
  if _FirstScan then
    CurrentState := WS_Init;
    
    //=======================================================
    //TCP Interface - Required for STRTOULONG()
    //=======================================================
    if OS_CILGET( "TCP_USER", #lsl_tcp_user) <> SYS_ERR_NONE then
      lsl_tcp_user := NIL;
    end_if;
  
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTBackgroundWorker::Background
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR
  VAR
  	ip            : UDINT;
    retCode : DINT;
  END_VAR

	state := READY;
  
  case CurrentState of
  	WS_Init:
      // nothing to do
      CurrentState := WS_Ready;
  	WS_Ready:
      // nothing to do
  	WS_ResolvingHostname:
      // this async call is only implemented on Salamander or higher
      if (OS_TCP_USER_VERSION >= 0x0C & _rtosversion > 0x9000) then
        CurrentState := WS_WaitForResolving;
        retCode := OS_TCP_USER_STRTOULONG_ASY(#hostnameToConvert[0], #StrToUlongCallback(), this);
      else
        ip := OS_TCP_USER_STRTOULONG(#hostnameToConvert[0]);
        pDNSLookupThis$t_pMQTTClient^.Callback_DNS_Lookup_Async(ip);
        CurrentState := WS_Ready;
      end_if;
    WS_WaitForResolving:
      // nothing to do
  end_case;

END_FUNCTION


FUNCTION GLOBAL MQTTBackgroundWorker::ConvertHostToIP
	VAR_INPUT
		hostName 	: ^CHAR;
		pThis 	: ^void;
	END_VAR
	VAR_OUTPUT
		retCode 	: DINT;
	END_VAR
  
  retCode := 0;
  
  // check all parameters and set error code if necessary
  if CurrentState <> WS_Ready then
    retCode := -2;
  end_if;
  if (hostName = NIL | SigCLib.StrLen(str:=hostName) > 255) then
    retCode := -3;
  end_if;
  if pThis = NIL then
    retCode := -4;
  end_if;
  if lsl_tcp_user = NIL then
    retCode := -5;
  end_if;
    
  // copy data and set the state such that the hostname can be resolved.
  if retCode = 0 then
    pDNSLookupThis := pThis;
    if (SigCLib.StrCpy(dst0:=#hostnameToConvert[0], src0:=hostName) = NIL) then
      retCode := -1;
    else
      CurrentState := WS_ResolvingHostname;
    end_if;
  end_if;
  
END_FUNCTION
