//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "AgvMain"
	Revision           = "0.0"
	GUID               = "{D11EBDC0-DD5F-4D60-8FD3-A37CD6E25BF1}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(720,180)">
	<Channels>
		<Server Name="MainState" GUID="{3E23AB70-EC40-489C-BA0C-C116A97C38BE}" Visualized="false" Initialize="true" DefValue="Agv_idle" WriteProtected="false" Retentive="false"/>
		<Client Name="ToAutoControl" Required="true" Internal="false"/>
		<Client Name="ToConfigSettingsCmd" Required="true" Internal="false"/>
		<Client Name="ToMainAux" Required="true" Internal="false"/>
		<Client Name="ToMainPeripheral" Required="true" Internal="false"/>
		<Client Name="ToManualControl" Required="true" Internal="false"/>
	</Channels>
	<Network Name="AgvMain">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{F5B6BD90-416C-4A55-9D53-953C9FD06AE5}"
				Class      = "WewoBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="m_Id"/>
					<Server Name="m_p_Name"/>
					<Server Name="o_ErrorWarningStatus"/>
					<Server Name="ObjectStatus"/>
					<Server Name="ToObject"/>
					<Client Name="c_Group"/>
					<Client Name="op_LogData"/>
					<Client Name="toOsLibTaskObjControl"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ToObject" Destination="_base.ToObject" Vertices="(856,210),(684,210),"/>
			<Connection Source="_base.op_LogData" Destination="this.op_LogData" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using WewoBase

AgvMain : CLASS
: WewoBase
	TYPE
	  t_StateHandeling :
	  (
	    StartPreState,
	    waitPreState,
	    StartState,
	    WaitReadyState,
	    CleanUpState,
	    ErrorState,
	    ReqExitState,
	    ReadyState
	  )$UDINT;
	END_TYPE
  //Servers:
	MainState 	: SvrCh_gt_AgvMainState;
  //Clients:
	ToConfigSettingsCmd 	: CltCh_gt_AgvSettingsCmd;
	ToMainAux 	: CltCh_gt_AgvMainAux;
	ToMainPeripheral 	: CltCh_gt_agvMainPeripherals;
	ToManualControl 	: CltCh_gt_AgvManual;
	ToAutoControl 	: CltCh_gt_AgvMainAuto;
  //Variables:
		AgvMainState 	: gt_AgvMainState;
		AgvCurHandleState 	: t_StateHandeling;
		CurMainState 	: gt_AgvMainState;
		ReqMainState 	: gt_AgvMainState;
		ReadyCounter 	: DINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION MainLoop;
	
	FUNCTION AgvConfiguration;
	
	FUNCTION AgvStartup;
	
	FUNCTION Agvidle;
	
	FUNCTION AgvAuto;
	
	FUNCTION AgvManual;
	
	FUNCTION AgvInError;
	
	FUNCTION AgvRecoverError;
	
	FUNCTION VIRTUAL GLOBAL MainState::Read
		VAR_OUTPUT
			output (EAX) 	: gt_AgvMainState;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL MainState::Write
		VAR_INPUT
			input (EAX) 	: gt_AgvMainState;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: gt_AgvMainState;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB AgvMain::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_AGVMAIN
0$UINT, 0$UINT, (SIZEOF(::AgvMain))$UINT, 
1$UINT, 5$UINT, 0$UINT, 
TO_UDINT(1927765696), "AgvMain", //Class
TO_UDINT(817841270), "WewoBase", 0$UINT, 29$UINT, //Baseclass
//Servers:
(::AgvMain.MainState.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1523027565), "MainState", 
//Clients:
(::AgvMain.ToConfigSettingsCmd.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2576158744), "ToConfigSettingsCmd", 
(::AgvMain.ToMainAux.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(635345907), "ToMainAux", 
(::AgvMain.ToMainPeripheral.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(192559386), "ToMainPeripheral", 
(::AgvMain.ToManualControl.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3059120599), "ToManualControl", 
(::AgvMain.ToAutoControl.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1555723731), "ToAutoControl", 
END_FUNCTION


#define USER_CNT_AgvMain 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_AgvMain] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION AgvMain::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= WewoBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= WewoBase::ToObject.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, WewoBase::ToObject.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_AgvMain;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	WewoBase::ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF WewoBase::ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	MainState.pMeth			:= StoreMethod( #MainState::Read(), #MainState::Write() );
	IF MainState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL AgvMain::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := ReadyState *)
	END_VAR

        MainState := MainState.Read();

        MainLoop();

END_FUNCTION


FUNCTION AgvMain::MainLoop
    // Check if step change is posible.
   
  
   if (ReqMainState <> CurMainState) &  (AgvCurHandleState = ReadyState  ) then
         CurMainState := ReqMainState;
         AgvCurHandleState := StartPreState;
         elsif   (ReqMainState <> CurMainState) &  (AgvCurHandleState <>  ReqExitState) then
        // Request Switch
        AgvCurHandleState :=ReqExitState;
    end_if;
    
    if ReqMainState = CurMainState  then
        case  ReqMainState of
            Agv_Recover_Error:
                CurMainState := ReqMainState;
                AgvCurHandleState := StartPreState;

            else  // default
                
             if AgvCurHandleState = ReadyState then
                // Reset and switch state
                CurMainState := Agv_idle ;
                AgvCurHandleState := StartPreState;
             end_if;

        end_case;
        
    end_if;

    case CurMainState of
    
        Agv_Configuration:
            AgvConfiguration();
             
        Agv_StartUp:
            AgvStartup();

        Agv_idle:
            Agvidle();
            
        Agv_Auto:
            AgvAuto();
            
        Agv_Manual:
             AgvManual();
             
        Agv_InError:
             AgvInError();
             
        Agv_Recover_Error:
            AgvRecoverError();
        
    end_case;



END_FUNCTION


FUNCTION AgvMain::AgvConfiguration
  

    
    case AgvCurHandleState of
    
        StartPreState:                                    
            ToConfigSettingsCmd.Write(input:=LoadSettings);
            AgvCurHandleState := t_StateHandeling::waitPreState;
          
            
        waitPreState:
            if ToConfigSettingsCmd.Read() = LoadReadyOk then
                AgvCurHandleState :=StartState;
                elsif  ToConfigSettingsCmd.Read() = LoadReadError then
                  AgvCurHandleState := ErrorState;
             end_if;
            
            
        StartState  :                          // 2.  set All parts to config mode
         
            ToMainAux.Write(input:=AuxMainConfig);
            ToMainPeripheral.Write(input:=PerConfig);
            ToManualControl.Write(input:=ManualConfig);
            ToAutoControl.Write(input:=AutoConfig);
            
            AgvCurHandleState :=  WaitReadyState;
                            
        WaitReadyState:                      // 3. Wait Until all ready.
            ToMainAux := ToMainAux.Read();
            ToMainPeripheral:=ToMainPeripheral.Read();
            ToManualControl:=ToManualControl.Read();
            ToAutoControl:= ToAutoControl.Read();
            
            if (ToMainAux = AuxMainIdle) & (ToMainPeripheral = PerIdle) & (ToManualControl = ManualIdle) & (ToAutoControl = AutoIdle) then
                AgvCurHandleState := CleanUpState;
            elsif  (ToMainAux = AuxMainError) | (ToMainPeripheral = PerError) | (ToManualControl = ManualError) | (ToAutoControl = AutoError) then   
                AgvCurHandleState := ErrorState;
            end_if;
            
        CleanUpState:                                // CleanUpState Local and Start next step.
           AgvCurHandleState := ReadyState;
    
        ErrorState:                            // Start State Error Sequence.
            //AgvCurHandleState := ReadyState;
        
        ReqExitState:                          // Run config exit.
            AgvCurHandleState := ReadyState;
        
       
        
      end_case;
        

END_FUNCTION


FUNCTION AgvMain::AgvStartup
    case AgvCurHandleState of
    
        StartPreState:                  // first step  Start pre step in state                         
            AgvCurHandleState :=   waitPreState;
         
        waitPreState:                  // Wait pre step ReadyState
            AgvCurHandleState :=StartState;
            
        StartState:                     // Start Current Step
         
            AgvCurHandleState :=  WaitReadyState;
                            
        WaitReadyState:                // Wait Current step ReadyState   
            AgvCurHandleState := CleanUpState;
        
                // AgvCurHandleState := ErrorState;
            
        CleanUpState:                                // CleanUpState Local and Start next step.
           AgvCurHandleState := ReadyState;
    
        ErrorState:                            // Start State Error Sequence.
            AgvCurHandleState := ReadyState;
        
        ReqExitState:                          // Run config exit.
            AgvCurHandleState := ReadyState;
        
      end_case;
END_FUNCTION


FUNCTION AgvMain::Agvidle
       Case AgvCurHandleState of
       
        StartPreState, waitPreState,               
        StartState,WaitReadyState, CleanUpState,
        ErrorState:
            AgvCurHandleState := ReadyState;
            ToMainAux := ToMainAux.Read();
            ToMainPeripheral:= ToMainPeripheral.Read();
            ToManualControl:= ToManualControl.Read();
            ToAutoControl:=ToAutoControl.Read();
        
        ReqExitState: 
            AgvCurHandleState := ReadyState;
       
        END_CASE;
        
END_FUNCTION


FUNCTION AgvMain::AgvAuto
     case AgvCurHandleState of
    
        StartPreState:                  // first step  Start pre step in state                         
            AgvCurHandleState :=   waitPreState;
         
        waitPreState:                  // Wait pre step ReadyState
            AgvCurHandleState :=StartState;
            
        StartState:                     // Start Current Step
         
            AgvCurHandleState :=  WaitReadyState;
                            
        WaitReadyState:                // Wait Current step ReadyState   
            AgvCurHandleState := CleanUpState;
        
                // AgvCurHandleState := ErrorState;
            
        CleanUpState:                                // CleanUpState Local and Start next step.
           AgvCurHandleState := ReadyState;
    
        ErrorState:                            // Start State Error Sequence.
            AgvCurHandleState := ReadyState;
        
        ReqExitState:                          // Run config exit.
            AgvCurHandleState := ReadyState;
           
        
      end_case;


END_FUNCTION


FUNCTION AgvMain::AgvManual
    case AgvCurHandleState of
    
        StartPreState:                  // first step  Start pre step in state                         
            AgvCurHandleState :=   waitPreState;
         
        waitPreState:                  // Wait pre step ReadyState
            AgvCurHandleState :=StartState;
            
        StartState:                     // Start Current Step
         
            AgvCurHandleState :=  WaitReadyState;
                            
        WaitReadyState:                // Wait Current step ReadyState   
            AgvCurHandleState := CleanUpState;
        
                // AgvCurHandleState := ErrorState;  
        CleanUpState:                                // CleanUpState Normal end of state
           AgvCurHandleState := ReadyState;
    
        ErrorState:                            // Start State Error Sequence.
            AgvCurHandleState := ReadyState;
        
        ReqExitState:                          // Run  break currend action
            AgvCurHandleState := ReadyState;
        
      end_case;
END_FUNCTION


FUNCTION AgvMain::AgvInError

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AgvMain::Init
  
AgvMainState:=CurMainState:=ReqMainState:=::gt_AgvMainState::Agv_idle;
    
END_FUNCTION


FUNCTION AgvMain::AgvRecoverError

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AgvMain::MainState::Write
	VAR_INPUT
		input (EAX) 	: gt_AgvMainState;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: gt_AgvMainState;
	END_VAR

	MainState := input;
    ReqMainState := MainState;
	result := MainState;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL AgvMain::MainState::Read
	VAR_OUTPUT
		output (EAX) 	: gt_AgvMainState;
	END_VAR

	output := CurMainState;

END_FUNCTION
