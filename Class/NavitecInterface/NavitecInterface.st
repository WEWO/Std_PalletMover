//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define NAVITEC_COM_TIMEOUTTIME 2000
#define RESEND_TIME 2
#define NAVITEC_CONNECTIONRETRIES 5
#define ID1119 1119
#define ID3102 3102
#define ID3123 3123
#define ID3129 3129
#define WAITFORCONNECTEDTIME 100
#define MAXWRONGDATASIZECOUNT 30
#define ENABLEDNOTCONNECTEDTIME 1000
#define INITALARMDELAY 20 SEC
//}}LSL_DEFINES

//{{LSL_DECLARATION

(*!
<Class
	Name               = "NavitecInterface"
	Revision           = "0.0"
	GUID               = "{72497B63-C176-44FF-BCE6-1C83B66098F4}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(574,120)">
	<Channels>
		<Server Name="ClassSvr" GUID="{1F6CFAC4-B671-4CD1-B5EB-3C6F8DCEC70F}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false"/>
		<Server Name="Connected" GUID="{8A6FD849-519D-48B3-B670-1F1525BDC1BA}" Visualized="true" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Server Name="Data" GUID="{2B0D03BA-D073-4843-A732-3A34D42DB3FF}" Class="StringRAM" Visualized="true" Remotely="true" Initialize="true" WriteProtected="false" Retentive="false"/>
		<Server Name="Enabled" GUID="{323ED886-1EBC-47A6-9A41-28E2D9E64D34}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
		<Client Name="_Alarm_Error_NavitrolError" Required="true" Internal="true"/>
		<Client Name="_Alarm_Error_NoCommunication" Required="true" Internal="true"/>
		<Client Name="_Alarm_Error_WrongDataReceive" Required="true" Internal="true"/>
		<Client Name="_Alarm_Error_WrongMessageNumber" Required="true" Internal="true"/>
		<Client Name="_TCPIP_CLIENT" Required="true" Internal="true"/>
		<Client Name="_TCPIP_PORT" Required="true" Internal="true"/>
		<Client Name="AlarmStartID" Required="false" Internal="false"/>
		<Client Name="IPString" Required="true" Internal="true"/>
		<Client Name="objAutomaticControl" Required="true" Internal="false"/>
		<Client Name="objBMS" Required="false" Internal="false"/>
		<Client Name="objKinematicNpivot" Required="true" Internal="false"/>
		<Client Name="objStateControl" Required="true" Internal="false"/>
		<Client Name="RiwoAlarmCollect1" Required="true" Internal="true"/>
	</Channels>
	<Network Name="NavitecInterface">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_Alarm_Error_NavitrolError"
				GUID       = "{AFDC2160-8A1D-454E-86B6-F06DC3781867}"
				Class      = "RiwoParamAlarm"
				Position   = "(900,1260)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="GroupId"/>
					<Server Name="Id"/>
					<Server Name="Level"/>
					<Server Name="Parameter1"/>
					<Server Name="Parameter2"/>
					<Server Name="Parameter3"/>
					<Server Name="Parameter4"/>
					<Server Name="Report"/>
					<Server Name="ResetReq"/>
					<Client Name="objNextRiwoParamAlarm"/>
					<Client Name="objRiwoEventLogger"/>
				</Channels>
			</Object>
			<Object
				Name       = "_Alarm_Error_NoCommunication"
				GUID       = "{63836C6F-85E3-46B7-BB18-B60C6BC9F856}"
				Class      = "RiwoParamAlarm"
				Position   = "(210,1260)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="GroupId"/>
					<Server Name="Id"/>
					<Server Name="Level"/>
					<Server Name="Parameter1"/>
					<Server Name="Parameter2"/>
					<Server Name="Parameter3"/>
					<Server Name="Parameter4"/>
					<Server Name="Report"/>
					<Server Name="ResetReq"/>
					<Client Name="objNextRiwoParamAlarm"/>
					<Client Name="objRiwoEventLogger"/>
				</Channels>
			</Object>
			<Object
				Name       = "_Alarm_Error_WrongDataReceive"
				GUID       = "{4446DE72-EBCF-4837-B434-E9FF5A6BC9EB}"
				Class      = "RiwoParamAlarm"
				Position   = "(2280,1260)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="GroupId"/>
					<Server Name="Id"/>
					<Server Name="Level"/>
					<Server Name="Parameter1"/>
					<Server Name="Parameter2"/>
					<Server Name="Parameter3"/>
					<Server Name="Parameter4"/>
					<Server Name="Report"/>
					<Server Name="ResetReq"/>
					<Client Name="objNextRiwoParamAlarm"/>
					<Client Name="objRiwoEventLogger"/>
				</Channels>
			</Object>
			<Object
				Name       = "_Alarm_Error_WrongMessageNumber"
				GUID       = "{A37A48C1-6C47-41B3-AED6-F841F5900736}"
				Class      = "RiwoParamAlarm"
				Position   = "(1590,1260)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="GroupId"/>
					<Server Name="Id"/>
					<Server Name="Level"/>
					<Server Name="Parameter1"/>
					<Server Name="Parameter2"/>
					<Server Name="Parameter3"/>
					<Server Name="Parameter4"/>
					<Server Name="Report"/>
					<Server Name="ResetReq"/>
					<Client Name="objNextRiwoParamAlarm"/>
					<Client Name="objRiwoEventLogger"/>
				</Channels>
			</Object>
			<Object
				Name           = "_TCPIP_CLIENT"
				GUID           = "{F011F418-F41F-48E5-8CA7-E913A4CB333F}"
				Class          = "_TCPIP_CLIENT"
				Position       = "(870,390)"
				Visualized     = "true"
				Remotely       = "true"
				CyclicTime     = "10 ms"
				BackgroundTime = "always">
				<Channels>
					<Server Name="Control"/>
					<Server Name="SemaName01"/>
					<Server Name="SemaName02"/>
					<Server Name="TaskName"/>
					<Client Name="cConfig"/>
					<Client Name="cMaxConnections" Value="0"/>
					<Client Name="co_MultiTask"/>
					<Client Name="co_SigCLib"/>
					<Client Name="co_StdLib"/>
					<Client Name="co_Task"/>
					<Client Name="cPort" Value="502"/>
					<Client Name="cSizeOfTXBuffer"/>
				</Channels>
			</Object>
			<Object
				Name       = "_TCPIP_PORT"
				GUID       = "{AA184314-1891-4023-A5E8-5DD9B7B15595}"
				Class      = "Merker"
				Position   = "(240,390)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data" Value="1000"/>
				</Channels>
			</Object>
			<Object
				Name       = "IPString"
				GUID       = "{6BCAF9F8-6377-41E3-9241-6A0A11A6B970}"
				Class      = "StringRAM"
				Position   = "(2040,720)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data" Value="&quot;192.168.127.1&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
					<Client Name="UseFile"/>
				</Channels>
			</Object>
			<Object
				Name           = "RiwoAlarmCollect1"
				GUID           = "{6F22CB17-4BAF-4103-9DC2-244B09A80CD1}"
				Class          = "RiwoAlarmCollect"
				Position       = "(2970,1260)"
				Visualized     = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="ErrorReportConfig"/>
					<Server Name="Errors"/>
					<Server Name="Warnings"/>
					<Client Name="objFirstRiwoParamAlarm"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this._TCPIP_CLIENT" Destination="_TCPIP_CLIENT.Control"/>
			<Connection Source="this._TCPIP_PORT" Destination="_TCPIP_PORT.Data"/>
			<Connection Source="_TCPIP_CLIENT.cPort" Destination="_TCPIP_PORT.Data" Vertices="(870,480),(676,480),"/>
			<Connection Source="this.IPString" Destination="IPString.Data"/>
			<Connection Source="this.Data" Destination="IPString.Data" Vertices="(3896,390),(2626,810),"/>
			<Connection Source="this._Alarm_Error_WrongDataReceive" Destination="_Alarm_Error_WrongDataReceive.ClassSvr"/>
			<Connection Source="this.RiwoAlarmCollect1" Destination="RiwoAlarmCollect1.ClassSvr"/>
			<Connection Source="RiwoAlarmCollect1.objFirstRiwoParamAlarm" Destination="_Alarm_Error_WrongDataReceive.ClassSvr" Vertices="(2970,1350),(2746,1350),"/>
			<Connection Source="_Alarm_Error_WrongDataReceive.objNextRiwoParamAlarm" Destination="_Alarm_Error_WrongMessageNumber.ClassSvr" Vertices="(2280,1410),(2190,1470),(2190,1350),(2056,1350),"/>
			<Connection Source="this._Alarm_Error_WrongMessageNumber" Destination="_Alarm_Error_WrongMessageNumber.ClassSvr"/>
			<Connection Source="_Alarm_Error_WrongMessageNumber.objNextRiwoParamAlarm" Destination="_Alarm_Error_NavitrolError.ClassSvr" Vertices="(1590,1410),(1500,1470),(1500,1350),(1366,1350),"/>
			<Connection Source="this._Alarm_Error_NavitrolError" Destination="_Alarm_Error_NavitrolError.ClassSvr"/>
			<Connection Source="_Alarm_Error_NavitrolError.objNextRiwoParamAlarm" Destination="_Alarm_Error_NoCommunication.ClassSvr" Vertices="(900,1410),(810,1470),(810,1350),(676,1350),"/>
			<Connection Source="this._Alarm_Error_NoCommunication" Destination="_Alarm_Error_NoCommunication.ClassSvr"/>
			<Connection Source="_Alarm_Error_NoCommunication.objNextRiwoParamAlarm" Destination="_Alarm_Error_CurrentSensorFault.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
NavitecInterface : CLASS
	TYPE
	  _eagvDriveMode :
	  (
	    dm_Undefined,
	    dm_ManualMode,
	    dm_AutomaticMode,
	    dm_SemiAutomaticMode
	  )$UINT;
	  _enavitrolState :
	  (
	    START_STATE:=1,
	    STANDBY_STATE:=2,
	    AUTO_STATE:=3,
	    FSTOP_STATE:=9,
	    LOAD_STATE:=14,
	    HOLD_STATE:=15,
	    MANUAL_STATE:=16,
	    PAUSE_STATE:=17
	  )$UDINT;
	  _eNextSendData :
	  (
	    nsd_MeasurementUpdate,
	    nsd_SupervisorStatus,
	    nsd_SetSpeedLimit,
	    nsd_AbortDriveWithData,
	    nsd_RequestDriveReady
	  )$UDINT;
#pragma pack(push, 1)
	  _tabortDriveWithData : STRUCT
	    adwd_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tabortDriveWithData.adwd_ProtocolVersion"/>
	    adwd_MessageID : UINT;  //! <Type Comment="=3033" Name="_tabortDriveWithData.adwd_MessageID"/>
	    adwd_MessageLength : UDINT;  //! <Type Comment="=14" Name="_tabortDriveWithData.adwd_MessageLength"/>
	    adwd_StatusControl : BINT
	    [
	      1 SetCompleted,  //! <Type Comment="1 = End current drive order while setting it as “completed” in Navithor&#13;&#10;0 = End current drive order without setting the current drive order to be completed&#13;&#10;" Name="_tabortDriveWithData.adwd_StatusControl.SetCompleted"/>
	    ];
	    adwd_Reserved1 : UINT;
	    adwd_Reserved2 : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tdriveReady : STRUCT
	    dr_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tdriveReady.dr_ProtocolVersion"/>
	    dr_MessageID : UINT;  //! <Type Comment="=3129" Name="_tdriveReady.dr_MessageID"/>
	    dr_MessageLength : UDINT;  //! <Type Comment="=12" Name="_tdriveReady.dr_MessageLength"/>
	    dr_DriveOrderResult : UDINT;  //! <Type Comment="0: Drive order OK&#13;&#10;1: Drive order failed&#13;&#10;" Name="_tdriveReady.dr_DriveOrderResult"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tmeasurementUpdateAGV : STRUCT
	    mua_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tmeasurementUpdateAGV.mua_ProtocolVersion"/>
	    mua_MessageID : UINT;  //! <Type Comment="=1019" Name="_tmeasurementUpdateAGV.mua_MessageID"/>
	    mua_MessageLength : UDINT;  //! <Type Comment="=54" Name="_tmeasurementUpdateAGV.mua_MessageLength"/>
	    mua_MessageNumber : UDINT;  //! <Type Comment="Identification number for feedback message. This value shall be incremented by one for each message sent and it should match with the received reply message number." Name="_tmeasurementUpdateAGV.mua_MessageNumber"/>
	    mua_MeasurementFormatSelector : UINT;  //! <Type Comment="=1. &#13;&#10;Selection of measurement format&#13;&#10;1 –wheel speed and angle measurements&#13;&#10;2 – vehicle motion (Not implemented yet)" Name="_tmeasurementUpdateAGV.mua_MeasurementFormatSelector"/>
	    mua_ReferenceAngleWheel0 : REAL;  //! <Type Comment="Steering angle of wheel 0 (+/-PI in radians)&#13;&#10;Positive turning direction is CCW, zero forwards" Name="_tmeasurementUpdateAGV.mua_ReferenceAngleWheel0"/>
	    mua_ReferenceSpeedWheel0 : REAL;  //! <Type Comment="Speed measurement from wheel 0 (m/s)&#13;&#10;Positive speed at zero steering angle results in forwards motion" Name="_tmeasurementUpdateAGV.mua_ReferenceSpeedWheel0"/>
	    mua_ReferenceAngleWheel1 : REAL;  //! <Type Comment="Steering angle of wheel 1 (+/-PI in radians)&#13;&#10;Positive turning direction is CCW, zero forwards" Name="_tmeasurementUpdateAGV.mua_ReferenceAngleWheel1"/>
	    mua_ReferenceSpeedWheel1 : REAL;  //! <Type Comment="Speed measurement from wheel 1 (m/s)&#13;&#10;Positive speed at zero steering angle results in forwards motion" Name="_tmeasurementUpdateAGV.mua_ReferenceSpeedWheel1"/>
	    mua_DrivingVectorAngle : REAL;  //! <Type Comment="Not implemented!" Name="_tmeasurementUpdateAGV.mua_DrivingVectorAngle"/>
	    mua_SteeringRadius : REAL;  //! <Type Comment="Not implemented!" Name="_tmeasurementUpdateAGV.mua_SteeringRadius"/>
	    mua_DrivingSpeed : REAL;  //! <Type Comment="Not implemented!" Name="_tmeasurementUpdateAGV.mua_DrivingSpeed"/>
	    mua_TurningSpeed : REAL;  //! <Type Comment="Not implemented!" Name="_tmeasurementUpdateAGV.mua_TurningSpeed"/>
	    mua_AGVDriveMode : _eagvDriveMode;
	    mua_Timestamp : UDINT;
	    mua_PLCStatus : BINT
	    [
	      1 PLCError,
	      2 EmergencyStop,
	      3 PLCSlowDown,
	      4 PLCStop,
	      7 Charging,
	      8 BrakeReleased,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tMotorControlAGV : STRUCT
	    mca_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tMotorControlAGV.mca_ProtocolVersion"/>
	    mca_MessageID : UINT;  //! <Type Comment="=1119" Name="_tMotorControlAGV.mca_MessageID"/>
	    mca_MessageLength : UDINT;  //! <Type Comment="=26" Name="_tMotorControlAGV.mca_MessageLength"/>
	    mca_MessageNumber : UDINT;  //! <Type Comment="Identification number for individual messages. NOTE: This value must match with the latest Odometer update message number sent by the AGV controller." Name="_tMotorControlAGV.mca_MessageNumber"/>
	    mca_DrivingVectorAngle : REAL;  //! <Type Comment="Reference driving vector angle relative to the vehicle frame (±p rad)&#13;&#10;&#13;&#10;0 – forwards along vehicle center line. Positive direction is CCW from vehicle center line.&#13;&#10;Hex 7FA00000 no control&#13;&#10;" Name="_tMotorControlAGV.mca_DrivingVectorAngle"/>
	    mca_SteeringRadius : REAL;  //! <Type Comment="Radius to center of rotation from navigation point (m).&#13;&#10;0-pivoting around vehicle navigation point.&#13;&#10;Positive PI/2 CCW from driving vector turning the vehicle to the left.&#13;&#10;Hex 7FA00000 no control.&#13;&#10;&#13;&#10;1/Radius = heading change/travelled distance" Name="_tMotorControlAGV.mca_SteeringRadius"/>
	    mca_DrivingSpeed : REAL;  //! <Type Comment="Reference speed of the vehicle navigation point along driving vector (m/s)&#13;&#10;Positive along driving vector, negative against driving vector (i.e. driving vector ± PI)&#13;&#10;Hex 7FA00000 no control&#13;&#10;" Name="_tMotorControlAGV.mca_DrivingSpeed"/>
	    mca_StatusControl : BINT
	    [
	      1 NavitrolError,
	      2 ControlEnable,  //! <Type Comment="If 0 don’t use reference values" Name="_tMotorControlAGV.mca_StatusControl.ControlEnable"/>
	      6 AckReset,
	      7 ChargeRequest,  //! <Type Comment="is set when vehicle is docked to charger" Name="_tMotorControlAGV.mca_StatusControl.ChargeRequest"/>
	      8 BrakeRelease,
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolMessageHeader : STRUCT
	    nmh_ProtocolVersion : UINT;
	    nmh_MessageID : UINT;
	    nmh_MessageLength : UDINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatusDefault : STRUCT
	    nsd_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tnavitrolStatusDefault.nsd_ProtocolVersion"/>
	    nsd_MessageID : UINT;  //! <Type Comment="=3102" Name="_tnavitrolStatusDefault.nsd_MessageID"/>
	    nsd_MessageLength : UDINT;  //! <Type Comment="Message length in bytes including all data fields" Name="_tnavitrolStatusDefault.nsd_MessageLength"/>
	    nsd_DefaultSectionLength : UDINT;  //! <Type Comment="Length of the default section" Name="_tnavitrolStatusDefault.nsd_DefaultSectionLength"/>
	    nsd_State : _enavitrolState;  //! <Type Comment="Navitrol state" Name="_tnavitrolStatusDefault.nsd_State"/>
	    nsd_Xcoordinate : REAL;  //! <Type Comment="In meter" Name="_tnavitrolStatusDefault.nsd_Xcoordinate"/>
	    nsd_Ycoordinate : REAL;  //! <Type Comment="In meter" Name="_tnavitrolStatusDefault.nsd_Ycoordinate"/>
	    nsd_Heading : REAL;  //! <Type Comment="Radians" Name="_tnavitrolStatusDefault.nsd_Heading"/>
	    nsd_Level : DINT;  //! <Type Comment="Level ID" Name="_tnavitrolStatusDefault.nsd_Level"/>
	    nsd_Speed : REAL;  //! <Type Comment="m/s" Name="_tnavitrolStatusDefault.nsd_Speed"/>
	    nsd_PositionInitializeStatus : UINT;  //! <Type Comment="0: Failed&#13;&#10;1: Succeeded&#13;&#10;" Name="_tnavitrolStatusDefault.nsd_PositionInitializeStatus"/>
	    nsd_PositionConfidence : UINT;  //! <Type Comment="Position confidence in percentage (1-100%)" Name="_tnavitrolStatusDefault.nsd_PositionConfidence"/>
	    nsd_ErrorStatus : UINT;  //! <Type Comment="0: no error&#13;&#10;1: error&#13;&#10;" Name="_tnavitrolStatusDefault.nsd_ErrorStatus"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatusGeneral : STRUCT  //! <Type Public="true" Name="_tnavitrolStatusGeneral"/>
	    nsg_SectionID : UINT;
	    nsg_SectionLength : UDINT;
	    nsg_BatteryVoltage : REAL;
	    nsg_OnRoute : UINT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatusVirtualTag : STRUCT
	    nsvt_SectionID : UINT;  //! <Type Comment="=3" Name="_tnavitrolStatusVirtualTag.nsvt_SectionID"/>
	    nsvt_SectionLength : UDINT;  //! <Type Comment="Length of the section including all data fields of the section" Name="_tnavitrolStatusVirtualTag.nsvt_SectionLength"/>
	    nsvt_VirtualTagInUse : UINT;  //! <Type Comment="1 the machine is close to a virtual tag location, 0 otherwise&#13;&#10;Applies only to Generic tags on symbolic points (doors, Navitrol features or any route properties/tags do not trigger this or the Virtual Tag value).&#13;&#10;" Name="_tnavitrolStatusVirtualTag.nsvt_VirtualTagInUse"/>
	    nsvt_ValueOfVirtualTag1 : UINT;
	    nsvt_ValueOfVirtualTag2 : UINT;  //! <Type Comment="If two ‘generic’ virtual tags are defined the second is sent in this field." Name="_tnavitrolStatusVirtualTag.nsvt_ValueOfVirtualTag2"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatusComingFromGoingTo : STRUCT
	    nsc_SectionID : UINT;
	    nsc_SectionLength : UDINT;
	    nsc_GoingToID : UDINT;
	    nsc_TargetReached : UINT;
	    nsc_GoingToName : ARRAY [0..31] OF CHAR;
	    nsc_ComingFromName : ARRAY [0..31] OF CHAR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatusCustomAttribute : STRUCT
	    nsca_SectionID : UINT;  //! <Type Comment="=6" Name="_tnavitrolStatusCustomAttribute.nsca_SectionID"/>
	    nsca_SectionLength : UDINT;  //! <Type Comment="=186" Name="_tnavitrolStatusCustomAttribute.nsca_SectionLength"/>
	    nsca_Attribute1Value : REAL;
	    nsca_Attribute1Name : ARRAY [0..31] OF CHAR;
	    nsca_Attribute2Value : REAL;
	    nsca_Attribute2Name : ARRAY [0..31] OF CHAR;
	    nsca_Attribute3Value : REAL;
	    nsca_Attribute3Name : ARRAY [0..31] OF CHAR;
	    nsca_Attribute4Value : REAL;
	    nsca_Attribute4Name : ARRAY [0..31] OF CHAR;
	    nsca_Attribute5Value : REAL;
	    nsca_Attribute5Name : ARRAY [0..31] OF CHAR;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatusDriveOrderInfo : STRUCT
	    nsdo_SectionID : UINT;  //! <Type Comment="=6" Name="_tnavitrolStatusDriveOrderInfo.nsdo_SectionID"/>
	    SectionLength : UDINT;  //! <Type Comment="=100" Name="_tnavitrolStatusDriveOrderInfo.SectionLength"/>
	    nsdo_GoingToID : UDINT;  //! <Type Comment="ID of ongoing or last drive target, updated at start of a drive" Name="_tnavitrolStatusDriveOrderInfo.nsdo_GoingToID"/>
	    nsdo_TargetReached : UINT;  //! <Type Comment="1 if the Going to ID destination has been reached, else 0" Name="_tnavitrolStatusDriveOrderInfo.nsdo_TargetReached"/>
	    nsdo_GoingToName : ARRAY [0..31] OF CHAR;  //! <Type Comment="Name of goal symbolic point of the drive, null-terminated string" Name="_tnavitrolStatusDriveOrderInfo.nsdo_GoingToName"/>
	    nsdo_ComingFromName : ARRAY [0..31] OF CHAR;  //! <Type Comment="Name of symbolic point where the drive started, null-terminated string" Name="_tnavitrolStatusDriveOrderInfo.nsdo_ComingFromName"/>
	    nsdo_CurrentSegment : UDINT;  //! <Type Comment="The ID of the segment on which the AGV currently is located" Name="_tnavitrolStatusDriveOrderInfo.nsdo_CurrentSegment"/>
	    nsdo_DistanceToSegment : REAL;  //! <Type Comment="The transversal distance to the segment in meters" Name="_tnavitrolStatusDriveOrderInfo.nsdo_DistanceToSegment"/>
	    nsdo_OnRoute : UINT;  //! <Type Comment="AGV on route information,&#13;&#10;1 – on route&#13;&#10;0 – not on route&#13;&#10;" Name="_tnavitrolStatusDriveOrderInfo.nsdo_OnRoute"/>
	    nsdo_TagID : UINT;  //! <Type Comment="ID of the route tag. A tag value can be defined on any part or group of segments to distinguish one part of the route network from another. Valid values 0 – 65280." Name="_tnavitrolStatusDriveOrderInfo.nsdo_TagID"/>
	    nsdo_DoorTagID : UINT;  //! <Type Comment="Door type symbolic point writes tag IDs to route automatically." Name="_tnavitrolStatusDriveOrderInfo.nsdo_DoorTagID"/>
	    nsdo_ReservedTagIDs : UDINT;  //! <Type Comment="Reserved bytes" Name="_tnavitrolStatusDriveOrderInfo.nsdo_ReservedTagIDs"/>
	    nsdo_DrivingVectorAngle : REAL;  //! <Type Comment="Driving vector angle relative to the vehicle frame (+/- PI in radians)&#13;&#10;0-forwards along vehicle center line. Positive direction is CCW from the vehicle center line.&#13;&#10;" Name="_tnavitrolStatusDriveOrderInfo.nsdo_DrivingVectorAngle"/>
	    nsdo_TurningInformation : UINT;  //! <Type Comment="Vehicle turning left / right.&#13;&#10;0 = No turning&#13;&#10;1 = Left 2 = Right&#13;&#10;3 = Blink both&#13;&#10;" Name="_tnavitrolStatusDriveOrderInfo.nsdo_TurningInformation"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tnavitrolStatus : STRUCT
	    ns_DefaultSection : _tnavitrolStatusDefault;
	    ns_GeneralSection : _tnavitrolStatusGeneral;
	    ns_VirtualTagSection : _tnavitrolStatusVirtualTag;
	    ns_ComingFromGoingToSection : _tnavitrolStatusComingFromGoingTo;
	    ns_CustomAttributeSection : _tnavitrolStatusCustomAttribute;
	    ns_DriveOrderInfoSection : _tnavitrolStatusDriveOrderInfo;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _trequestDriveReady : STRUCT
	    rdr_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_trequestDriveReady.rdr_ProtocolVersion"/>
	    rdr_MessageID : UINT;  //! <Type Comment="=3038" Name="_trequestDriveReady.rdr_MessageID"/>
	    rdr_MessageLength : UDINT;  //! <Type Comment="=12" Name="_trequestDriveReady.rdr_MessageLength"/>
	    rdr_RequestDriveReady : UDINT;  //! <Type Comment="What drive is requested to be ready. 0 = none, 1 = docking, 2 = buffer lane." Name="_trequestDriveReady.rdr_RequestDriveReady"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tsetSpeedLimit : STRUCT
	    ssl_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tsetSpeedLimit.ssl_ProtocolVersion"/>
	    ssl_MessageID : UINT;  //! <Type Comment="=3023" Name="_tsetSpeedLimit.ssl_MessageID"/>
	    ssl_MessageLength : UDINT;  //! <Type Comment="=14" Name="_tsetSpeedLimit.ssl_MessageLength"/>
	    ssl_ReleaseSet : UINT;  //! <Type Comment="0 = release, 1 = set" Name="_tsetSpeedLimit.ssl_ReleaseSet"/>
	    ssl_SpeedLimit : REAL;  //! <Type Comment="Max speed in m/s; absolute value regardless of driving direction; ignored when release/set=0" Name="_tsetSpeedLimit.ssl_SpeedLimit"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tspeedLimitSet : STRUCT
	    sls_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tspeedLimitSet.sls_ProtocolVersion"/>
	    sls_MessageID : UINT;  //! <Type Comment="=3123" Name="_tspeedLimitSet.sls_MessageID"/>
	    sls_MessageLength : UDINT;  //! <Type Comment="=14" Name="_tspeedLimitSet.sls_MessageLength"/>
	    sls_ReleaseSet : UINT;  //! <Type Comment="Message length in bytes including all data fields&#13;&#10;0 – released, 1 – set" Name="_tspeedLimitSet.sls_ReleaseSet"/>
	    sls_SpeedLimit : REAL;  //! <Type Comment="Max speed set in m/s" Name="_tspeedLimitSet.sls_SpeedLimit"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tsupervisorStatusDefault : STRUCT
	    ssd_ProtocolVersion : UINT;  //! <Type Comment="=4" Name="_tsupervisorStatusDefault.ssd_ProtocolVersion"/>
	    ssd_MessageID : UINT;  //! <Type Comment="=3002" Name="_tsupervisorStatusDefault.ssd_MessageID"/>
	    ssd_MessageLength : UDINT;
	    ssd_Status : UINT;  //! <Type Comment="1 if OK, 0 otherwise. If status is set to 1 Navitrol can drive the AGV" Name="_tsupervisorStatusDefault.ssd_Status"/>
	    ssd_EstopOn : UINT;  //! <Type Comment="1 when ESTOP active, 0 otherwise" Name="_tsupervisorStatusDefault.ssd_EstopOn"/>
	    ssd_NumberOfSections : UINT;  //! <Type Comment="Number of the requested section IDs" Name="_tsupervisorStatusDefault.ssd_NumberOfSections"/>
	    ssd_SectionID : ARRAY [0..4] OF UINT;  //! <Type Comment="IDs of the requested section." Name="_tsupervisorStatusDefault.ssd_SectionID"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tsupervisorStatusScanner : STRUCT
	    sss_SectionID : UINT;  //! <Type Comment="=5" Name="_tsupervisorStatusScanner.sss_SectionID"/>
	    sss_SectionLength : UDINT;  //! <Type Comment="=12" Name="_tsupervisorStatusScanner.sss_SectionLength"/>
	    sss_WarningZone2 : UINT;  //! <Type Comment="1 when Warning Zone 2 is triggered. Otherwise 0. Decrease in speed." Name="_tsupervisorStatusScanner.sss_WarningZone2"/>
	    sss_WarningZone1 : UINT;  //! <Type Comment="1 when Warning Zone 1 is triggered. Otherwise 0. Slow down with ramp." Name="_tsupervisorStatusScanner.sss_WarningZone1"/>
	    sss_ProtectionZone : UINT;  //! <Type Comment="1 Protection Zone is triggered. Otherwise 0. Emergency stop." Name="_tsupervisorStatusScanner.sss_ProtectionZone"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tsupervisorStatusBattery : STRUCT
	    ssb_SectionID : UINT;  //! <Type Comment="=8" Name="_tsupervisorStatusBattery.ssb_SectionID"/>
	    ssb_SectionLength : UDINT;  //! <Type Comment="=30" Name="_tsupervisorStatusBattery.ssb_SectionLength"/>
	    ssb_BatteryStateOfCharge : UINT;  //! <Type Comment="In percentages, range 0…100 %, 65535 not used" Name="_tsupervisorStatusBattery.ssb_BatteryStateOfCharge"/>
	    ssb_BatteryVoltage : UINT;  //! <Type Comment="Value * 0.1 Volt, 65535 not used" Name="_tsupervisorStatusBattery.ssb_BatteryVoltage"/>
	    ssb_CurrentDraw : INT;  //! <Type Comment="Value * 0.1 Ampere, 32767 not used. Negative values if discharging and positive values, if battery is being charged." Name="_tsupervisorStatusBattery.ssb_CurrentDraw"/>
	    ssb_EnergyDraw : INT;  //! <Type Comment="Value * 0.1 Ah, 32767 not used" Name="_tsupervisorStatusBattery.ssb_EnergyDraw"/>
	    ssb_TimeToGo : UINT;  //! <Type Comment="Estimated time left in minutes until the battery is empty, 65535 not used." Name="_tsupervisorStatusBattery.ssb_TimeToGo"/>
	    ssb_BatteryStateOfHealth : UINT;  //! <Type Comment="In percentages, range 0…100 %, 65535 not used" Name="_tsupervisorStatusBattery.ssb_BatteryStateOfHealth"/>
	    ssb_BatteryTemperature : INT;  //! <Type Comment="In Celsius degrees, 32767 not used" Name="_tsupervisorStatusBattery.ssb_BatteryTemperature"/>
	    ssb_BatteryLoadCycles : UINT;  //! <Type Comment="Number of load cycles performed for battery, 65535 not used" Name="_tsupervisorStatusBattery.ssb_BatteryLoadCycles"/>
	    ssb_OperatingHours : UINT;  //! <Type Comment="Total number of operating hours, 65535 not used" Name="_tsupervisorStatusBattery.ssb_OperatingHours"/>
	    ssb_ChargerVoltage : UINT;  //! <Type Comment="Value * 0.1 Volt, 65535 not used" Name="_tsupervisorStatusBattery.ssb_ChargerVoltage"/>
	    ssb_Errors : BINT
	    [
	      3 UndervoltageError,
	      4 OvervoltageError,
	      7 InternalDefect,
	      15 GenericError1,
	      16 GenericError2,
	    ];
	    ssb_BinaryData1 : BSINT
	    [
	      1 ChargeStateCritical,  //! <Type Comment="1 charging required" Name="_tsupervisorStatusBattery.ssb_BinaryData1.ChargeStateCritical"/>
	      2 Charging,  //! <Type Comment="1 charging, 0 not charging" Name="_tsupervisorStatusBattery.ssb_BinaryData1.Charging"/>
	    ];
	    ssb_BinaryData2 : BSINT
	    [
	    ];
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  _tsupervisorStatus : STRUCT
	    ss_DefaultSection : _tsupervisorStatusDefault;
	    ss_SafetyScannerSection : _tsupervisorStatusScanner;
	    ss_BatterySection : _tsupervisorStatusBattery;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  tConnectionData : STRUCT
	    rd_ConnectionEstablished : BOOL;
	    rd_ConnectionTimeOut : BOOL;
	    rd_Data : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	ClassSvr 	: SvrChCmd_DINT;
	Enabled 	: SvrCh_DINT;
	Connected 	: SvrCh_DINT;
	Data 	: SvrChCmd_UDINT;
  //Clients:
	_TCPIP_PORT 	: CltChCmd_Merker;
	_TCPIP_CLIENT 	: CltChCmd__TCPIP_CLIENT;
	AlarmStartID 	: CltCh_DINT;
	objBMS 	: CltChCmd_HAL_BMS_Base;
	objKinematicNpivot 	: CltChCmd_KinematicNpivot;
	objStateControl 	: CltChCmd_StateControl;
	objAutomaticControl 	: CltChCmd_AutomaticControl;
	IPString 	: CltChCmd_StringRAM;
	_Alarm_Error_WrongDataReceive 	: CltChCmd_RiwoParamAlarm;
	_Alarm_Error_WrongMessageNumber 	: CltChCmd_RiwoParamAlarm;
	_Alarm_Error_NavitrolError 	: CltChCmd_RiwoParamAlarm;
	_Alarm_Error_NoCommunication 	: CltChCmd_RiwoParamAlarm;
	RiwoAlarmCollect1 	: CltChCmd_RiwoAlarmCollect;
  //Variables:
		_ConnectionStepper 	: DINT;
		_handle 	: DINT;
		_IpAddress : ARRAY [0..16] OF CHAR;

		_MeasurementUpdateAGV 	: _tmeasurementUpdateAGV;			//! <Variable Comment="Navitec message 1019" Name="_MeasurementUpdateAGV"/>
		_SupervisorStatus 	: _tsupervisorStatus;			//! <Variable Comment="Navitec message 3002" Name="_SupervisorStatus"/>
		_StartConnectTime 	: UDINT;
		_LastSendedMessageTime 	: UDINT;
		_ConnectCounter 	: DINT;
		_ResponseConnectionData 	: tConnectionData;
		_SetSpeedLimit 	: _tsetSpeedLimit;			//! <Variable Comment="Navitec message 3023" Name="_SetSpeedLimit"/>
		_AbortDriveWithData 	: _tabortDriveWithData;			//! <Variable Comment="Navitec message 3033" Name="_AbortDriveWithData"/>
		_RequestDriveReady 	: _trequestDriveReady;			//! <Variable Comment="Navitec message 3038" Name="_RequestDriveReady"/>
		_MotorControlAGV 	: _tMotorControlAGV;
		_SpeedLimitSet 	: _tspeedLimitSet;
		_DriveReady 	: _tdriveReady;
		_wrongDataSizeCounter 	: DINT;
		_NavitrolStatus 	: _tnavitrolStatus;
		_NextSendData 	: _eNextSendData;
		_AddConnectionTime 	: UDINT;
		_MeasurementUpdateCounter 	: UDINT;
		_initCounter 	: DINT;
		_MostRecentMessageNumber 	: UDINT;
		_EnabledNotConnectedTimer 	: UDINT;
		_NextSendSpeedLimit 	: BOOL;
		_NextSendRequestDriveReady 	: DINT;
		_initAlarmDelayTimer 	: UDINT;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION GLOBAL Callback
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION GLOBAL SetUpConnection
		VAR_OUTPUT
			retCode 	: DINT;
		END_VAR;
	
	FUNCTION GLOBAL CloseConnection;
	
	FUNCTION GLOBAL SetSpeedLimit
		VAR_INPUT
			SpeedLimitActive 	: BOOL;
			SpeedLimit 	: REAL;			//! <Variable Comment="Max speed in m/s" Name="SetSpeedLimit.SpeedLimit"/>
		END_VAR;
	
	FUNCTION GLOBAL RequestDriveReady
		VAR_INPUT
			requestDrive 	: UDINT;			//! <Variable Comment="What drive is requested to be ready. 0 = none, 1 = docking, 2 = buffer lane." Name="RequestDriveReady.requestDrive"/>
		END_VAR;
	
	FUNCTION _callbackMotorControlAGV
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION _callbackNavitrolStatus
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION _callbackSpeedLimitSet
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION _callbackDriveReady
		VAR_INPUT
			pData 	: ^void;
			udSize 	: UDINT;
		END_VAR;
	
	FUNCTION _updateMeasurementUpdateAGV;
	
	FUNCTION _updateSupervisorStatus;
	
	FUNCTION _updateAbortDriveWithData;
	
	FUNCTION _updateSetSpeedLimit
		VAR_INPUT
			ReleaseSet 	: BOOL;
			SpeedLimit 	: REAL;
		END_VAR;
	
	FUNCTION _updateRequestDriveReady
		VAR_INPUT
			requestDrive 	: UDINT;
		END_VAR;
	
	FUNCTION _navitecStateToMasterState
		VAR_INPUT
			navitecState 	: _enavitrolState;
		END_VAR
		VAR_OUTPUT
			returnValue 	: StateControl::eMasterState;
		END_VAR;
	
	FUNCTION _handleAlarmResets;
	
	FUNCTION VIRTUAL GLOBAL Data::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL Data::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _TCPIP_CLIENT
#pragma using Merker
#pragma using RiwoAlarmCollect
#pragma using RiwoParamAlarm
#pragma using StringRAM
#pragma usingLtd AutomaticControl
#pragma usingLtd HAL_BMS_Base
#pragma usingLtd KinematicNpivot
#pragma usingLtd StateControl


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB NavitecInterface::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_NAVITECINTERFACE
0$UINT, 0$UINT, (SIZEOF(::NavitecInterface))$UINT, 
4$UINT, 13$UINT, 0$UINT, 
TO_UDINT(256278040), "NavitecInterface", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::NavitecInterface.ClassSvr.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(619352855), "ClassSvr", 
(::NavitecInterface.Enabled.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1874609566), "Enabled", 
(::NavitecInterface.Connected.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(1584727642), "Connected", 
(::NavitecInterface.Data.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(2607161047), "Data", 
//Clients:
(::NavitecInterface._TCPIP_PORT.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2971237659), "_TCPIP_PORT", TO_UDINT(2276934072), "Merker", 1$UINT, 0$UINT, 
(::NavitecInterface._TCPIP_CLIENT.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2629403047), "_TCPIP_CLIENT", TO_UDINT(2629403047), "_TCPIP_CLIENT", 1$UINT, 17$UINT, 
(::NavitecInterface.AlarmStartID.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000000$UINT, TO_UDINT(688888888), "AlarmStartID", 
(::NavitecInterface.objBMS.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1576911554), "objBMS", TO_UDINT(3662255972), "HAL_BMS_Base", 0$UINT, 0$UINT, 
(::NavitecInterface.objKinematicNpivot.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4105540354), "objKinematicNpivot", TO_UDINT(1530409541), "KinematicNpivot", 0$UINT, 0$UINT, 
(::NavitecInterface.objStateControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2641290446), "objStateControl", TO_UDINT(2283691383), "StateControl", 0$UINT, 0$UINT, 
(::NavitecInterface.objAutomaticControl.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(249169011), "objAutomaticControl", TO_UDINT(3872218593), "AutomaticControl", 0$UINT, 0$UINT, 
(::NavitecInterface.IPString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(2946579348), "IPString", TO_UDINT(2408581120), "StringRAM", 1$UINT, 10$UINT, 
(::NavitecInterface._Alarm_Error_WrongDataReceive.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(903483506), "_Alarm_Error_WrongDataReceive", TO_UDINT(1396228774), "RiwoParamAlarm", 0$UINT, 2$UINT, 
(::NavitecInterface._Alarm_Error_WrongMessageNumber.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1053283012), "_Alarm_Error_WrongMessageNumber", TO_UDINT(1396228774), "RiwoParamAlarm", 0$UINT, 2$UINT, 
(::NavitecInterface._Alarm_Error_NavitrolError.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3804193342), "_Alarm_Error_NavitrolError", TO_UDINT(1396228774), "RiwoParamAlarm", 0$UINT, 2$UINT, 
(::NavitecInterface._Alarm_Error_NoCommunication.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(259986451), "_Alarm_Error_NoCommunication", TO_UDINT(1396228774), "RiwoParamAlarm", 0$UINT, 2$UINT, 
(::NavitecInterface.RiwoAlarmCollect1.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3609966480), "RiwoAlarmCollect1", TO_UDINT(688852726), "RiwoAlarmCollect", 0$UINT, 1$UINT, 
END_FUNCTION


#define USER_CNT_NavitecInterface 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_NavitecInterface] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION NavitecInterface::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_NavitecInterface, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	ClassSvr.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ClassSvr.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Enabled.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Enabled.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Connected.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Connected.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, Data.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #Data::Read();
	vmt.CmdTable.Write		:= #Data::Write();
	Data.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF Data.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION


FUNCTION VIRTUAL GLOBAL NavitecInterface::Init

  _initCounter += 1;

  if (_initCounter = INIT_CYCLE_10) then
    AlarmStartId := AlarmStartId.Read();
    
    _Alarm_Error_WrongDataReceive.SetAlarmIds(startId:=AlarmStartId);
    
    _Alarm_Error_WrongDataReceive.Level := RiwoParamAlarm::eal_Error;
    _Alarm_Error_WrongDataReceive.Report := RiwoParamAlarm::ear_Yes;
    
    _Alarm_Error_WrongMessageNumber.Level := RiwoParamAlarm::eal_Error;
    _Alarm_Error_WrongMessageNumber.Report := RiwoParamAlarm::ear_Yes;
    
    _Alarm_Error_NavitrolError.Level := RiwoParamAlarm::eal_Info;
    _Alarm_Error_NavitrolError.Report := RiwoParamAlarm::ear_Yes;
    
    _Alarm_Error_NoCommunication.Level := RiwoParamAlarm::eal_Error;
    _Alarm_Error_NoCommunication.Report := RiwoParamAlarm::ear_Yes;    
    
    _NextSendData := nsd_SupervisorStatus;    
    
    _initAlarmDelayTimer := ops.tAbsolute;
  end_if;

END_FUNCTION



FUNCTION VIRTUAL GLOBAL NavitecInterface::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR
  
  case _ConnectionStepper of
    //****************************************************************************************
    -1://### close connection
    //****************************************************************************************
      _TCPIP_CLIENT.DelConnection(dhandle:= _handle); //kills aktive connection
      _ConnectionStepper := 0;
    //****************************************************************************************
    0: //### open connection
    //****************************************************************************************
      if (Enabled = 1) then //only initialize if the object is set active
        
        
          _handle := _TCPIP_CLIENT.AddConnection(pIPAddress := #_IpAddress[0],
                                                pCallbackThis := this,
                                                pCallbackMeth := #Callback(),
                                                udTimeout := NAVITEC_COM_TIMEOUTTIME
                                                );

        _ConnectionStepper := 1;
        _AddConnectionTime := ops.tAbsolute;
      end_if;
      Connected := 0;


    //****************************************************************************************
    1: //### check if Connection is OK, call one function object and send the request
    //****************************************************************************************
      if (Enabled = 1) then //only do something if the object is set active 
        Connected := _TCPIP_CLIENT.IsConnected(_handle);
        
        if Connected then
          
          if _NextSendData = nsd_MeasurementUpdate then
          
            _updateMeasurementUpdateAGV();
            
            if _TCPIP_CLIENT.SendData(pData := #_MeasurementUpdateAGV, udSize := sizeof(_MeasurementUpdateAGV), dhandle := _handle, bDirect := TRUE) = 0 then
              _ConnectionStepper := 2;
              _StartConnectTime := ops.tAbsolute;
              _LastSendedMessageTime := ops.tAbsolute;
              _MeasurementUpdateCounter += 1;
            else
              _TCPIP_CLIENT.FLUSHRingbuffer(dhandle := _handle);
              _ConnectionStepper := -1; 
            end_if;
          
          elsif _NextSendData = nsd_SupervisorStatus then
            
            _updateSupervisorStatus();
            
            if _TCPIP_CLIENT.SendData(pData := #_SupervisorStatus, udSize := sizeof(_SupervisorStatus), dhandle := _handle, bDirect := TRUE) = 0 then
              _ConnectionStepper := 2;
              _StartConnectTime := ops.tAbsolute;
              _LastSendedMessageTime := ops.tAbsolute;
            else
              _TCPIP_CLIENT.FLUSHRingbuffer(dhandle := _handle);
              _ConnectionStepper := -1; 
            end_if;
            
          elsif _NextSendData = nsd_SetSpeedLimit then
            
            if _TCPIP_CLIENT.SendData(pData := #_SetSpeedLimit, udSize := sizeof(_SetSpeedLimit), dhandle := _handle, bDirect := TRUE) = 0 then
              _ConnectionStepper := 2;
              _StartConnectTime := ops.tAbsolute;
              _LastSendedMessageTime := ops.tAbsolute;
            else
              _TCPIP_CLIENT.FLUSHRingbuffer(dhandle := _handle);
              _ConnectionStepper := -1; 
            end_if;            

          end_if;
          
        elsif (ops.tAbsolute - _AddConnectionTime > WAITFORCONNECTEDTIME) then
          
          _TCPIP_CLIENT.FLUSHRingbuffer(dhandle := _handle); 
          _ConnectionStepper := -1; 
          
          if (ops.tAbsolute - _initAlarmDelayTimer) > INITALARMDELAY then
            if _Alarm_Error_NoCommunication.ClassSvr = false then
              _Alarm_Error_NoCommunication.SetActive();
            end_if;
          end_if;
        end_if;
      else
        _ConnectionStepper := -1;
      end_if;

    //****************************************************************************************
    2: //### wait until the response is received
    //****************************************************************************************
      Connected := _TCPIP_CLIENT.IsConnected(_handle);
      if Connected = 0 then
        _ConnectionStepper := -1;
        //************************************************************
        _TCPIP_CLIENT.FLUSHRingbuffer(dhandle := _handle);
        //************************************************************
      else
        // try to send the message Again 
        if OPS.tAbsolute - _LastSendedMessageTime > RESEND_TIME then
          _ConnectionStepper := 1;
          case _NextSendData of
            nsd_MeasurementUpdate:
              _NextSendData := nsd_SupervisorStatus;
            nsd_SupervisorStatus:
              _NextSendData := nsd_MeasurementUpdate;
            else
              _NextSendData := nsd_MeasurementUpdate;
          end_case;
          if _NextSendRequestDriveReady = TRUE then
            //_NextSendData := nsd_RequestDriveReady;
            _NextSendRequestDriveReady := FALSE;
          end_if;
          if _NextSendSpeedLimit = TRUE then
            //NextSendData := nsd_SetSpeedLimit;
            _NextSendSpeedLimit := FALSE;
          end_if;
        end_if;
      end_if;
      
      // break the connection
      if Enabled = false then
        _ConnectionStepper := -1 ;
      end_if;
      
      //check for timeout
      IF (ops.tAbsolute - _StartConnectTime) > NAVITEC_COM_TIMEOUTTIME THEN
        //send no connection as responce and delete connection so that the stream stops!
        //this is neede otherwise old anwers could be retreived and proccessed
        _ConnectionStepper := -1;        
      END_IF; 

  end_case;
  
  IF Connected THEN
    _ConnectCounter := 0;
    _StartConnectTime := ops.tAbsolute;
    
    _ResponseConnectionData.rd_ConnectionTimeOut := false;
  ELSE
    IF Enabled THEN
      IF _ConnectCounter >= NAVITEC_CONNECTIONRETRIES THEN
        _ResponseConnectionData.rd_ConnectionTimeOut := true;
      ELSIF(ops.tAbsolute - _StartConnectTime) > NAVITEC_COM_TIMEOUTTIME THEN
        _StartConnectTime := ops.tAbsolute;
        _ConnectCounter += 1;
      END_IF;
    ELSE
      _ConnectCounter := 0;
      _StartConnectTime := ops.tAbsolute; 
    END_IF;
    _ResponseConnectionData.rd_ConnectionEstablished := falsE;
    //Clear response data if no connection
    _memset(dest:=#_ResponseConnectionData.rd_Data, usByte:=0, cntr:=sizeof(_ResponseConnectionData.rd_Data));
  END_IF;
  if !!(Enabled & !!Connected) then
    _EnabledNotConnectedTimer := ops.tAbsolute;
  end_if;
  if (ops.tAbsolute - _initAlarmDelayTimer) > INITALARMDELAY then
    if ops.tAbsolute - _EnabledNotConnectedTimer > ENABLEDNOTCONNECTEDTIME then
      if _Alarm_Error_NoCommunication.ClassSvr = false then
        _Alarm_Error_NoCommunication.ClassSvr.Write(TRUE);
      end_if;  
    end_if;
  end_if;
  
  _handleAlarmResets();
  
	state := READY;

END_FUNCTION


FUNCTION GLOBAL NavitecInterface::Callback
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
  VAR
  	messageHeader : _tnavitrolMessageHeader;
  END_VAR

  _memset(dest:=#messageHeader, usByte:=0, cntr:=sizeof(messageHeader));
  _memcpy(ptr1:=#messageHeader, ptr2:=pData, cntr:=sizeof(messageHeader));  
  
  if (udSize = messageHeader.nmh_MessageLength) then
    case messageHeader.nmh_MessageID of
      ID1119:
        _callbackMotorControlAGV(pData:=pData, udSize:=udSize);
      ID3102:
        _callbackNavitrolStatus(pData:=pData, udSize:=udSize);
      ID3123:
        _callbackSpeedLimitSet(pData:=pData, udSize:=udSize);
      ID3129:
        _callbackDriveReady(pData:=pData, udSize:=udSize);
    end_case;
  end_if;

END_FUNCTION


FUNCTION GLOBAL NavitecInterface::SetUpConnection
	VAR_OUTPUT
		retCode 	: DINT;
	END_VAR
  VAR
  	strLen : UDINT;
  END_VAR  

    strLen := IPString.GetLength();  
    _memset(dest:=#_IpAddress[0], usByte:=0, cntr:=sizeof(_IpAddress));
    IPString.GetDataAt(pData := #_IpAddress[0], udSize := strLen, udAt := 0);
    Enabled := TRUE;
    retcode := 1;

END_FUNCTION


FUNCTION GLOBAL NavitecInterface::CloseConnection
  Enabled := false;
END_FUNCTION


FUNCTION NavitecInterface::_callbackMotorControlAGV
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
  VAR
  	automaticControlData : AutomaticControl::tAutomaticControlData;
    masterStateControlData : StateControl::tMasterStatusControl;
  END_VAR

  
  if (udSize = sizeof(_MotorControlAGV)) then
    _memcpy(ptr1:=#_MotorControlAGV, ptr2:=pData, cntr:=udSize);
    
    // Distribute data to other classes
    automaticControlData.acd_DrivingVectorAngle := _MotorControlAGV.mca_DrivingVectorAngle;
    automaticControlData.acd_SteeringRadius := _MotorControlAGV.mca_SteeringRadius;
    automaticControlData.acd_DrivingSpeed := _MotorControlAGV.mca_DrivingSpeed;
    objAutomaticControl.SetData(automaticControlData);
    
    masterStateControlData.msc_Error := _MotorControlAGV.mca_StatusControl.NavitrolError;
    masterStateControlData.msc_ControlEnable := _MotorControlAGV.mca_StatusControl.ControlEnable;
    masterStateControlData.msc_BrakeRelease := _MotorControlAGV.mca_StatusControl.BrakeRelease;
    objStateControl.SetMasterStatusControl(masterStateControlData);
    
    
    // reset wrong data count
    _wrongDataSizeCounter := 0;    
    if _MotorControlAGV.mca_StatusControl.NavitrolError = TRUE then
      if _Alarm_Error_NavitrolError.ClassSvr = false then
        _Alarm_Error_NavitrolError.ClassSvr.Write(TRUE);
      end_if;
    end_if;   
    if _MostRecentMessageNumber <> _MotorControlAGV.mca_MessageNumber then
      if _Alarm_Error_WrongMessageNumber.ClassSvr = false then
        _Alarm_Error_WrongMessageNumber.ClassSvr.Write(TRUE);
      end_if;    
    end_if; 
  else
    _wrongDataSizeCounter += 1;

    // check if wrong message is received to many times
    if _wrongDataSizeCounter > MAXWRONGDATASIZECOUNT then
      if _Alarm_Error_WrongDataReceive.ClassSvr = false then
        _Alarm_Error_WrongDataReceive.ClassSvr.Write(TRUE);
      end_if;
    end_if;    
  end_if;

END_FUNCTION


FUNCTION NavitecInterface::_callbackNavitrolStatus
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
  VAR
  	mastercurrentstatus : StateControl::tMasterCurrentStatus;
    virtualtags : StateControl::tVirtualTagsMaster;
    routeinformation : StateControl::tRouteInformation;
    customattributes : StateControl::tCustomAttributesMaster;
  END_VAR

  if (udSize = sizeof(_NavitrolStatus)) then
    _memcpy(ptr1:=#_NavitrolStatus, ptr2:=pData, cntr:=udSize);
    
    // Distribute data to other classes
    // Default Section
    mastercurrentstatus.mcs_MasterState := _navitecStateToMasterState(_NavitrolStatus.ns_DefaultSection.nsd_State);
    mastercurrentstatus.mcs_AGVX := _NavitrolStatus.ns_DefaultSection.nsd_Xcoordinate;
    mastercurrentstatus.mcs_AGVY := _NavitrolStatus.ns_DefaultSection.nsd_Ycoordinate;
    mastercurrentstatus.mcs_AGVAngle := _NavitrolStatus.ns_DefaultSection.nsd_Heading;
    mastercurrentstatus.mcs_AGVLevel := _NavitrolStatus.ns_DefaultSection.nsd_Level;
    mastercurrentstatus.mcs_AGVSpeed := _NavitrolStatus.ns_DefaultSection.nsd_Speed;
    mastercurrentstatus.mcs_PositionInitializeStatus := _NavitrolStatus.ns_DefaultSection.nsd_PositionInitializeStatus$BOOL;
    mastercurrentstatus.mcs_PositionConfidence := to_dint(_NavitrolStatus.ns_DefaultSection.nsd_PositionConfidence);
    mastercurrentstatus.mcs_ErrorStatus := _NavitrolStatus.ns_DefaultSection.nsd_ErrorStatus$BOOL;
    objStateControl.SetMasterCurrentStatus(mastercurrentstatus);
    
    // Virtual Tag Section
    virtualtags.vtm_TagActive := _NavitrolStatus.ns_VirtualTagSection.nsvt_VirtualTagInUse$BOOL;
    virtualtags.vtm_ValueTag1 := _NavitrolStatus.ns_VirtualTagSection.nsvt_ValueOfVirtualTag1;
    virtualtags.vtm_ValueTag2 := _NavitrolStatus.ns_VirtualTagSection.nsvt_ValueOfVirtualTag2;
    objStateControl.SetVirtualTags(virtualtags);
    
    // Coming From Going To Section
    routeinformation.ri_TargetPositionID := _NavitrolStatus.ns_ComingFromGoingToSection.nsc_GoingToID;
    routeinformation.ri_TargetReached := _NavitrolStatus.ns_ComingFromGoingToSection.nsc_TargetReached$BOOL;
    _strcpy(dest:=#routeinformation.ri_TargetPositionName[0], src:=#_NavitrolStatus.ns_ComingFromGoingToSection.nsc_GoingToName[0]);
    _strcpy(dest:=#routeinformation.ri_OriginPositionName[0], src:=#_NavitrolStatus.ns_ComingFromGoingToSection.nsc_ComingFromName[0]);        
    objStateControl.SetRouteInformation(routeinformation);
    
    // Custom Attributes Section
    _strcpy(dest:=#customattributes[1].Name[0], src:=#_NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute1Name[0]);
    _strcpy(dest:=#customattributes[2].Name[0], src:=#_NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute2Name[0]);
    _strcpy(dest:=#customattributes[3].Name[0], src:=#_NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute3Name[0]);
    _strcpy(dest:=#customattributes[4].Name[0], src:=#_NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute4Name[0]);
    _strcpy(dest:=#customattributes[5].Name[0], src:=#_NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute5Name[0]);
    customattributes[1].Value := _NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute1Value;
    customattributes[2].Value := _NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute2Value;
    customattributes[3].Value := _NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute3Value;
    customattributes[4].Value := _NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute4Value;
    customattributes[5].Value := _NavitrolStatus.ns_CustomAttributeSection.nsca_Attribute5Value;
    objStateControl.SetCustomAttributes(customattributes);
    
    // reset wrong data count
    _wrongDataSizeCounter := 0;    
  else
    _wrongDataSizeCounter += 1;  
    
    // check if wrong message is received to many times
    if _wrongDataSizeCounter > MAXWRONGDATASIZECOUNT then
      if _Alarm_Error_WrongDataReceive.ClassSvr = false then
        _Alarm_Error_WrongDataReceive.ClassSvr.Write(TRUE);
      end_if;
    end_if;      
  end_if;

END_FUNCTION


FUNCTION NavitecInterface::_callbackSpeedLimitSet
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR
  
  if (udSize = sizeof(_SpeedLimitSet)) then
    _memcpy(ptr1:=#_SpeedLimitSet, ptr2:=pData, cntr:=udSize);
    
    // Distribute data to other classes
    objStateControl.SetSpeedLimitFeedback(SpeedLimitActive:=_SpeedLimitSet.sls_ReleaseSet$BOOL, SpeedLimit:=_SpeedLimitSet.sls_SpeedLimit);

    // reset wrong data count
    _wrongDataSizeCounter := 0;        
  else
    _wrongDataSizeCounter += 1;
    
    // check if wrong message is received to many times
    if _wrongDataSizeCounter > MAXWRONGDATASIZECOUNT then
      if _Alarm_Error_WrongDataReceive.ClassSvr = false then
        _Alarm_Error_WrongDataReceive.ClassSvr.Write(TRUE);
      end_if;
    end_if;      
  end_if;

END_FUNCTION


FUNCTION NavitecInterface::_callbackDriveReady
	VAR_INPUT
		pData 	: ^void;
		udSize 	: UDINT;
	END_VAR

  if (udSize = sizeof(_DriveReady)) then
    _memcpy(ptr1:=#_DriveReady, ptr2:=pData, cntr:=udSize);
    
    // Distribute data to other classes
    if _DriveReady.dr_DriveOrderResult = 0 then
      objStateControl.SetDriveReadyFeedback(driveOrderOK:=TRUE);
    else
      objStateControl.SetDriveReadyFeedback(driveOrderOK:=FALSE);
    end_if;
    
    // reset wrong data count
    _wrongDataSizeCounter := 0;    
  else
    _wrongDataSizeCounter += 1;
    
    // check if wrong message is received to many times
    if _wrongDataSizeCounter > MAXWRONGDATASIZECOUNT then
      if _Alarm_Error_WrongDataReceive.ClassSvr = false then
        _Alarm_Error_WrongDataReceive.ClassSvr.Write(TRUE);
      end_if;
    end_if;      
  end_if;

END_FUNCTION


FUNCTION NavitecInterface::_updateMeasurementUpdateAGV
  VAR
  	referenceWheelInfo : KinematicNpivot::tReferenceWheelsInfo;
    batteryInfo : HAL_BMS_Base::tBMSData;
    stateInfo : StateControl::tStateData;
  END_VAR
  
  // Get info
  if IsClientConnected(#objBMS) then
    batteryInfo := objBMS.GetBMSData();
  else
    _memset(dest:=#batteryInfo, usByte:=0, cntr:=sizeof(batteryInfo));
  end_if;
  referenceWheelInfo := objKinematicNpivot.GetReferenceWheelsInfo();
  stateInfo := objStateControl.GetStateData();
  
  // Static values
  _MeasurementUpdateAGV.mua_ProtocolVersion := 4;
  _MeasurementUpdateAGV.mua_MessageID := 1019;
  _MeasurementUpdateAGV.mua_MessageLength := sizeof(_MeasurementUpdateAGV);
  _MeasurementUpdateAGV.mua_MessageNumber := _MeasurementUpdateCounter;
  _MeasurementUpdateAGV.mua_MeasurementFormatSelector := 1;
  
  // Reference wheels
  _MeasurementUpdateAGV.mua_ReferenceAngleWheel0 := referenceWheelInfo.rwi_ReferenceWheel1Angle/180 * SigClib_pi;
  _MeasurementUpdateAGV.mua_ReferenceSpeedWheel0 := referenceWheelInfo.rwi_ReferenceWheel1Speed;
  _MeasurementUpdateAGV.mua_ReferenceAngleWheel1 := referenceWheelInfo.rwi_ReferenceWheel2Angle/180 * SigClib_pi;
  _MeasurementUpdateAGV.mua_ReferenceSpeedWheel1 := referenceWheelInfo.rwi_ReferenceWheel2Speed;

  // Unused variables
  _MeasurementUpdateAGV.mua_DrivingVectorAngle := 0;
  _MeasurementUpdateAGV.mua_SteeringRadius := 0;
  _MeasurementUpdateAGV.mua_DrivingSpeed := 0;
  _MeasurementUpdateAGV.mua_TurningSpeed := 0;
  
  // Current status
  if (stateInfo.sd_AGVMode = StateControl::am_Auto) | ((stateInfo.sd_AGVMode = StateControl::am_Manual) & ((stateInfo.sd_GeneralAlarm = TRUE) | (stateInfo.sd_EStopActive = TRUE))) then
    _MeasurementUpdateAGV.mua_AGVDriveMode := _eagvDriveMode::dm_AutomaticMode;
  else
    _MeasurementUpdateAGV.mua_AGVDriveMode := _eagvDriveMode::dm_ManualMode;
  end_if;
  
  _MeasurementUpdateAGV.mua_Timestamp := ops.tAbsolute;
  _MeasurementUpdateAGV.mua_PLCStatus.PLCError := stateInfo.sd_GeneralAlarm;
  _MeasurementUpdateAGV.mua_PLCStatus.EmergencyStop := stateInfo.sd_EStopActive;
  _MeasurementUpdateAGV.mua_PLCStatus.PLCSlowDown := (stateInfo.sd_AGVMovementMode = amm_SlowMovement);
  _MeasurementUpdateAGV.mua_PLCStatus.PLCStop := (stateInfo.sd_AGVMovementMode = amm_NoMovement);
  _MeasurementUpdateAGV.mua_PLCStatus.Charging := batteryInfo.bd_BatteryCharging;
  _MeasurementUpdateAGV.mua_PLCStatus.BrakeReleased := stateInfo.sd_BrakeReleased;
  
  // Store message number to check if response number corresponds
  _MostRecentMessageNumber := _MeasurementUpdateAGV.mua_MessageNumber;
  
END_FUNCTION


FUNCTION NavitecInterface::_updateSupervisorStatus
  VAR
  	batteryInfo : HAL_BMS_Base::tBMSData;
    stateInfo : StateControl::tStateData;    
  END_VAR
  
  // Get info
  if IsClientConnected(#objBMS) then
    batteryInfo := objBMS.GetBMSData();
  else
    _memset(dest:=#batteryInfo, usByte:=0, cntr:=sizeof(batteryInfo));
  end_if;
  stateInfo := objStateControl.GetStateData();
  
  // Default section
  _SupervisorStatus.ss_DefaultSection.ssd_ProtocolVersion := 4;
  _SupervisorStatus.ss_DefaultSection.ssd_MessageID := 3002;
  _SupervisorStatus.ss_DefaultSection.ssd_MessageLength := sizeof(_SupervisorStatus);
   _SupervisorStatus.ss_DefaultSection.ssd_Status := 1;
   _SupervisorStatus.ss_DefaultSection.ssd_EstopOn := to_uint(stateInfo.sd_EStopActive);
  _SupervisorStatus.ss_DefaultSection.ssd_NumberOfSections := 5;
  _SupervisorStatus.ss_DefaultSection.ssd_SectionID[0] := 1;
  _SupervisorStatus.ss_DefaultSection.ssd_SectionID[1] := 3;
  _SupervisorStatus.ss_DefaultSection.ssd_SectionID[2] := 4;
  _SupervisorStatus.ss_DefaultSection.ssd_SectionID[3] := 6;
  _SupervisorStatus.ss_DefaultSection.ssd_SectionID[4] := 12;

  // Safety scanner section
  _SupervisorStatus.ss_SafetyScannerSection.sss_SectionID := 5;
  _SupervisorStatus.ss_SafetyScannerSection.sss_SectionLength := sizeof(_SupervisorStatus.ss_SafetyScannerSection);

  _SupervisorStatus.ss_SafetyScannerSection.sss_WarningZone2 := 0;
  _SupervisorStatus.ss_SafetyScannerSection.sss_WarningZone1 := 0;
  _SupervisorStatus.ss_SafetyScannerSection.sss_ProtectionZone := 0;


  // Battery section
  _SupervisorStatus.ss_BatterySection.ssb_SectionID := 8;
  _SupervisorStatus.ss_BatterySection.ssb_SectionLength := sizeof(_SupervisorStatus.ss_BatterySection);
  _SupervisorStatus.ss_BatterySection.ssb_BatteryStateOfCharge := batteryInfo.bd_StateOfCharge;
  _SupervisorStatus.ss_BatterySection.ssb_BatteryVoltage := batteryInfo.bd_BatteryVoltage;
  _SupervisorStatus.ss_BatterySection.ssb_CurrentDraw := batteryInfo.bd_BatteryCurrent;
  _SupervisorStatus.ss_BatterySection.ssb_EnergyDraw := batteryInfo.bd_EnergyDraw;
  _SupervisorStatus.ss_BatterySection.ssb_TimeToGo := batteryInfo.bd_TimeToGo;
  _SupervisorStatus.ss_BatterySection.ssb_BatteryStateOfHealth := 100;
  _SupervisorStatus.ss_BatterySection.ssb_BatteryTemperature := batteryInfo.bd_BatteryTemperature;
  _SupervisorStatus.ss_BatterySection.ssb_BatteryLoadCycles := 0;
  _SupervisorStatus.ss_BatterySection.ssb_OperatingHours := 0;
  _SupervisorStatus.ss_BatterySection.ssb_ChargerVoltage := 0;
  _SupervisorStatus.ss_BatterySection.ssb_Errors.UndervoltageError := batteryInfo.bd_Alarm.ba_UnderVoltage;
  _SupervisorStatus.ss_BatterySection.ssb_Errors.OvervoltageError := batteryInfo.bd_Alarm.ba_OverVoltage;
  _SupervisorStatus.ss_BatterySection.ssb_Errors.InternalDefect := batteryInfo.bd_Alarm.ba_InternalDefect;
  _SupervisorStatus.ss_BatterySection.ssb_Errors.GenericError1 := FALSE;
  _SupervisorStatus.ss_BatterySection.ssb_Errors.GenericError2 := FALSE;
  _SupervisorStatus.ss_BatterySection.ssb_BinaryData1.ChargeStateCritical := batteryInfo.bd_Alarm.ba_BatteryAlmostEmpty;
  _SupervisorStatus.ss_BatterySection.ssb_BinaryData1.Charging := batteryInfo.bd_BatteryCharging;

END_FUNCTION


FUNCTION NavitecInterface::_updateSetSpeedLimit
	VAR_INPUT
		ReleaseSet 	: BOOL;
		SpeedLimit 	: REAL;
	END_VAR

  _SetSpeedLimit.ssl_ProtocolVersion := 4;
  _SetSpeedLimit.ssl_MessageID := 3023;
  _SetSpeedLimit.ssl_MessageLength := sizeof(_SetSpeedLimit);
  _SetSpeedLimit.ssl_ReleaseSet := to_uint(ReleaseSet);
  _SetSpeedLimit.ssl_SpeedLimit := SpeedLimit;

END_FUNCTION


FUNCTION NavitecInterface::_updateAbortDriveWithData

  _AbortDriveWithData.adwd_ProtocolVersion := 4;
  _AbortDriveWithData.adwd_MessageID := 3033;
  _AbortDriveWithData.adwd_MessageLength := sizeof(_AbortDriveWithData);
  _AbortDriveWithData.adwd_StatusControl.SetCompleted := 0;
  _AbortDriveWithData.adwd_Reserved1 := 0;
  _AbortDriveWithData.adwd_Reserved2 := 0;

END_FUNCTION





FUNCTION NavitecInterface::_navitecStateToMasterState
	VAR_INPUT
		navitecState 	: _enavitrolState;
	END_VAR
	VAR_OUTPUT
		returnValue 	: StateControl::eMasterState;
	END_VAR
  
  case navitecState of
    START_STATE:
      returnValue := StateControl::ms_StartState;
    STANDBY_STATE:
      returnValue := StateControl::ms_StandbyState;
    AUTO_STATE:
      returnValue := StateControl::ms_AutoState;
    FSTOP_STATE:
      returnValue := StateControl::ms_FstopState;
    LOAD_STATE:
      returnValue := StateControl::ms_LoadState;
    HOLD_STATE:
      returnValue := StateControl::ms_HoldState;
    MANUAL_STATE:
      returnValue := StateControl::ms_ManualState;
    PAUSE_STATE:
      returnValue := StateControl::ms_PauseState;
    else
      returnValue := StateControl::ms_Undefined;
  end_case;  

END_FUNCTION


FUNCTION GLOBAL NavitecInterface::SetSpeedLimit
	VAR_INPUT
		SpeedLimitActive 	: BOOL;
		SpeedLimit 	: REAL;
	END_VAR
  
  _NextSendSpeedLimit := TRUE;
  _updateSetSpeedLimit(ReleaseSet:=SpeedLimitActive, SpeedLimit:=SpeedLimit);

END_FUNCTION


FUNCTION NavitecInterface::_updateRequestDriveReady
	VAR_INPUT
		requestDrive 	: UDINT;
	END_VAR
  
  _RequestDriveReady.rdr_ProtocolVersion := 4;
  _RequestDriveReady.rdr_MessageID := 3038;
  _RequestDriveReady.rdr_MessageLength := sizeof(_RequestDriveReady);
  _RequestDriveReady.rdr_RequestDriveReady := requestDrive;
  
END_FUNCTION


FUNCTION GLOBAL NavitecInterface::RequestDriveReady
	VAR_INPUT
		requestDrive 	: UDINT;
	END_VAR
  
  _NextSendRequestDriveReady := TRUE;
  _updateRequestDriveReady(requestDrive);

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NavitecInterface::Data::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	Data := IPString.Data.Read();
	output := Data;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL NavitecInterface::Data::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	Data := input;
	result := (IPString.Data.Write(Data))$UDINT;

END_FUNCTION


FUNCTION NavitecInterface::_handleAlarmResets

  if _Alarm_Error_WrongDataReceive.ResetReq = TRUE then
    _Alarm_Error_WrongDataReceive.SetInActive(); 
  end_if;
  
  if _Alarm_Error_WrongMessageNumber.ResetReq = TRUE then
    _Alarm_Error_WrongMessageNumber.SetInActive(); 
  end_if;
  
  if _Alarm_Error_NavitrolError.ResetReq = TRUE then
    _Alarm_Error_NavitrolError.SetInActive(); 
  end_if;
  
  if _Alarm_Error_NoCommunication.ResetReq = TRUE then
    _Alarm_Error_NoCommunication.SetInActive(); 
  end_if;  

END_FUNCTION
