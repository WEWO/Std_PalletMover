//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)

//{{LSL_DEFINES
#define MQTTCLIENTINTERFACE_MAX_XMLNAME_LEN         255
#define MQTTCLIENTINTERFACE_INIT_CYCLE              MQTTCLIENT_INIT_CYCLE
#define MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK     MQTTCLIENT_DEFAULT_MALLOC_MARK
#define MQTTCLIENTINTERFACE_PUB_MID_INITVAL         1
#define MQTTCLIENTINTERFACE_PUB_MID_ROLLOVER        MQTTCLIENTINTERFACE_PUB_MID_INITVAL + 5000
#define MQTTCLIENTINTERFACE_SUB_MID_INITVAL         5000 + 1
#define MQTTCLIENTINTERFACE_SUB_MID_ROLLOVER        MQTTCLIENTINTERFACE_SUB_MID_INITVAL + 5000
#define MQTTCLIENTINTERFACE_APPLID_ROLLOVER         10000
#define MQTTCLIENTINTERFACE_APPLID_INITVAL          1

//Topic Comparison
#define MQTTCLIENTINTERFACE_TOPIC_WC_SINGLE             16#2B 
#define MQTTCLIENTINTERFACE_TOPIC_WC_MULTI              16#23 
#define MQTTCLIENTINTERFACE_TOPIC_SEPARATOR             16#2F 

//Timeouts
#define MQTTCLIENTINTERFACE_XML_MAX_READ_TIME           5secs
#define MQTTCLIENTINTERFACE_CONNECT_TIMEOUT             10secs
#define MQTTCLIENTINTERFACE_DATAMAP_SUB_TIMEOUT         500
#define MQTTCLIENTINTERFACE_DATAMAP_PUB_TIMEOUT         500
#define MQTTCLIENTINTERFACE_DATAMAP_DEFAULT_RESET       1000
#define MQTTCLIENTINTERFACE_DEFAULT_AUTORESET_TIME      1000

//Diagnostic
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_ERROR_CHECK_INTERVAL         2secs
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALCINTERVAL         1secs
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG             10
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_COMDIAG_ID           10000
//These defines must match those in ComDiagnosis_MQTT
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_COMDIAG_RESET        0
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_CONNECTCOUNT     1
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_CONNECTFAILCNT   2
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_RETRYCOUNT       3
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_WATCHDOGCOUNT    4
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_ACTERRORCODE     5   //Not Used
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_LASTERRORCODE    6   //Last Non Successful Return Value from MQTTClient
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_ERRORCNT         7   //Number of non successful returns from MQTTClient
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_READCNT          8   //Number of Subscribe Requests
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_READERRORCNT     9   //Number of Subscribe Failures
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_WRITECNT         10  //Number of Publish Requests
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_WRITEERRORCNT    11  //Number of Publish Failures
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_UNSUBSCRIBES     50  //Number of Unsubscribe Requests
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_UNSUBFAILS       51  //Number of Unsubscribe Failures
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_PUBSUBENTRIES    52  //Number of PubSub List Entries
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_LOGCOUNT         53  //Number of Logs Made
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_PINGREQSENT      54  //Number of PINGREQ Sent
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_PINGRESPREC      55  //Number of PINGRESP Received
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS0_PUB         56  //Number of QOS0 Publish Messages
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS1_PUB         57  //Number of QOS1 Publish Messages
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS2_PUB         58  //Number of QOS2 Publish Messages
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS0_SUB         59  //Number of QOS0 Subscribe Messages
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS1_SUB         60  //Number of QOS1 Subscribe Messages
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS2_SUB         61  //Number of QOS2 Subscribe Messages
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_DM_ELEMENTS      62  //Number of Datamap Entries
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_TX_RATE          63  //TX Rate
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_RX_RATE          64  //RX Rate
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_RX_BYTES         65  //Total RX Bytes
#define MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_TX_BYTES         66  //Total TX Bytes

//======================================================================
//-----------------------------PUBSUBLIST-------------------------------
//======================================================================
#define MQTTCLIENTINTERFACE_NUM_PUBSUB_ELEMENTS           128
#define MQTTCLIENTINTERFACE_PUBSUB_TOPIC_MAX_LEN          MQTTCLIENT_TOPIC_MAX_LEN

//======================================================================
//------------------------------LOGGING---------------------------------
//======================================================================
//Config
#define MQTTCLIENTINTERFACE_LOG_MQTTCLIENT_MSGGRP           0
#define MQTTCLIENTINTERFACE_LOG_MQTTCLIENT_MSGNBR           1
#define MQTTCLIENTINTERFACE_LOG_MQTTCLIENTINTERFACE_MSGGRP  1
#define MQTTCLIENTINTERFACE_LOG_MQTTDATAMAP_MSGGRP          2
#define MQTTCLIENTINTERFACE_LOG_MQTTXML_MSGGRP              3
#define MQTTCLIENTINTERFACE_LOG_MQTTTOPIC_MSGGRP            4

#define MQTTCLIENTINTERFACE_COMLOGGING_ID                   6
#define MQTTCLIENTINTERFACE_LOG_ENVVAR_FILE                 "LOGLEVEL_MQTT_FILE"
#define MQTTCLIENTINTERFACE_LOG_ENVVAR_EVENTLOG             "LOGLEVEL_MQTT_EVENTLOG"

//Entries
#define MQTTCLIENTINTERFACE_LOG_ERR_NBR_MQCLILOGFAILED_WRONG_ID     1
#define MQTTCLIENTINTERFACE_LOG_ERR_TXT_MQCLILOGFAILED_WRONG_ID     "Failed to create Log passed from MQTTClient, Incorrect ID Passed. See Log Parameter for ID Passed."
#define MQTTCLIENTINTERFACE_LOG_ERR_NBR_MQCLILOGFAILED_NO_TXT       2
#define MQTTCLIENTINTERFACE_LOG_ERR_TXT_MQCLILOGFAILED_NO_TXT       "Failed to create Log passed from MQTTClient, No Text Passed."
#define MQTTCLIENTINTERFACE_LOG_INFO_NBR_MQCLIACTIVATED             3
#define MQTTCLIENTINTERFACE_LOG_INFO_TXT_MQCLIACTIVATED             "MQTTClient_Interface has been activated."

#define MQTTCLIENTINTERFACE_LOG_ERROR_XML_CONFIG_XML_TXT  "Interpreting ClientID Section of XML File Failed."
#define MQTTCLIENTINTERFACE_LOG_ERROR_XML_CONFIG_XML_LST  0

//======================================================================
//------------------------------DataMap---------------------------------
//======================================================================
#define MQTTCLIENTINTERFACE_DATAMAP_MAXNUM_PUBLISH_ELEMENTS       25
#define MQTTCLIENTINTERFACE_DATAMAP_MAXNUM_SUBSCRIBE_ELEMENTS     25
#define MQTTCLIENTINTERFACE_DATAMAP_TOPIC_NAME_MAX_LEN            255
#define MQTTCLIENTINTERFACE_DATAMAP_ELEMENT_MAX_LEN               512
#define MQTTCLIENTINTERFACE_DATAMAP_TOPIC_MAX_LEN                 MQTTCLIENT_TOPIC_MAX_LEN
#define MQTTCLIENTINTERFACE_DATAMAP_DATALEN_DINT                  4
#define MQTTCLIENTINTERFACE_DATAMAP_DATALEN_UDINT                 4
#define MQTTCLIENTINTERFACE_DATAMAP_DATALEN_REAL                  4
#define MQTTCLIENTINTERFACE_DATAMAP_SERVER_DATA_OFFSET            4
#define MQTTCLIENTINTERFACE_DATAMAP_CRCCALC_INITVAL               0

//======================================================================
//--------------------XML Headings & Test Values------------------------
//======================================================================
//Root Element
#define MQTTCLIENT_INT_XML_FIRST_ELEMENT_NAME   "MQTTCLIENT"
  #define MQTTCLIENT_INT_XML_FIRST_ELEMENT_MAX_LEN  12

  #define MTTCLIENT_INT_XML_CONFIG_DATAMAP_MAX_LEN  8
  
  //-- Config
  #define MTTCLIENT_INT_XML_CONFIG_ELEMENT        "CONFIG"
    #define MQTTCLIENT_INT_XML_CONFIG_MAX_LEN       13
    #define MQTTCLIENT_INT_XML_CONFIG_CLIENTID      "CLIENTID"
  
    //-- Config -> Connection
    #define MQTTCLIENT_INT_XML_CONFIG_CONNECTION    "CONNECTION"
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_MAX_LEN      22
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_HOSTNAME     "HOSTNAME"
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_PORT         "PORT"
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_KEEPALIVE    "KEEPALIVE"
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_MAXINFLIGHT  "MAX_INFLIGHT_MESSAGES"
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_USERNAME     "USERNAME"
      #define MQTTCLIENT_INT_XML_CONFIG_CONN_PASSWORD     "PASSWORD"
      
    //-- Config -> Will
    #define MQTTCLIENT_INT_XML_CONFIG_WILL                  "WILL"
      #define MQTTCLIENT_INT_XML_CONFIG_WILL_MAX_LEN          12
      #define MQTTCLIENT_INT_XML_CONFIG_WILL_TOPIC            "TOPIC"
      #define MQTTCLIENT_INT_XML_CONFIG_WILL_PLTEXT           "PAYLOADTEXT"
      #define MQTTCLIENT_INT_XML_CONFIG_WILL_QOS              "QOS" 
        #define MQTTCLIENT_INT_XML_CONFIG_WILL_QOS_0            '0' 
        #define MQTTCLIENT_INT_XML_CONFIG_WILL_QOS_1            '1' 
        #define MQTTCLIENT_INT_XML_CONFIG_WILL_QOS_2            '2' 
      #define MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN           "RETAIN"
        #define MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN_TRUE      '1' 
        #define MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN_FALSE     '0' 
        #define MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN_MAXLEN    1
        
    //-- Config -> Reconnection
    #define MQTTCLIENT_INT_XML_CONFIG_RECONNECTION  "RECONNECTION"
      #define MQTTCLIENT_INT_XML_CONFIG_RECONN_MAXLEN     18
      #define MQTTCLIENT_INT_XML_CONFIG_RECONN_MININT     "MIN_INTERVAL"
      #define MQTTCLIENT_INT_XML_CONFIG_RECONN_MAXINT     "MAX_INTERVAL"
      #define MQTTCLIENT_INT_XML_CONFIG_RECONN_EXPSCALE   "EXPONENTIAL_SCALE"
        #define MQTTCLIENT_INT_XML_CONFIG_RECONNECT_EXP_ON  "1"
    
    //-- Config -> TLS
    #define MQTTCLIENT_INT_XML_CONFIG_TLS           "TLS"
      #define MQTTCLIENT_INT_XML_CONFIG_TLS_MAXLEN        9
      #define MQTTCLIENT_INT_XML_CONFIG_TLS_CAFILE        "CAFILE"
      #define MQTTCLIENT_INT_XML_CONFIG_TLS_CERTFILE      "CERTFILE"
      #define MQTTCLIENT_INT_XML_CONFIG_TLS_KEYFILE       "KEYFILE"
      #define MQTTCLIENT_INT_XML_CONFIG_TLS_PW            "PW"
    
    //-- Config -> LOGGING
    #define MQTTCLIENT_INT_XML_CONFIG_LOGGING       "LOGGING"
      #define MQTTCLIENT_INT_XML_CONFIG_LOG_MAX_LEN       10
      #define MQTTCLIENT_INT_XML_CONFIG_LOG_INFO          "INFO"
      #define MQTTCLIENT_INT_XML_CONFIG_LOG_NOTICE        "NOTICE"
      #define MQTTCLIENT_INT_XML_CONFIG_LOG_WARNING       "WARNING"
      #define MQTTCLIENT_INT_XML_CONFIG_LOG_ERROR         "ERROR"
      #define MQTTCLIENT_INT_XML_CONFIG_LOG_DEBUGGING     "DEBUGGING"
        #define MQTTCLIENT_INT_XML_CONFIG_LOG_ON          '1'
        #define MQTTCLIENT_INT_XML_CONFIG_LOG_OFF         '0'
      
  //-- DataMap
  #define MTTCLIENT_INT_XML_DATAMAP_ELEMENT       "DATAMAP"
    #define MQTTCLIENT_INT_XML_DATAMAP_TOPIC_DIVIDER  "/"
    #define MQTTCLIENT_INT_XML_DATAMAP_TOPIC_SECT_END_MAX_LEN 14
    #define MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION   "TOPICSECTION"
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECLEN   255
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECDEPTH 20
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_ATTR_MAX_LEN  5
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_ATTR_NAME     "NAME"
    #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT  "TOPICENDPOINT"
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_MAX_ATTRS        7
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_NAME_MAX_LEN     MQTTCLIENTINTERFACE_DATAMAP_TOPIC_NAME_MAX_LEN
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN  MQTTCLIENTINTERFACE_DATAMAP_ELEMENT_MAX_LEN
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_MAX_LEN     10
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_NAME        "NAME"
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_ELEMENT     "ELEMENT"
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_OPERATION   "OPERATION"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_MAX_LEN    10
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_POLL       "POLL"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_CHANGE     "CHANGE"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_SUBSCRIBE  "SUBSCRIBE"
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_INTERVAL    "INTERVAL"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_INTERVAL_MAX_LEN  10
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_DATATYPE    "DATATYPE"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_MAXLEN  13
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_DINT    "DINT"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_UDINT   "UDINT"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_REAL    "REAL"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_STRING  "STRING"
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_QOS         "QOS"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_QOS_MAX_LEN  1
      #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_RETAIN      "RETAIN"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_RETAIN_MAX_LEN  5
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_MAX_LEN     6
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_TRUE       "TRUE"
        #define MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_FALSE      "FALSE"
      
  
//XML Data Lengths
#define MQTTCLIENTINTERFACE_CONNECT_HOSTNAME_MAX_LEN    (MQTTCLIENT_HOSTNAME_MAX_LEN)
#define MQTTCLIENTINTERFACE_CONNECT_PORT_MAX_LEN        6
#define MQTTCLIENTINTERFACE_CONNECT_KEEPALIVE_MAX_LEN   6
#define MQTTCLIENTINTERFACE_CONNECT_INFLIGHT_MAX_LEN    6
#define MQTTCLIENTINTERFACE_CONNECT_USERNAME_MAX_LEN    (MQTTCLIENT_CONNECT_MAX_USERNAME_LEN)
#define MQTTCLIENTINTERFACE_CONNECT_PASSWORD_MAX_LEN    (MQTTCLIENT_CONNECT_MAX_PASSWORD_LEN)

#define MQTTCLIENTINTERFACE_WILL_TOPIC_MAX_LEN          (MQTTCLIENT_WILL_TOPIC_MAX_LEN)
#define MQTTCLIENTINTERFACE_WILL_PAYLOAD_MAX_LEN        (MQTTCLIENT_WILL_PAYLOAD_MAX_LEN)
#define MQTTCLIENTINTERFACE_WILL_QOS_MAX_LEN            1 // 0 / 1 / 2

#define MQTTCLIENTINTERFACE_RECONNECT_MININT_MAX_LEN    6
#define MQTTCLIENTINTERFACE_RECONNECT_MAXINT_MAX_LEN    6

#define MQTTCLIENTINTERFACE_TLS_CAFILE_MAX_LEN          (MQTTCLIENT_CONNECT_MAX_FILENAME_LEN)
#define MQTTCLIENTINTERFACE_TLS_CERTFILE_MAX_LEN        (MQTTCLIENT_CONNECT_MAX_FILENAME_LEN)
#define MQTTCLIENTINTERFACE_TLS_KEYFILE_MAX_LEN         (MQTTCLIENT_CONNECT_MAX_FILENAME_LEN)
#define MQTTCLIENTINTERFACE_TLS_PASSWORD_MAX_LEN        (MQTTCLIENT_CONNECT_MAX_PASSWORD_LEN)

#define MQTTCLIENTINTERFACE_LOG_ON_OFF_MAX_LEN          1 // 0 / 1
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO          (MQTT_LOG_INFO)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_NOTICE        (MQTT_LOG_NOTICE)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING       (MQTT_LOG_WARNING)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR           (MQTT_LOG_ERR)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG         (MQTT_LOG_DEBUG)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_SUBSCRIBE     (MQTT_LOG_SUBSCRIBE)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_UNSUBSCRIBE   (MQTT_LOG_UNSUBSCRIBE)
#define MQTTCLIENTINTERFACE_LOGGING_LEVEL_WEBSOCKETS    (MQTT_LOG_WEBSOCKETS)
//}}LSL_DEFINES

//{{LSL_DECLARATION
#include "..\..\Class\MQTTClient_Interface\MQTTClientInterface_LogTexts.h"

(*!
<Class
	Name               = "MQTTClient_Interface"
	Revision           = "1.16"
	GUID               = "{EAFFEB12-3380-4E80-8A57-A2D335332499}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	DefCyclictime      = "10 ms"
	BackgroundTask     = "false"
	Sigmatek           = "true"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	IconPath           = ".\Class\MQTTClient_Interface\mqtt.ico"
	SharedCommandTable = "true"
	Objectsize         = "(716,120)"
	Comment            = "Interface for the MQTT Client.&#13;&#10;&#13;&#10;This class allows the MQTTClient class to be easily integrated in the Application.&#13;&#10;&#13;&#10;It Provides:&#13;&#10;1. Easy Configuration (XML + MQTTClient_Interface_Config)&#13;&#10;2. Logging&#13;&#10;3. Application Integration (DataMap Server Read / Write, MQTTTopic Class integration)">
	<Channels>
		<Server Name="CleanSession" GUID="{C18AFCAD-38FB-4033-BFD6-4168B4A89B83}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="This class is an MQTT Client that provides the ability to connect to an MQTT Broker using:&#13;&#10;1. TCP&#13;&#10;2. Encrypted TCP (SSL / TLS)&#13;&#10;&#13;&#10;The Class also provides the ability to publish and subscribe to topics.&#13;&#10;&#13;&#10;The user can use the class alone or use the MQTTClientInterface class that already contains an object of this MQTTClient class with an easy to use interface."/>
		<Server Name="ClientActive" GUID="{C586BEAE-0F1A-436B-AAC1-F19C679CA0C3}" Visualized="true" Initialize="true" DefValue="1" WriteProtected="false" Retentive="false" Comment="0...Deactivate client&#13;&#10;1...Activate client."/>
		<Server Name="ClientID" GUID="{A911CB23-DD61-4B45-AEB5-41020711CB09}" Visualized="true" Initialize="true" WriteProtected="false" Retentive="false" Comment="ClientID of the MQTTClient Interface, String function can be accessed using this Object Channel."/>
		<Server Name="ComDiagnosis" GUID="{58464FFE-E68A-47FA-96C5-AC64E83F2441}" Visualized="false" Initialize="false" WriteProtected="true" Retentive="false" Comment="Server to connect the Command Channel of the ComDiagnosis_MQTT object.&#13;&#10;This server contains the required NewInst() Methods for the functioning of the Object."/>
		<Server Name="InterfaceState" GUID="{CA465FA0-7FF1-4F67-89EB-A7C063632081}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Shows the current state of the MQTTClient_Interface."/>
		<Server Name="Reset" GUID="{B37A7FE5-AB4B-4959-9086-0B482248BB3B}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false" Comment="Set to 1 to reset the class from the error state. Class will be reinitialised. "/>
		<Server Name="SessionPresent" GUID="{114FAE7E-B0BE-4025-93EB-C6835F25C19A}" Visualized="true" Initialize="false" WriteProtected="true" Retentive="false" Comment="Indicates whether the Broker acknowledged the existence of a session with this client.&#13;&#10;The ClientID is used for session identification and must therefor be unique on the MQTT Broker."/>
		<Server Name="XMLFilename" GUID="{3131C681-AFEA-46D1-850B-0962CD43195B}" Class="String" Visualized="true" Initialize="true" DefValue="&quot;C:/MQTT_Client.xml&quot;" WriteProtected="false" Retentive="false" Comment="String used to store the XML File Name String, this string must be initialised and will be used when reading the XML File for setup."/>
		<Client Name="_ComLogging" Required="true" Internal="true"/>
		<Client Name="_XMLReader" Required="true" Internal="true"/>
		<Client Name="cActivateTrace" Required="false" Internal="false" Comment="Client to specify whether logging messages must be forwarded to the Trace Message System of LASAL Class 2."/>
		<Client Name="cAutoResetTime" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_DEFAULT_AUTORESET_TIME" Comment="If the value on this client is not 0, the MQTTClient_Interface will automatically reset after the specified time in case of an error occurring.&#13;&#10;Specified in mS."/>
		<Client Name="cConnectTimeout" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_CONNECT_TIMEOUT" Comment="Connection timeout.&#13;&#10;Specified in mS."/>
		<Client Name="cDataMapPubTimeout" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_DATAMAP_PUB_TIMEOUT" Comment="Timeout for the publish procedure of the interface.&#13;&#10;Specified in mS."/>
		<Client Name="cDataMapResetTimeout" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_DATAMAP_DEFAULT_RESET" Comment="Client is used to set the DataMap reset time. If an error occurs in a DataMap element, the timout specified on this client will be used to automatically reset the element.&#13;&#10;Specified in mS."/>
		<Client Name="cDataMapSubTimeout" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_DATAMAP_SUB_TIMEOUT" Comment="Timeout for the subscribe procedure of the interface.&#13;&#10;Specified in mS."/>
		<Client Name="cEventLog" Required="false" Internal="false" Comment="Command Channel to the EventLog class, this client is forwarded from the Internal _ComLogging class."/>
		<Client Name="cLogConfig" Required="true" Internal="false" DefValue="0" Comment="This client shows the actual logging configuration.&#13;&#10;&#13;&#10;Logging information can be:&#13;&#10;1. Initialised on this client.&#13;&#10;2. Configured by XML.&#13;&#10;"/>
		<Client Name="CriticalSection" Required="true" Internal="true"/>
		<Client Name="cUseXML" Required="true" Internal="false" DefValue="1"/>
		<Client Name="DataMapEntries" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_DATAMAP_MAXNUM_PUBLISH_ELEMENTS " Comment="The value on this client indicates the amount of entries allowed for both the Publish and Subscribe DataMap entries.&#13;&#10;The value must be initialised and can be set to a minimum of MQTTCLIENTINTERFACE_DATAMAP_MAXNUM_PUBLISH_ELEMENTS (see Class Defines)."/>
		<Client Name="MQTTClient" Required="true" Internal="true"/>
		<Client Name="OpenSSL" Required="false" Internal="false"/>
		<Client Name="PubSubEntries" Required="true" Internal="false" DefValue="MQTTCLIENTINTERFACE_NUM_PUBSUB_ELEMENTS" Comment="The value on this client indicates the amount of entries allowed in the Publich and Subscribe list, this is the total amount of topics that can be Subscribed / Published to.&#13;&#10;The value must be initialised and can be set to a minimum of MQTTCLIENTINTERFACE_NUM_PUBSUB_ELEMENTS(see Class Defines)."/>
		<Client Name="SigCLib" Required="false" Internal="false" Comment="Object channel to the class SigCLib. Must not be connected."/>
		<Client Name="Stdlib" Required="false" Internal="false" Comment="Object channel to the class _StdLib. Must not be connected."/>
		<Client Name="XMLFilenameString" Required="true" Internal="true"/>
	</Channels>
	<Dependencies>
		<Files>
			<File Path=".\Class\MQTTClient_Interface\MQTTClientInterface_LogTexts.h" Include="true"/>
			<File Path=".\Class\MQTTClient_Interface\MQTTClient_Interface_en.pdf"/>
			<File Path=".\Class\MQTTClient_Interface\MQTTClient_Interface_de.pdf"/>
		</Files>
	</Dependencies>
	<RevDoku>
		<Owner Company="Sigmatek" Author="VelGer"/>
		<Dokumentation Revision="1.16" Date="2021-06-01" Author="MehMar&#13;&#10;VelGer" Company="Sigmatek" Description="1. BugFix: When the connection is lost but the socket is not closed, the message queue builds up and is not emptied anymore.&#13;&#10;2. BugFix: The SessionPresent Information was not processed correctly, this has been corrected."/>
		<Dokumentation Revision="1.15" Date="2021-03-25" Author="VelGer" Company="Sigmatek" Description="1. BugFix: The &quot;onchange&quot; functionality of the DataMap always published 4-Byte values after adding them, even if they did not change, this has been corrected.&#13;&#10;2. BugFix: Empty strings will be sent correctly according to the specification."/>
		<Dokumentation Revision="1.14" Date="2021-01-15" Author="VelGer" Company="Sigmatek" Description="1. Special: Class Description updated."/>
		<Dokumentation Revision="1.13" Date="2020-11-25" Author="MehMar" Company="Sigmatek" Description="1. Improvement: It is now possible to send OnChange DataMap Entries either immediately after adding, or to wait for the first change in the value before sending.&#13;&#10;2. Improvement: It is now possible to set the username and the password via the interface.&#13;&#10;3. Improvement: Connection is possible with X.509 certificates.&#13;&#10;4. Bugfix: If the DataMap detected a change in a value (Element set to OnChange) and the publishing of the value failed, publishing was not retried, therefore publishes could be missed. This has been corrected."/>
		<Dokumentation Revision="1.12" Date="2020-04-21" Author="VelGer" Company="Sigmatek" Description="1. Improvement: The ability to read a unique error code for each event message has been added. To this goal the methods Logging_GetLastXXXXEvent() have been created.&#13;&#10;2. BugFix: Logging Texts were reworked to be Uniform throughout the MQTT Package.&#13;&#10;3. Special: Comments and indentation has generally been improved."/>
		<Dokumentation Revision="1.11" Date="2020-03-11" Author="VelGer" Company="Sigmatek" Description="1. Improvement: Wildcards (Single- (+) and Multilayer (#)) in Subscriptions are now matched to their respective PubSub elements, thus the Application can now Subscribe to topics using Wildcards and receive the respective ublish Messages.&#13;&#10;2. BugFix: In the DataMap, if a 4-Byte Server was set to Poll, the Read method was never called, the result was that the sent value was always 0. This has been corrected."/>
		<Dokumentation Revision="1.1" Date="2020-02-17" Author="VelGer" Company="Sigmatek" Description="1. BugFix: DataMap and PubSub lists are now handled dynmically (sizes of each can be initialised on the Clients &quot;DataMapEntries&quot; and &quot;PubSubEntries&quot;).&#13;&#10;2. BugFix: Read &amp; Write methods of Servers that are accessed by the DataMap are now triggered.&#13;&#10;3. Improvement: Default timeouts have been changed to larger values.&#13;&#10;4. BugFix: DataMap - When adding a new entry it is now checked if the element datatype and pointer channel type match for both Strings and Servers (Server = Server, String = Object).&#13;&#10;5. BugFix: MemoryHandling has been reworked in conjunction with the PacketQueue and MQTTClient Classes.&#13;&#10;6. BugFix: Artificial dependencies have been created so that classes that are called via callback (and are thus dependenies) are also copied if only this class is imported.&#13;&#10;7. Improvement: XML File Interpretation is now not case sensitive anymore."/>
		<Dokumentation Revision="1.0" Date="2019-03-13" Author="VelGer" Company="Sigmatek" Description="Initial Version"/>
	</RevDoku>
	<Network Name="MQTTClient_Interface">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name           = "_ComLogging"
				GUID           = "{9A7F0F4D-7E54-429E-B330-8A776E39893F}"
				Class          = "_ComLogging"
				Position       = "(270,1590)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "500 ms">
				<Channels>
					<Server Name="Category" Value="MQTT_PROT_PROTNAME"/>
					<Server Name="DebugCnt"/>
					<Server Name="Env_EventLogLevelName" Value="MQTTCLIENTINTERFACE_LOG_ENVVAR_EVENTLOG"/>
					<Server Name="Env_FileLogLevelName" Value="MQTTCLIENTINTERFACE_LOG_ENVVAR_FILE"/>
					<Server Name="ErrorCnt"/>
					<Server Name="EventLogLevel"/>
					<Server Name="FileLogLevel"/>
					<Server Name="Flush"/>
					<Server Name="InfoCnt"/>
					<Server Name="InitOK"/>
					<Server Name="LogFlushInterval" Value="USERLOGGING_LOGFLUSH_INTERVAL"/>
					<Server Name="WarningCnt"/>
					<Client Name="cActivateTrace" Value="0"/>
					<Client Name="cEventLog"/>
					<Client Name="cLogBufferSize" Value="USERLOGGING_DEFAULTLOGSIZE"/>
					<Client Name="cLogFileID" Value="MQTTCLIENTINTERFACE_COMLOGGING_ID"/>
					<Client Name="SigCLib"/>
					<Client Name="SysMsg"/>
				</Channels>
			</Object>
			<Object
				Name           = "_XMLReader"
				GUID           = "{565290D4-7475-49AB-952E-22477F2859D0}"
				Class          = "_XMLReader"
				Position       = "(390,960)"
				Visualized     = "true"
				Remotely       = "true"
				BackgroundTime = "100 ms">
				<Channels>
					<Server Name="ClassSvr"/>
					<Server Name="DoConvert"/>
					<Server Name="ErrorLine"/>
					<Server Name="ErrorSign"/>
					<Server Name="ErrorState"/>
					<Server Name="XmlState"/>
					<Client Name="CreateTask" Value="0"/>
					<Client Name="FileSys"/>
					<Client Name="MultiTask"/>
					<Client Name="SigCLib"/>
					<Client Name="StdLib"/>
				</Channels>
			</Object>
			<Object
				Name       = "CriticalSection"
				GUID       = "{2539BBC9-2C4A-4E9E-87F3-D8239FDAD084}"
				Class      = "CriticalSection"
				Position   = "(1380,1020)"
				Visualized = "false">
				<Channels>
					<Server Name="ClassSvr"/>
				</Channels>
			</Object>
			<Object
				Name       = "MQTTClient"
				GUID       = "{01311C4D-E41C-4AFE-9168-DFC1B2009BAC}"
				Class      = "MQTTClient"
				Position   = "(300,210)"
				Visualized = "true"
				Remotely   = "true"
				CyclicTime = "1 ms">
				<Channels>
					<Server Name="CleanSession"/>
					<Server Name="ClientID"/>
					<Server Name="MQTTClientState"/>
					<Server Name="SessionPresent"/>
					<Client Name="cConnectTimeout" Value="MQTTCLIENT_CONNECT_TIMEOUT"/>
					<Client Name="cDisconnectTimeout" Value="MQTTCLIENT_DISCONNECT_SEND_TIMEOUT"/>
					<Client Name="cMultitaskEnable" Value="MQTTCLIENT_DEFAULT_MULTITASK_ENABLE"/>
					<Client Name="cPacketReceiveWatchdog" Value="MQTTCLIENT_TCP_RECEIVE_WATCHDOG"/>
					<Client Name="cPacketRetryCount" Value="MQTTCLIENT_MAX_RERTYCOUNT"/>
					<Client Name="cPublishTimeout" Value="MQTTCLIENT_PUBLISH_TIMEOUT"/>
					<Client Name="cSubscribeTimeout" Value="MQTTCLIENT_SUBSCRIBE_TIMEOUT"/>
					<Client Name="cUnsubscribeTimeout" Value="MQTTCLIENT_UNSUBSCRIBE_TIMEOUT"/>
					<Client Name="Multitask"/>
					<Client Name="SigCLib"/>
					<Client Name="Stdlib"/>
				</Channels>
			</Object>
			<Object
				Name       = "XMLFilenameString"
				GUID       = "{AC1D33DD-B2B0-448D-BD60-3774E6150A04}"
				Class      = "String"
				Position   = "(450,1440)"
				Visualized = "true"
				Remotely   = "true">
				<Channels>
					<Server Name="Data" Value="&quot;C:/MQTT_Client.xml&quot;"/>
					<Client Name="SingleRealloc" Value="1"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.MQTTClient" Destination="MQTTClient.MQTTClientState"/>
			<Connection Source="this.ClientID" Destination="MQTTClient.ClientID" Vertices="(1852,270),(1230,270),(1200,300),(1200,330),(1170,360),(1088,360),"/>
			<Connection Source="MQTTClient.SigCLib" Destination="this.SigCLib" Vertices="(300,420),(270,420),(240,390),(240,240),(210,210),(38,210),"/>
			<Connection Source="MQTTClient.Stdlib" Destination="this.Stdlib" Vertices="(300,480),(240,480),(210,450),(210,300),(180,270),(38,270),"/>
			<Connection Source="this._XMLReader" Destination="_XMLReader.ClassSvr"/>
			<Connection Source="_XMLReader.SigCLib" Destination="this.SigCLib" Vertices="(390,1170),(270,1170),(240,1140),(240,240),(210,210),(38,210),"/>
			<Connection Source="_XMLReader.StdLib" Destination="this.Stdlib" Vertices="(390,1110),(240,1110),(210,1080),(210,300),(180,270),(38,270),"/>
			<Connection Source="this.XMLFilenameString" Destination="XMLFilenameString.Data"/>
			<Connection Source="this.XMLFilename" Destination="XMLFilenameString.Data" Vertices="(1852,510),(1200,510),(1170,540),(1170,1500),(1140,1530),(1186,1530),"/>
			<Connection Source="this._ComLogging" Destination="_ComLogging.InitOK"/>
			<Connection Source="this.CleanSession" Destination="MQTTClient.CleanSession" Vertices="(1852,390),(1200,390),(1170,420),(1088,420),"/>
			<Connection Source="this.SessionPresent" Destination="MQTTClient.SessionPresent" Vertices="(1852,450),(1200,450),(1170,480),(1088,480),"/>
			<Connection Source="_ComLogging.cEventLog" Destination="this.cEventLog" Vertices="(270,1680),(210,1680),(180,1650),(180,840),(150,810),(38,810),"/>
			<Connection Source="_ComLogging.cActivateTrace" Destination="this.cActivateTrace" Vertices="(270,1920),(180,1920),(150,1890),(150,900),(120,870),(38,870),"/>
			<Connection Source="this.CriticalSection" Destination="CriticalSection.ClassSvr"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
MQTTClient_Interface : CLASS
	TYPE
	  t_bd_IsConnected : BDINT
	  [
	    1 LogConfig,
	    2 PubTimeout,
	    3 SubTimeout,
	    4 ConnTimeout,
	    5 UseXML,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  t_bd_LogConfig : BDINT  //! <Type Public="true" Name="t_bd_LogConfig"/>
	  [
	    1 Log_Info,
	    2 Log_Notice,
	    3 Log_Warning,
	    4 Log_Error,
	    5 Log_Debug,
	    6 Log_Subscribe,
	    7 Log_Unsubscribe,
	    8 Log_WebSockets,
	    9 Bit9,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 Bit31,
	    32 Bit32,
	  ];
	  t_e_ConfigObjectEntries :
	  (
	    CO_ClientID,
	    CO_ConnectionDetails,
	    CO_MaxInflightMessages,
	    CO_Authentication,
	    CO_Will,
	    CO_Reconnection,
	    CO_TLS
	  )$UDINT;
	  t_e_ConfigParameters :  //! <Type Public="true" Comment="Enumeration containing the possible settings that can be made, see the comment of the individual settings for further information." Name="t_e_ConfigParameters"/>
	  (
	    CP_DataMap_SendOnAdd  //! <Type Comment="For Elements with send event set to OnChange:&#13;&#10;This value indicates whether the DataMap Element is sent automatically when added or not.&#13;&#10;This means, when active the Element will always be sent when added to the DataMap (also at Application restart), if not active the DataMap waits for the first change before sending the element.&#13;&#10;&#13;&#10;NOTE: This setting can only be made after the DataMap memory has been initialized, the memory initialization is performed in the init cycle described by the define MQTTCLIENT_INIT_CYCLE (default = 12 / _Firstscan).&#13;&#10;&#13;&#10;0 = Inactive (Default)&#13;&#10;1 = Active" Name="t_e_ConfigParameters.CP_DataMap_SendOnAdd"/>
	  )$UDINT;
	  t_e_DataMap_DataTypes :  //! <Type Public="true" Name="t_e_DataMap_DataTypes"/>
	  (
	    DD_Unknown,
	    DD_UDINT,
	    DD_DINT,
	    DD_REAL,
	    DD_String
	  )$UDINT;
	  t_e_DataMap_ElementTypes :  //! <Type Public="true" Name="t_e_DataMap_ElementTypes"/>
	  (
	    DM_Publish,
	    DM_Subscribe
	  )$UDINT;
	  t_e_DataMap_Operations :  //! <Type Public="true" Name="t_e_DataMap_Operations"/>
	  (
	    DO_Unknown,
	    DO_Poll,
	    DO_Change,
	    DO_Subscribe
	  )$UDINT;
	  t_e_DataMap_PublishStates :
	  (
	    DMPS_Ready,
	    DMPS_WaitForAction,
	    DMPS_Publish,
	    DMPS_WaitForPublish,
	    DMPS_Remove,
	    DMPS_Error
	  )$UDINT;
	  t_e_DataMap_RetainStates :
	  (
	    DRS_Unknown,
	    DRS_True,
	    DRS_False
	  )$UDINT;
	  t_e_DataMap_RetCode :  //! <Type Public="true" Name="t_e_DataMap_RetCode"/>
	  (
	    DM_OK:=0,
	    DM_TopicNameTooLong:=4294967295,
	    DM_ElementNameTooLong:=4294967294,
	    DM_ListFull:=4294967293,
	    DM_ElementNotFound:=4294967292,
	    DM_InputValueError:=4294967291
	  )$DINT;
	  t_e_DataMap_SubscribeStates :
	  (
	    DMSS_Ready,
	    DMSS_Subscribe,
	    DMSS_WaitForSubscribe,
	    DMSS_Subscribed,
	    DMSS_Unsubscribe,
	    DMSS_WaitForUnsubscribe:=5,
	    DMSS_Unsubscribed,
	    DMSS_Error:=7
	  )$UDINT;
	  t_e_DiagnosticLogTypes :
	  (
	    DL_Reset,
	    DL_Connect,
	    DL_ConnectFail,
	    DL_ConnectRetry,
	    DL_WatchdogTimeout,
	    DL_NotUsed,
	    DL_LastErrorCode,
	    DL_Error,
	    DL_SubRequest,
	    DL_SubFail,
	    DL_PubRequest,
	    DL_PubFail,
	    DL_UnsubRequest,
	    DL_UnsubFail,
	    DL_PubSubEntries,
	    DL_Log,
	    DL_PingReq,
	    DL_PingResp,
	    DL_Pub0,
	    DL_Pub1,
	    DL_Pub2,
	    DL_Sub0,
	    DL_Sub1,
	    DL_Sub2,
	    DL_DataMapEntries,
	    DL_TXRate,
	    DL_RXRate,
	    DL_RXBytes,
	    DL_TXBytes
	  )$UDINT;
	  t_e_MCSInit :
	  (
	    MCSI_Initialize,
	    MCSI_ReadXML,
	    MCSI_WaitForReadXML,
	    MCSI_PrepDataMap,
	    MCSI_ProcessXML,
	    MCSI_AppliConfig,
	    MCSI_Error
	  )$UDINT;
	  t_e_MQTTClientStates :  //! <Type Public="true" Name="t_e_MQTTClientStates"/>
	  (
	    MCIS_Ready:=0,
	    MCIS_Initialise:=1,
	    MCIS_Prepare,
	    MCIS_WaitForConnection,
	    MCIS_Reconnecting,
	    MCIS_Connected,
	    MCIS_Error
	  )$UDINT;
	  t_e_PubSubEntries :
	  (
	    PSE_Publish,
	    PSE_Subscribe
	  )$UDINT;
	  t_e_PubSubRetCodes :  //! <Type Public="true" Name="t_e_PubSubRetCodes"/>
	  (
	    PSRC_Subscribed,  //! <Type Comment="Subscribed to topic" Name="t_e_PubSubRetCodes.PSRC_Subscribed"/>
	    PSRC_Unsubscribed,  //! <Type Comment="Unsubscribed from topic" Name="t_e_PubSubRetCodes.PSRC_Unsubscribed"/>
	    PSRC_PublishReceived,  //! <Type Comment="Data received from subscribed topic." Name="t_e_PubSubRetCodes.PSRC_PublishReceived"/>
	    PSRC_Published,  //! <Type Comment="Data to topic published" Name="t_e_PubSubRetCodes.PSRC_Published"/>
	    PSRC_Disconnected  //! <Type Comment="MQTT Client was disconnected." Name="t_e_PubSubRetCodes.PSRC_Disconnected"/>
	  )$UDINT;
	  t_e_TaskRet :
	  (
	    TR_Busy,
	    TR_Done,
	    TR_Error
	  )$UDINT;
	  t_e_XML :
	  (
	    X_Unknown,
	    X_Config,
	    X_DataMap
	  )$UDINT;
	  t_e_XML_Config :
	  (
	    XC_Unknown,
	    XC_ClientID,
	    XC_Connection,
	    XC_Reconnection,
	    XC_TLS,
	    XC_Logging,
	    XC_Will
	  )$UDINT;
	  t_e_XML_Config_Conn :
	  (
	    XCC_Unknown,
	    XCC_hostname,
	    XCC_port,
	    XCC_keepalive,
	    XCC_max_inflight_messages,
	    XCC_username,
	    XCC_password
	  )$UDINT;
	  t_e_XML_DataMap :
	  (
	    XD_Unknown,
	    XD_TopicSection,
	    XD_TopicEndpoint
	  )$UDINT;
#pragma pack(push, 1)
	  t_s_ClientConfigData : STRUCT
	    Config : STRUCT
	      aClientID : ARRAY [0..MQTT_PROT_MAX_CLIENTID_NAME_LEN] OF UINT;
	      bClientIDSet : BOOL;
	      Connect : STRUCT
	        ValuesSet : BDINT
	        [
	          1 Hostname,
	          2 Port,
	          3 Keepalive,
	          4 MaxInflight,
	          5 Username,
	          6 Password,
	          7 Bit7,
	          8 Bit8,
	          9 Bit9,
	          10 Bit10,
	          11 Bit11,
	          12 Bit12,
	          13 Bit13,
	          14 Bit14,
	          15 Bit15,
	          16 Bit16,
	          17 Bit17,
	          18 Bit18,
	          19 Bit19,
	          20 Bit20,
	          21 Bit21,
	          22 Bit22,
	          23 Bit23,
	          24 Bit24,
	          25 Bit25,
	          26 Bit26,
	          27 Bit27,
	          28 Bit28,
	          29 Bit29,
	          30 Bit30,
	          31 Bit31,
	          32 Bit32,
	        ];
	        aHostname : ARRAY [0..MQTTCLIENT_HOSTNAME_MAX_LEN] OF UINT;
	        iPort : INT;
	        iKeepalive : INT;
	        iMaxInflightMessages : INT;
	        aUsername : ARRAY [0..MQTTCLIENTINTERFACE_CONNECT_USERNAME_MAX_LEN] OF UINT;
	        aPassword : ARRAY [0..MQTTCLIENTINTERFACE_CONNECT_PASSWORD_MAX_LEN] OF UINT;
	      END_STRUCT;
	      Will : STRUCT
	        ValuesSet : BDINT
	        [
	          1 Topic,
	          2 Payload,
	          3 QoS,
	          4 RetainWill,
	          5 Bit5,
	          6 Bit6,
	          7 Bit7,
	          8 Bit8,
	          9 Bit9,
	          10 Bit10,
	          11 Bit11,
	          12 Bit12,
	          13 Bit13,
	          14 Bit14,
	          15 Bit15,
	          16 Bit16,
	          17 Bit17,
	          18 Bit18,
	          19 Bit19,
	          20 Bit20,
	          21 Bit21,
	          22 Bit22,
	          23 Bit23,
	          24 Bit24,
	          25 Bit25,
	          26 Bit26,
	          27 Bit27,
	          28 Bit28,
	          29 Bit29,
	          30 Bit30,
	          31 Bit31,
	          32 Bit32,
	        ];
	        aTopic : ARRAY [0..MQTTCLIENTINTERFACE_WILL_TOPIC_MAX_LEN] OF UINT;
	        aPayload : ARRAY [0..MQTTCLIENTINTERFACE_WILL_PAYLOAD_MAX_LEN] OF CHAR;
	        iQoS : INT;
	        bRetain : BOOL;
	      END_STRUCT;
	      Reconnect : STRUCT
	        ValuesSet : BDINT
	        [
	          1 MinInterval,
	          2 MaxInterval,
	          3 ExponentialScale,
	          4 Bit4,
	          5 Bit5,
	          6 Bit6,
	          7 Bit7,
	          8 Bit8,
	          9 Bit9,
	          10 Bit10,
	          11 Bit11,
	          12 Bit12,
	          13 Bit13,
	          14 Bit14,
	          15 Bit15,
	          16 Bit16,
	          17 Bit17,
	          18 Bit18,
	          19 Bit19,
	          20 Bit20,
	          21 Bit21,
	          22 Bit22,
	          23 Bit23,
	          24 Bit24,
	          25 Bit25,
	          26 Bit26,
	          27 Bit27,
	          28 Bit28,
	          29 Bit29,
	          30 Bit30,
	          31 Bit31,
	          32 Bit32,
	        ];
	        iMinInterval : INT;
	        iMaxInterval : INT;
	        bExponential : BOOL;
	      END_STRUCT;
	      TLS : STRUCT
	        ValuesSet : BDINT
	        [
	          1 CAFile,
	          2 CertFile,
	          3 KeyFile,
	          4 Password,
	          5 TLS,
	          6 Bit6,
	          7 Bit7,
	          8 Bit8,
	          9 Bit9,
	          10 Bit10,
	          11 Bit11,
	          12 Bit12,
	          13 Bit13,
	          14 Bit14,
	          15 Bit15,
	          16 Bit16,
	          17 Bit17,
	          18 Bit18,
	          19 Bit19,
	          20 Bit20,
	          21 Bit21,
	          22 Bit22,
	          23 Bit23,
	          24 Bit24,
	          25 Bit25,
	          26 Bit26,
	          27 Bit27,
	          28 Bit28,
	          29 Bit29,
	          30 Bit30,
	          31 Bit31,
	          32 Bit32,
	        ];
	        aCAFile : ARRAY [0..MQTTCLIENTINTERFACE_TLS_CAFILE_MAX_LEN] OF CHAR;
	        aCertFile : ARRAY [0..MQTTCLIENTINTERFACE_TLS_CERTFILE_MAX_LEN] OF CHAR;
	        aKeyFile : ARRAY [0..MQTTCLIENTINTERFACE_TLS_KEYFILE_MAX_LEN] OF CHAR;
	        aPassword : ARRAY [0..MQTTCLIENTINTERFACE_TLS_PASSWORD_MAX_LEN] OF CHAR;
	      END_STRUCT;
	      Logging : STRUCT
	        bLogSet : BOOL;
	        bdActiveLogs : BDINT
	        [
	          1 Bit1,
	          2 Bit2,
	          3 Bit3,
	          4 Bit4,
	          5 Bit5,
	          6 Bit6,
	          7 Bit7,
	          8 Bit8,
	          9 Bit9,
	          10 Bit10,
	          11 Bit11,
	          12 Bit12,
	          13 Bit13,
	          14 Bit14,
	          15 Bit15,
	          16 Bit16,
	          17 Bit17,
	          18 Bit18,
	          19 Bit19,
	          20 Bit20,
	          21 Bit21,
	          22 Bit22,
	          23 Bit23,
	          24 Bit24,
	          25 Bit25,
	          26 Bit26,
	          27 Bit27,
	          28 Bit28,
	          29 Bit29,
	          30 Bit30,
	          31 Bit31,
	          32 Bit32,
	        ];
	      END_STRUCT;
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
	  t_s_TopicString : ARRAY [0..MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECLEN] OF CHAR;
#pragma pack(push, 1)
	  t_s_DataMap_ElementEntry_Publish : STRUCT
	    aElement : ARRAY [0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN] OF CHAR;
	    aTopic : ARRAY [0..MQTTCLIENTINTERFACE_DATAMAP_TOPIC_MAX_LEN] OF UINT;
	    Operation : t_e_DataMap_Operations;
	    Datatype : t_e_DataMap_DataTypes;
	    udDataLen : UDINT;
	    udApplID : UDINT;
	    bRetain : BOOL;
	    udInterval : UDINT;
	    pData : ^void;
	    pTempMem : ^void;  //! <Type Comment="This pointer stores the address of the temporary memory used when sending DataMap memory of type String / Other.&#13;&#10;Also see the variable: TempMem" Name="t_s_DataMap_ElementEntry_Publish.pTempMem"/>
	    TempMem : UDINT;  //! <Type Comment="This Varibale stores the data to send when sending DataMap memory of type DINT / UDINT / REAL.&#13;&#10;Also see the variable: pTempMem" Name="t_s_DataMap_ElementEntry_Publish.TempMem"/>
	    State : t_e_DataMap_PublishStates;
	    udLastAction : UDINT;
	    udCRC : UDINT;
	    iMid : INT;
	    bRemove : BOOL;
	    bPublishComplete : BOOL;
	    bAddedByXML : BOOL;
	    iQoS : INT;
	    bInitialPublish : BOOL;  //! <Type Comment="This value is used to track whether the DataMap entry has been published atleast once if the Interface is configured as such (see MQTTClient_Interface::t_e_ConfigParameters::CP_DataMap_SendOnAdd).&#13;&#10;- Entry should be published after being added: The value is set to false when the entry is added and then to true if the entry is published.&#13;&#10;- Entry should be published after the first change in the data: The value is set to true when the entry is added and then to true if the entry is published." Name="t_s_DataMap_ElementEntry_Publish.bInitialPublish"/>
	  END_STRUCT;
#pragma pack(pop)
	  t_s_DataMap_ElementEntry_Publish_Debug : ARRAY [0..500] OF t_s_DataMap_ElementEntry_Publish;
#pragma pack(push, 1)
	  t_s_DataMap_ElementEntry_Subscribe : STRUCT
	    aElement : ARRAY [0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN] OF CHAR;
	    aTopic : ARRAY [0..MQTTCLIENTINTERFACE_DATAMAP_TOPIC_MAX_LEN] OF UINT;
	    DataType : t_e_DataMap_DataTypes;
	    pData : ^void;
	    State : t_e_DataMap_SubscribeStates;
	    iMid : INT;
	    iQoS : INT;
	    bRemove : BOOL;
	    bAddedByXML : BOOL;
	    udApplMsgID : UDINT;
	    udLastAction : UDINT;
	  END_STRUCT;
#pragma pack(pop)
	  t_s_DataMap_ElementEntry_Subscribe_Debug : ARRAY [0..500] OF t_s_DataMap_ElementEntry_Subscribe;
#pragma pack(push, 1)
	  t_s_DataMap_ElementEntries : STRUCT
	    pPublishEntries : ^t_s_DataMap_ElementEntry_Publish;
	    pPublishDebug : ^t_s_DataMap_ElementEntry_Publish_Debug;
	    pSubscribeEntries : ^t_s_DataMap_ElementEntry_Subscribe;
	    pSubscribeDebug : ^t_s_DataMap_ElementEntry_Subscribe_Debug;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_DataMapConfig : STRUCT
	    aTopicStrings : ARRAY [0..MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECDEPTH-1] OF t_s_TopicString;
	    udEntries : UDINT;  //! <Type Comment="Contains the number of entries that is read in the Init()." Name="t_s_DataMapConfig.udEntries"/>
	    udTopicStringDepth : UDINT;
	    udPublishElements : UDINT;
	    udSubscribeElements : UDINT;
	    udCRC : UDINT;
	    Elements : t_s_DataMap_ElementEntries;
	    Config : STRUCT  //! <Type Comment="Configuration of the DataMap Functionality" Name="t_s_DataMapConfig.Config"/>
	      bSendOnAdd : BOOL;  //! <Type Comment="OnChange Elements:&#13;&#10;This value indicates whether the CRC for a DataMap Element is calculated when it is added or not.&#13;&#10;This means, when true the Element will always be sent when added to the DataMap, if false the DataMap waits for the first change before sending the element." Name="t_s_DataMapConfig.Config.bSendOnAdd"/>
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PubSubEntry : STRUCT
	    iMid : INT;
	    EntryType : t_e_PubSubEntries;
	    Callback : STRUCT
	      pThis : ^void;
	      pMethod : ^void;
	    END_STRUCT;
	    udAppliID : UDINT;
	    aTopic : ARRAY [0..MQTTCLIENTINTERFACE_PUBSUB_TOPIC_MAX_LEN-1] OF UINT;
	    iUnsubMid : INT;
	  END_STRUCT;
#pragma pack(pop)
	  t_s_PubSubEntriesDebug : ARRAY [0..500] OF t_s_PubSubEntry;
#pragma pack(push, 1)
	  t_s_PubSubList : STRUCT
	    udNumEntries : UDINT;
	    udMaxEntries : UDINT;  //! <Type Comment="Maximum number of entries, read at init. set by Client PubSubEntries." Name="t_s_PubSubList.udMaxEntries"/>
	    pEntries : ^t_s_PubSubEntry;
	    EntriesDebug : ^t_s_PubSubEntriesDebug;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PubSubConfig : STRUCT
	    udNextAppliID : UDINT;
	    PubSubList : t_s_PubSubList;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_ConfigStruct : STRUCT
	    bFirstRun : BOOL;
	    bFirstCall : BOOL;
	    IsConn : t_bd_IsConnected;
	    Initialize : STRUCT
	      aXMLFilename : ARRAY [0..MQTTCLIENTINTERFACE_MAX_XMLNAME_LEN] OF CHAR;
	    END_STRUCT;
	    pDataMapConfig : ^t_s_DataMapConfig;
	    pPubSubConfig : ^t_s_PubSubConfig;
	    iNextSubMID : INT;
	    iNextPubMID : INT;
	    ConfigObject : STRUCT
	      pThis : ^void;
	      State : t_e_ConfigObjectEntries;
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_LastEvent : STRUCT
	    dLastClientGroup : DINT;  //! <Type Comment="Group of the last event that was logged from the Client." Name="t_s_LastEvent.dLastClientGroup"/>
	    dLastClientMessage : DINT;  //! <Type Comment="Message Number of the Last Event logged from the Client." Name="t_s_LastEvent.dLastClientMessage"/>
	    dLastGlobalGroup : DINT;  //! <Type Comment="Group of the last event that was logged." Name="t_s_LastEvent.dLastGlobalGroup"/>
	    dLastGlobalMessage : DINT;  //! <Type Comment="Message Number of the Last Event logged." Name="t_s_LastEvent.dLastGlobalMessage"/>
	    dLastInterfaceGroup : DINT;  //! <Type Comment="Group of the last event that was logged from the Interface." Name="t_s_LastEvent.dLastInterfaceGroup"/>
	    dLastInterfaceMessage : DINT;  //! <Type Comment="Message Number of the Last Event logged from the Interface." Name="t_s_LastEvent.dLastInterfaceMessage"/>
	    dLastTopicGroup : DINT;  //! <Type Comment="Group of the last event that was logged from an MQTTTopic Object." Name="t_s_LastEvent.dLastTopicGroup"/>
	    dLastTopicMessage : DINT;  //! <Type Comment="Message of the last event that was logged from an MQTTTopic Object." Name="t_s_LastEvent.dLastTopicMessage"/>
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_DiagnosticStruct : STRUCT
	    udLastCalcTimestamp : UDINT;
	    udLastErrorCheck : UDINT;
	    TransferRateCalc : STRUCT
	      udLastTotalBytesTx : UDINT;
	      udLastTotalBytesRx : UDINT;
	      aTxEntries : ARRAY [0..MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG-1] OF UDINT;
	      aRxEntries : ARRAY [0..MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG-1] OF UDINT;
	      udIndex : UDINT;
	    END_STRUCT;
	    ComDiagnosis : STRUCT
	      udTxRate : UDINT;
	      udRxRate : UDINT;
	      udTotalBytesTx : UDINT;
	      udTotalBytesRx : UDINT;
	      udConnect : UDINT;
	      udConnectFail : UDINT;
	      udConnectRetry : UDINT;
	      udWDTimeout : UDINT;
	      udLastRet : UDINT;
	      udFailRet : UDINT;
	      udSubReqs : UDINT;
	      udSubFail : UDINT;
	      udPubReq : UDINT;
	      udPubFail : UDINT;
	      udUnsubReq : UDINT;
	      udUnsubFail : UDINT;
	      udPubSubEntries : UDINT;
	      udLogs : UDINT;
	      udPingReq : UDINT;
	      udPingResp : UDINT;
	      udPubQOS0 : UDINT;
	      udPubQOS1 : UDINT;
	      udPubQOS2 : UDINT;
	      udSubQOS0 : UDINT;
	      udSubQOS1 : UDINT;
	      udSubQOS2 : UDINT;
	      udDMEntries : UDINT;
	    END_STRUCT;
	    LogEvents : STRUCT  //! <Type Comment="Struct containing the Last Events that occurred for each of the areas, the values are set in Logging_CreateLog() and read from Logging_GetLastXXXX()." Name="t_s_DiagnosticStruct.LogEvents"/>
	      Level_Error : t_s_LastEvent;
	      Level_Warning : t_s_LastEvent;
	      Level_Info : t_s_LastEvent;
	      Level_Debug : t_s_LastEvent;
	    END_STRUCT;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_PointerType : STRUCT  //! <Type Comment="This structure is not intended to be used in the MQTTClient_Interface class, it serves the purpose of creating dependencies on HelpClasses." Name="t_s_PointerType"/>
	    pMQTTTopic : ^MQTTTopic;
	    pConfig : ^MQTTClient_Interface_ConfigBase;
	  END_STRUCT;
#pragma pack(pop)
#pragma pack(push, 1)
	  t_s_States : STRUCT
	    Initialise : t_e_MCSInit;
	    Prepare : DINT;
	  END_STRUCT;
#pragma pack(pop)
	END_TYPE
  //Servers:
	InterfaceState 	: SvrChCmd_t_e_MQTTClientStates_PTofCls_MQTTClient_Interface;
	ClientID 	: SvrCh_UDINT;
	ClientActive 	: SvrCh_DINT;
	CleanSession 	: SvrCh_DINT;
	SessionPresent 	: SvrCh_DINT;
	XMLFilename 	: SvrChCmd_UDINT;
	Reset 	: SvrCh_DINT;
	ComDiagnosis 	: SvrChCmd_DINT;
  //Clients:
	MQTTClient 	: CltChCmd_MQTTClient;
	SigCLib 	: CltChCmd_SigCLib;
	Stdlib 	: CltChCmd__StdLib;
	XMLFilenameString 	: CltChCmd_String;
	_XMLReader 	: CltChCmd__XMLReader;
	OpenSSL 	: CltChCmd__OpenSSL;
	cUseXML 	: CltCh_DINT;
	cDataMapPubTimeout 	: CltCh_UDINT;
	cLogConfig 	: CltCh_BDINT;
	cDataMapSubTimeout 	: CltCh_UDINT;
	cDataMapResetTimeout 	: CltCh_UDINT;
	cConnectTimeout 	: CltCh_UDINT;
	cAutoResetTime 	: CltCh_UDINT;
	cEventLog 	: CltChCmd_DINT;
	cActivateTrace 	: CltCh_UDINT;
	DataMapEntries 	: CltCh_UDINT;
	PubSubEntries 	: CltCh_UDINT;
	_ComLogging 	: CltChCmd__ComLogging;
	CriticalSection 	: CltChCmd_CriticalSection;
  //Variables:
		States 	: t_s_States;
		LastState 	: t_e_MQTTClientStates;
		Config 	: t_s_ConfigStruct;
		udInitCounter 	: UDINT;
		udTimestamp 	: UDINT;
		MQTTClientConfigData 	: t_s_ClientConfigData;
		DiagnosticData 	: t_s_DiagnosticStruct;
  //Functions:
				//! <Function Comment="Init class.&#13;&#10;&#13;&#10;Allocate memory for internal lists." Name="Init"/>
	FUNCTION VIRTUAL GLOBAL Init;
				//! <Function Comment="Do the internal routine." Name="CyWork"/>
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT;
		END_VAR;
				//! <Function Comment="This method is called from the MQTTClient_Interface_ConfigBase object during Init().&#13;&#10;The User does not have to call this method explicitly." Name="Config_Login"/>
	FUNCTION GLOBAL Config_Login
		VAR_INPUT
			pThis 	: ^void;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Using this method it is possible to configure the MQTTClient_Interface Class Functionality.&#13;&#10;See the comment of the relative enumeration entry for more information." Name="Config_SetParameter"/>
	FUNCTION GLOBAL Config_SetParameter
		VAR_INPUT
			Parameter 	: t_e_ConfigParameters;			//! <Variable Comment="Parameter to be changed, see the comment of the enumeration entries for further information." Name="Config_SetParameter.Parameter"/>
			Value 	: DINT;			//! <Variable Comment="Value to be set, see the comment of the relative enumeration entry for more information." Name="Config_SetParameter.Value"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;			//! <Variable Comment="Return code for the for the SetParameter Call:&#13;&#10;0 - Success&#13;&#10;3 - Set Value incorrect / out of range." Name="Config_SetParameter.retCode"/>
		END_VAR;
				//! <Function Comment="Log Function, called whenever a log is to be made (By an MQTTTopic Object).&#13;&#10;This function relays the log information to the selected log location. " Name="Logging_CreateLog"/>
	FUNCTION GLOBAL Logging_CreateLog
		VAR_INPUT
			usLevel 	: USINT;			//! <Variable Comment="Level of the logged message&#13;&#10;&#13;&#10;Debug&#13;&#10;Info&#13;&#10;Warning&#13;&#10;Error" Name="Logging_CreateLog.usLevel"/>
			dMsgGroup 	: DINT;			//! <Variable Comment="Message Group No." Name="Logging_CreateLog.dMsgGroup"/>
			dMsgNbr 	: DINT;			//! <Variable Comment="Message number" Name="Logging_CreateLog.dMsgNbr"/>
			pMsg 	: ^CHAR;			//! <Variable Comment="Pointer to the message" Name="Logging_CreateLog.pMsg"/>
			pPara1 	: ^DINT;			//! <Variable Comment="Pointer to addtional parameter" Name="Logging_CreateLog.pPara1"/>
			pPara2 	: ^DINT;			//! <Variable Comment="Pointer to addtional parameter" Name="Logging_CreateLog.pPara2"/>
			pPara3 	: ^DINT;			//! <Variable Comment="Pointer to addtional parameter" Name="Logging_CreateLog.pPara3"/>
			pPara4 	: ^DINT;			//! <Variable Comment="Pointer to addtional parameter" Name="Logging_CreateLog.pPara4"/>
			udClient 	: UDINT := 0;
		END_VAR;
				//! <Function Comment="This method can be called to query the last Client Event that was logged." Name="Logging_GetLastClientEvent"/>
	FUNCTION GLOBAL Logging_GetLastClientEvent
		VAR_INPUT
			pGroup 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Group Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pGroup &lt;&gt; NIL." Name="Logging_GetLastClientEvent.pGroup"/>
			pMessage 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Message Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pMessage &lt;&gt; NIL." Name="Logging_GetLastClientEvent.pMessage"/>
			Level 	: DINT;			//! <Variable Comment="Level of the Last Event that should be written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;INFO - 0x01&#10;&#13;&#10;WARNING - 0x04&#10;&#13;&#10;ERROR - 0x08&#10; &#13;&#10;DEBUG - 0x10" Name="Logging_GetLastClientEvent.Level"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="Return value indicating whether the values were written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;True - Values written Successfully&#13;&#10;False - Values not written, possible causes:&#13;&#10;1. A pointer value was = NIL.&#13;&#10;2. The level value is invalid." Name="Logging_GetLastClientEvent.bOK"/>
		END_VAR;
				//! <Function Comment="This method can be called to query the last Global Event that was logged.&#13;&#10;&#13;&#10;Global Events include the events from all Logging Sources:&#13;&#10;MQTTClient_Interface&#13;&#10;MQTTClient&#13;&#10;MQTTTopic Implementations" Name="Logging_GetLastGlobalEvent"/>
	FUNCTION GLOBAL Logging_GetLastGlobalEvent
		VAR_INPUT
			pGroup 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Group Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pGroup &lt;&gt; NIL." Name="Logging_GetLastGlobalEvent.pGroup"/>
			pMessage 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Message Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pMessage &lt;&gt; NIL." Name="Logging_GetLastGlobalEvent.pMessage"/>
			Level 	: DINT;			//! <Variable Comment="Level of the Last Event that should be written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;INFO - 0x01&#10;&#13;&#10;WARNING - 0x04&#10;&#13;&#10;ERROR - 0x08&#10; &#13;&#10;DEBUG - 0x10" Name="Logging_GetLastGlobalEvent.Level"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="Return value indicating whether the values were written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;True - Values written Successfully&#13;&#10;False - Values not written, possible causes:&#13;&#10;1. A pointer value was = NIL.&#13;&#10;2. The level value is invalid." Name="Logging_GetLastGlobalEvent.bOK"/>
		END_VAR;
				//! <Function Comment="This method can be called to query the last Interface Event that was logged by the MQTTClient_Interface." Name="Logging_GetLastInterfaceEvent"/>
	FUNCTION GLOBAL Logging_GetLastInterfaceEvent
		VAR_INPUT
			pGroup 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Group Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pGroup &lt;&gt; NIL." Name="Logging_GetLastInterfaceEvent.pGroup"/>
			pMessage 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Message Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pMessage &lt;&gt; NIL." Name="Logging_GetLastInterfaceEvent.pMessage"/>
			Level 	: DINT;			//! <Variable Comment="Level of the Last Event that should be written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;INFO - 0x01&#10;&#13;&#10;WARNING - 0x04&#10;&#13;&#10;ERROR - 0x08&#10; &#13;&#10;DEBUG - 0x10" Name="Logging_GetLastInterfaceEvent.Level"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="Return value indicating whether the values were written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;True - Values written Successfully&#13;&#10;False - Values not written, possible causes:&#13;&#10;1. A pointer value was = NIL.&#13;&#10;2. The level value is invalid." Name="Logging_GetLastInterfaceEvent.bOK"/>
		END_VAR;
				//! <Function Comment="This method can be called to query the last Interface Event that was logged by an MQTTTopic instance." Name="Logging_GetLastTopicEvent"/>
	FUNCTION GLOBAL Logging_GetLastTopicEvent
		VAR_INPUT
			pGroup 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Group Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pGroup &lt;&gt; NIL." Name="Logging_GetLastTopicEvent.pGroup"/>
			pMessage 	: ^DINT;			//! <Variable Comment="Pointer to the DINT Variable where the Message Value should be written.&#13;&#10;&#13;&#10;Valid Values:&#13;&#10;pMessage &lt;&gt; NIL." Name="Logging_GetLastTopicEvent.pMessage"/>
			Level 	: DINT;			//! <Variable Comment="Level of the Last Event that should be written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;INFO - 0x01&#10;&#13;&#10;WARNING - 0x04&#10;&#13;&#10;ERROR - 0x08&#10; &#13;&#10;DEBUG - 0x10" Name="Logging_GetLastTopicEvent.Level"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="Return value indicating whether the values were written.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;True - Values written Successfully&#13;&#10;False - Values not written, possible causes:&#13;&#10;1. A pointer value was = NIL.&#13;&#10;2. The level value is invalid." Name="Logging_GetLastTopicEvent.bOK"/>
		END_VAR;
				//! <Function Comment="Call function to publish data  to a defined topic." Name="MQTT_Publish"/>
	FUNCTION GLOBAL MQTT_Publish
		VAR_INPUT
			pTopic 	: ^UINT;			//! <Variable Comment="Pointer to the topic name" Name="MQTT_Publish.pTopic"/>
			iQoS 	: INT;			//! <Variable Comment="Define the desired &quot;Quality of Service&quot; between the communication of client and server for this topic. &#13;&#10;&#13;&#10;0...at most once. Sending of data will be done only once. There is no guarantee of delivery. The recipient does not send an acknowledge.&#13;&#10;&#13;&#10;1...at least once.  This level guarantees that the message is delivered at least once. The sender waits for an acknowledge of the recipient and if this takes too long, the sender sends the same message again.&#13;&#10;It can happen that the same message gets send and delivered multiple times.&#13;&#10;&#13;&#10;2...exactly once. This level guarantees the delivery of the message to the recipient exactly once. This level is the safest and slowest quality of service. &#13;&#10;&#13;&#10;Note: A higher level, also results in a longer execution of the send and receive routine. " Name="MQTT_Publish.iQoS"/>
			pPayload 	: ^void;			//! <Variable Comment="Pointer to the data, which should be published." Name="MQTT_Publish.pPayload"/>
			udPayloadLen 	: UDINT;			//! <Variable Comment="Size of the Data in Byte." Name="MQTT_Publish.udPayloadLen"/>
			bRetain 	: BOOL;			//! <Variable Comment="Defines if the published data will be stored in the server.&#13;&#10;&#13;&#10;False...data won&apos;t be stored in the server&#13;&#10;True...data will be stored in the server." Name="MQTT_Publish.bRetain"/>
			pThis 	: ^void;			//! <Variable Comment="This pointer of the calling object." Name="MQTT_Publish.pThis"/>
			pCallback 	: ^void;			//! <Variable Comment="Pointer to the callback method" Name="MQTT_Publish.pCallback"/>
			pMid 	: ^INT;			//! <Variable Comment="Pointer to the variable, where the message ID should be saved." Name="MQTT_Publish.pMid"/>
			pApplMsgID 	: ^UDINT;			//! <Variable Comment="Pointer to the variable, where the internal application message ID should be saved." Name="MQTT_Publish.pApplMsgID"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;			//! <Variable Comment="0...successfull&#13;&#10;1...Error. No memory left for the publish message&#13;&#10;3...Error. Publish faild. Parameters invalid.&#13;&#10;4...Error. No connection to the mqtt server&#13;&#10;18...Error. Topic name is not correct formatted. (Has to be unicode)" Name="MQTT_Publish.retCode"/>
		END_VAR;
				//! <Function Comment="Call function to read the logging configuration on the client cLogConfig." Name="MQTT_ReadLogConfig"/>
	FUNCTION GLOBAL MQTT_ReadLogConfig
		VAR_OUTPUT
			bUpdated 	: BOOL;			//! <Variable Comment="True...logging configuration was updated&#13;&#10;False...logging configuration was not updated" Name="MQTT_ReadLogConfig.bUpdated"/>
		END_VAR;
				//! <Function Comment="Call function to delete all sessions " Name="MQTT_SetCleanSession"/>
	FUNCTION GLOBAL MQTT_SetCleanSession
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="True...all sessions cleaned&#13;&#10;False...cleaning sessions failed." Name="MQTT_SetCleanSession.bOK"/>
		END_VAR;
				//! <Function Comment="This function can be called to Subscribe to a Topic, if subscribed, the data sent to the Topic is delivered to the application over the Callback information provided." Name="MQTT_Subscribe"/>
	FUNCTION GLOBAL MQTT_Subscribe
		VAR_INPUT
			pTopic 	: ^UINT;			//! <Variable Comment="Pointer to the topic name." Name="MQTT_Subscribe.pTopic"/>
			iQoS 	: INT;			//! <Variable Comment="Define the desired &quot;Quality of Service&quot; between the communication of client and server for this topic. &#13;&#10;&#13;&#10;0...at most once. Sending of data will be done only once. There is no guarantee of delivery. The recipient does not send an acknowledge.&#13;&#10;&#13;&#10;1...at least once.  This level guarantees that the message is delivered at least once. The sender waits for an acknowledge of the recipient and if this takes too long, the sender sends the same message again.&#13;&#10;It can happen that the same message gets send and delivered multiple times.&#13;&#10;&#13;&#10;2...exactly once. This level guarantees the delivery of the message to the recipient exactly once. This level is the safest and slowest quality of service. &#13;&#10;&#13;&#10;Note: A higher level, also results in a longer execution of the send and receive routine. " Name="MQTT_Subscribe.iQoS"/>
			pThis 	: ^void;			//! <Variable Comment="this pointer of the calling object for the callback." Name="MQTT_Subscribe.pThis"/>
			pCallback 	: ^void;			//! <Variable Comment="Pointer to the callback method. " Name="MQTT_Subscribe.pCallback"/>
			pMid 	: ^INT;			//! <Variable Comment="Pointer to a Variable, where the message ID should be saved." Name="MQTT_Subscribe.pMid"/>
			pApplMsgID 	: ^UDINT;			//! <Variable Comment="Pointer to a variable, where the internal application message ID should be saved.&#13;&#10;&#13;&#10;The saved ID can be used for the unsubscribe function." Name="MQTT_Subscribe.pApplMsgID"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;			//! <Variable Comment="0...successfull&#13;&#10;1...no memory left to add a new subscriber&#13;&#10;3...adding subscriber failed." Name="MQTT_Subscribe.retCode"/>
		END_VAR;
				//! <Function Comment="This function can be called to unsubscribe from a previously subscribed topic.&#13;&#10;The Unsubscription can be made over an Application ID that was delivered whilst Subscribing or over the Topic Name Text." Name="MQTT_Unsubscribe"/>
	FUNCTION GLOBAL MQTT_Unsubscribe
		VAR_INPUT
			pApplMsgID 	: ^UDINT;			//! <Variable Comment="Pointer to the internal application message ID, that was saved from the subscribe call.&#13;&#10;&#13;&#10;If the parameter pTopic is set, the ID is not neccessary." Name="MQTT_Unsubscribe.pApplMsgID"/>
			pTopic 	: ^UINT;			//! <Variable Comment="Pointer to the topic name.&#13;&#10;&#13;&#10;If the parameter pApplMsgID is set, the topic name is not neccessary." Name="MQTT_Unsubscribe.pTopic"/>
			pMid 	: ^INT;			//! <Variable Comment="Pointer to a variable, where the message ID should be saved." Name="MQTT_Unsubscribe.pMid"/>
			pThis 	: ^void;			//! <Variable Comment="This pointer of the calling object." Name="MQTT_Unsubscribe.pThis"/>
			pCallback 	: ^void;			//! <Variable Comment="Pointer to the callback function." Name="MQTT_Unsubscribe.pCallback"/>
		END_VAR
		VAR_OUTPUT
			retCode 	: INT;			//! <Variable Comment="0...successfull&#13;&#10;1...unsubscribe failed. No memory left in the message buffer&#13;&#10;3...unsubscribe failed. Invalid input parameters&#13;&#10;4...unsubscribe failed. No connection to the mqtt server" Name="MQTT_Unsubscribe.retCode"/>
		END_VAR;
				//! <Function Comment="Callback for the OnConnectWithFlags function." Name="Callback_OnConnectWithFlags"/>
	FUNCTION Callback_OnConnectWithFlags
		VAR_INPUT
			pThis 	: ^void;
			retCode 	: INT;
			flags 	: BYTE;
		END_VAR;
				//! <Function Comment="Callback for the OnDisconnect function." Name="Callback_OnDisconnect"/>
	FUNCTION Callback_OnDisconnect
		VAR_INPUT
			pThis 	: ^void;
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Callback for the OnLog function." Name="Callback_OnLog"/>
	FUNCTION Callback_OnLog
		VAR_INPUT
			pThis 	: ^void;
			level 	: INT;
			pStr 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Callback for the OnLog function that is expanded with a group and message number, this is introduced to introduce the identification to the MQTTClient class logging." Name="Callback_OnLog_WithDetail"/>
	FUNCTION Callback_OnLog_WithDetail
		VAR_INPUT
			pThis 	: ^void;			//! <Variable Comment="This Pointer for overloading.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;pThis &lt;&gt; NIL" Name="Callback_OnLog_WithDetail.pThis"/>
			usLevel 	: USINT;
			dMsgGroup 	: DINT;
			dMsgNbr 	: DINT;
			pMsg 	: ^CHAR;
			pPara1 	: ^DINT;
			pPara2 	: ^DINT;
			pPara3 	: ^DINT;
			pPara4 	: ^DINT;
		END_VAR;
				//! <Function Comment="Callback for the OnMessage function" Name="Callback_OnMessage"/>
	FUNCTION Callback_OnMessage
		VAR_INPUT
			pThis 	: ^void;
			pMessage 	: ^MQTTClient::t_s_MQTTMessage;
		END_VAR;
				//! <Function Comment="Callback for the OnPublish function." Name="Callback_OnPublish"/>
	FUNCTION Callback_OnPublish
		VAR_INPUT
			pThis 	: ^void;
			mid 	: INT;
		END_VAR;
				//! <Function Comment="Callback for the OnSubscribe function." Name="Callback_OnSubscribe"/>
	FUNCTION Callback_OnSubscribe
		VAR_INPUT
			pThis 	: ^void;
			mid 	: INT;
			qos_count 	: INT;
			granted_qos 	: ^INT;
		END_VAR;
				//! <Function Comment="Callback for the OnUnsubscribe function." Name="Callback_OnUnsubscribe"/>
	FUNCTION Callback_OnUnsubscribe
		VAR_INPUT
			pThis 	: ^void;
			mid 	: INT;
		END_VAR;
	
	FUNCTION ConfigObject_Process
		VAR_OUTPUT
			eRet 	: t_e_TaskRet;
		END_VAR;
				//! <Function Comment="Get the actual Appl. ID" Name="Counters_GetApplID"/>
	FUNCTION Counters_GetApplID
		VAR_OUTPUT
			udApplID 	: UDINT;
		END_VAR;
				//! <Function Comment="Get the actual Publish MID." Name="Counters_GetPubMID"/>
	FUNCTION Counters_GetPubMID
		VAR_OUTPUT
			iMID 	: INT;
		END_VAR;
				//! <Function Comment="Get the actual subscription MID." Name="Counters_GetSubMID"/>
	FUNCTION Counters_GetSubMID
		VAR_OUTPUT
			iMID 	: INT;
		END_VAR;
				//! <Function Comment="Increment the Appl. ID." Name="Counters_IncApplID"/>
	FUNCTION Counters_IncApplID
		VAR_OUTPUT
			udApplID 	: UDINT;
		END_VAR;
				//! <Function Comment="Increment the Publish MID." Name="Counters_IncPubMID"/>
	FUNCTION Counters_IncPubMID
		VAR_OUTPUT
			iMid 	: INT;
		END_VAR;
				//! <Function Comment="Increment the subscription MID." Name="Counters_IncSubMID"/>
	FUNCTION Counters_IncSubMID
		VAR_OUTPUT
			iMid 	: INT;
		END_VAR;
				//! <Function Comment="Call function to add an element to the subscribe or publish list." Name="DataMap_AddElement"/>
	FUNCTION DataMap_AddElement
		VAR_INPUT
			pTopic 	: ^CHAR;			//! <Variable Comment="Pointer to the topic name." Name="DataMap_AddElement.pTopic"/>
			pElement 	: ^CHAR;			//! <Variable Comment="Pointer to the element name. (e.g. ObjectName.ServerName)" Name="DataMap_AddElement.pElement"/>
			Operation 	: t_e_DataMap_Operations;			//! <Variable Comment="Select the operation for the element.&#13;&#10;&#13;&#10;DO_Unknown...not defined --&gt; will result in error&#13;&#10;DO_Poll...the data from the element will be published every interval time (udInterval)&#13;&#10;DO_Change...every interval time (udInterval), the data from the element will be checked for changes. If changes are detected, the data will be published.&#13;&#10;DO_Subscribe...Element will be subscribed to the topic." Name="DataMap_AddElement.Operation"/>
			Datatype 	: t_e_DataMap_DataTypes;			//! <Variable Comment="Set the datatype of the element." Name="DataMap_AddElement.Datatype"/>
			udInterval 	: UDINT;			//! <Variable Comment="Interval time [ms]&#13;&#10;&#13;&#10;Used for the operation DO_Poll &amp; DO_Change" Name="DataMap_AddElement.udInterval"/>
			iQoS 	: INT;			//! <Variable Comment="Define the desired &quot;Quality of Service&quot; between the communication of client and server for this topic. &#13;&#10;&#13;&#10;0...at most once. Sending of data will be done only once. There is no guarantee of delivery. The recipient does not send an acknowledge.&#13;&#10;&#13;&#10;1...at least once.  This level guarantees that the message is delivered at least once. The sender waits for an acknowledge of the recipient and if this takes too long, the sender sends the same message again.&#13;&#10;It can happen that the same message gets send and delivered multiple times.&#13;&#10;&#13;&#10;2...exactly once. This level guarantees the delivery of the message to the recipient exactly once. This level is the safest and slowest quality of service. &#13;&#10;&#13;&#10;Note: A higher level, also results in a longer execution of the send and receive routine. " Name="DataMap_AddElement.iQoS"/>
			bRetain 	: BOOL;			//! <Variable Comment="Defines if the published data will be stored in the server.&#13;&#10;&#13;&#10;False...data won&apos;t be stored in the server&#13;&#10;True...data will be stored in the server." Name="DataMap_AddElement.bRetain"/>
		END_VAR
		VAR_OUTPUT
			RetCode 	: t_e_DataMap_RetCode;			//! <Variable Comment="Return code of the function.&#13;&#10;&#13;&#10;check the return struct." Name="DataMap_AddElement.RetCode"/>
		END_VAR;
				//! <Function Comment="Add an element to the data mapping." Name="DataMap_AddElement_Internal"/>
	FUNCTION DataMap_AddElement_Internal
		VAR_INPUT
			pTopic 	: ^CHAR;
			pElement 	: ^CHAR;
			Operation 	: t_e_DataMap_Operations;
			Datatype 	: t_e_DataMap_DataTypes;
			udInterval 	: UDINT;
			iQoS 	: INT;
			bRetain 	: BOOL;
			bAddedByXML 	: BOOL;
		END_VAR
		VAR_OUTPUT
			RetCode 	: t_e_DataMap_RetCode;
		END_VAR;
				//! <Function Comment="Do the data mapping routine. (Subscribe and Publish)" Name="DataMap_ProcessMap"/>
	FUNCTION DataMap_ProcessMap;
				//! <Function Comment="do the mapping routine for publish elements." Name="DataMap_ProcessMap_Publish"/>
	FUNCTION DataMap_ProcessMap_Publish;
				//! <Function Comment="do the mapping routine for the subscribe elements." Name="DataMap_ProcessMap_Subscribe"/>
	FUNCTION DataMap_ProcessMap_Subscribe;
				//! <Function Comment="Call function to remove an element from the subscribe or publish list." Name="DataMap_RemoveElement"/>
	FUNCTION DataMap_RemoveElement
		VAR_INPUT
			pElement 	: ^CHAR;			//! <Variable Comment="Pointer to the element name. (e.g. ObjectName.ServerName)" Name="DataMap_RemoveElement.pElement"/>
			ElementType 	: t_e_DataMap_ElementTypes;			//! <Variable Comment="Type of Element. Publish or Subscribe." Name="DataMap_RemoveElement.ElementType"/>
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;			//! <Variable Comment="True...removing element successfull&#13;&#10;False...removing element failed" Name="DataMap_RemoveElement.bOK"/>
		END_VAR;
				//! <Function Comment="Remove an element from the data mapping by its index." Name="DataMap_RemoveElement_ByIndex"/>
	FUNCTION DataMap_RemoveElement_ByIndex
		VAR_INPUT
			udIndex 	: UDINT;
			ElementType 	: t_e_DataMap_ElementTypes;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Reset the states of the mapped parameters." Name="DataMap_ResetStates"/>
	FUNCTION DataMap_ResetStates
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Returned Data from the MQTT Server." Name="DataMap_Return"/>
	FUNCTION DataMap_Return
		VAR_INPUT
			MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes;
			iMid 	: INT;
			iGrantedQoS 	: INT;
			pMessage 	: ^MQTTClient::t_s_MQTTMessage;
		END_VAR;
				//! <Function Comment="Callback for the DataMap Return function." Name="DataMap_Return_Callback"/>
	FUNCTION DataMap_Return_Callback
		VAR_INPUT
			pThis 	: ^void;
			MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes;
			iMid 	: INT;
			iGrantedQoS 	: INT;
			pMessage 	: ^MQTTClient::t_s_MQTTMessage;
		END_VAR;
	
	FUNCTION DataMap_Clear;
	
	FUNCTION Diagnostic_Calculate;
	
	FUNCTION Diagnostic_Event
		VAR_INPUT
			Event 	: t_e_DiagnosticLogTypes;
			udValue 	: UDINT;
		END_VAR;
	
	FUNCTION Diagnostic_GetData
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR;
	
	FUNCTION Diagnostic_ReadErrors;
	
	FUNCTION InitMem;
				//! <Function Comment="Method used to Log internal Interface Events" Name="Logging_InterfLog"/>
	FUNCTION Logging_InterfLog
		VAR_INPUT
			usLevel 	: USINT;
			dMsgGroup 	: DINT;
			dMsgNbr 	: DINT;
			pMsg 	: ^CHAR;
			pPara1 	: ^DINT;
			pPara2 	: ^DINT;
			pPara3 	: ^DINT;
			pPara4 	: ^DINT;
		END_VAR;
				//! <Function Comment="This internal method is called from the Interface methods to create a log, called from:&#13;&#10;1. OnLog_XXXX - Callback from MQTTClient&#13;&#10;2. Logging_InterfLog - Log Event from within the MQTTClient_Interface&#13;&#10;3. Logging_CreateLog - Call from the MQTTTopic Objects." Name="Logging_InternLog"/>
	FUNCTION Logging_InternLog
		VAR_INPUT
			usLevel 	: USINT;
			dMsgGroup 	: DINT;
			dMsgNbr 	: DINT;
			pMsg 	: ^CHAR;
			pPara1 	: ^DINT;
			pPara2 	: ^DINT;
			pPara3 	: ^DINT;
			pPara4 	: ^DINT;
			udClient 	: UDINT := 0;
		END_VAR;
				//! <Function Comment="Get client configuration from the .xml file." Name="MCIT_Initialise"/>
	FUNCTION MCIT_Initialise
		VAR_INPUT
			bFirstCall 	: BOOL;
		END_VAR
		VAR_OUTPUT
			eRet 	: t_e_TaskRet;
		END_VAR;
				//! <Function Comment="Prepare the client with the known configuration." Name="MCIT_Prepare"/>
	FUNCTION MCIT_Prepare
		VAR_INPUT
			bFirstCall 	: BOOL;
		END_VAR
		VAR_OUTPUT
			eRet 	: t_e_TaskRet;
		END_VAR;
				//! <Function Comment="Task routine of the MQTTClient Interface." Name="MQTTClientInterfaceTask"/>
	FUNCTION MQTTClientInterfaceTask;
				//! <Function Comment="Will be called with the feedback of the connection procedure." Name="OnConnectWithFlags"/>
	FUNCTION OnConnectWithFlags
		VAR_INPUT
			retCode 	: INT;
			flags 	: BYTE;
		END_VAR;
				//! <Function Comment="Will be called with the feedback of the Disconnect procedure." Name="OnDisconnect"/>
	FUNCTION OnDisconnect
		VAR_INPUT
			retCode 	: INT;
		END_VAR;
				//! <Function Comment="Will be called from the MQTTClient for logging." Name="OnLog"/>
	FUNCTION OnLog
		VAR_INPUT
			level 	: INT;
			pStr 	: ^CHAR;
		END_VAR;
				//! <Function Comment="Internal method called by the MQTTClient to log events" Name="OnLog_WithDetail"/>
	FUNCTION OnLog_WithDetail
		VAR_INPUT
			usLevel 	: USINT;
			dMsgGroup 	: DINT;
			dMsgNbr 	: DINT;
			pMsg 	: ^CHAR;
			pPara1 	: ^DINT;
			pPara2 	: ^DINT;
			pPara3 	: ^DINT;
			pPara4 	: ^DINT;
		END_VAR;
				//! <Function Comment="Received a message for a element which is subscribed to a certain topic." Name="OnMessage"/>
	FUNCTION OnMessage
		VAR_INPUT
			pMessage 	: ^MQTTClient::t_s_MQTTMessage;
		END_VAR;
				//! <Function Comment="Will be called when a publish was confirmed." Name="OnPublish"/>
	FUNCTION OnPublish
		VAR_INPUT
			mid 	: INT;
		END_VAR;
				//! <Function Comment="Will be called when a subscribe was confirmed." Name="OnSubscribe"/>
	FUNCTION OnSubscribe
		VAR_INPUT
			mid 	: INT;
			qos_count 	: INT;
			granted_qos 	: ^INT;
		END_VAR;
				//! <Function Comment="Will be called when an unsubscribe was confirmed." Name="OnUnsubscribe"/>
	FUNCTION OnUnsubscribe
		VAR_INPUT
			mid 	: INT;
		END_VAR;
				//! <Function Comment="Process the .xml File. " Name="ProcessXML"/>
	FUNCTION ProcessXML
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Function to define the type of the element in the .xml file." Name="ProcessXML_GetElementType"/>
	FUNCTION ProcessXML_GetElementType
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			ElementType 	: t_e_XML;
		END_VAR;
				//! <Function Comment="Process config parameters from the .xml file." Name="ProcessXML_ProcessConfig"/>
	FUNCTION ProcessXML_ProcessConfig
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Process the client ID from the config." Name="ProcessXML_ProcessConfig_ClientID"/>
	FUNCTION ProcessXML_ProcessConfig_ClientID
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Process the connection configuration from the .xml file." Name="ProcessXML_ProcessConfig_Connection"/>
	FUNCTION ProcessXML_ProcessConfig_Connection
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Get the type of the config element from the .xml file." Name="ProcessXML_ProcessConfig_GetElementType"/>
	FUNCTION ProcessXML_ProcessConfig_GetElementType
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			ElementType 	: t_e_XML_Config;
		END_VAR;
				//! <Function Comment="Process the logging configuration from the .xml file." Name="ProcessXML_ProcessConfig_Logging"/>
	FUNCTION ProcessXML_ProcessConfig_Logging
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Process the reconnection configuration from the .xml file." Name="ProcessXML_ProcessConfig_Reconnection"/>
	FUNCTION ProcessXML_ProcessConfig_Reconnection
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Process the TSL configuration from the .xml file." Name="ProcessXML_ProcessConfig_TLS"/>
	FUNCTION ProcessXML_ProcessConfig_TLS
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Process the will configuration from the .xml file." Name="ProcessXML_ProcessConfig_Will"/>
	FUNCTION ProcessXML_ProcessConfig_Will
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Process the data mapping from the .xml file." Name="ProcessXML_ProcessDataMap"/>
	FUNCTION ProcessXML_ProcessDataMap
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Get the type of the data mapping element." Name="ProcessXML_ProcessDataMap_GetElementType"/>
	FUNCTION ProcessXML_ProcessDataMap_GetElementType
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			ElementType 	: t_e_XML_DataMap;
		END_VAR;
				//! <Function Comment="Process the topic end point from the .xml file." Name="ProcessXML_ProcessDataMap_TopicEndpoint"/>
	FUNCTION ProcessXML_ProcessDataMap_TopicEndpoint
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Get the dataype from the topic endpoint element." Name="ProcessXML_ProcessDataMap_TopicEndpoint_GetDataType"/>
	FUNCTION ProcessXML_ProcessDataMap_TopicEndpoint_GetDataType
		VAR_INPUT
			pChar 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			DataType 	: t_e_DataMap_DataTypes;
		END_VAR;
				//! <Function Comment="Get the type of operation from the topic endpoint element." Name="ProcessXML_ProcessDataMap_TopicEndpoint_GetOperation"/>
	FUNCTION ProcessXML_ProcessDataMap_TopicEndpoint_GetOperation
		VAR_INPUT
			pChar 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			Operation 	: t_e_DataMap_Operations;
		END_VAR;
				//! <Function Comment="Get the information if the parameter is retained." Name="ProcessXML_ProcessDataMap_TopicEndpoint_GetRetain"/>
	FUNCTION ProcessXML_ProcessDataMap_TopicEndpoint_GetRetain
		VAR_INPUT
			pChar 	: ^CHAR;
		END_VAR
		VAR_OUTPUT
			RetainState 	: t_e_DataMap_RetainStates;
		END_VAR;
				//! <Function Comment="Process the topic section from the .xml file." Name="ProcessXML_ProcessDataMap_TopicSection"/>
	FUNCTION ProcessXML_ProcessDataMap_TopicSection
		VAR_INPUT
			pElement 	: ^_XML_ELEMENT;
		END_VAR
		VAR_OUTPUT
			bOK 	: BOOL;
		END_VAR;
				//! <Function Comment="Call the unsubscribe callback for subscribed elements." Name="PubSub_Reset"/>
	FUNCTION PubSub_Reset;
	
	FUNCTION PubSub_CheckSubscription
		VAR_INPUT
			pTopic 	: ^UINT;
			pThis 	: ^void;
			pCallback 	: ^void;
		END_VAR
		VAR_OUTPUT
			udAppliID 	: UDINT;
		END_VAR;
				//! <Function Comment="This method compares MQTT Topic strings with the support for Wildcards (# / +)." Name="PubSub_TopicCompare"/>
	FUNCTION PubSub_TopicCompare
		VAR_INPUT
			pStr 	: ^UINT;			//! <Variable Comment="Pointer to the Topic-String to compare the Wildcard string to.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;pStr &lt;&gt; NIL." Name="PubSub_TopicCompare.pStr"/>
			pWCString 	: ^UINT;			//! <Variable Comment="Pointer to the Topic-String (With / Without Wildcards) to compare the Topic-String to.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;pWCStr &lt;&gt; NIL." Name="PubSub_TopicCompare.pWCString"/>
		END_VAR
		VAR_OUTPUT
			bEqual 	: BOOL;			//! <Variable Comment="Indicates whether the topic strings are equal or not.&#13;&#10;&#13;&#10;Possible Values:&#13;&#10;True - Strings are equal.&#13;&#10;False - The Strings are not equal. / The input was not acceptable." Name="PubSub_TopicCompare.bEqual"/>
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClientID::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClientID::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ClientActive::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CleanSession::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL CleanSession::Write
		VAR_INPUT
			input (EAX) 	: DINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL SessionPresent::Read
		VAR_OUTPUT
			output (EAX) 	: DINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL XMLFilename::Read
		VAR_OUTPUT
			output (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL XMLFilename::Write
		VAR_INPUT
			input (EAX) 	: UDINT;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: UDINT;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL ComDiagnosis::NewInst
		VAR_INPUT
			pPara 	: ^CmdStruct;
			pResult 	: ^results;
		END_VAR
		VAR_OUTPUT
			ret_code 	: iprStates;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

#pragma using _ComLogging
#pragma using _XMLReader
#pragma using CriticalSection
#pragma using MQTTClient
#pragma using String
#pragma usingLtd _OpenSSL
#pragma usingLtd _StdLib
#pragma usingLtd SigCLib


//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MQTTClient_Interface::@CT_
0$UINT,
2#0100000000000000$UINT, //TY_MQTTCLIENT_INTERFACE
1$UINT, 16$UINT, (SIZEOF(::MQTTClient_Interface))$UINT, 
8$UINT, 19$UINT, 0$UINT, 
TO_UDINT(2880242173), "MQTTClient_Interface", //Class
TO_UDINT(0), 0, 0$UINT, 0$UINT, //Baseclass
//Servers:
(::MQTTClient_Interface.InterfaceState.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(2895168853), "InterfaceState", 
(::MQTTClient_Interface.ClientID.pMeth)$UINT, _CH_SVR$UINT, 2#0000000001000000$UINT, TO_UDINT(3115012432), "ClientID", 
(::MQTTClient_Interface.ClientActive.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(4151952697), "ClientActive", 
(::MQTTClient_Interface.CleanSession.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(528144264), "CleanSession", 
(::MQTTClient_Interface.SessionPresent.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2160867824), "SessionPresent", 
(::MQTTClient_Interface.XMLFilename.pMeth)$UINT, _CH_SVR_OBJ$UINT, 2#0000000001000000$UINT, TO_UDINT(1694653390), "XMLFilename", 
(::MQTTClient_Interface.Reset.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(2815000061), "Reset", 
(::MQTTClient_Interface.ComDiagnosis.pMeth)$UINT, _CH_CMD$UINT, 2#0000000000000000$UINT, TO_UDINT(3469133610), "ComDiagnosis", 
//Clients:
(::MQTTClient_Interface.MQTTClient.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(1836049339), "MQTTClient", TO_UDINT(1836049339), "MQTTClient", 1$UINT, 5$UINT, 
(::MQTTClient_Interface.SigCLib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(77440046), "SigCLib", TO_UDINT(77440046), "SigCLib", 0$UINT, 38$UINT, 
(::MQTTClient_Interface.Stdlib.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000100$UINT, TO_UDINT(584375759), "Stdlib", TO_UDINT(3689364044), "_StdLib", 0$UINT, 0$UINT, 
(::MQTTClient_Interface.XMLFilenameString.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(4000462193), "XMLFilenameString", TO_UDINT(1850111279), "String", 1$UINT, 11$UINT, 
(::MQTTClient_Interface._XMLReader.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(3727258101), "_XMLReader", TO_UDINT(3727258101), "_XMLReader", 2$UINT, 3$UINT, 
(::MQTTClient_Interface.OpenSSL.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000000$UINT, TO_UDINT(1216330219), "OpenSSL", TO_UDINT(1010260118), "_OpenSSL", 1$UINT, 9$UINT, 
(::MQTTClient_Interface.cUseXML.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1067939633), "cUseXML", 
(::MQTTClient_Interface.cDataMapPubTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2713916592), "cDataMapPubTimeout", 
(::MQTTClient_Interface.cLogConfig.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1241577001), "cLogConfig", 
(::MQTTClient_Interface.cDataMapSubTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1257549747), "cDataMapSubTimeout", 
(::MQTTClient_Interface.cDataMapResetTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2105960007), "cDataMapResetTimeout", 
(::MQTTClient_Interface.cConnectTimeout.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2610202812), "cConnectTimeout", 
(::MQTTClient_Interface.cAutoResetTime.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(1255223870), "cAutoResetTime", 
(::MQTTClient_Interface.cEventLog.pCh)$UINT, _CH_CLT_CMD$UINT, 2#0000000000000100$UINT, TO_UDINT(982396215), "cEventLog", 
(::MQTTClient_Interface.cActivateTrace.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000100$UINT, TO_UDINT(219171063), "cActivateTrace", 
(::MQTTClient_Interface.DataMapEntries.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(3109295212), "DataMapEntries", 
(::MQTTClient_Interface.PubSubEntries.pCh)$UINT, _CH_CLT_DATA$UINT, 2#0000000000000010$UINT, TO_UDINT(2727187074), "PubSubEntries", 
(::MQTTClient_Interface._ComLogging.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(776174809), "_ComLogging", TO_UDINT(776174809), "_ComLogging", 1$UINT, 3$UINT, 
(::MQTTClient_Interface.CriticalSection.pCh)$UINT, _CH_CLT_OBJ$UINT, 2#0000000000000010$UINT, TO_UDINT(794617671), "CriticalSection", TO_UDINT(794617671), "CriticalSection", 0$UINT, 4$UINT, 
END_FUNCTION


#define USER_CNT_MQTTClient_Interface 0

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MQTTClient_Interface] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MQTTClient_Interface::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
	END_VAR

	//Command Methods
	InitCmdTable (nCmd := nSTDCMD + USER_CNT_MQTTClient_Interface, pCmd := #vmt.CmdTable);
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	InterfaceState.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF InterfaceState.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ClientID.pMeth			:= StoreMethod( #ClientID::Read(), #ClientID::Write() );
	IF ClientID.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	ClientActive.pMeth			:= StoreMethod( #M_RD_DIRECT(), #ClientActive::Write() );
	IF ClientActive.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	CleanSession.pMeth			:= StoreMethod( #CleanSession::Read(), #CleanSession::Write() );
	IF CleanSession.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	SessionPresent.pMeth			:= StoreMethod( #SessionPresent::Read(), #M_NO_F() );
	IF SessionPresent.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, XMLFilename.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.Read		:= #XMLFilename::Read();
	vmt.CmdTable.Write		:= #XMLFilename::Write();
	XMLFilename.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF XMLFilename.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	Reset.pMeth			:= StoreMethod( #M_RD_DIRECT(), #M_WR_DIRECT() );
	IF Reset.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	_memcpy((#vmt.CmdTable)$^USINT, ComDiagnosis.pMeth, SIZEOF(CMDMETH));
	vmt.CmdTable.nCmds		:= nSTDCMD;
	vmt.CmdTable.NewInstr		:= #ComDiagnosis::NewInst();
	ComDiagnosis.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF ComDiagnosis.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

#pragma usingLtd MQTTClient_Interface_ConfigBase
#pragma usingLtd MQTTTopic

//{{LSL_IMPLEMENTATION
#pragma usingLtd StringInternal
#pragma usingLtd MQTTTopic
#pragma usingLtd MQTTClient_Interface_ConfigBase
FUNCTION PubSub_Callback   VAR_INPUT pThis 	: ^void; MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes; iMid 	: INT; iGrantedQoS 	: INT; pMessage : ^MQTTClient::t_s_MQTTMessage;  END_VAR;

//================================================================================================================================================================
//-------------------------------------------------------------------INITITALISE METHODS--------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::Init

  //Increment the Init Counter
  udInitCounter += 1;
  
  //If in the correct state
  if udInitCounter = MQTTCLIENTINTERFACE_INIT_CYCLE then
    
    //Init Variables
    Config.bFirstCall           := TRUE;
    Config.bFirstRun            := TRUE;
    Config.IsConn.LogConfig     := to_bool(IsClientConnected(input:=#cLogConfig));
    Config.IsConn.PubTimeout    := to_bool(IsClientConnected(input:=#cDataMapPubTimeout));
    Config.IsConn.SubTimeout    := to_bool(IsClientConnected(input:=#cDataMapSubTimeout));
    Config.IsConn.ConnTimeout   := to_bool(IsClientConnected(input:=#cConnectTimeout));
    Config.IsConn.UseXML        := to_bool(IsClientConnected(input:=#cUseXML));
    Config.iNextSubMID          := MQTTCLIENTINTERFACE_SUB_MID_INITVAL;
    Config.iNextPubMID          := MQTTCLIENTINTERFACE_PUB_MID_INITVAL;
    
    //Memory Allocations
    if Config.pDataMapConfig = NIL then
    
      Config.pDataMapConfig$^void := MQTTClient.MallocV1( size0 :=  sizeof(t_s_DataMapConfig), 
                                                          mark0 :=  MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK);
      
      //If the allocation was OK, clear the mem and allocate mem for the Publish and Subscribe Entries
      if Config.pDataMapConfig <> NIL then
        
        SigCLib.MemSet( dst   :=  Config.pDataMapConfig, 
                        c     :=  0x00, 
                        len   :=  sizeof(t_s_DataMapConfig));
        
        //If the amount of DataMap Entries are too low, set the minimum value
        DataMapEntries := DataMapEntries.Read();        
        if DataMapEntries < MQTTCLIENTINTERFACE_DATAMAP_MAXNUM_PUBLISH_ELEMENTS then
          DataMapEntries := MQTTCLIENTINTERFACE_DATAMAP_MAXNUM_PUBLISH_ELEMENTS;
          DataMapEntries.Write(input:=DataMapEntries);
        end_if;
        
        Config.pDataMapConfig^.udEntries := DataMapEntries;
        
        //Allocate mem for the Publish Entries
        Config.pDataMapConfig^.Elements.pPublishEntries$^void := MQTTClient.MallocV1( size0 :=  sizeof(t_s_DataMap_ElementEntry_Publish) * Config.pDataMapConfig^.udEntries, 
                                                                                      mark0 :=  MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK);                                                                    
                                                                            
        //Allocate mem for the Subscribe Entries
        Config.pDataMapConfig^.Elements.pSubscribeEntries$^void := MQTTClient.MallocV1( size0 :=  sizeof(t_s_DataMap_ElementEntry_Subscribe) * Config.pDataMapConfig^.udEntries, 
                                                                                        mark0 :=  MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK);
        
        //If the allocation is OK, clear the mem, else stop and error
        if Config.pDataMapConfig^.Elements.pPublishEntries    &
           Config.pDataMapConfig^.Elements.pSubscribeEntries  then
          
          //Set the Debug Pointers
          Config.pDataMapConfig^.Elements.pPublishDebug$^t_s_DataMap_ElementEntry_Publish     := Config.pDataMapConfig^.Elements.pPublishEntries;
          Config.pDataMapConfig^.Elements.pSubscribeDebug$^t_s_DataMap_ElementEntry_Subscribe := Config.pDataMapConfig^.Elements.pSubscribeEntries;
          
          SigCLib.MemSet( dst :=  Config.pDataMapConfig^.Elements.pPublishEntries, 
                          c   :=  0x00, 
                          len :=  sizeof(t_s_DataMap_ElementEntry_Publish) * Config.pDataMapConfig^.udEntries);
          
          SigCLib.MemSet( dst :=  Config.pDataMapConfig^.Elements.pSubscribeEntries, 
                          c   :=  0x00, 
                          len :=  sizeof(t_s_DataMap_ElementEntry_Subscribe) * Config.pDataMapConfig^.udEntries);
                              
        else
        
          //Create Log: Failed to assign memory for DataMap Entries.
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_INIT_DATAMAP_PUBSUB_MALLOC_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_INIT_DATAMAP_PUBSUB_MALLOC_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_INIT_DATAMAP_PUBSUB_MALLOC_TEXT,
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                      
                      
          InterfaceState := MCIS_Error;
        end_if;
         
      else
        //Create Log: Failed to assign memory for DataMap Entries.
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_INIT_DATAMAP_MALLOC_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_INIT_DATAMAP_MALLOC_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_INIT_DATAMAP_MALLOC_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                    
                    
        InterfaceState := MCIS_Error;
      end_if;
        
    end_if;
    
    if Config.pPubSubConfig = NIL then
    
      Config.pPubSubConfig$^void := MQTTClient.MallocV1(size0 :=  sizeof(t_s_PubSubConfig), 
                                                        mark0 :=  MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK);
                                                    
      if Config.pPubSubConfig then
      
        SigCLib.MemSet( dst :=  Config.pPubSubConfig, 
                        c   :=  0x00, 
                        len :=  sizeof(t_s_PubSubConfig));
        
        //If the number of entries are too few, increase
        PubSubEntries := PubSubEntries.Read();
        
        if PubSubEntries < MQTTCLIENTINTERFACE_NUM_PUBSUB_ELEMENTS then
          
          PubSubEntries := MQTTCLIENTINTERFACE_NUM_PUBSUB_ELEMENTS;
          PubSubEntries.Write(input:=PubSubEntries);
          
        end_if;
        
        Config.pPubSubConfig^.udNextAppliID := MQTTCLIENTINTERFACE_APPLID_INITVAL;
        
        Config.pPubSubConfig^.PubSubList.udMaxEntries := PubSubEntries;
        
        Config.pPubSubConfig^.PubSubList.pEntries$^void := MQTTClient.MallocV1( size0  :=  Config.pPubSubConfig^.PubSubList.udMaxEntries * sizeof(t_s_PubSubEntry), 
                                                                                mark0  :=  MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK);
        
        Config.pPubSubConfig^.PubSubList.EntriesDebug$UDINT := Config.pPubSubConfig^.PubSubList.pEntries$UDINT;
        
        if Config.pPubSubConfig^.PubSubList.pEntries = NIL then
          
          //Create Log: Failed to assign Memory for PubSubList.
                          
          InterfaceState := MCIS_Error;
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_INIT_PUBSUBLIST_ENTRIES_MALLOC_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_INIT_PUBSUBLIST_ENTRIES_MALLOC_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_INIT_PUBSUBLIST_ENTRIES_MALLOC_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
        
        end_if;

        
      else
        //Create Log: Failed to assign Memory for PubSubList.
                        
        InterfaceState := MCIS_Error;
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_INIT_PUBSUBLIST_MALLOC_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_INIT_PUBSUBLIST_MALLOC_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_INIT_PUBSUBLIST_MALLOC_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
      end_if;

      
    end_if;
    
    //=======================
    //Prepare Logging:
    //=======================
      
      DiagnosticData.LogEvents.Level_Error.dLastClientGroup       := -1;
      DiagnosticData.LogEvents.Level_Error.dLastClientMessage     := -1;
      DiagnosticData.LogEvents.Level_Error.dLastGlobalGroup       := -1;
      DiagnosticData.LogEvents.Level_Error.dLastGlobalMessage     := -1;
      DiagnosticData.LogEvents.Level_Error.dLastInterfaceGroup    := -1;
      DiagnosticData.LogEvents.Level_Error.dLastInterfaceMessage  := -1;
      DiagnosticData.LogEvents.Level_Error.dLastTopicGroup        := -1;
      DiagnosticData.LogEvents.Level_Error.dLastTopicMessage      := -1;
      
      DiagnosticData.LogEvents.Level_Warning  := DiagnosticData.LogEvents.Level_Error;
      DiagnosticData.LogEvents.Level_Info     := DiagnosticData.LogEvents.Level_Error;
      DiagnosticData.LogEvents.Level_Debug    := DiagnosticData.LogEvents.Level_Error;
    
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::InitMem
  
  
  
END_FUNCTION
//================================================================================================================================================================
//----------------------------------------------------------------END OF INITITALISE METHODS----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-----------------------------------------------------------------SERVER INTERFACE METHODS-----------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::ClientID::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	ClientID := MQTTClient.ClientID.Read();
	output := ClientID;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::ClientID::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	ClientID := input;
	result := (MQTTClient.ClientID.Write(ClientID))$UDINT;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::XMLFilename::Read
	VAR_OUTPUT
		output (EAX) 	: UDINT;
	END_VAR

	XMLFilename := XMLFilenameString.Data.Read();
	output := XMLFilename;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::XMLFilename::Write
	VAR_INPUT
		input (EAX) 	: UDINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: UDINT;
	END_VAR

	XMLFilename := input;
	result := (XMLFilenameString.Data.Write(XMLFilename))$UDINT;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::ClientActive::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR
  VAR
  	iRetCode : INT;
    tmpPara : DINT;
  END_VAR

  //Falling edge (Disabling Client)
  if (ClientActive = 1) &
     (input = 0)        then
    
    //If the state is OK
    if InterfaceState = MCIS_Connected         |
       InterfaceState = MCIS_WaitForConnection |
       InterfaceState = MCIS_Reconnecting      then
      
      //Issue Disconnect Command
      iRetCode := MQTTClient.mqtt_disconnect();
      
      
      //Diagnostic Info:
      Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                        udValue :=  iRetCode$UDINT);
      
      if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
        Diagnostic_Event( Event   :=  DL_Error, 
                          udValue :=  0);
      end_if;
                        
      if iRetCode = MQTTClient::MQTT_ERR_SUCCESS$INT then
        //Create Log: MQTT Client disconnect requested
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG,
                          dMsgGroup   :=  MQCLIINF_LOG_DEBUG_CLIENTACTIVE_DISCONNECT_REQUESTED_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_DEBUG_CLIENTACTIVE_DISCONNECT_REQUESTED_MSG, 
                          pMsg        :=  MQCLIINF_LOG_DEBUG_CLIENTACTIVE_DISCONNECT_REQUESTED_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
      elsif iRetCode = MQTTClient::MQTT_ERR_NO_CONN$INT then
        //Create Log: Requesting MQTT Client Disconnect Failed, no Connection to disconnect.
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_CLIENTACTIVE_DISCONNECT_REQUESTED_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_CLIENTACTIVE_DISCONNECT_REQUESTED_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_CLIENTACTIVE_DISCONNECT_REQUESTED_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
      else
        //Create Log: Unexpected retcode whilst requesting MQTT Client Disconnect.
        tmpPara := to_dint(iRetCode);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_CLIENTACTIVE_DISCONNECT_UNEXPECTED_RETCODE_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_CLIENTACTIVE_DISCONNECT_UNEXPECTED_RETCODE_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_CLIENTACTIVE_DISCONNECT_UNEXPECTED_RETCODE_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
      end_if;
      
    end_if;
    
    ClientActive := 0;
    
  else
    
    ClientActive := input;
    
  end_if;
  
	result := ClientActive;

END_FUNCTION
//================================================================================================================================================================
//--------------------------------------------------------------END OF SERVER INTERFACE METHODS-------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-----------------------------------------------------------------------CYCLIC METHODS---------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;
	END_VAR

	state := READY;
  MQTTClientInterfaceTask();

END_FUNCTION

FUNCTION MQTTClient_Interface::MQTTClientInterfaceTask
  VAR
  	iRetCode : INT;
    dTemp : DINT;
  END_VAR

  //Set FirstCall if state is changed
  Config.bFirstCall := InterfaceState <> LastState;
  
  //If not already in Error state, check for errors from interfaces
  if InterfaceState <> MCIS_Error then
    Diagnostic_ReadErrors();
  end_if;
  
  //=============================================
  //FSM For MQTT Client Interface
  //=============================================
  case InterfaceState of
  
    //-----------------------------------------------------------------
    //Wait for activation
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Ready:
      
      if ClientActive = 1 then
        
        if Config.IsConn.PubTimeout then
          cDataMapPubTimeout := cDataMapPubTimeout.Read();
        end_if;
        
        if Config.IsConn.SubTimeout then
          cDataMapSubTimeout := cDataMapSubTimeout.Read();
        end_if;
        
        if Config.IsConn.ConnTimeout then
          cConnectTimeout := cConnectTimeout.Read();
        end_if;

        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO, 
                          dMsgGroup   :=  MQCLIINF_LOG_INFO_FSM_CLIENT_ACTIVATED_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_INFO_FSM_CLIENT_ACTIVATED_MSG, 
                          pMsg        :=  MQCLIINF_LOG_INFO_FSM_CLIENT_ACTIVATED_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        
        InterfaceState := MCIS_Initialise;
        
        //Reset Diagnostic Data
        Diagnostic_Event( Event   :=  DL_Reset, 
                          udValue :=  0);
      end_if;
      
      LastState := MCIS_Ready;
      
    //-----------------------------------------------------------------
    //Initialise, Prepare, Read XML
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Initialise:
      
      //Perform Init task
      case MCIT_Initialise(bFirstCall:=Config.bFirstCall) of
        
        TR_Busy:  //Stay in this state
          
        TR_Done:  //Next State
          
          InterfaceState := MCIS_Prepare;
          
        TR_Error: //Go to Error State
          
          InterfaceState := MCIS_Error;
          
      end_case;
      
      LastState := MCIS_Initialise;
      
    //-----------------------------------------------------------------
    //Prepare Connection, set parameters, initiate Connection
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Prepare:
    
      //Perform Prepare task
      case MCIT_Prepare(bFirstCall:=Config.bFirstCall) of
        
        TR_Busy:  //Stay in this state
          
        TR_Done:  //Create Connection & Next State
          
          udTimestamp := ops.tAbsolute;
          
          MQTTClient.mqtt_loop_start();
          
          iRetCode := MQTTClient.mqtt_connect_async(  host      :=  #MQTTClientConfigData.Config.Connect.aHostname[0], 
                                                      port      :=  MQTTClientConfigData.Config.Connect.iPort, 
                                                      keepalive :=  MQTTClientConfigData.Config.Connect.iKeepalive);
          
          //Diagnostic Info:
          Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                            udValue :=  iRetCode$UDINT);
          
          if iRetCode = MQTTClient::MQTT_ERR_SUCCESS$INT then
            
            InterfaceState := MCIS_WaitForConnection;
            udTimestamp := ops.tAbsolute;
          
          else
            
            //Diagnostic Info:  
            Diagnostic_Event( Event   :=  DL_Error, 
                              udValue :=  0);
            
            Diagnostic_Event( Event   :=  DL_ConnectFail, 
                              udValue :=  0);
            
            dTemp := to_dint(iRetCode);
            
            //Create Log Message
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_CONNECTION_FAILED_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_CONNECTION_FAILED_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_FSM_CONNECTION_FAILED_TEXT, 
                              pPara1      :=  #dTemp, 
                              pPara2      :=  NIL, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
            
            //Go to Error
            InterfaceState := MCIS_Error;
            
          end_if;
          
        TR_Error: //Go to Error State
          
          InterfaceState := MCIS_Error;
          
      end_case;  
      
      LastState := MCIS_Prepare;    
      
    //-----------------------------------------------------------------
    //Wait for connection to be made
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_WaitForConnection:
      
      if ops.tAbsolute - udTimestamp >= cConnectTimeout then
        InterfaceState := MCIS_Error;
        //Diagnostic Info:
        Diagnostic_Event( Event   :=  DL_WatchdogTimeout, 
                          udValue :=  0);
      end_if;
      
      LastState := MCIS_WaitForConnection;
    
    //-----------------------------------------------------------------
    //Wait for connection to be made
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Reconnecting:
      
      Diagnostic_Calculate();
      
    //-----------------------------------------------------------------
    //Connected state
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Connected:
     
      Diagnostic_Calculate();
      DataMap_ProcessMap();
    
      LastState := MCIS_Connected;
    
    //-----------------------------------------------------------------
    //Error Occured
    //-----------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Error:
      
      //If this is the first cycle in this state
      if LastState <> InterfaceState then
        MQTTClient.mqtt_disconnect();
        udTimestamp := ops.tAbsolute;
      end_if;
      
      //If Reset
      if (Reset = 1)                                    |
         (cAutoResetTime <> 0                         &
          ops.tAbsolute - udTimestamp >= cAutoResetTime) then
        Reset := 0;
        InterfaceState := MCIS_Ready;
      end_if;
      
      LastState := MCIS_Error;
      
  end_case;
    
END_FUNCTION

FUNCTION MQTTClient_Interface::MCIT_Initialise
  VAR_INPUT
    bFirstCall : BOOL;
  END_VAR
	VAR_OUTPUT
		eRet 	: t_e_TaskRet;
	END_VAR
  
  //Assume Busy
  eRet := TR_Busy;
  
  //If first call, restart the FSM
  if bFirstCall then
    States.Initialise := MCSI_Initialize;
  end_if;

  //============================================
  //Initialise FSM
  //============================================
  case States.Initialise of
    
    //----------------------------------
    //Prepare mem, name and XML Reader
    //----------------------------------
    t_e_MCSInit::MCSI_Initialize:
      
      //Clear Mem
      SigCLib.MemSet( dst :=  #MQTTClientConfigData, 
                      c   :=  0x00, 
                      len :=  sizeof(MQTTClientConfigData));
      
      //If using the XML File, process it
      if Config.IsConn.UseXML then
        cUseXML := cUseXML.Read();
      end_if;
      
      if cUseXML = 1 then
      
        //XML Filename
        SigCLib.MemSet( dst :=  #Config.Initialize.aXMLFilename, 
                        c   :=  0x00, 
                        len :=  sizeof(Config.Initialize.aXMLFilename));
        XMLFilenameString.ReadDataOff(udOff :=  0, 
                                      pData :=  #Config.Initialize.aXMLFilename[0], 
                                      udMax :=  MQTTCLIENTINTERFACE_MAX_XMLNAME_LEN);
        //Reset Reader
        _XMLReader.Reset();
        _XMLReader.FreeReader();
        
        States.Initialise := MCSI_ReadXML;
      
      
      //If not using the XML File, skip reading & Processing
      else
      
        States.Initialise := MCSI_AppliConfig;
      
      end_if;

      //Get Logging Config from Client
      if Config.IsConn.LogConfig then
        cLogConfig := cLogConfig.Read();
      end_if;
   
    //----------------------------------
    //Read the XML
    //----------------------------------
    t_e_MCSInit::MCSI_ReadXML:
      
      //Start XML File Read
      if _XMLReader.ReadFile(FileName:=#Config.Initialize.aXMLFilename[0]) then
        States.Initialise := MCSI_WaitForReadXML;
        udTimestamp := ops.tAbsolute;
      else
        //Create Log: Failed to read XML File
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_INIT_READ_FILE_FAILED_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_INIT_READ_FILE_FAILED_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_FSM_INIT_READ_FILE_FAILED_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        States.Initialise := MCSI_Error;
      end_if;
            
    //----------------------------------
    //Wait for read to finish
    //----------------------------------
    t_e_MCSInit::MCSI_WaitForReadXML:
      
      //Read Complete
      if _XMLReader.GetXmlState() = _XMLReader::XML_READ_STATE::_STRUCT_CREATED then
        
        States.Initialise := MCSI_PrepDataMap;
        
      //Read Error
      elsif _XMLReader.GetXmlState() = _XMLReader::XML_READ_STATE::_ERROR then
      
        States.Initialise := MCSI_Error;
        
      //Timeout
      elsif ops.tAbsolute - udTimestamp >= MQTTCLIENTINTERFACE_XML_MAX_READ_TIME then
      
        States.Initialise := MCSI_Error;
      
      end_if;
    
    //----------------------------------
    //Prepare the DataMap - Remove all datamap entries that belong to the XML
    //----------------------------------
    t_e_MCSInit::MCSI_PrepDataMap:
        
      if Config.pDataMapConfig = NIL then
        //Create Log: Could not initialise, Datamap memory is not OK.
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_INIT_DATAMAP_PTR_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_INIT_DATAMAP_PTR_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_FSM_INIT_DATAMAP_PTR_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        eRet := TR_Error;
        return;
      end_if;
      
      DataMap_Clear();

      eRet := TR_Busy;
      States.Initialise := MCSI_ProcessXML;
      
    //----------------------------------
    //Process the XML
    //----------------------------------
    t_e_MCSInit::MCSI_ProcessXML:
      
      //Process XML
      if ProcessXML() then
        
        //Update Log Config
        cLogConfig := MQTTClientConfigData.Config.Logging.bdActiveLogs;
        if Config.IsConn.LogConfig then
          cLogConfig.Write(input:=cLogConfig);
        end_if;

        States.Initialise := MCSI_AppliConfig;
        Config.ConfigObject.State := CO_ClientID;
        
      //Failed
      else
        
        States.Initialise := MCSI_Error;
        
      end_if;

    
    //----------------------------------
    //Call the application config object
    //----------------------------------
    t_e_MCSInit::MCSI_AppliConfig:
      
      //If an object is logged in
      if Config.ConfigObject.pThis then
        
        //Process the user config
        case ConfigObject_Process() of
          //------------
          //Keep Calling
          //------------
          TR_Busy:
          
            eRet := TR_Busy;
          
          //------------
          //Done, Advance
          //------------
          TR_Done:
            
            eRet := TR_Done;
          
          //------------
          //Error Occurred
          //------------
          TR_Error:
            
            States.Initialise := MCSI_Error;
          
        end_case;
        
      else
        
        eRet := TR_Done;
        
      end_if;

    
    //----------------------------------
    //Error Occurred
    //----------------------------------
    t_e_MCSInit::MCSI_Error:
      
      eRet := TR_Error;
      
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::MCIT_Prepare
	VAR_INPUT
		bFirstCall 	: BOOL;
	END_VAR
	VAR_OUTPUT
		eRet 	: t_e_TaskRet;
	END_VAR
  VAR
  	iRetCode              : INT;
    pCA, pCert, pKey, pPW : ^CHAR;
    tmpPayLoadSize        : UDINT;
    tmpPara1              : DINT;
    tmpPara2              : DINT;
    tmpPara3              : DINT;
    pID                   : ^UINT;
  END_VAR

  //Assume OK
  eRet := TR_Done;
  
  //==================================
  //Set the MQTT Class Parameters
  //==================================
    
    //---------------------------------
    //Client ID
    //---------------------------------
    if MQTTClientConfigData.Config.bClientIDSet then
      pID := #MQTTClientConfigData.Config.aClientID[0];
    else
      pID := NIL;
    end_if;

    iRetCode := MQTTClient.mqtt_reinitialise( id            :=  pID, 
                                              clean_session :=  (CleanSession.Read() = 1));
    
    //Diagnostic Info:
    Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                      udValue :=  iRetCode$UDINT);
    
    if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
      Diagnostic_Event( Event   :=  DL_Error, 
                        udValue :=  0);
    end_if;
    //- - - - - - - - - - - - - - - - - - - - -
    //Process Reponse
    //- - - - - - - - - - - - - - - - - - - - -
    case iRetCode$MQTTClient::t_e_MQTTErrors of
      //-  -  -  -  -  -  -  -  -  -
      //OK
      //-  -  -  -  -  -  -  -  -  -
      MQTTClient::MQTT_ERR_SUCCESS: 
      
        
      
      //-  -  -  -  -  -  -  -  -  -
      //Not OK
      //-  -  -  -  -  -  -  -  -  -
      MQTTClient::MQTT_ERR_NOMEM:
      
        eRet := TR_Error;
        //Create Log: Error during setting MQTTClient Parameters from XML File, Setting ClientID Failed, Not Enough memory
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_INIT_FAIL_NOMEM_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_INIT_FAIL_NOMEM_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_INIT_FAIL_NOMEM_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        return;
        
      //-  -  -  -  -  -  -  -  -  -
      //
      //-  -  -  -  -  -  -  -  -  -
      MQTTClient::MQTT_ERR_INVAL:
        
        eRet := TR_Error;
        //Create Log: Error during setting MQTTClient Parameters from XML File, Setting ClientID Failed, Input Value / Client State Not OK
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_INIT_FAIL_INPUT_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_INIT_FAIL_INPUT_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_INIT_FAIL_INPUT_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        return;
      
    end_case;
    
    //---------------------------------
    //Connect -> Username & Password
    //---------------------------------
    if MQTTClientConfigData.Config.Connect.ValuesSet.Username then //& 
       //MQTTClientConfigData.Config.Connect.ValuesSet.Password then
      
      iRetCode := MQTTClient.mqtt_username_pw_set(username    :=  #MQTTClientConfigData.Config.Connect.aUsername[0], 
                                                  password    :=  #MQTTClientConfigData.Config.Connect.aPassword[0]$BYTE, 
                                                  udPassLen   :=  (SigCLib.StrLen16(str0:=#MQTTClientConfigData.Config.Connect.aPassword[0])*sizeof(UINT)));
      
      //Diagnostic Info:
      Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                        udValue :=  iRetCode$UDINT);
      
      if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
        Diagnostic_Event( Event   :=  DL_Error, 
                          udValue :=  0);
      end_if;
      
      //- - - - - - - - - - - - - - - - - - - - -
      //Process Reponse
      //- - - - - - - - - - - - - - - - - - - - -
      case iRetCode$MQTTClient::t_e_MQTTErrors of
        //-  -  -  -  -  -  -  -  -  -
        //OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_SUCCESS: 
        
          
        
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_NOMEM:
        
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Username & Password Failed, Not Enough memory
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_USNPW_FAIL_NOMEM_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_USNPW_FAIL_NOMEM_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_USNPW_FAIL_NOMEM_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
          
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_INVAL:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Username & Password Failed, Input Value / Client State Not OK
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_USNPW_FAIL_INPUT_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_USNPW_FAIL_INPUT_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_USNPW_FAIL_INPUT_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
        
      end_case;
      
      
    end_if;

    
    //---------------------------------
    //Connect -> Max Inflight Messages
    //---------------------------------
    if MQTTClientConfigData.Config.Connect.ValuesSet.MaxInflight then
      
      iRetCode := MQTTClient.mqtt_max_inflight_messages_set(max_inflight_messages:=MQTTClientConfigData.Config.Connect.iMaxInflightMessages);
      
      //Diagnostic Info:
      Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                        udValue :=  iRetCode$UDINT);
      
      if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
        Diagnostic_Event( Event   :=  DL_Error, 
                          udValue :=  0);
      end_if;
      
      //- - - - - - - - - - - - - - - - - - - - -
      //Process Reponse
      //- - - - - - - - - - - - - - - - - - - - -
      case iRetCode$MQTTClient::t_e_MQTTErrors of
        //-  -  -  -  -  -  -  -  -  -
        //OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_SUCCESS: 
        
          
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_INVAL:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Max Inflight Messages Failed, Input Value / Client State Not OK
          tmpPara1 := to_dint(MQTTClientConfigData.Config.Connect.iMaxInflightMessages);
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_INFLIGHT_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_INFLIGHT_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_INFLIGHT_TEXT, 
                            pPara1      :=  #tmpPara1, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
        
      end_case;
      
      
    end_if;
    
    //---------------------------------
    //Will
    //---------------------------------
    if MQTTClientConfigData.Config.Will.ValuesSet.Topic       & 
       MQTTClientConfigData.Config.Will.ValuesSet.Payload     & 
       MQTTClientConfigData.Config.Will.ValuesSet.QoS         &
       MQTTClientConfigData.Config.Will.ValuesSet.RetainWill  then
      
      MQTTClient.mqtt_will_clear();
      
      tmpPayLoadSize := SigCLib.StrLen(str:=#MQTTClientConfigData.Config.Will.aPayload[0]);
      
      iRetCode := MQTTClient.mqtt_will_set( topic       :=  #MQTTClientConfigData.Config.Will.aTopic[0], 
                                            payloadLen  :=  tmpPayLoadSize, 
                                            payload     :=  #MQTTClientConfigData.Config.Will.aPayload[0]$BYTE, 
                                            qos         :=  MQTTClientConfigData.Config.Will.iQoS, 
                                            retain_will :=  MQTTClientConfigData.Config.Will.bRetain);
      
      //Diagnostic Info:
      Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                        udValue :=  iRetCode$UDINT);
      
      
      if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
        Diagnostic_Event( Event   :=  DL_Error, 
                          udValue :=  0);
      end_if;
      
      //- - - - - - - - - - - - - - - - - - - - -
      //Process Reponse
      //- - - - - - - - - - - - - - - - - - - - -
      case iRetCode$MQTTClient::t_e_MQTTErrors of
        //-  -  -  -  -  -  -  -  -  -
        //OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_SUCCESS: 
        
          
        
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_NOMEM:
        
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Will Failed, Not Enough memory
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_NOMEM_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_NOMEM_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_NOMEM_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
          
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_INVAL:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Will Failed, Input Value / Client State Not OK
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_INPUT_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_INPUT_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_INPUT_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
          
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_PAYLOAD_SIZE:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Will Failed, Invalid Payload Size
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_PAYLOAD_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_PAYLOAD_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_PAYLOAD_TEXT, 
                            pPara1      :=  #tmpPayLoadSize$DINT, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                            
          return;
          
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_MALFORMED_UTF8:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Will Failed, Malformed UTF8
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_UTF8_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_UTF8_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_WILL_UTF8_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
        
      end_case;
      
      
    end_if;
    
    //---------------------------------
    //Reconnect
    //---------------------------------
    if MQTTClientConfigData.Config.Reconnect.ValuesSet.MinInterval      & 
       MQTTClientConfigData.Config.Reconnect.ValuesSet.MaxInterval      & 
       MQTTClientConfigData.Config.Reconnect.ValuesSet.ExponentialScale then
      
      iRetCode := MQTTClient.mqtt_reconnect_delay_set(reconnect_delay             :=  to_uint(MQTTClientConfigData.Config.Reconnect.iMinInterval), 
                                                      reconnect_delay_max         :=  to_uint(MQTTClientConfigData.Config.Reconnect.iMaxInterval), 
                                                      reconnect_exponential_delay :=  MQTTClientConfigData.Config.Reconnect.bExponential);
      //Diagnostic Info:
      Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                        udValue :=  iRetCode$UDINT);
                          
      if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
        Diagnostic_Event( Event   :=  DL_Error, 
                          udValue :=  0);
      end_if;
                          
      //- - - - - - - - - - - - - - - - - - - - -
      //Process Reponse
      //- - - - - - - - - - - - - - - - - - - - -
      case iRetCode$MQTTClient::t_e_MQTTErrors of
        //-  -  -  -  -  -  -  -  -  -
        //OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_SUCCESS: 
        
          
        
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_INVAL:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting Reconnect Parameters Failed, Input Value / Client State Not OK
          
          tmpPara1 := to_dint(MQTTClientConfigData.Config.Reconnect.iMinInterval);
          tmpPara2 := to_dint(MQTTClientConfigData.Config.Reconnect.iMaxInterval);
          tmpPara3 := to_dint(MQTTClientConfigData.Config.Reconnect.bExponential);
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_RECONNECT_INPUT_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_RECONNECT_INPUT_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_RECONNECT_INPUT_TEXT, 
                            pPara1      :=  #tmpPara1, 
                            pPara2      :=  #tmpPara2, 
                            pPara3      :=  #tmpPara3, 
                            pPara4      :=  NIL);
                            
          return;
        
      end_case;
      
      
    end_if;
    
    //---------------------------------
    //TLS
    //---------------------------------
    
    if MQTTClientConfigData.Config.TLS.ValuesSet.TLS then
    
      pCA := pCert := pKey := pPW := NIL;
      
      if MQTTClientConfigData.Config.TLS.ValuesSet.CAFile then
        pCA := #MQTTClientConfigData.Config.TLS.aCAFile[0];
      end_if;
      if MQTTClientConfigData.Config.TLS.ValuesSet.CertFile then
        pCert := #MQTTClientConfigData.Config.TLS.aCertFile[0];
      end_if;
      if MQTTClientConfigData.Config.TLS.ValuesSet.KeyFile then
        pKey := #MQTTClientConfigData.Config.TLS.aKeyFile[0];
      end_if;
      if MQTTClientConfigData.Config.TLS.ValuesSet.Password then
        pPW := #MQTTClientConfigData.Config.TLS.aPassword[0];
      end_if;

      
      
      iRetCode := MQTTClient.mqtt_tls_set(cafile    :=  pCA, 
                                          certfile  :=  pCert, 
                                          keyfile   :=  pKey, 
                                          pw        :=  pPW);
      
      //Diagnostic Info:
      Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                        udValue :=  iRetCode$UDINT);
      
      if iRetCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then
        Diagnostic_Event( Event   :=  DL_Error, 
                          udValue :=  0);
      end_if;
      
      //- - - - - - - - - - - - - - - - - - - - -
      //Process Reponse
      //- - - - - - - - - - - - - - - - - - - - -
      case iRetCode$MQTTClient::t_e_MQTTErrors of
        //-  -  -  -  -  -  -  -  -  -
        //OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_SUCCESS: 
        
          
        
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_NOMEM:
        
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting TLS Data Failed, Not Enough memory
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_TLS_NOMEM_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_TLS_NOMEM_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_TLS_NOMEM_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
          
        //-  -  -  -  -  -  -  -  -  -
        //Not OK
        //-  -  -  -  -  -  -  -  -  -
        MQTTClient::MQTT_ERR_INVAL:
          
          eRet := TR_Error;
          //Create Log: Error during setting MQTTClient Parameters from XML File, Setting TLS Data Failed, Input Value / Client State Not OK
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_TLS_INPUT_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_TLS_INPUT_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_FSM_PREP_SET_TLS_INPUT_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          return;
        
      end_case;
    
    end_if;   
    
    
    //===================
    //Set Callbacks
    //===================
    MQTTClient.mqtt_connect_with_flags_callback_set(  pThis                 :=  this, 
                                                      on_connect_with_flags :=  #Callback_OnConnectWithFlags());
    MQTTClient.mqtt_disconnect_callback_set(          pThis                 :=  this, 
                                                      on_disconnect         :=  #Callback_OnDisconnect());
    MQTTClient.mqtt_publish_callback_set(             pThis                 :=  this, 
                                                      on_publish            :=  #Callback_OnPublish());
    MQTTClient.mqtt_message_callback_set(             pThis                 :=  this, 
                                                      on_message            :=  #Callback_OnMessage());
    MQTTClient.mqtt_subscribe_callback_set(           pThis                 :=  this, 
                                                      on_subscribe          :=  #Callback_OnSubscribe());
    MQTTClient.mqtt_unsubscribe_callback_set(         pThis                 :=  this, 
                                                      on_unsubscribe        :=  #Callback_OnUnsubscribe());
    MQTTClient.mqtt_log_callback_set(                 pThis                 :=  this, 
                                                      on_log                :=  #Callback_OnLog());
    MQTTClient.mqtt_log_with_detail_callback_set(     pThis                 :=  this, 
                                                      on_log_with_detail    :=  #Callback_OnLog_WithDetail());
    
    
    //===================
    //Set Logging Filter
    //===================
    if MQTTClientConfigData.Config.Logging.bLogSet then
      _ComLogging.FileLogLevel.Write(input:=MQTTClientConfigData.Config.Logging.bdActiveLogs$UDINT);
      _ComLogging.EventLogLevel.Write(input:=MQTTClientConfigData.Config.Logging.bdActiveLogs$UDINT);
    end_if;

    
    
END_FUNCTION
//================================================================================================================================================================
//-------------------------------------------------------------------END OF CYCLIC METHODS------------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//---------------------------------------------------------------------INTERFACE METHODS--------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION GLOBAL MQTTClient_Interface::MQTT_Subscribe
	VAR_INPUT
		pTopic 	: ^UINT;
		iQoS 	: INT;
		pThis 	: ^void;
		pCallback 	: ^void;
		pMid 	: ^INT;
		pApplMsgID 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
  	iThisMID : INT;
    udThisApplID : UDINT;
    tmpPara, tmpPara2 : DINT;
    pEntry : ^t_s_PubSubEntry;
  END_VAR

  //Assume Error
  retCode := MQTT_ERR_INVAL;
  
  CriticalSection.SectionStart();
  
  //Diagnostic Info
  Diagnostic_Event( Event   :=  DL_SubRequest, 
                    udValue :=  0);
  
  //If the input values are not OK
  if pTopic = NIL               |
     iQoS < MQTT_PROT_QOS_MIN   |
     iQoS > MQTT_PROT_QOS_MAX   |
     pThis = NIL                |
     pMid = NIL                 then
    //Create Log: Could not Issue Subscirbe Request, invalid input values.
    
    tmpPara := to_dint(iQoS);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_INVALID_INPUT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_INVALID_INPUT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_INVALID_INPUT_TEXT, 
                      pPara1      :=  #pTopic$DINT, 
                      pPara2      :=  #tmpPara, 
                      pPara3      :=  #pThis$DINT, 
                      pPara4      :=  #pCallback$DINT);
                      
    Diagnostic_Event( Event   :=  DL_SubFail, 
                      udValue :=  0);
           
    CriticalSection.SectionStop();
    return;
    
  end_if;
  
  //If the interface is not in the correct state
  if InterfaceState < MCIS_Reconnecting |
     InterfaceState > MCIS_Connected    |
     Config.pPubSubConfig = NIL         then
     
    //Create Log: Could not issue Subscribe Request, The MQTT Interface is not initialized.
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_INTERFACE_STATE_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_INTERFACE_STATE_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_INTERFACE_STATE_TEXT, 
                      pPara1      :=  #InterfaceState$DINT, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    Diagnostic_Event( Event   :=  DL_SubFail, 
                      udValue :=  0);
                      
    CriticalSection.SectionStop();
    return;
    
  end_if;

  //If there is no more space in the list
  if Config.pPubSubConfig^.PubSubList.udNumEntries >= Config.pPubSubConfig^.PubSubList.udMaxEntries - 1 then
  
    retCode := MQTT_ERR_NOMEM;
    //Create Log: Could not issue subscribe request, MQTT Interface PubSubList is Full.
    
    tmpPara   := to_dint(Config.pPubSubConfig^.PubSubList.udMaxEntries);
    tmpPara2  := to_dint(Config.pPubSubConfig^.PubSubList.udNumEntries);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_LIST_FULL_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_LIST_FULL_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_LIST_FULL_TEXT, 
                      pPara1      :=  #tmpPara2, 
                      pPara2      :=  #tmpPara, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    Diagnostic_Event( Event   :=  DL_SubFail, 
                      udValue :=  0);      
                      
    CriticalSection.SectionStop();
    return;
    
  end_if;
  
  //========================
  //Add the QoS Diag Event
  //========================
  case iQos of
    //---------
    //QoS 0
    //---------
    0:
        Diagnostic_Event( Event   :=  DL_Sub0, 
                          udValue :=  0);
    
    //---------
    //QoS 1
    //---------
    1:
        Diagnostic_Event( Event   :=  DL_Sub1, 
                          udValue :=  0);
                          
    //---------
    //QoS 2
    //---------
    2:
        Diagnostic_Event( Event   :=  DL_Sub2, 
                          udValue :=  0);
  end_case;
  
  // Check if the subscription already exists, if so just return Already Subscribed
  udThisApplID := PubSub_CheckSubscription( pTopic    :=  pTopic, 
                                            pThis     :=  pThis, 
                                            pCallback :=  pCallback);
                                            
  if udThisApplID > 0 then
    
    tmpPara := to_dint(udThisApplID);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                      dMsgGroup   :=  MQCLIINF_LOG_INFO_SUBSCRIBE_ALREADY_SUBSCRIBED_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_INFO_SUBSCRIBE_ALREADY_SUBSCRIBED_MSG, 
                      pMsg        :=  MQCLIINF_LOG_INFO_SUBSCRIBE_ALREADY_SUBSCRIBED_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    retCode := MQTTClient::MQTT_ERR_ALREADY_SUB;
    
    CriticalSection.SectionStop();
    return;
    
  end_if;
  
  iThisMID      := Counters_GetSubMID();
  udThisApplID  := Counters_GetApplID();
  
  //Subscribe
  retCode := MQTTClient.mqtt_subscribe(mid        :=  #iThisMID, 
                                       subscribe  :=  pTopic, 
                                       qos        :=  iQoS);
  
  //Diagnostic Info:
  Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                    udValue :=  retCode$UDINT);
  
  //If the MQTT Client accepts the subscription, log the subscription to the PubSub List
  if retCode = MQTT_ERR_SUCCESS$INT then
    
    pEntry := (Config.pPubSubConfig^.PubSubList.pEntries$UDINT + sizeof(t_s_PubSubEntry)*Config.pPubSubConfig^.PubSubList.udNumEntries)$^t_s_PubSubEntry;
    
    pEntry^.iMid             := iThisMID;
    pEntry^.EntryType        := PSE_Subscribe;
    pEntry^.Callback.pThis   := pThis;
    pEntry^.Callback.pMethod := pCallback;
    pEntry^.udAppliID        := udThisApplID;    
    pEntry^.iUnsubMid        := -1;                       
    
    if pApplMsgID then
      pApplMsgID^ := udThisApplID; 
    end_if;
    
    if pMid then
      pMid^ := iThisMID;
    end_if;
    
    SigCLib.MemSet( dst :=  #pEntry^.aTopic[0], 
                    c   :=  0x00, 
                    len :=  sizeof(t_s_PubSubEntry.aTopic)); 
    SigCLib.StrCpy16( dst0  :=  #pEntry^.aTopic[0], 
                      src0  :=  pTopic);   
    
    Config.pPubSubConfig^.PubSubList.udNumEntries += 1;
    Counters_IncSubMID();
    Counters_IncApplID();
    
    //Create Log: Successfully issued Subscribe Request.
    
    tmpPara := to_dint(iThisMID);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                      dMsgGroup   :=  MQCLIINF_LOG_INFO_SUBSCRIBE_ENTRY_ADDED_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_INFO_SUBSCRIBE_ENTRY_ADDED_MSG, 
                      pMsg        :=  MQCLIINF_LOG_INFO_SUBSCRIBE_ENTRY_ADDED_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
  
  else
    
       
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    //Diagnostic Data
    Diagnostic_Event( Event   :=  DL_Error, 
                      udValue :=  0);
    Diagnostic_Event( Event   :=  DL_SubFail, 
                      udValue :=  0);
    
  end_if;
  
  CriticalSection.SectionStop();
    
END_FUNCTION

FUNCTION GLOBAL MQTTClient_Interface::MQTT_Publish
	VAR_INPUT
		pTopic 	: ^UINT;
		iQoS 	: INT;
		pPayload 	: ^void;
		udPayloadLen 	: UDINT;
		bRetain 	: BOOL;
		pThis 	: ^void;
		pCallback 	: ^void;
		pMid 	: ^INT;
		pApplMsgID 	: ^UDINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
    iRetCode : INT;
  	iThisMID : INT;
    udThisApplID : UDINT;
    tmpPara, tmpPara2 : DINT;
    pEntry : ^t_s_PubSubEntry;
  END_VAR
  
  CriticalSection.SectionStart();
  
  //Assume Fail
  retCode := MQTT_ERR_INVAL;
  
  Diagnostic_Event( Event   :=  DL_PubRequest, 
                    udValue :=  0);
  
  //Check input values
  if pTopic = NIL                                                                 |
     SigCLib.StrLen16(str0:=pTopic) > MQTTCLIENTINTERFACE_PUBSUB_TOPIC_MAX_LEN    |
     iQoS > MQTT_PROT_QOS_MAX                                                     |
     iQos < MQTT_PROT_QOS_MIN                                                     |
     udPayloadLen > MQTTCLIENT_MAX_DATA_LEN                                       |
     ((pPayload <> NIL) & (udPayloadLen = 0))                                     then
    //Create Log: Failed to issue publish request, invalid input values.
    
    tmpPara := to_dint(iQoS);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_PUBLISH_PUB_FAILED_INVALID_INPUT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_PUBLISH_PUB_FAILED_INVALID_INPUT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_PUBLISH_PUB_FAILED_INVALID_INPUT_TEXT, 
                      pPara1      :=  #pTopic$DINT, 
                      pPara2      :=  #tmpPara, 
                      pPara3      :=  #udPayloadLen$DINT, 
                      pPara4      :=  #pPayload$DINT);
                      
    Diagnostic_Event( Event   :=  DL_PubFail, 
                      udValue :=  0);  
                      
    return;
    
  end_if;
  
  //Check the state
  if InterfaceState < MCIS_Reconnecting |
     InterfaceState > MCIS_Connected    |
     Config.pPubSubConfig = NIL         then
     
    retCode := MQTT_ERR_NO_CONN;
    
    //Create Log: Failed to issue publish request, no Connection MQTT Broker or the MQTT interface class is not initialised.
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_PUBLISH_PUB_FAILED_INTERFACE_STATE_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_PUBLISH_PUB_FAILED_INTERFACE_STATE_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_PUBLISH_PUB_FAILED_INTERFACE_STATE_TEXT, 
                      pPara1      :=  #InterfaceState$DINT, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    Diagnostic_Event( Event   :=  DL_PubFail, 
                      udValue :=  0);   
                      
    return;
    
  end_if;

  //If there is no more space in the list
  if Config.pPubSubConfig^.PubSubList.udNumEntries >= Config.pPubSubConfig^.PubSubList.udMaxEntries - 1 then
    
    retCode := MQTT_ERR_NOMEM;
    
    Diagnostic_Event( Event   :=  DL_PubFail, 
                      udValue :=  0);    
    
    tmpPara   := to_dint(Config.pPubSubConfig^.PubSubList.udMaxEntries);
    tmpPara2  := to_dint(Config.pPubSubConfig^.PubSubList.udNumEntries);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_LIST_FULL_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_LIST_FULL_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_LIST_FULL_TEXT, 
                      pPara1      :=  #tmpPara2, 
                      pPara2      :=  #tmpPara, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    return;
    
  end_if;
  
  udThisApplID  := Counters_GetApplID();
        
  iRetCode := MQTTClient.mqtt_publish(mid         :=  #iThisMID, 
                                      topic       :=  pTopic, 
                                      payloadLen  :=  udPayloadLen, 
                                      payload     :=  pPayload, 
                                      qos         :=  iQoS, 
                                      retain_pub  :=  bRetain);  
                                      
  //Diagnostic Info:
  Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                    udValue :=  retCode$UDINT);
    
  if iRetCode <> MQTT_ERR_SUCCESS$INT then
  
    retCode := iRetCode;
    
    tmpPara := to_dint(retCode);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_SUBSCRIBE_SUB_FAILED_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    Diagnostic_Event( Event   :=  DL_PubFail, 
                      udValue :=  0);   
                      
    Diagnostic_Event( Event   :=  DL_Error, 
                      udValue :=  0);
                      
    return;
  
  end_if;
  
  Counters_IncPubMID();
  Counters_IncApplID();
  
  //========================
  //Add the QoS Diag Event
  //========================
  case iQos of
    //---------
    //QoS 0
    //---------
    0:
        Diagnostic_Event( Event   :=  DL_Pub0, 
                          udValue :=  0);
    
    //---------
    //QoS 1
    //---------
    1:
        Diagnostic_Event( Event   :=  DL_Pub1, 
                          udValue :=  0);
                          
    //---------
    //QoS 2
    //---------
    2:
        Diagnostic_Event( Event   :=  DL_Pub2, 
                          udValue :=  0);
  end_case;

  
  Diagnostic_Event( Event   :=  DL_TXBytes, 
                    udValue :=  udPayloadLen);
  
  //Add to the PubSubList
  
  pEntry := (Config.pPubSubConfig^.PubSubList.pEntries$UDINT + sizeof(t_s_PubSubEntry)*Config.pPubSubConfig^.PubSubList.udNumEntries)$^t_s_PubSubEntry;
  
  pEntry^.iMid             := iThisMID;
  pEntry^.EntryType        := PSE_Publish;
  pEntry^.udAppliID        := udThisApplID;
  pEntry^.Callback.pThis   := pThis;
  pEntry^.Callback.pMethod := pCallback;  
  pEntry^.iUnsubMid        := -1;
  
  SigCLib.MemSet( dst :=  #pEntry^.aTopic, 
                  c   :=  0x00, 
                  len :=  sizeof(t_s_PubSubEntry.aTopic));
  
  SigCLib.StrCpy16( dst0  :=  #pEntry^.aTopic[0], 
                    src0  :=  pTopic);
  
  if pMid then
    pMid^ := iThisMID;
  end_if;
  if pApplMsgID then
    pApplMsgID^:= udThisApplID;
  end_if;
    
  Config.pPubSubConfig^.PubSubList.udNumEntries += 1;
  
  retCode := MQTT_ERR_SUCCESS;
  
  CriticalSection.SectionStop();
  
END_FUNCTION

FUNCTION GLOBAL MQTTClient_Interface::MQTT_Unsubscribe
	VAR_INPUT
		pApplMsgID 	: ^UDINT;
		pTopic 	: ^UINT;
		pMid 	: ^INT;
		pThis 	: ^void;
		pCallback 	: ^void;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  VAR
    iThisMID : INT;
  	udApplMsgID, udCount, udCount2 : UDINT;
    pPubSubEntry, pPubSubSearchEntry : ^t_s_PubSubEntry;
    bTopicFound, bSubscriptionFound : BOOL;
    tmpPara : DINT;
  END_VAR

  //Assume Error
  retCode := MQTT_ERR_INVAL; 
  
  Diagnostic_Event( Event   :=  DL_UnsubRequest, 
                    udValue :=  0);    
  
  //If the input is oK
  if (pApplMsgID | pTopic)                                &
     Config.pPubSubConfig                                 &
     (Config.pPubSubConfig^.PubSubList.udNumEntries > 0)  then
    
    udApplMsgID := 0;
    bTopicFound := TRUE;
    
    //1. Determine the Application Message ID:
    
    //==========================================================
    //Based on the input, determine the ApplMsgID to Unsubscribe
    //==========================================================
      //-----------------------------------
      //Both are set, Use the ApplMsgID
      //-----------------------------------
      if pApplMsgID &
         pTopic then
      
        udApplMsgID := pApplMsgID^;
      
      //-----------------------------------
      //Only ApplMsgID is set, use this
      //-----------------------------------
      elsif pApplMsgID      &
            (pTopic = NIL)  then
        
        udApplMsgID := pApplMsgID^;
        
      //-----------------------------------
      //Only Topic is set, Determine ApplMsgID
      //-----------------------------------
      elsif pTopic              &
            (pApplMsgID = NIL)  then
        
        pPubSubEntry := Config.pPubSubConfig^.PubSubList.pEntries;
        
        for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
          
          if SigCLib.StrCmp16(src1:=pTopic, src2:=#pPubSubEntry^.aTopic[0]) = 0 then
            udApplMsgID := pPubSubEntry^.udAppliID;
            bTopicFound := TRUE;
            exit;
          end_if;
          
          pPubSubEntry$UDINT += sizeof(t_s_PubSubEntry);
          
        end_for;
        
        if bTopicFound = FALSE then
          //Create Log: Failed to perform Unsubscribe command, Could not find the Subscription in the PubSubList.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOT_FOUND_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOT_FOUND_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOT_FOUND_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                            
          Diagnostic_Event( Event   :=  DL_UnsubFail, 
                            udValue :=  0);  
          
          return;
        end_if;
        
      end_if;
    
    //2. Find and Unsubscribe the Message
    
    pPubSubEntry := Config.pPubSubConfig^.PubSubList.pEntries;
    
    for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
      
      if pPubSubEntry^.udAppliID = udApplMsgID then
        
        //See if this topic is still subscribed to by any other parties, if so, do not unsubscribe
        bSubscriptionFound := FALSE;
        
        pPubSubSearchEntry$UDINT := (Config.pPubSubConfig^.PubSubList.pEntries)$UDINT;
        
        for udCount2 := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
          
          if (udCount2 <> udCount) & 
             SigCLib.StrCmp16(src1:=#pPubSubEntry^.aTopic[0], src2:=#pPubSubSearchEntry^.aTopic[0]) = 0 then
            
            //Create Log: Unsubscribe: Unsubscribe requested for a topic where atleast one other party in the application is still subscribed, the Unsubscribe request will not be sent
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG,
                              dMsgGroup   :=  MQCLIINF_LOG_DEBUG_UNSUBSCRIBE_STILL_SUBSCRIBED_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_DEBUG_UNSUBSCRIBE_STILL_SUBSCRIBED_MSG, 
                              pMsg        :=  MQCLIINF_LOG_DEBUG_UNSUBSCRIBE_STILL_SUBSCRIBED_TEXT, 
                              pPara1      :=  #pPubSubEntry^.udAppliID$DINT, 
                              pPara2      :=  #pPubSubSearchEntry^.udAppliID$DINT, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
            
            bSubscriptionFound := TRUE;
            exit;
            
          end_if;

          pPubSubSearchEntry$UDINT += sizeof(t_s_PubSubEntry);
          
        end_for;
        
        iThisMID := Counters_GetSubMID();
        
        pPubSubEntry^.iUnsubMid := iThisMID;
        
        if pMid then
          pMid^ := iThisMID;
        end_if;
        
        Counters_IncSubMID();

        //If no other subscription was found for this topic, unsubscribe
        if bSubscriptionFound = FALSE then
          
          retCode := MQTTClient.mqtt_unsubscribe( mid   :=  #pPubSubEntry^.iUnsubMid, 
                                                  unsub :=  #pPubSubEntry^.aTopic[0]);
          
          //Diagnostic Info:
          Diagnostic_Event( Event   :=  DL_LastErrorCode, 
                            udValue :=  retCode$UDINT);
                            
          if retCode <> MQTTClient::MQTT_ERR_SUCCESS$INT then

            Diagnostic_Event( Event   :=  DL_UnsubFail, 
                              udValue :=  0);  
            Diagnostic_Event( Event   :=  DL_Error, 
                              udValue :=  0);
                              
          end_if;

          //====================
          //Act on RetCode
          //====================
          case retCode$MQTTClient::t_e_MQTTErrors of
            //-----------------
            //OK
            //-----------------
            MQTT_ERR_SUCCESS:
              
              //Save Callback Data if set
              if pCallback &
                 pThis     then
                 
                pPubSubEntry^.Callback.pThis    := pThis;
                pPubSubEntry^.Callback.pMethod  := pCallback;
              
              //Callback data not set but also no pre-existing callback data, the user will receive no feedback
              elsif pPubSubEntry^.Callback.pThis    = NIL |
                    pPubSubEntry^.Callback.pMethod  = NIL then
                
                //Create Log: No Callback details specified during Unsubscribe, also no pre existing details, no callback possible.
                
                tmpPara := to_dint(iThisMID);
                
                Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                  dMsgGroup   :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_CALLBACK_NOTSET_GRP, 
                                  dMsgNbr     :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_CALLBACK_NOTSET_MSG, 
                                  pMsg        :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_CALLBACK_NOTSET_TEXT, 
                                  pPara1      :=  #udApplMsgID$DINT, 
                                  pPara2      :=  #tmpPara, 
                                  pPara3      :=  NIL, 
                                  pPara4      :=  NIL);
                
              end_if;
              
              //Create Log: Successfully issued the unsubscribe request for...
              
              tmpPara := to_dint(iThisMID);
              
              Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                                dMsgGroup   :=  MQCLIINF_LOG_INFO_UNSUBSCRIBE_ENTRY_ADDED_GRP, 
                                dMsgNbr     :=  MQCLIINF_LOG_INFO_UNSUBSCRIBE_ENTRY_ADDED_MSG, 
                                pMsg        :=  MQCLIINF_LOG_INFO_UNSUBSCRIBE_ENTRY_ADDED_TEXT, 
                                pPara1      :=  #udApplMsgID$DINT, 
                                pPara2      :=  #tmpPara, 
                                pPara3      :=  NIL, 
                                pPara4      :=  NIL);
            
            //-----------------
            //Error
            //-----------------
            MQTT_ERR_INVAL:
            
              //Create Log: Unsubscribe failed, input values not accepted
              
              tmpPara := to_dint(iThisMID);
              
              Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                                dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_REQ_FAILED_INPUT_GRP, 
                                dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_REQ_FAILED_INPUT_MSG, 
                                pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_REQ_FAILED_INPUT_TEXT, 
                                pPara1      :=  #udApplMsgID$DINT, 
                                pPara2      :=  #tmpPara, 
                                pPara3      :=  NIL, 
                                pPara4      :=  NIL);
              
            //-----------------
            //Retry
            //-----------------
            MQTT_ERR_NO_CONN:
            
              //Create Log: Unsubscribe failed, no connection mqtt client
              
              tmpPara := to_dint(iThisMID);
              
              Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                                dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_CONN_GRP, 
                                dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_CONN_MSG, 
                                pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_CONN_TEXT, 
                                pPara1      :=  #udApplMsgID$DINT, 
                                pPara2      :=  #tmpPara, 
                                pPara3      :=  NIL, 
                                pPara4      :=  NIL);
            
            //-----------------
            //Retry
            //-----------------
            MQTT_ERR_NOMEM:
            
              //Create Log: Unsubscribe failed, no space in message buffer
              
              tmpPara := to_dint(iThisMID);
              
              Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                                dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOMEM_GRP, 
                                dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOMEM_MSG, 
                                pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOMEM_TEXT, 
                                pPara1      :=  #udApplMsgID$DINT, 
                                pPara2      :=  #tmpPara, 
                                pPara3      :=  NIL, 
                                pPara4      :=  NIL);
          //All other
          else
            
            tmpPara := to_dint(retCode);
    
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_TEXT, 
                              pPara1      :=  #tmpPara, 
                              pPara2      :=  NIL, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
            
            
          end_case;

          return;
        
        //Someone else is still subscribed to this data.
        else
          
          //Perform the Unsubscribed callback for this entry if it is set 
          //(Even though we did not send an Unsubscribe Request we must let the requesting party know that we handled their request)
          if pPubSubEntry^.Callback.pThis   &
             pPubSubEntry^.Callback.pMethod then
            
            pPubSubEntry^.Callback.pMethod$PubSub_Callback(pThis        :=  pPubSubEntry^.Callback.pThis, 
                                                           MsgType      :=  PSRC_Unsubscribed, 
                                                           iMid         :=  pPubSubEntry^.iUnsubMid, 
                                                           iGrantedQoS  :=  -1, 
                                                           pMessage     :=  NIL);
          
          //If this is the MQTTTopic Class
          elsif pPubSubEntry^.Callback.pThis          &
                pPubSubEntry^.Callback.pMethod = NIL  then
            
            pPubSubEntry^.Callback.pThis$^MQTTTopic^.PubSubData(MsgType     :=  PSRC_Unsubscribed, 
                                                                iMid        :=  pPubSubEntry^.iUnsubMid, 
                                                                iGrantedQoS :=  -1, 
                                                                pMessage    :=  NIL);
          
          end_if;

          
          //Remove this entry from the PubSubList
          if Config.pPubSubConfig^.PubSubList.udNumEntries - 1 > udCount then
            
            SigCLib.MemCpy( dst0  :=  pPubSubEntry, 
                            src0  :=  (pPubSubEntry$UDINT + sizeof(t_s_PubSubEntry))$^void, 
                            len0  :=  (sizeof(t_s_PubSubEntry) * (Config.pPubSubConfig^.PubSubList.udNumEntries - 1 - udCount)));
            
          end_if;
          
          Config.pPubSubConfig^.PubSubList.udNumEntries -= 1;
          
          //Return Success
          retCode := MQTTClient::MQTT_ERR_SUCCESS;
          return;
          
        end_if;

      end_if;
      
      pPubSubEntry$UDINT += sizeof(t_s_PubSubEntry);
      
    end_for;
    
    //Create Log: Failed to perform Unsubscribe command, Could not find the Subscription in the PubSubList.
    
    tmpPara := to_dint(pMid^);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOT_FOUND_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOT_FOUND_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_NOT_FOUND_TEXT, 
                      pPara1      :=  pApplMsgID$^DINT, 
                      pPara2      :=  #tmpPara, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    Diagnostic_Event( Event   :=  DL_UnsubFail, 
                      udValue :=  0);  
    
  //Input values not OK
  else
  
    //Create Log: Failed to perform Unsubscribe Command, Input values are not OK
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_INPUT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_INPUT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_UNSUBSCRIBE_UNSUB_FAILED_INPUT_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    Diagnostic_Event( Event   :=  DL_UnsubFail, 
                      udValue :=  0);   
    
  end_if;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient_Interface::MQTT_SetCleanSession
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR

  //Assume Fail
  bOK := FALSE;
  
  //If the state is OK
  if (InterfaceState = MCIS_Ready)              | 
     (InterfaceState = MCIS_Connected)          |
     (InterfaceState = MCIS_WaitForConnection)  |
     (InterfaceState = MCIS_Reconnecting)       then
    
    //if the Pub Sub List is ready
    if Config.pPubSubConfig then
      
      Config.pPubSubConfig^.PubSubList.udNumEntries := 0;
      
      SigCLib.MemSet( dst :=  Config.pPubSubConfig^.PubSubList.pEntries,  
                      c   :=  0x00, 
                      len :=  sizeof(t_s_PubSubEntry)*Config.pPubSubConfig^.PubSubList.udMaxEntries);
      
      
    //PubSubList not Ready
    else
    
      //Create Log: Tried to Clean the session, Pubsub list not inititialised.
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_CLEANSESSION_PUBSUB_NOT_INITED_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_CLEANSESSION_PUBSUB_NOT_INITED_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_CLEANSESSION_PUBSUB_NOT_INITED_TEXT, 
                        pPara1      :=  NIL, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                      
    end_if;
    
    Config.iNextSubMID          := MQTTCLIENTINTERFACE_SUB_MID_INITVAL;
    Config.iNextPubMID          := MQTTCLIENTINTERFACE_PUB_MID_INITVAL;
     
    bOK := DataMap_ResetStates();
    
  //State not OK
  else
    
    //Create Log: Cannot Set clean session, the MQTT Interface is not in the correct state.
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_CLEANSESSION_FAILED_WRONG_STATE_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_CLEANSESSION_FAILED_WRONG_STATE_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_CLEANSESSION_FAILED_WRONG_STATE_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
  end_if;

  
END_FUNCTION
//================================================================================================================================================================
//-----------------------------------------------------------------END OF INTERFACE METHODS-----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//----------------------------------------------------------------------LOGGING METHODS---------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION GLOBAL MQTTClient_Interface::Logging_CreateLog
	VAR_INPUT
		usLevel 	: USINT;
		dMsgGroup 	: DINT;
		dMsgNbr 	: DINT;
		pMsg 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		pPara3 	: ^DINT;
		pPara4 	: ^DINT;
		udClient 	: UDINT;(* := 0 *)
	END_VAR
  
  if udClient = 0 then
    return;
  end_if;

  
  //===================================
  //Set the Last Log Details
  //===================================
  case usLevel of
    
    //-----------------
    //Error
    //-----------------
    MQTT_LOG_ERR:
      
      DiagnosticData.LogEvents.Level_Error.dLastTopicGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Error.dLastTopicMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Error.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Error.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Info
    //-----------------
    MQTT_LOG_INFO:
      
      DiagnosticData.LogEvents.Level_Info.dLastTopicGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Info.dLastTopicMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Info.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Info.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Debug
    //-----------------
    MQTT_LOG_DEBUG:
      
      DiagnosticData.LogEvents.Level_Debug.dLastTopicGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Debug.dLastTopicMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Debug.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Debug.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Warning
    //-----------------
    MQTT_LOG_WARNING:
      
      DiagnosticData.LogEvents.Level_Warning.dLastTopicGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Warning.dLastTopicMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Warning.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Warning.dLastGlobalMessage := dMsgNbr;
      
  end_case;
  
  //Forward the log to the internal log function:
  Logging_InternLog(usLevel   :=  usLevel, 
                    dMsgGroup :=  dMsgGroup, 
                    dMsgNbr   :=  dMsgNbr, 
                    pMsg      :=  pMsg, 
                    pPara1    :=  pPara1, 
                    pPara2    :=  pPara2, 
                    pPara3    :=  pPara3, 
                    pPara4    :=  pPara4);

END_FUNCTION


FUNCTION GLOBAL MQTTClient_Interface::Logging_GetLastClientEvent
	VAR_INPUT
		pGroup 	  : ^DINT;
		pMessage 	: ^DINT;
		Level 	  : DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Check if the input is OK
  bOK := pGroup & pMessage;
  
  if bOK then
    
    //================================================================
    //Based on the Event Level, write the last Event Group and Number
    //================================================================
    case level of
    
      //-------------
      //Error
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Error.dLastClientGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Error.dLastClientMessage;
        
      //-------------
      //Warning
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Warning.dLastClientGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Warning.dLastClientMessage;
    
      //-------------
      //Info
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Info.dLastClientGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Info.dLastClientMessage;
    
      //-------------
      //Debug
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Debug.dLastClientGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Debug.dLastClientMessage;
      
    else
      
      bOK := FALSE;
      return;
    
    end_case;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL MQTTClient_Interface::Logging_GetLastInterfaceEvent
	VAR_INPUT
		pGroup 	  : ^DINT;
		pMessage 	: ^DINT;
		Level 	  : DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Check if the input is OK
  bOK := pGroup & pMessage;
  
  if bOK then
    
    //================================================================
    //Based on the Event Level, write the last Event Group and Number
    //================================================================
    case level of
    
      //-------------
      //Error
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Error.dLastInterfaceGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Error.dLastInterfaceMessage;
        
      //-------------
      //Warning
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Warning.dLastInterfaceGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Warning.dLastInterfaceMessage;
    
      //-------------
      //Info
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Info.dLastInterfaceGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Info.dLastInterfaceMessage;
    
      //-------------
      //Debug
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Debug.dLastInterfaceGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Debug.dLastInterfaceMessage;
      
    else
      
      bOK := FALSE;
      return;
      
    end_case;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL MQTTClient_Interface::Logging_GetLastGlobalEvent
	VAR_INPUT
		pGroup 	  : ^DINT;
		pMessage 	: ^DINT;
		Level 	  : DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Check if the input is OK
  bOK := pGroup & pMessage;
  
  if bOK then
    
    //================================================================
    //Based on the Event Level, write the last Event Group and Number
    //================================================================
    case level of
    
      //-------------
      //Error
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Error.dLastGlobalGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Error.dLastGlobalMessage;
        
      //-------------
      //Warning
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Warning.dLastGlobalGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Warning.dLastGlobalMessage;
    
      //-------------
      //Info
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Info.dLastGlobalGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Info.dLastGlobalMessage;
    
      //-------------
      //Debug
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Debug.dLastGlobalGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Debug.dLastGlobalMessage;
      
    else
      
      bOK := FALSE;
      return;
    
    end_case;
    
  end_if;
  
END_FUNCTION


FUNCTION GLOBAL MQTTClient_Interface::Logging_GetLastTopicEvent
	VAR_INPUT
		pGroup 	  : ^DINT;
		pMessage 	: ^DINT;
		Level 	  : DINT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Check if the input is OK
  bOK := pGroup & pMessage;
  
  if bOK then
    
    //================================================================
    //Based on the Event Level, write the last Event Group and Number
    //================================================================
    case level of
    
      //-------------
      //Error
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Error.dLastTopicGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Error.dLastTopicMessage;
        
      //-------------
      //Warning
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Warning.dLastTopicGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Warning.dLastTopicMessage;
    
      //-------------
      //Info
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Info.dLastTopicGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Info.dLastTopicMessage;
    
      //-------------
      //Debug
      //-------------
      MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG:
        
        pGroup^   := DiagnosticData.LogEvents.Level_Debug.dLastTopicGroup;
        pMessage^ := DiagnosticData.LogEvents.Level_Debug.dLastTopicMessage;
      
    else
      
      bOK := FALSE;
      return;
      
    end_case;
    
  end_if;
  
END_FUNCTION


FUNCTION MQTTClient_Interface::Logging_InterfLog
	VAR_INPUT
		usLevel 	: USINT;
		dMsgGroup 	: DINT;
		dMsgNbr 	: DINT;
		pMsg 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		pPara3 	: ^DINT;
		pPara4 	: ^DINT;
	END_VAR
  
  //===================================
  //Set the Last Log Details
  //===================================
  case usLevel of
    
    //-----------------
    //Error
    //-----------------
    MQTT_LOG_ERR:
      
      DiagnosticData.LogEvents.Level_Error.dLastInterfaceGroup  := dMsgGroup;
      DiagnosticData.LogEvents.Level_Error.dLastInterfaceMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Error.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Error.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Info
    //-----------------
    MQTT_LOG_INFO:
      
      DiagnosticData.LogEvents.Level_Info.dLastInterfaceGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Info.dLastInterfaceMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Info.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Info.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Debug
    //-----------------
    MQTT_LOG_DEBUG:
      
      DiagnosticData.LogEvents.Level_Debug.dLastInterfaceGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Debug.dLastInterfaceMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Debug.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Debug.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Warning
    //-----------------
    MQTT_LOG_WARNING:
      
      DiagnosticData.LogEvents.Level_Warning.dLastInterfaceGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Warning.dLastInterfaceMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Warning.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Warning.dLastGlobalMessage := dMsgNbr;
      
  end_case;

  //Forward the log to the internal log function:
  Logging_InternLog(usLevel   :=  usLevel, 
                    dMsgGroup :=  dMsgGroup, 
                    dMsgNbr   :=  dMsgNbr, 
                    pMsg      :=  pMsg, 
                    pPara1    :=  pPara1, 
                    pPara2    :=  pPara2, 
                    pPara3    :=  pPara3, 
                    pPara4    :=  pPara4);

END_FUNCTION


FUNCTION MQTTClient_Interface::Logging_InternLog
	VAR_INPUT
		usLevel 	: USINT;
		dMsgGroup 	: DINT;
		dMsgNbr 	: DINT;
		pMsg 	: ^CHAR;
		pPara1 	: ^DINT;
		pPara2 	: ^DINT;
		pPara3 	: ^DINT;
		pPara4 	: ^DINT;
		udClient 	: UDINT;(* := 0 *)
	END_VAR
  
  if udClient = 0 then
    return;
  end_if;

  
  //Forward Log to ComLogging
  _ComLogging.AddUserEntry( Level     :=  usLevel, 
                            MsgGroup  :=  dMsgGroup, 
                            MsgNbr    :=  dMsgNbr, 
                            pMsg      :=  pMsg, 
                            pPara1    :=  pPara1, 
                            pPara2    :=  pPara2, 
                            pPara3    :=  pPara3, 
                            pPara4    :=  pPara4);

END_FUNCTION
//================================================================================================================================================================
//------------------------------------------------------------------END OF LOGGING METHODS------------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//---------------------------------------------------------------------PROCESS XML METHODS------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient_Interface::ProcessXML
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	pElement : ^_XML_ELEMENT;
    bFoundElement : BOOL;
    aString : ARRAY[0..MQTTCLIENT_INT_XML_FIRST_ELEMENT_MAX_LEN] of CHAR;
  END_VAR

  //Assume Error
  bOK := bFoundElement := FALSE;
  
  //Check the First Element
  pElement := _XMLReader.GetFirstElement();
  if pElement = NIL       |
     pElement^.Name = NIL then
    return;
  end_if;
  
  //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pElement^.Name, 
                    count :=  MQTTCLIENT_INT_XML_FIRST_ELEMENT_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pElement^.Name)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
  
  //If the Root Element is OK and has Children, get first Child, else stop
  if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_FIRST_ELEMENT_NAME) = 0 & 
     pElement^.pChildren <> NIL                                                       then
     
    pElement := pElement^.pChildren;
    
  else
    //Create Log: Root Element in XML File is invalid, cannot process.
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_FAILED_ROOT_WRONG_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_FAILED_ROOT_WRONG_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_XML_FAILED_ROOT_WRONG_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                            
    return;
    
  end_if;
  
  bOK := TRUE;
  
  //Step through all the children of the root element and process each
  while pElement <> NIL do
    
    //======================================================
    //Based on the XML Config section
    //======================================================
    case ProcessXML_GetElementType(pElement:=pElement) of
      //----------------------------
      //Did Not Find Element, Ignore
      //----------------------------
      X_Unknown:
        
      
      //----------------------------
      //Config Section
      //----------------------------  
      X_Config:
        bOK := ProcessXML_ProcessConfig(pElement:=pElement^.pChildren);
        if bOK = FALSE then
          //Create Log, An error occurred whilst processing the Config section of the XML Document, see Log.
        end_if;

        bFoundElement := TRUE;
        
      //----------------------------
      //DataMap Section
      //----------------------------
      X_DataMap:
        bOK := ProcessXML_ProcessDataMap(pElement:=pElement^.pChildren);
        if bOK = FALSE then
          //Create Log, An error occurred whilst processing the DataMap section of the XML Document, see Log.
        end_if;
        bFoundElement := TRUE;
      
    end_case;
    
    //Next Element
    pElement := pElement^.pNext;
    
  end_while;
  
  bOK := bFoundElement;

END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	pThisElement : ^_XML_ELEMENT;
  END_VAR

  //Assume OK
  bOK := TRUE;
  
  if pElement = NIL then
    return;
  end_if;

  pThisElement := pElement;
  
  while pThisElement do
    
    //==========================================================
    //Based on the type of Element, Process the section
    //==========================================================
    case ProcessXML_ProcessConfig_GetElementType(pElement:=pThisElement) of
      
      //-------------------------------
      //Client ID
      //-------------------------------
      t_e_XML_Config::XC_ClientID:
      
        //Process ClientID
        if ProcessXML_ProcessConfig_ClientID(pElement:=pThisElement) = FALSE then
          //CreateLog: Processing ClientID Section of Configuration XML File Failed.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_CONFIG_CONFIG_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_CONFIG_CONFIG_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_CONFIG_CONFIG_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                            
          bOK := FALSE;
        end_if;
      
      //-------------------------------
      //Connection
      //-------------------------------
      t_e_XML_Config::XC_Connection:
        
        if ProcessXML_ProcessConfig_Connection(pElement:=pThisElement) = FALSE then
          //CreateLog: Processing Connection Section of Configuration XML File Failed.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_CONFIG_CONNECTION_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_CONFIG_CONNECTION_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_CONFIG_CONNECTION_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                            
                            
          bOK := FALSE;
        end_if;
        
      //-------------------------------
      //Will
      //-------------------------------
      t_e_XML_Config::XC_Will:        
      
        if ProcessXML_ProcessConfig_Will(pElement:=pThisElement) = FALSE then
          //CreateLog: Processing Will Section of Configuration XML File Failed.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_CONFIG_WILL_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_CONFIG_WILL_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_CONFIG_WILL_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          bOK := FALSE;
        end_if;
      
      //-------------------------------
      //Reconnection
      //-------------------------------
      t_e_XML_Config::XC_Reconnection:
      
        if ProcessXML_ProcessConfig_Reconnection(pElement:=pThisElement) = FALSE then
          //CreateLog: Processing Reonnection Section of Configuration XML File Failed.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_CONFIG_RECONNECT_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_CONFIG_RECONNECT_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_CONFIG_RECONNECT_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                            
          bOK := FALSE;
          
        end_if;
        
      //-------------------------------
      //TLS
      //-------------------------------
      t_e_XML_Config::XC_TLS:
      
        if ProcessXML_ProcessConfig_TLS(pElement:=pThisElement) = FALSE then
          //CreateLog: Processing TLS Section of Configuration XML File Failed.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_CONFIG_TLS_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_CONFIG_TLS_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_CONFIG_TLS_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                            
          bOK := FALSE;
        end_if;
        
      //-------------------------------
      //Logging
      //-------------------------------
      t_e_XML_Config::XC_Logging:
      
        if ProcessXML_ProcessConfig_Logging(pElement:=pThisElement) = FALSE then
          //CreateLog: Processing Logging Section of Configuration XML File Failed.
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_CONFIG_LOGGING_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_CONFIG_LOGGING_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_CONFIG_LOGGING_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                          
          bOK := FALSE;
        end_if;
      
      //-------------------------------
      //Unknown, Skip
      //-------------------------------
      t_e_XML_Config::XC_Unknown:
    
    end_case;
    
    //Get the next client
    pThisElement := pThisElement^.pNext;
    
  end_while;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_GetElementType
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		ElementType 	: t_e_XML_Config;
	END_VAR
  VAR
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_CONFIG_MAX_LEN] of CHAR;
  END_VAR
  
  //Assume Unknown
  ElementType := XC_Unknown;
  
  if  pElement = NIL        |
      pElement^.Name = NIL  then
    return;
  end_if;
  
  //Convert the String to all upper for comparison to eliminate casing constraints
  SigCLib.StrNCpy(dst0  :=  #aString[0], 
                  src0  :=  pElement^.Name, 
                  count :=  MQTTCLIENT_INT_XML_CONFIG_MAX_LEN-1);
  
  aString[SigCLib.StrLen(str:=pElement^.Name)] := 0x00;
  
  SigCLib.StrUpr(ps1:=#aString[0]);
  
  if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CLIENTID) = 0 then
    ElementType := XC_ClientID;
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONNECTION) = 0 then
    ElementType := XC_Connection;
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_RECONNECTION) = 0 then
    ElementType := XC_Reconnection;
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_TLS) = 0 then
    ElementType := XC_TLS;
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_LOGGING) = 0 then
    ElementType := XC_Logging;
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_WILL) = 0 then
    ElementType := XC_Will;
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_ClientID
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //Assume Fail
  MQTTClientConfigData.Config.bClientIDSet := bOK := FALSE;
  
  //Get the ClientID from the XML File
  if  pElement                                                                              &
      pElement^.pText                                                                       &
      SigCLib.StrLen(str:=pElement^.pText) < sizeof(MQTTClientConfigData.Config.aClientID)  then
    
    SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.aClientID[0], 
                    c     :=  0x00, 
                    len   :=  sizeof(MQTTClientConfigData.Config.aClientID));
    SigCLib.Utf8ToStr16(dst :=  #MQTTClientConfigData.Config.aClientID[0],
                        src :=  pElement^.pText);
    
    MQTTClientConfigData.Config.bClientIDSet := bOK := TRUE;
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_GetElementType
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		ElementType 	: t_e_XML;
	END_VAR
  VAR
  	aString : ARRAY[0..MTTCLIENT_INT_XML_CONFIG_DATAMAP_MAX_LEN] of CHAR;
  END_VAR

  //Assume Not Found
  ElementType := X_Unknown;
  
    //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pElement^.Name, 
                    count :=  MTTCLIENT_INT_XML_CONFIG_DATAMAP_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pElement^.Name)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
  
  if pElement then
    
    if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MTTCLIENT_INT_XML_CONFIG_ELEMENT) = 0 then
      ElementType := X_Config;
      return;
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MTTCLIENT_INT_XML_DATAMAP_ELEMENT) = 0 then
      ElementType := X_DataMap;
      return;
    end_if;
    
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	pThisElement : ^_XML_ELEMENT;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  if pElement = NIL then
    return;
  end_if;
  
  bOK := TRUE;
  pThisElement := pElement;
  
  //Step through all the children
  while pThisElement do
    
    //======================================================================
    //Based on the type of element, process
    //======================================================================
    case ProcessXML_ProcessDataMap_GetElementType(pElement:=pThisElement) of
      
      //-------------------------------
      //Unknown
      //-------------------------------
      t_e_XML_DataMap::XD_Unknown:
        
        //Create Log: Unexpected input in DataMap section
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_UNEXPECTED_ENTRY_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_UNEXPECTED_ENTRY_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_UNEXPECTED_ENTRY_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                            
        bOK := FALSE;
        
      //-------------------------------
      //Topic Section
      //-------------------------------
      t_e_XML_DataMap::XD_TopicSection:
      
        if ProcessXML_ProcessDataMap_TopicSection(pElement:=pThisElement) = FALSE then
        
          bOK := FALSE;
          //Create Log: Failed Processing TopicSection in the DataMap Section
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TOPICSECT_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TOPICSECT_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TOPICSECT_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
        end_if;
        
      //-------------------------------
      //Topic Endpoint
      //-------------------------------
      t_e_XML_DataMap::XD_TopicEndpoint:
      
        if ProcessXML_ProcessDataMap_TopicEndpoint(pElement:=pThisElement) = FALSE then
          bOK := FALSE;
          //Create Log: Failed Processing TopicEndpoint in the DataMap Section
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                            dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TOPICENDPT_NOT_OK_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TOPICENDPT_NOT_OK_MSG, 
                            pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TOPICENDPT_NOT_OK_TEXT, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
                          
        end_if;
      
    end_case;
  
    pThisElement := pThisElement^.pNext;
  
  end_while;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_Connection
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
    pThisElement : ^_XML_ELEMENT;
    aString : ARRAY[0..MQTTCLIENT_INT_XML_CONFIG_CONN_MAX_LEN] of CHAR;
  END_VAR

  bOK := FALSE;
  
  //Process the Connect Config
  if pElement             &
     pElement^.pChildren  then
    
    //==========================================================
    //Set Parameters
    //==========================================================
    pThisElement := pElement^.pChildren;
    
    while pThisElement        &
          pThisElement^.Name  &
          pThisElement^.pText do
      
      //Convert the String to all upper for comparison to eliminate casing constraints
      SigCLib.StrNCpy(dst0  :=  #aString[0], 
                      src0  :=  pThisElement^.Name, 
                      count :=  MQTTCLIENT_INT_XML_CONFIG_CONN_MAX_LEN-1);
      
      aString[SigCLib.StrLen(str:=pThisElement^.Name)] := 0x00;
      
      SigCLib.StrUpr(ps1:=#aString[0]);
      
      //------------------------------------------------------------------------------------------------------
      //Hostname
      //------------------------------------------------------------------------------------------------------
      if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONN_HOSTNAME) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENT_HOSTNAME_MAX_LEN then
          SigCLib.Utf8ToStr16(dst:=#MQTTClientConfigData.Config.Connect.aHostname[0], src:=pThisElement^.pText);
          MQTTClientConfigData.Config.Connect.ValuesSet.Hostname := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Port
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONN_PORT) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_CONNECT_PORT_MAX_LEN then
          MQTTClientConfigData.Config.Connect.iPort := to_int(SigCLib.AToI(ps1:=pThisElement^.pText));
          MQTTClientConfigData.Config.Connect.ValuesSet.Port := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Keepalive
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONN_KEEPALIVE) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_CONNECT_KEEPALIVE_MAX_LEN then
          MQTTClientConfigData.Config.Connect.iKeepalive := to_int(SigCLib.AToI(ps1:=pThisElement^.pText));
          MQTTClientConfigData.Config.Connect.ValuesSet.Keepalive := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Max Inflight
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONN_MAXINFLIGHT) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_CONNECT_INFLIGHT_MAX_LEN then
          MQTTClientConfigData.Config.Connect.iMaxInflightMessages := to_int(SigCLib.AToI(ps1:=pThisElement^.pText));
          MQTTClientConfigData.Config.Connect.ValuesSet.MaxInflight := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Username
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONN_USERNAME) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_CONNECT_USERNAME_MAX_LEN then
          SigCLib.Utf8ToStr16(dst:=#MQTTClientConfigData.Config.Connect.aUsername[0], src:=pThisElement^.pText);
          MQTTClientConfigData.Config.Connect.ValuesSet.Username := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Password
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_CONN_PASSWORD) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_CONNECT_PASSWORD_MAX_LEN then
          SigCLib.Utf8ToStr16(dst:=#MQTTClientConfigData.Config.Connect.aPassword[0], src:=pThisElement^.pText);
          MQTTClientConfigData.Config.Connect.ValuesSet.Password := TRUE;
        end_if;
      
      end_if;
      
      pThisElement := pThisElement^.pNext;
      
    end_while;

    //Return is OK if atleast the Hostname is set
    bOK := MQTTClientConfigData.Config.Connect.ValuesSet.Hostname;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_Will
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
    pThisElement : ^_XML_ELEMENT;
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_CONFIG_WILL_MAX_LEN] of CHAR;
  END_VAR

  bOK := FALSE;
  
  //Process the Connect Config
  if pElement             &
     pElement^.pChildren  then
    
    //==========================================================
    //Set Parameters
    //==========================================================
    pThisElement := pElement^.pChildren;
    
    while pThisElement        &
          pThisElement^.Name  &
          pThisElement^.pText do
      
      //Convert the String to all upper for comparison to eliminate casing constraints
      SigCLib.StrNCpy(dst0  :=  #aString[0], 
                      src0  :=  pThisElement^.Name, 
                      count :=  MQTTCLIENT_INT_XML_CONFIG_WILL_MAX_LEN-1);
      
      aString[SigCLib.StrLen(str:=pThisElement^.Name)] := 0x00;
      
      SigCLib.StrUpr(ps1:=#aString[0]);      
      
      //------------------------------------------------------------------------------------------------------
      //Topic
      //------------------------------------------------------------------------------------------------------
      if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_WILL_TOPIC) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_WILL_TOPIC_MAX_LEN then
          SigCLib.Utf8ToStr16(dst:=#MQTTClientConfigData.Config.Will.aTopic[0], src:=pThisElement^.pText);
          MQTTClientConfigData.Config.Will.ValuesSet.Topic := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Payload
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_WILL_PLTEXT) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_WILL_PAYLOAD_MAX_LEN then
          //Data from XML Structure must be text, although the payload in the MQTT Client allows for Non-UTF8 input
          SigCLib.StrCpy(dst0:=#MQTTClientConfigData.Config.Will.aPayload[0], src0:=pThisElement^.pText);
          MQTTClientConfigData.Config.Will.ValuesSet.Payload := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //QoS
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_WILL_QOS) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENTINTERFACE_WILL_QOS_MAX_LEN then
          
          MQTTClientConfigData.Config.Will.ValuesSet.QoS := TRUE;
          
          //=======================================
          //Conv QoS CHAR to INT
          //=======================================
          case pThisElement^.pText^ of
            //-----------------------------------
            //QoS 0
            //-----------------------------------
            MQTTCLIENT_INT_XML_CONFIG_WILL_QOS_0:
              
              MQTTClientConfigData.Config.Will.iQoS := 0;
            
            //-----------------------------------
            //QoS 1
            //-----------------------------------
            MQTTCLIENT_INT_XML_CONFIG_WILL_QOS_1:
              
              MQTTClientConfigData.Config.Will.iQoS := 1;
            
            //-----------------------------------
            //QoS 2
            //-----------------------------------
            MQTTCLIENT_INT_XML_CONFIG_WILL_QOS_2:
          
              MQTTClientConfigData.Config.Will.iQoS := 2;
          
          //Not a valid Character
          else
            
            MQTTClientConfigData.Config.Will.ValuesSet.QoS := FALSE;
            
          end_case;

        end_if;
            
      //------------------------------------------------------------------------------------------------------
      //Retain
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN_MAXLEN then
          
          //===========================
          //Set Log based on text value
          //===========================
          case pThisElement^.pText^ of
            //---------------------------------
            //True
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN_TRUE:
              MQTTClientConfigData.Config.Will.bRetain := TRUE;                  
              MQTTClientConfigData.Config.Will.ValuesSet.RetainWill := TRUE;
            //---------------------------------
            //False
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_WILL_RETAIN_FALSE:
              MQTTClientConfigData.Config.Will.bRetain := FALSE;     
              MQTTClientConfigData.Config.Will.ValuesSet.RetainWill := TRUE;
          end_case;

        end_if;
      
      end_if;
      
      pThisElement := pThisElement^.pNext;
      
    end_while;

    //All Paras are required
    bOK :=  MQTTClientConfigData.Config.Will.ValuesSet.Topic      &
            MQTTClientConfigData.Config.Will.ValuesSet.Payload    &
            MQTTClientConfigData.Config.Will.ValuesSet.QoS        &
            MQTTClientConfigData.Config.Will.ValuesSet.RetainWill;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_Reconnection
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
    pThisElement : ^_XML_ELEMENT;
    aString : ARRAY[0..MQTTCLIENT_INT_XML_CONFIG_RECONN_MAXLEN] of CHAR;
  END_VAR

  bOK := FALSE;
  
  //Process the Connect Config
  if pElement             &
     pElement^.pChildren  then
    
    //==========================================================
    //Set Parameters
    //==========================================================
    pThisElement := pElement^.pChildren;
    
    while pThisElement        &
          pThisElement^.Name  &
          pThisElement^.pText do
      
      //Convert the String to all upper for comparison to eliminate casing constraints
      SigCLib.StrNCpy(dst0  :=  #aString[0], 
                      src0  :=  pThisElement^.Name, 
                      count :=  MQTTCLIENT_INT_XML_CONFIG_RECONN_MAXLEN-1);
      
      aString[SigCLib.StrLen(str:=pThisElement^.Name)] := 0x00;
      
      SigCLib.StrUpr(ps1:=#aString[0]);  
      
      //------------------------------------------------------------------------------------------------------
      //Min Interval
      //------------------------------------------------------------------------------------------------------
      if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_RECONN_MININT) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_RECONNECT_MININT_MAX_LEN then
          MQTTClientConfigData.Config.Reconnect.iMinInterval := to_int(SigCLib.AToI(ps1:=pThisElement^.pText));
          MQTTClientConfigData.Config.Reconnect.ValuesSet.MinInterval := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Max Interval
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_RECONN_MAXINT) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_RECONNECT_MAXINT_MAX_LEN then
          MQTTClientConfigData.Config.Reconnect.iMaxInterval := to_int(SigCLib.AToI(ps1:=pThisElement^.pText));
          MQTTClientConfigData.Config.Reconnect.ValuesSet.MaxInterval := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Exponential Scale
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_RECONN_EXPSCALE) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = SigCLib.StrLen(str:=MQTTCLIENT_INT_XML_CONFIG_RECONNECT_EXP_ON) then
          MQTTClientConfigData.Config.Reconnect.bExponential := (SigCLib.StrCmp(ps1:=pThisElement^.pText, ps2:=MQTTCLIENT_INT_XML_CONFIG_RECONNECT_EXP_ON) = 0);
          MQTTClientConfigData.Config.Reconnect.ValuesSet.ExponentialScale := TRUE;
        end_if;
            
      end_if;
      
      pThisElement := pThisElement^.pNext;
      
    end_while;

    //Return is OK if all is set
    bOK :=  MQTTClientConfigData.Config.Reconnect.ValuesSet.MinInterval &
            MQTTClientConfigData.Config.Reconnect.ValuesSet.MaxInterval &
            MQTTClientConfigData.Config.Reconnect.ValuesSet.ExponentialScale;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_TLS
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
    pThisElement : ^_XML_ELEMENT;
    aString : ARRAY[0..MQTTCLIENT_INT_XML_CONFIG_TLS_MAXLEN] of CHAR;
  END_VAR

  bOK := FALSE;
  
  //Process the Connect Config
  if pElement             &
     pElement^.pChildren  then
     
    MQTTClientConfigData.Config.TLS.ValuesSet.TLS := TRUE;
    
    //==========================================================
    //Set Parameters
    //==========================================================
    pThisElement := pElement^.pChildren;
    
    while pThisElement        &
          pThisElement^.Name  &
          pThisElement^.pText do
      
      //Convert the String to all upper for comparison to eliminate casing constraints
      SigCLib.StrNCpy(dst0  :=  #aString[0], 
                      src0  :=  pThisElement^.Name, 
                      count :=  MQTTCLIENT_INT_XML_CONFIG_TLS_MAXLEN-1);
      
      aString[SigCLib.StrLen(str:=pThisElement^.Name)] := 0x00;
      
      SigCLib.StrUpr(ps1:=#aString[0]);  
      
      //------------------------------------------------------------------------------------------------------
      //cafile
      //------------------------------------------------------------------------------------------------------
      if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_TLS_CAFILE) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_TLS_CAFILE_MAX_LEN then
          SigCLib.StrCpy(dst0:=#MQTTClientConfigData.Config.TLS.aCAFile[0], src0:=pThisElement^.pText);
          MQTTClientConfigData.Config.TLS.ValuesSet.CAFile := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //certfile
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_TLS_CERTFILE) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_TLS_CERTFILE_MAX_LEN then
          SigCLib.StrCpy(dst0:=#MQTTClientConfigData.Config.TLS.aCertFile[0], src0:=pThisElement^.pText);
          MQTTClientConfigData.Config.TLS.ValuesSet.CertFile := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //keyfile
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_TLS_KEYFILE) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_TLS_KEYFILE_MAX_LEN then
          SigCLib.StrCpy(dst0:=#MQTTClientConfigData.Config.TLS.aKeyFile[0], src0:=pThisElement^.pText);
          MQTTClientConfigData.Config.TLS.ValuesSet.KeyFile := TRUE;
        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //pw
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_TLS_PW) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) < MQTTCLIENTINTERFACE_TLS_PASSWORD_MAX_LEN then
          SigCLib.StrCpy(dst0:=#MQTTClientConfigData.Config.TLS.aPassword[0], src0:=pThisElement^.pText);
          MQTTClientConfigData.Config.TLS.ValuesSet.Password := TRUE;
        end_if;
      
      end_if;
      
      pThisElement := pThisElement^.pNext;
      
    end_while;

    //No input is required
    bOK := TRUE;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessConfig_Logging
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
    pThisElement : ^_XML_ELEMENT;
    aString : ARRAY[0..MQTTCLIENT_INT_XML_CONFIG_LOG_MAX_LEN] of CHAR;
  END_VAR

  bOK := FALSE;
  
  MQTTClientConfigData.Config.Logging.bLogSet       := FALSE;
  MQTTClientConfigData.Config.Logging.bdActiveLogs  := 0;
  
  //Process the Logging Config
  if pElement             &
     pElement^.pChildren  then
    
    //==========================================================
    //Set Parameters
    //==========================================================
    pThisElement := pElement^.pChildren;
    
    while pThisElement        &
          pThisElement^.Name  &
          pThisElement^.pText do
      
      //Convert the String to all upper for comparison to eliminate casing constraints
      SigCLib.StrNCpy(dst0  :=  #aString[0], 
                      src0  :=  pThisElement^.Name, 
                      count :=  MQTTCLIENT_INT_XML_CONFIG_LOG_MAX_LEN-1);
      
      aString[SigCLib.StrLen(str:=pThisElement^.Name)] := 0x00;
      
      SigCLib.StrUpr(ps1:=#aString[0]);  
      
      //If any log entry is present, set the ValuePresent
      MQTTClientConfigData.Config.Logging.bLogSet := TRUE;
            
      //------------------------------------------------------------------------------------------------------
      //Info
      //------------------------------------------------------------------------------------------------------
      if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_LOG_INFO) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENTINTERFACE_LOG_ON_OFF_MAX_LEN then
          
          //===========================
          //Set Log based on text value
          //===========================
          case pThisElement^.pText^ of
            //---------------------------------
            //Off
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_OFF:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT AND (NOT (MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO$BDINT));
            //---------------------------------
            //On
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_ON:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT OR MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO$BDINT;
          end_case;

        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Notice
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_LOG_NOTICE) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENTINTERFACE_LOG_ON_OFF_MAX_LEN then
          
          //===========================
          //Set Log based on text value
          //===========================
          case pThisElement^.pText^ of
            //---------------------------------
            //Off
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_OFF:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT AND (NOT (MQTTCLIENTINTERFACE_LOGGING_LEVEL_NOTICE$BDINT));
            //---------------------------------
            //On
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_ON:
              MQTTClientConfigData.Config.Logging.bdActiveLogs := MQTTClientConfigData.Config.Logging.bdActiveLogs OR MQTTCLIENTINTERFACE_LOGGING_LEVEL_NOTICE$BDINT;
          end_case;

        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Warning
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_LOG_WARNING) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENTINTERFACE_LOG_ON_OFF_MAX_LEN then
          
          //===========================
          //Set Log based on text value
          //===========================
          case pThisElement^.pText^ of
            //---------------------------------
            //Off
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_OFF:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT AND (NOT MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING);
            //---------------------------------
            //On
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_ON:
              MQTTClientConfigData.Config.Logging.bdActiveLogs := MQTTClientConfigData.Config.Logging.bdActiveLogs OR MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING$BDINT;
          end_case;

        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Error
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_LOG_ERROR) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENTINTERFACE_LOG_ON_OFF_MAX_LEN then
          
          //===========================
          //Set Log based on text value
          //===========================
          case pThisElement^.pText^ of
            //---------------------------------
            //Off
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_OFF:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT AND (NOT (MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR$BDINT));
            //---------------------------------
            //On
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_ON:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT OR MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR$BDINT;
          end_case;

        end_if;
      
      //------------------------------------------------------------------------------------------------------
      //Debugging
      //------------------------------------------------------------------------------------------------------
      elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_CONFIG_LOG_DEBUGGING) = 0 then
        
        if SigCLib.StrLen(str:=pThisElement^.pText) = MQTTCLIENTINTERFACE_LOG_ON_OFF_MAX_LEN then
          
          //===========================
          //Set Log based on text value
          //===========================
          case pThisElement^.pText^ of
            //---------------------------------
            //Off
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_OFF:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT AND (NOT (MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG$BDINT));
            //---------------------------------
            //On
            //---------------------------------
            MQTTCLIENT_INT_XML_CONFIG_LOG_ON:
              MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT := MQTTClientConfigData.Config.Logging.bdActiveLogs$BDINT OR MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG$BDINT;
          end_case;

        end_if;
      
      end_if;
      
      pThisElement := pThisElement^.pNext;
      
    end_while;

    //Return is always OK
    bOK := TRUE;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap_GetElementType
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		ElementType 	: t_e_XML_DataMap;
	END_VAR
  VAR
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPIC_SECT_END_MAX_LEN] of CHAR;
  END_VAR
  
  //Assume Unknown
  ElementType := XD_Unknown;
    
  if pElement then
        
  //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pElement^.Name, 
                    count :=  MQTTCLIENT_INT_XML_DATAMAP_TOPIC_SECT_END_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pElement^.Name)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
    
    if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION) = 0 then
      ElementType := XD_TopicSection;
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT) = 0 then
      ElementType := XD_TopicEndpoint;
    end_if;

  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap_TopicSection
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	pChild : ^_XML_ELEMENT;
    tmpPara : DINT;
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_ATTR_MAX_LEN] of CHAR;
  END_VAR

  //Assume Fail
  bOK := FALSE;
  
  if pElement = NIL                           |
     pElement^.Attributes.pList = NIL         | 
     pElement^.Attributes.pList^.Name = NIL   |
     pElement^.Attributes.pList^.Value = NIL then
    return;
  end_if;
  
  //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pElement^.Attributes.pList^.Name, 
                    count :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_ATTR_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pElement^.Attributes.pList^.Name)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
  
  //Append the section to the Topicname being built (First and only Attribute should be "name")
  if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_ATTR_NAME) = 0 then
    
    //Topic Depth OK
    if Config.pDataMapConfig^.udTopicStringDepth >= 0 &
       Config.pDataMapConfig^.udTopicStringDepth <  MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECDEPTH then
      
      //Value set but too long
      if  (SigCLib.StrLen(str:=pElement^.Attributes.pList^.Value) >= MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECLEN) then
        
        //Create Log: DataMap, Processing topic Section failed - Section title too long
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_TITLE_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_TITLE_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_TITLE_LEN_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
        
      //Value not set
      elsif pElement^.Attributes.pList^.Value = NIL then
      
        //Create Log: DataMap, Processing topic Section failed - Section title empty
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_TITLE_EMPTY_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_TITLE_EMPTY_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_TITLE_EMPTY_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                        
        return;
      
      //Value set and OK
      else
        
        SigCLib.MemSet( dst :=  #Config.pDataMapConfig^.aTopicStrings[Config.pDataMapConfig^.udTopicStringDepth][0], 
                        c   :=  0x00, 
                        len :=  sizeof(t_s_TopicString));
        SigCLib.StrCpy( dst0  :=  #Config.pDataMapConfig^.aTopicStrings[Config.pDataMapConfig^.udTopicStringDepth][0], 
                        src0  :=  pElement^.Attributes.pList^.Value);
        Config.pDataMapConfig^.udTopicStringDepth += 1;
        bOK := TRUE;
      
      end_if;

    //Exceeded maximum topic depth
    elsif Config.pDataMapConfig^.udTopicStringDepth >= MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECDEPTH then
      
      //Create Log: DataMap, Processing topic section failed, maximum topic depth exceeded.
      
      tmpPara := MQTTCLIENT_INT_XML_DATAMAP_TOPICSECTION_MAXSECDEPTH;
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_MAX_DEPTH_EXCEED_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_MAX_DEPTH_EXCEED_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TS_MAX_DEPTH_EXCEED_TEXT, 
                        pPara1      :=  #Config.pDataMapConfig^.udTopicStringDepth$DINT, 
                        pPara2      :=  #tmpPara, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
      
    end_if;

    //Process any children the Section has
    pChild := pElement^.pChildren;
    if pChild then
      bOK := ProcessXML_ProcessDataMap(pElement:=pChild);
    else
      bOK := FALSE;
    end_if;
    
    if Config.pDataMapConfig^.udTopicStringDepth >= 1 then
      Config.pDataMapConfig^.udTopicStringDepth -= 1;
    end_if;
    
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap_TopicEndpoint
	VAR_INPUT
		pElement 	: ^_XML_ELEMENT;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
    aTopicString    : ARRAY[0..MQTTCLIENT_TOPIC_MAX_LEN] of CHAR;
  	udAtt, udCount  : UDINT;
    pAtt            : ^_XML_ATTRIBUTE;
    aEndpointName   : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_NAME_MAX_LEN] of CHAR;
    aElement        : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN] of CHAR;
    Operation       : t_e_DataMap_Operations;
    udInterval      : UDINT;
    DataType        : t_e_DataMap_DataTypes;
    bNameSet, bElementSet : BOOL;
    udLen           : UDINT;
    iQoS            : INT;
    DRSRetain       : t_e_DataMap_RetainStates;
    DataMapRet      : t_e_DataMap_RetCode;
    tmpPara         : DINT;
    aString         : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_MAX_LEN] of CHAR;
  END_VAR

  //Assume Fail
  bOK := FALSE;
  
  if pElement = NIL                                                                 |
     pElement^.Attributes.no = 0                                                    |
     pElement^.Attributes.no > MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_MAX_ATTRS   |
     pElement^.Attributes.pList = NIL                                               then
    return;
  end_if;
  
  //Set Default Values
  Operation   := DO_Subscribe;
  udInterval  := 0;
  DataType    := DD_DINT;
  bNameSet    := bElementSet := FALSE;
  iQoS        := 0;
  DRSRetain   := DRS_False;
    
  udAtt := pElement^.Attributes.no;
  
  while udAtt > 0 do
    
    //=======================
    //Process the Attribute
    //=======================
    pAtt := ((pElement^.Attributes.pList$UDINT) + (udAtt-1)*sizeof(_XML_ATTRIBUTE))$^_XML_ATTRIBUTE;
    
    if pAtt^.Name = NIL |
       pAtt^.Value = NIL then
      return;
    end_if;
    
    //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pAtt^.Name$^CHAR, 
                    count :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pAtt^.Name$^CHAR)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
    
    //------------------------
    //Name
    //------------------------
    if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_NAME) = 0 then
      
      udLen := SigCLib.StrLen(str:=pAtt^.Value$^CHAR);
      
      if udLen > MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_NAME_MAX_LEN | 
         udLen = 0                                                        then
        //Create Log: DataMap, Element text too long
        
        tmpPara := to_dint(udLen);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_NAME_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_NAME_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_NAME_LEN_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
      end_if;    
      
      SigCLib.MemSet( dst :=  #aEndpointName, 
                    c   :=  0x00, 
                    len :=  sizeof(aEndpointName));
      SigCLib.StrCpy( dst0  :=  #aEndpointName[0], 
                        src0  :=  pAtt^.Value$^CHAR);
      bNameSet := TRUE;
      
    //------------------------
    //Element
    //------------------------
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_ELEMENT) = 0 then
      
      udLen := SigCLib.StrLen(str:=pAtt^.Value$^CHAR);
      
      if udLen > MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN | 
         udLen = 0                                                        then
        //Create Log: DataMap, Element text too long
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_ELEMENT_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_ELEMENT_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_ELEMENT_LEN_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
      end_if;   
      
      SigCLib.MemSet( dst :=  #aElement, 
                    c   :=  0x00, 
                    len :=  sizeof(aElement));
      SigCLib.StrCpy(dst0:=#aElement[0], src0:=pAtt^.Value$^CHAR);
      bElementSet := TRUE;
      
    //------------------------
    //Operation
    //------------------------
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_OPERATION) = 0 then
      
      Operation := ProcessXML_ProcessDataMap_TopicEndpoint_GetOperation(pChar:=pAtt^.Value$^CHAR);
      if Operation = DO_Unknown then
        //Create Log: DataMap, operation type unknown.
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_UNKNOWN_TYPE_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_UNKNOWN_TYPE_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_UNKNOWN_TYPE_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
      end_if;

    //------------------------
    //Interval
    //------------------------
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_INTERVAL) = 0 then
      
      udLen := SigCLib.StrLen(str:=pAtt^.Value$^CHAR);
      
      if udLen > MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_INTERVAL_MAX_LEN then
        //Create Log: DataMap, Interval string too long
        
        tmpPara := to_dint(udLen);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_INTERVEL_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_INTERVEL_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_INTERVEL_LEN_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
      end_if;
      
      udInterval := to_udint(SigCLib.AToI(ps1:=pAtt^.Value$^CHAR));
    
    //------------------------
    //Datatype
    //------------------------
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_DATATYPE) = 0 then
    
      DataType := ProcessXML_ProcessDataMap_TopicEndpoint_GetDataType(pChar:=pAtt^.Value$^CHAR);
      
      if DataType = DD_Unknown then
        //Create Log: DataMap, Datatype unknown.
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_DATATYPE_UNKNOWN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_DATATYPE_UNKNOWN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_DATATYPE_UNKNOWN_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
        
      end_if;
    
    //------------------------
    //QoS
    //------------------------
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_QOS) = 0 then
      
      udLen := SigCLib.StrLen(str:=pAtt^.Value$^CHAR);
      
      if udLen > MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_QOS_MAX_LEN then
        //Create Log: DataMap, QoS string too long
        
        tmpPara := to_dint(udLen);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_QOS_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_QOS_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_QOS_LEN_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
      end_if;
      
      iQoS := to_int(SigCLib.AToI(ps1:=pAtt^.Value$^CHAR));
      
      if iQos < MQTT_PROT_QOS_MIN |
         iQoS > MQTT_PROT_QOS_MAX then
        //Create Log: DataMap, QoS Invalid
        
        tmpPara := to_dint(iQoS);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_QOS_INVALID_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_QOS_INVALID_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_QOS_INVALID_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
      end_if;
      
    //------------------------
    //Retain
    //------------------------
    elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_RETAIN) = 0 then
      
      udLen := SigCLib.StrLen(str:=pAtt^.Value$^CHAR);
      
      if udLen > MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ATTR_RETAIN_MAX_LEN then
        //Create Log: DataMap, Retin String too long
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_RETAIN_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_RETAIN_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_RETAIN_LEN_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
      end_if;
      
      DRSRetain := ProcessXML_ProcessDataMap_TopicEndpoint_GetRetain(pChar:=pAtt^.Value$^CHAR);
      
      if DRSRetain = DRS_Unknown then
        //Create Log: DataMap, Retain Value not known.
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_RETAIN_INVALID_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_RETAIN_INVALID_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_RETAIN_INVALID_TEXT, 
                          pPara1      :=  #DRSRetain$DINT, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                          
        return;
        
      end_if;

      
    end_if;
    
    udAtt -= 1;
    
  end_while;
  
  //OK If the Name and element are set
  bOK := bNameSet & bElementSet;

  //Required Elements set
  if bOK then
                 
    SigCLib.MemSet( dst :=  #aTopicString[0], 
                    c   :=  0x00, 
                    len :=  sizeof(aTopicString));
    
    udCount := 0;
    
    //Build the Topic String (Concatenate all the Sections and Endpoint).
    while udCount < Config.pDataMapConfig^.udTopicStringDepth do
      
      udLen := SigCLib.StrLen(str:=#Config.pDataMapConfig^.aTopicStrings[udCount][0]) + SigCLib.StrLen(str:=#aTopicString[0]) + 1;
      
      //String will fit
      if udLen < MQTTCLIENT_TOPIC_MAX_LEN then
      
        if udCount > 0 then
        
          SigCLib.StrCat( ps1  :=  #aTopicString[0],
                          ps2  :=  MQTTCLIENT_INT_XML_DATAMAP_TOPIC_DIVIDER);
        end_if;
        
        SigCLib.StrCat( ps1  :=  #aTopicString[0], 
                        ps2  :=  #Config.pDataMapConfig^.aTopicStrings[udCount][0]);
                        
      //String too long
      else
        
        tmpPara := to_dint(udLen);
        
        //Create Log: Topic too long
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_TOPIC_LEN_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_TOPIC_LEN_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_TOPIC_LEN_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                        
        return;
        
      end_if;
      
      udCount += 1;
      
    end_while;
    
    if Config.pDataMapConfig^.udTopicStringDepth > 0                          &
       SigCLib.StrLen(str:=#aTopicString[0]) + 1 <= MQTTCLIENT_TOPIC_MAX_LEN  then
       
      SigCLib.StrCat( ps1  :=  #aTopicString[0], 
                      ps2  :=  MQTTCLIENT_INT_XML_DATAMAP_TOPIC_DIVIDER);
                      
    end_if;
    
    udLen := SigCLib.StrLen(str:=#aTopicString[0]) + SigCLib.StrLen(str:=#aEndpointName[0]);
    
    if udLen >= MQTTCLIENT_TOPIC_MAX_LEN then
      //Create Log: DataMap Processing Element Failed, topic name too long
      
      tmpPara := to_dint(udLen);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_CONCAT_TOPIC_LEN_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_CONCAT_TOPIC_LEN_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_CONCAT_TOPIC_LEN_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      bOK := FALSE;
      return;
    end_if;
    
    SigCLib.StrCat( ps1 :=  #aTopicString[0], 
                    ps2 :=  #aEndpointName[0]);
    
    DataMapRet := DataMap_AddElement_Internal(pTopic      :=  #aTopicString[0], 
                                              pElement    :=  #aElement[0], 
                                              Operation   :=  Operation, 
                                              Datatype    :=  DataType, 
                                              udInterval  :=  udInterval, 
                                              iQoS        :=  iQos, 
                                              bRetain     :=  (DRSRetain = DRS_True),
                                              bAddedByXML :=  TRUE); 
    
    bOK := DataMapRet = DM_OK;
    
    if bOK = FALSE then
          
      //Create Log: DataMap, adding Element to DataMap Failed.
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_DATAMAP_ADD_FAIL_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_DATAMAP_ADD_FAIL_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_DATAMAP_ADD_FAIL_TEXT, 
                        pPara1      :=  #DataMapRet$DINT, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                      
      return;
    end_if;
    
  //Required Elements not set
  else
  
    //Create Log: DataMap, Failed processing topic endpoint, all required attributes have not been set
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_MISSING_ENTRIES_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_MISSING_ENTRIES_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_XML_DATAMAP_TE_MISSING_ENTRIES_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    return;
    
  end_if;


END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap_TopicEndpoint_GetOperation
	VAR_INPUT
		pChar 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		Operation 	: t_e_DataMap_Operations;
	END_VAR
  VAR
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_MAX_LEN] of CHAR;
  END_VAR

  //Assume not found
  Operation := DO_Unknown;
  
  if pChar = NIL then
    return;
  end_if;
  
  //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pChar, 
                    count :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pChar)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
  
  //Poll
  if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_POLL) = 0 then
    
    Operation := DO_Poll;
    
  //Change
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_CHANGE) = 0 then
  
    Operation := DO_Change;
  
  //Subscribe
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_OPERATION_SUBSCRIBE) = 0 then
  
    Operation := DO_Subscribe;
  
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap_TopicEndpoint_GetDataType
	VAR_INPUT
		pChar 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		DataType 	: t_e_DataMap_DataTypes;
	END_VAR
  VAR
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_MAXLEN] of CHAR;
  END_VAR
  
  //Assume not found
  DataType := DD_Unknown;
  
  if pChar = NIL then
    return;
  end_if;
  
  //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pChar, 
                    count :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_MAXLEN-1);
    
    aString[SigCLib.StrLen(str:=pChar)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
  
  //DINT
  if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_DINT) = 0 then
    
    DataType := DD_DINT;
    
  //UDINT
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_UDINT) = 0 then
  
    DataType := DD_UDINT;
  
  //REAL
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_REAL) = 0 then
  
    DataType := DD_REAL;
  
  //String
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_DATATYPE_STRING) = 0 then
  
    DataType := DD_STRING;
  
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::ProcessXML_ProcessDataMap_TopicEndpoint_GetRetain
	VAR_INPUT
		pChar 	: ^CHAR;
	END_VAR
	VAR_OUTPUT
		RetainState 	: t_e_DataMap_RetainStates;
	END_VAR
  VAR
  	aString : ARRAY[0..MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_MAX_LEN] of CHAR;
  END_VAR
  
  //Assume not found
  RetainState := DRS_Unknown;
  
  if pChar = NIL then
    return;
  end_if;
  
  //Convert the String to all upper for comparison to eliminate casing constraints
    SigCLib.StrNCpy(dst0  :=  #aString[0], 
                    src0  :=  pChar, 
                    count :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_MAX_LEN-1);
    
    aString[SigCLib.StrLen(str:=pChar)] := 0x00;
    
    SigCLib.StrUpr(ps1:=#aString[0]);
  
  //TRUE
  if SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_TRUE) = 0 then
    
    RetainState := DRS_True;
    
  //FALSE
  elsif SigCLib.StrCmp(ps1:=#aString[0], ps2:=MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_RETAIN_FALSE) = 0 then
  
    RetainState := DRS_False;
  
  end_if;
  
END_FUNCTION
//================================================================================================================================================================
//------------------------------------------------------------------END OF PROCESS XML METHODS--------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//----------------------------------------------------------------------DATAMAP METHODS---------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient_Interface::DataMap_AddElement
	VAR_INPUT
		pTopic 	: ^CHAR;
		pElement 	: ^CHAR;
		Operation 	: t_e_DataMap_Operations;
		Datatype 	: t_e_DataMap_DataTypes;
		udInterval 	: UDINT;
		iQoS 	: INT;
		bRetain 	: BOOL;
	END_VAR
	VAR_OUTPUT
		RetCode 	: t_e_DataMap_RetCode;
	END_VAR
  
  RetCode := DataMap_AddElement_Internal(pTopic, pElement, Operation, Datatype, udInterval, iQoS, bRetain, bAddedByXML:=FALSE);

END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_AddElement_Internal
	VAR_INPUT
		pTopic 	: ^CHAR;
		pElement 	: ^CHAR;
		Operation 	: t_e_DataMap_Operations;
		Datatype 	: t_e_DataMap_DataTypes;
		udInterval 	: UDINT;
		iQoS 	: INT;
		bRetain 	: BOOL;
		bAddedByXML 	: BOOL;
	END_VAR
	VAR_OUTPUT
		RetCode 	: t_e_DataMap_RetCode;
	END_VAR
  VAR
  	pElementPtr : ^void;
    ChannelMode : CHMODE;
    pPubEntry   : ^t_s_DataMap_ElementEntry_Publish;
    pSubEntry   : ^t_s_DataMap_ElementEntry_Subscribe;
    tmpPara1    : DINT;
    udLen       : UDINT;
  END_VAR

  RetCode := DM_OK;
  
  if pTopic = NIL           | 
     pElement = NIL         | 
     Datatype = DD_Unknown  |
     Operation = DO_Unknown then
     
    RetCode := DM_InputValueError;
    //Create Log: Adding DataMap Element failed, Inout value error
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_INPUT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_INPUT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_INPUT_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    return;
    
  end_if;
  
  //Check Topic Name Len
  udLen := SigCLib.StrLen(str:=pTopic); 
  
  if udLen >= MQTTCLIENTINTERFACE_DATAMAP_TOPIC_NAME_MAX_LEN then
  
    RetCode := DM_TopicNameTooLong;
    //Create Log: Adding Publish Element Failed, Topic Name too long
    
    tmpPara1 := to_dint(udLen);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_TOPIC_LEN_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_TOPIC_LEN_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_TOPIC_LEN_TEXT, 
                      pPara1      :=  #tmpPara1, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    return;
    
  end_if;
  
  udLen := SigCLib.StrLen(str:=pElement);
  
  if udLen >= MQTTCLIENTINTERFACE_DATAMAP_ELEMENT_MAX_LEN then
  
    RetCode := DM_ElementNameTooLong;
    //Create Log: Adding Publish Element Failed, Element Name too long
    
    tmpPara1 := to_dint(udLen);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_ELEMENT_LEN_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_ELEMENT_LEN_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_ELEMENT_LEN_TEXT, 
                      pPara1      :=  #tmpPara1, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    return;
    
  end_if;
  
  ChannelMode := _LookUpEmbed_C(  pText   :=  pElement, 
                                  pObj_ch :=  #pElementPtr, 
                                  pObj    :=  NIL);
  
  //If the Pointer is not found, log and fail
  if pElementPtr = NIL then
  
    RetCode := DM_ElementNotFound;
    //Create Log: Adding DataMap Element failed, Element not found
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_NOT_FOUND_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_NOT_FOUND_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_NOT_FOUND_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                          
    return;
  
  //If the Channel type is not OK, log & Fail
    //If this is a String and the ChannelType is not Object
    //If this is a 4-Byte Value and the ChannelTye is not SVR and not CMD.
  elsif (Datatype = DD_String   &
        ChannelMode <> _CH_OBJ) |
        ((Datatype = DD_DINT   | 
          Datatype = DD_UDINT  | 
          Datatype = DD_REAL)  &
         (ChannelMode <> _CH_SVR) &
         (ChannelMode <> _CH_CMD)) then
    
    RetCode := DM_InputValueError;
    
    //Create Log:
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_TYPE_MISMATCH_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_TYPE_MISMATCH_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_FAIL_TYPE_MISMATCH_TEXT, 
                      pPara1      :=  NIL, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    return;
    
  end_if;
  
  //==============================================================
  //Based on the requested operation, add the element to the list
  //==============================================================
  case Operation of
    //---------------------------------
    //PUBLISH
  	//---------------------------------
    t_e_DataMap_Operations::DO_Poll, DO_Change:
      
      if Config.pDataMapConfig^.udPublishElements >= Config.pDataMapConfig^.udEntries then
      
        RetCode := DM_ListFull;
        //Create Log: Adding Publish Element Failed, Too many entries
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_PUB_FAIL_FULL_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_PUB_FAIL_FULL_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_PUB_FAIL_FULL_TEXT, 
                          pPara1      :=  NIL,  
                          pPara2      :=  NIL,
                          pPara3      :=  NIL,
                          pPara4      :=  NIL);
                          
        return;
        
      end_if;
      
      pPubEntry := (Config.pDataMapConfig^.Elements.pPublishEntries$UDINT + (sizeof(t_s_DataMap_ElementEntry_Publish)*Config.pDataMapConfig^.udPublishElements))$^t_s_DataMap_ElementEntry_Publish;
      //pPubEntry := #Config.pDataMapConfig^.Elements.aPublishEntries[Config.pDataMapConfig^.udPublishElements];
      
      pPubEntry^.pData         := pElementPtr;
      pPubEntry^.Operation     := Operation;
      pPubEntry^.Datatype      := Datatype;
      pPubEntry^.iQoS          := iQoS;
      pPubEntry^.bRetain       := bRetain;
      pPubEntry^.udInterval    := udInterval;
      pPubEntry^.udLastAction  := ops.tAbsolute;
      pPubEntry^.bAddedByXML   := bAddedByXML;
      pPubEntry^.pTempMem      := NIL;
      
      SigCLib.MemSet( dst :=  #pPubEntry^.aElement, 
                      c   :=  0x00, 
                      len :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN);
                      
      SigCLib.StrCpy( dst0  :=  #pPubEntry^.aElement[0], 
                      src0  :=  pElement);
      
      SigCLib.MemSet( dst   :=  #pPubEntry^.aTopic, 
                      c     :=  0x00, 
                      len   :=  sizeof(t_s_DataMap_ElementEntry_Publish.aTopic));
    
      SigCLib.Utf8ToStr16(dst := #pPubEntry^.aTopic[0], 
                          src := pTopic);
      
      
      pPubEntry^.udDataLen  := 0;
      pPubEntry^.udCRC      := 0;
      //===================================
      //Based on Type, set Len
      //===================================
      case Datatype of
      	t_e_DataMap_DataTypes::DD_UDINT:
          pPubEntry^.udDataLen := MQTTCLIENTINTERFACE_DATAMAP_DATALEN_UDINT;
      	t_e_DataMap_DataTypes::DD_DINT:
          pPubEntry^.udDataLen := MQTTCLIENTINTERFACE_DATAMAP_DATALEN_DINT;
      	t_e_DataMap_DataTypes::DD_REAL:
          pPubEntry^.udDataLen := MQTTCLIENTINTERFACE_DATAMAP_DATALEN_REAL;
      end_case;
      
      //Calc CRC
      if Operation = DO_Change then
        
        // If the value should not be published immediately, we set the flag to true so that the initial publish is not made
        pPubEntry^.bInitialPublish := Config.pDataMapConfig^.Config.bSendOnAdd = FALSE;
        
        if  pPubEntry^.udDataLen > 0           &
            pPubEntry^.Datatype <> DD_String  then
          
          pPubEntry^.udCRC$DINT := RD(pt:= pPubEntry^.pData);
          
        elsif pPubEntry^.Datatype = DD_String then
          
          pPubEntry^.udCRC := pPubEntry^.pData$^StringInternal^.GetCRC();
          
        end_if;
        
      end_if;

      pPubEntry^.State := DMPS_Ready;
      Config.pDataMapConfig^.udPublishElements += 1;
      
    //---------------------------------
    //Subscribe
    //---------------------------------
  	t_e_DataMap_Operations::DO_Subscribe:
    
      if Config.pDataMapConfig^.udSubscribeElements >= Config.pDataMapConfig^.udEntries then
        RetCode := DM_ListFull;
        //Create Log: Adding Subscribe Element Failed, Too many entries
        
        tmpPara1 := to_dint(Config.pDataMapConfig^.udEntries);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_SUB_FAIL_FULL_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_SUB_FAIL_FULL_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_ADD_SUB_FAIL_FULL_TEXT, 
                          pPara1      :=  NIL, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                                  
        return;
      end_if;
      
      pSubEntry := (Config.pDataMapConfig^.Elements.pSubscribeEntries$UDINT + (sizeof(t_s_DataMap_ElementEntry_Subscribe)*Config.pDataMapConfig^.udSubscribeElements))$^t_s_DataMap_ElementEntry_Subscribe;
      //pSubEntry := #Config.pDataMapConfig^.Elements.aSubscribeEntries[Config.pDataMapConfig^.udSubscribeElements];
      
      pSubEntry^.pData        := pElementPtr;
      pSubEntry^.Datatype     := Datatype;
      pSubEntry^.iQoS         := iQoS;
      pSubEntry^.bAddedByXML  := bAddedByXML;
      pSubEntry^.bRemove      := FALSE;
      
      SigCLib.MemSet( dst :=  #pSubEntry^.aElement, 
                      c   :=  0x00, 
                      len :=  MQTTCLIENT_INT_XML_DATAMAP_TOPICENDPOINT_ELEMENT_MAX_LEN);
                      
      SigCLib.StrCpy( dst0  :=  #pSubEntry^.aElement[0], 
                      src0  :=  pElement);
      
      SigCLib.MemSet( dst   :=  #pSubEntry^.aTopic, 
                      c     :=  0x00, 
                      len   :=  sizeof(t_s_DataMap_ElementEntry_Subscribe.aTopic));
      
      SigCLib.Utf8ToStr16(dst := #pSubEntry^.aTopic[0], 
                          src := pTopic);
      
      pSubEntry^.State := DMSS_Ready;
      Config.pDataMapConfig^.udSubscribeElements += 1;
    
  end_case;
  
  RetCode := DM_OK;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_ProcessMap
  
  //Process the DataMap Lists
  DataMap_ProcessMap_Publish();
  DataMap_ProcessMap_Subscribe();
    
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_ProcessMap_Publish
  VAR
  	pEntry    : ^t_s_DataMap_ElementEntry_Publish;
    udCount   : UDINT;
    pData     : ^void;
    tmpPara1  : DINT;
    tmpPara2  : DINT;
    iMQRet    : INT;
  END_VAR
  
  //Process the Publish List
  if Config.pDataMapConfig^.udPublishElements > 0 then
    
    for udCount := 0 to Config.pDataMapConfig^.udPublishElements - 1 do
      
      pEntry := (Config.pDataMapConfig^.Elements.pPublishEntries$UDINT + (udCount*sizeof(t_s_DataMap_ElementEntry_Publish)))$^t_s_DataMap_ElementEntry_Publish;
            
      //=========================================================
      //Entry FSM
      //=========================================================
      case pEntry^.State of
        //--------------------------------------------
        //Prepare
        //--------------------------------------------
        t_e_DataMap_PublishStates::DMPS_Ready:
        
          pEntry^.udLastAction := ops.tAbsolute;
          pEntry^.State := DMPS_WaitForAction;
        
        //--------------------------------------------
        //Wait for publish event
        //--------------------------------------------
        t_e_DataMap_PublishStates::DMPS_WaitForAction:
          
          //If the entry needs to be removed, remove it
          if pEntry^.bRemove then

            pEntry^.State := DMPS_Remove;
            return;
            
          end_if;              
          
          //Reset MID
          pEntry^.iMid := -1;
                    
          //Test for Timeout (or if the initial publish should be made)
          if ops.tAbsolute - pEntry^.udLastAction >= pEntry^.udInterval
            | pEntry^.bInitialPublish = FALSE then
            
            //Test for Event and prepare to send
            
            //Poll always sends, advance to publish
            if pEntry^.Operation = DO_Poll then
              
              pEntry^.State := DMPS_Publish;
            
            //If the data needs to be monitored for a change, check if changed and advance to publish if necessary
            elsif pEntry^.Operation = DO_Change then
            
              //Determine if the data has changed
              
                //If this is a String object, use the string object CRC method
                if pEntry^.Datatype = DD_String then
                
                  Config.pDataMapConfig^.udCRC := pEntry^.pData$^StringInternal^.GetCRC();
                  
                //If this is a Server Value, call the Read Method, check if changed and store the value to publish
                elsif pEntry^.Datatype = DD_DINT  |
                      pEntry^.Datatype = DD_UDINT |
                      pEntry^.Datatype = DD_REAL  then
                  
                  //As the CRC and the data is the same length, just read the actual data, we won't unnecessarily calculate a CRC.
                  Config.pDataMapConfig^.udCRC$DINT := RD(pt:= pEntry^.pData);
                  
                //If this is some other block of Data, calculate the CRC Manually
                else
                
                  Config.pDataMapConfig^.udCRC := sigclib_crc32(  initval :=  MQTTCLIENTINTERFACE_DATAMAP_CRCCALC_INITVAL, 
                                                                  psrc    :=  pEntry^.pData, 
                                                                  length  :=  pEntry^.udDataLen);
                end_if;
              
                //Compare the CRCs (Old vs New)
                if pEntry^.udCRC <> Config.pDataMapConfig^.udCRC | 
                   pEntry^.bInitialPublish = FALSE               then
                
                  pEntry^.udCRC := Config.pDataMapConfig^.udCRC;
                  pEntry^.State := DMPS_Publish;
                  
                end_if;
              
            end_if;
            
            //Prepare the data to send: If the state was advanced to publish (In the above If-Stetment) We need to collect the data for the publish step
            if pEntry^.State = DMPS_Publish then

              //======================================================================================
              //Based on the DataType, prepare for publishing
              //======================================================================================
              case pEntry^.Datatype of

                //---------------------
                //String Object
                //---------------------
                DD_String:

                  pEntry^.udDataLen := pEntry^.pData$^StringInternal^.GetLength();
                  
                  if pEntry^.udDataLen > MQTTCLIENT_MAX_DATA_LEN then
                    //Create Log: DataMap tried sending a string that is larger than allowable maximum.

                    tmpPara1 := to_dint(pEntry^.udDataLen);
                    tmpPara2 := MQTTCLIENT_MAX_DATA_LEN;
                    
                    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_STRING_TRUNCATED_GRP, 
                                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_STRING_TRUNCATED_MSG, 
                                      pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_STRING_TRUNCATED_TEXT, 
                                      pPara1      :=  #tmpPara2, 
                                      pPara2      :=  #tmpPara1, 
                                      pPara3      :=  NIL, 
                                      pPara4      :=  NIL);
                    
                    pEntry^.udDataLen := MQTTCLIENT_MAX_DATA_LEN;
                    
                  end_if;

                  if pEntry^.pTempMem <> NIL then
                  
                    //Create Log: DataMap entry Temp Memory POinter was not NIL, Attempting free.
                    tmpPara1 := to_dint(pEntry^.iMid);

                    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_PUBLISH_TMPPTR_NOTNIL_GRP, 
                                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_PUBLISH_TMPPTR_NOTNIL_MSG, 
                                      pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_PUBLISH_TMPPTR_NOTNIL_TEXT, 
                                      pPara1      :=  #tmpPara1, 
                                      pPara2      :=  NIL, 
                                      pPara3      :=  NIL, 
                                      pPara4      :=  NIL);
                              
                    MQTTClient.Free(mptr:=pEntry^.pTempMem);
                    pEntry^.pTempMem := NIL;
                    
                  end_if;
                  
                  if pEntry^.udDataLen > 0 then
                    
                    // There is some data available, this needs to be copied
                    
                    pEntry^.pTempMem := MQTTClient.MallocV1(size0 :=  pEntry^.udDataLen,
                                                            mark0 :=  MQTTCLIENT_DEFAULT_MALLOC_MARK);
                                                
                    if pEntry^.pTempMem = NIL then
                      //Create Log: DataMap failed to allocate memory to send the string: ...

                      tmpPara1 := to_dint(pEntry^.iMid);
                      tmpPara2 := pEntry^.pData$DINT;
                      
                      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_PUBLISH_FAIL_STRMALLOC_GRP, 
                                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_PUBLISH_FAIL_STRMALLOC_MSG, 
                                        pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_PUBLISH_FAIL_STRMALLOC_TEXT, 
                                        pPara1      :=  #tmpPara1, 
                                        pPara2      :=  #tmpPara2, 
                                        pPara3      :=  NIL, 
                                        pPara4      :=  NIL);
                            
                      pEntry^.State := DMPS_WaitForAction;

                    else
                      
                      //We do not care about the 0-Termination of the string as the MQTTClient::Publish() Method will only copy the length specified.
                      pEntry^.pData$^StringInternal^.ReadDataOff( udOff :=  0, 
                                                                  pData :=  pEntry^.pTempMem$^USINT, 
                                                                  udMax :=  pEntry^.udDataLen);
                    end_if;
                                    
                  end_if;
                  

                //---------------------
                //4 Byte Server Values
                //---------------------
                DD_DINT,
                DD_UDINT,
                DD_REAL:
                  
                  //If the server is polled, we still need to fetch the data, do so.
                  if pEntry^.Operation = DO_Poll then
                    
                    pEntry^.TempMem$DINT := RD(pt:=pEntry^.pData);
                  
                  //This is an OnChange-Entry - Server has already been read, do not call the RD() method twice.
                  else
                    
                    //Copy the CRC Value
                    pEntry^.TempMem := pEntry^.udCRC;
                  
                  end_if;                  
                  
                //--------------------------------------------------------------------------------------------------------------------
                //Other Payloads (Assumed to be a problem, DataMap could be expanded later to fetch blocks of memory behind pointers).
                //--------------------------------------------------------------------------------------------------------------------
                DD_Unknown:
                  
                  pEntry^.State := DMPS_Error;

              end_case;

            end_if;
            
            //Update the timestamp to be able to wait another cycle
            pEntry^.udLastAction := ops.tAbsolute;
            
          end_if;
                    
        //--------------------------------------------
        //Perform Publish
        //--------------------------------------------
        t_e_DataMap_PublishStates::DMPS_Publish:
          
          //Prepare Data pointer
            //Strings are copied into Temporary Memory
            if pEntry^.Datatype = DD_String then
              
              pData := pEntry^.pTempMem;
              
            //4-Byte Values are stored in the Structure
            elsif pEntry^.Datatype = DD_DINT  |
                  pEntry^.Datatype = DD_UDINT |
                  pEntry^.Datatype = DD_REAL  then
            
              pData := #pEntry^.TempMem;
            
            end_if;
          
          //Perform Publish
          iMQRet := MQTT_Publish( pTopic        :=  #pEntry^.aTopic[0], 
                                  iQoS          :=  pEntry^.iQoS, 
                                  pPayload      :=  pData, 
                                  udPayloadLen  :=  pEntry^.udDataLen, 
                                  bRetain       :=  pEntry^.bRetain, 
                                  pThis         :=  this,  
                                  pCallback     :=  #DataMap_Return_Callback(), 
                                  pMid          :=  #pEntry^.iMid, 
                                  pApplMsgID    :=  #pEntry^.udApplID);
                                  
          if iMQRet = MQTT_ERR_SUCCESS$INT then

            //Create Log: DataMap Successfully Requested Publish for ... 
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := pEntry^.pData$DINT;
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG,
                              dMsgGroup   :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_PUBLISHED_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_PUBLISHED_MSG, 
                              pMsg        :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_PUBLISHED_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #tmpPara2, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
                              
                              
            pEntry^.State := DMPS_WaitForPublish;
            pEntry^.udLastAction := ops.tAbsolute;
            
          else
            
            //Create Log: DataMap Failed to issue Publish Request for ...
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := to_dint(iMQRet);
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_PUBLISH_FAIL_MQCLI_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_PUBLISH_FAIL_MQCLI_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_PUBLISH_FAIL_MQCLI_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #tmpPara2, 
                              pPara3      :=  #pEntry^.pData$DINT, 
                              pPara4      :=  NIL);
                              
            pEntry^.State := DMPS_Error;
            
          end_if;
          
        //--------------------------------------------
        //Wait for feedback
        //--------------------------------------------
        t_e_DataMap_PublishStates::DMPS_WaitForPublish:
          
          //Wait For Feedback from the MQTT Client
          if pEntry^.bPublishComplete then
            
            //Create Log: Datamap, Publish Complete
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := pEntry^.pData$DINT;
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                              dMsgGroup   :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_PUB_COMP_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_PUB_COMP_MSG, 
                              pMsg        :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_PUB_COMP_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #tmpPara2, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
                              
            pEntry^.bPublishComplete := FALSE;
            pEntry^.bInitialPublish := TRUE;
            pEntry^.State := DMPS_WaitForAction;
            
          end_if;
          
          //If the entry is moving on, free any temp mem associated with it.
          if pEntry^.State = DMPS_WaitForAction then
            
            //If this was a string
            if pEntry^.Datatype = DD_String then
              
              //If the entry had Tempmem associated with it, free it
              if pEntry^.pTempMem then
              
                MQTTClient.Free(mptr:=pEntry^.pTempMem);
                pEntry^.pTempMem := NIL;
                
              else
                
                tmpPara1 := to_dint(pEntry^.iMid);
                tmpPara2 := pEntry^.pData$DINT;
                
                Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                  dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_PUBLISH_TMPPTR_NIL_GRP, 
                                  dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_PUBLISH_TMPPTR_NIL_MSG, 
                                  pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_PUBLISH_TMPPTR_NIL_TEXT, 
                                  pPara1      :=  #tmpPara1, 
                                  pPara2      :=  #tmpPara2, 
                                  pPara3      :=  NIL, 
                                  pPara4      :=  NIL);
              end_if;

              
            end_if;

            
          end_if;
          
          //pEntry^.iMid := -1;
          
        //--------------------------------------------
        //Remove the Entry from the DataMap
        //--------------------------------------------
        t_e_DataMap_PublishStates::DMPS_Remove:
          
          //Remove this entry
          if udCount < (Config.pDataMapConfig^.udPublishElements - 1) then
            
            SigCLib.MemCpy( dst0  :=  pEntry, 
                            src0  :=  (pEntry$UDINT + (sizeof(t_s_DataMap_ElementEntry_Publish)))$^void, 
                            len0  :=  (sizeof(t_s_DataMap_ElementEntry_Publish))*(Config.pDataMapConfig^.udPublishElements - 1 - udCount));
            
          end_if;
          
          Config.pDataMapConfig^.udPublishElements -= 1;
          
          return;
        
        //--------------------------------------------
        //Error Occurred
        //--------------------------------------------
        t_e_DataMap_PublishStates::DMPS_Error:
          
          pEntry^.iMid := -1;
          //v1.13
          //In case an error occurs the topic should be recognized as not sent and will be sent as soon as the error is gone
          pEntry^.udCRC := 0;
          
          //If the reset time is set, wait for reset
          if (cDataMapResetTimeout <> 0) &
             (ops.tAbsolute - pEntry^.udLastAction >= cDataMapResetTimeout) then
            
            pEntry^.State := DMPS_Ready;
            
          end_if;
        
      end_case;

      
    end_for;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_ProcessMap_Subscribe
  VAR
  	pEntry : ^t_s_DataMap_ElementEntry_Subscribe;
    udCount : UDINT;
    iRetCode : INT;
    tmpPara1 : DINT;
    tmpPara2 : DINT;
  END_VAR
  
  //Process the Subscribe List
  if Config.pDataMapConfig^.udSubscribeElements > 0 then
    
    for udCount := 0 to Config.pDataMapConfig^.udSubscribeElements - 1 do
      
      pEntry$UDINT := ((Config.pDataMapConfig^.Elements.pSubscribeEntries)$UDINT + (udCount*sizeof(t_s_DataMap_ElementEntry_Subscribe)));
            
      //=========================================================
      //Entry FSM
      //=========================================================
      case pEntry^.State of
        
        //----------------------------------------------------
        //Ready to start operation, initialise
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_Ready:
          
          //Reset Mid
          pEntry^.iMid  := -1;          
          pEntry^.State := DMSS_Subscribe;
        
        //----------------------------------------------------
        //Issue Subscribe Request
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_Subscribe:
          
          iRetCode := MQTT_Subscribe( pTopic      :=  #pEntry^.aTopic[0], 
                                      iQoS        :=  pEntry^.iQos, 
                                      pThis       :=  this, 
                                      pCallback   :=  #DataMap_Return_Callback(), 
                                      pMid        :=  #pEntry^.iMid,
                                      pApplMsgID  :=  #pEntry^.udApplMsgID);
          
          if iRetCode = MQTT_ERR_SUCCESS$INT then
            //Create Log: Subscribed DataMap Element, Element=XXXX
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := pEntry^.pData$DINT;
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG,
                              dMsgGroup   :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_SUBD_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_SUBD_MSG, 
                              pMsg        :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_SUBD_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  NIL, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
                  
            pEntry^.State := DMSS_WaitForSubscribe;
            pEntry^.udLastAction := ops.tAbsolute;
            
          else
            //Create Log: Failed to Subscribe DataMap Element, MQTTClient Subscribe returned:XX, Element=XXXX
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := to_dint(iRetCode);
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_SUBSCRIBE_FAIL_MQCLI_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_SUBSCRIBE_FAIL_MQCLI_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_SUBSCRIBE_FAIL_MQCLI_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #tmpPara2, 
                              pPara3      :=  #pEntry^.pData$DINT, 
                              pPara4      :=  NIL);
                              
                           
            pEntry^.State := DMSS_Error;
            pEntry^.udLastAction := ops.tAbsolute;
            
          end_if;
          
        //----------------------------------------------------
        //Wait for Subscribe confirmation
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_WaitForSubscribe:
          
          if ops.tAbsolute - pEntry^.udLastAction >= cDataMapSubTimeout then
            
            //Create Log: DataMap Failed to subscribe Entry, Timeout. retry.
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := pEntry^.pData$DINT;
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_SUBSCRIBE_FAIL_TIMEOUT_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_SUBSCRIBE_FAIL_TIMEOUT_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_SUBSCRIBE_FAIL_TIMEOUT_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #cDataMapSubTimeout$DINT, 
                              pPara3      :=  #tmpPara2, 
                              pPara4      :=  NIL);
                              
            pEntry^.State := DMSS_Ready;
            
          end_if;
          
        //----------------------------------------------------
        //Subscribed
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_Subscribed:
           
        //----------------------------------------------------
        //Issue Unsubscribe Command
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_Unsubscribe:
          
          iRetCode := MQTT_Unsubscribe( pApplMsgID  :=  #pEntry^.udApplMsgID, 
                                        pTopic      :=  NIL, 
                                        pMid        :=  #pEntry^.iMid,
                                        pThis       :=  NIL,
                                        pCallback   :=  NIL);
                                  
          if iRetCode = MQTT_ERR_SUCCESS$INT then
            //Create Log: Subscribed DataMap Element, Element=XXXX
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := pEntry^.pData$DINT;
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG,
                              dMsgGroup   :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_UNSUBD_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_UNSUBD_MSG, 
                              pMsg        :=  MQCLIINF_LOG_INFO_DATAMAP_ENTRY_UNSUBD_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #tmpPara2, 
                              pPara3      :=  NIL, 
                              pPara4      :=  NIL);
            
            //If this state has not already been changed by a phony callback (made from within MQTT_Unsubscribe), then change the state
            //to DMSS_WaitForUnsubscribe as we are actually still waiting for a callback.
            if pEntry^.State = DMSS_Unsubscribe then
              pEntry^.State := DMSS_WaitForUnsubscribe;
            end_if;

            pEntry^.udLastAction := ops.tAbsolute;
          
          elsif iRetCode = MQTTClient::MQTT_ERR_ALREADY_SUB$INT then
          
            // The Subscription was already there
            pEntry^.State := DMSS_Subscribed;
            pEntry^.udLastAction := ops.tAbsolute;
          
          else
          
            //Create Log: Failed to Subscribe DataMap Element, MQTTClient Subscribe returned:XX, Element=XXXX
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := to_dint(iRetCode);
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_MQCLI_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_MQCLI_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_MQCLI_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #tmpPara2, 
                              pPara3      :=  #pEntry^.pData$DINT, 
                              pPara4      :=  NIL);
                              
            pEntry^.State := DMSS_Error;
            pEntry^.udLastAction := ops.tAbsolute;
            
          end_if;
          
        //----------------------------------------------------
        //Wait for Unsubscribe confirmation
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_WaitForUnsubscribe:       
          
          if ops.tAbsolute - pEntry^.udLastAction >= cDataMapSubTimeout then
            
            //Create Log: DataMap Failed to subscribe Entry, Timeout. Moving On.
            
            tmpPara1 := to_dint(pEntry^.iMid);
            tmpPara2 := pEntry^.pData$DINT;
            
            Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                              dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_TIMEOUT_GRP, 
                              dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_TIMEOUT_MSG, 
                              pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_TIMEOUT_TEXT, 
                              pPara1      :=  #tmpPara1, 
                              pPara2      :=  #cDataMapSubTimeout$DINT, 
                              pPara3      :=  #tmpPara2, 
                              pPara4      :=  NIL);
                                 
            pEntry^.State := DMSS_Unsubscribed;
            
          end_if;
        
        //----------------------------------------------------
        //Cleanup & Finish
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_Unsubscribed:
          
          //Reset Mid
          pEntry^.iMid  := -1;     
          
          //If the element must be removed do so, else return it to the original state
          if pEntry^.bRemove then
                        
            if DataMap_RemoveElement_ByIndex( udIndex     :=  udCount, 
                                              ElementType :=  DM_Subscribe) = FALSE then
               
               //Create Log: Failed to remove unsubscribed PubSub Entry from PubSub list.
               
               tmpPara1 := to_dint(pEntry^.iMid);
               tmpPara2 := to_dint(udCount);
               
               Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                                 dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_RMVE_LIST_GRP, 
                                 dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_RMVE_LIST_MSG, 
                                 pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_UNSUBSCRIBE_FAIL_RMVE_LIST_TEXT, 
                                 pPara1      :=  #tmpPara1, 
                                 pPara2      :=  #tmpPara2, 
                                 pPara3      :=  NIL, 
                                 pPara4      :=  NIL);
                      
               pEntry^.State := DMSS_Error;
               pEntry^.udLastAction := ops.tAbsolute;
               
            end_if;                                   
           
          //Return State to allow a resubscription.
          else
            
            pEntry^.State := DMSS_Ready;
            
          end_if;

        //----------------------------------------------------
        //Error Occurred
        //----------------------------------------------------
        t_e_DataMap_SubscribeStates::DMSS_Error:
          
          //Reset Mid
          pEntry^.iMid  := -1; 
          
          //If the reset time is set, wait for reset
          if (cDataMapResetTimeout <> 0) &
             (ops.tAbsolute - pEntry^.udLastAction >= cDataMapResetTimeout) then
            
            pEntry^.State := DMSS_Ready;
            
          end_if;

      end_case;

      
    end_for;

  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_RemoveElement
	VAR_INPUT
		pElement 	: ^CHAR;
		ElementType 	: t_e_DataMap_ElementTypes;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udElementIndex : UDINT;
    pPublishEntry : ^t_s_DataMap_ElementEntry_Publish;
    pSubscribeEntry : ^t_s_DataMap_ElementEntry_Subscribe;
  END_VAR
  
  bOK := FALSE;
  udElementIndex := 0;
  
  if pElement = NIL then
    return;
  end_if;
  
  //==========================================
  //Based on the type of element
  //==========================================
  
  case ElementType of
  
    
    //-------------------------------------
    //Publish List
    //-------------------------------------
  	t_e_DataMap_ElementTypes::DM_Publish:
    
      if Config.pDataMapConfig^.udPublishElements > 0 then
          
        pPublishEntry := Config.pDataMapConfig^.Elements.pPublishEntries;

        for udElementIndex := 0 to Config.pDataMapConfig^.udPublishElements - 1 do
          
          if SigCLib.StrCmp(ps1:=#pPublishEntry^.aElement[0], ps2:=pElement) = 0 then
            bOK := DataMap_RemoveElement_ByIndex(udIndex:=udElementIndex, ElementType:=ElementType);
            exit;
          end_if;

          pPublishEntry$UDINT += sizeof(t_s_DataMap_ElementEntry_Publish);
        end_for;
        
      else
        return;
      end_if;
    
    //-------------------------------------
    //Subscribe List
    //-------------------------------------
  	t_e_DataMap_ElementTypes::DM_Subscribe:
    
      if Config.pDataMapConfig^.udSubscribeElements > 0 then
        
        pSubscribeEntry := Config.pDataMapConfig^.Elements.pSubscribeEntries;

        for udElementIndex := 0 to Config.pDataMapConfig^.udSubscribeElements - 1 do

          if SigCLib.StrCmp(ps1:=#pSubscribeEntry^.aElement[0], ps2:=pElement) = 0 then
            
            if pSubscribeEntry^.State = DMSS_Subscribed then
              pSubscribeEntry^.State    := DMSS_Unsubscribe;
              pSubscribeEntry^.bRemove  := TRUE;
              bOK                       := TRUE;
            end_if;
            
            exit;
          end_if;
          
          pSubscribeEntry$UDINT += sizeof(t_s_DataMap_ElementEntry_Subscribe);

        end_for;
       
      else
        return;
      end_if;
    
  end_case;

END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_RemoveElement_ByIndex
	VAR_INPUT
		udIndex 	: UDINT;
		ElementType 	: t_e_DataMap_ElementTypes;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	tmpPara : DINT;
  END_VAR

  //Assume not OK
  bOK := FALSE;
  
  if Config.pDataMapConfig = NIL then
    //Create Log: Tried removing an entry from the DataMap, DataMap not inited.
    
    tmpPara := to_dint(udIndex);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_REMOVE_FAILED_NOTINIT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_REMOVE_FAILED_NOTINIT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_REMOVE_FAILED_NOTINIT_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
    
  end_if;
  
  //========================================================
  //Based on the type of element - Find and remove the entry
  //========================================================
  case ElementType of
  
    //-------------------------------------
    //Publish List
    //-------------------------------------
  	t_e_DataMap_ElementTypes::DM_Publish:
    
      //If the index is ok
      if udIndex >= 0                                         &
         udIndex <  Config.pDataMapConfig^.udPublishElements  then
        
        //If this is the last entry, we don't need to copy any data
        if udIndex = Config.pDataMapConfig^.udPublishElements - 1 then
        
          Config.pDataMapConfig^.udPublishElements -= 1;
          
        //If this is not the last entry, the data has to be moved back
        else
        
          SigCLib.MemCpy( dst0  :=  (Config.pDataMapConfig^.Elements.pPublishEntries$UDINT + sizeof(t_s_DataMap_ElementEntry_Publish)*udIndex)$^void, 
                          src0  :=  (Config.pDataMapConfig^.Elements.pPublishEntries$UDINT + sizeof(t_s_DataMap_ElementEntry_Publish)*(udIndex+1))$^void, 
                          len0  :=  ((Config.pDataMapConfig^.udPublishElements-1) - udIndex)*sizeof(t_s_DataMap_ElementEntry_Publish));
          
          Config.pDataMapConfig^.udPublishElements -= 1;
          
        end_if;
        
        bOK := TRUE;
        return;
        
      else
      
        //Create Log: Tried removing an Entry from the DataMap with invalid Index.
        
        tmpPara := to_dint(udIndex);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_REMOVE_FAILED_INDEX_INV_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_REMOVE_FAILED_INDEX_INV_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_REMOVE_FAILED_INDEX_INV_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
      
      end_if;    
    
    //-------------------------------------
    //Subscribe List
    //-------------------------------------
  	t_e_DataMap_ElementTypes::DM_Subscribe:
    
      //If the index is ok
      if udIndex >= 0 &
         udIndex <  Config.pDataMapConfig^.udSubscribeElements then
        
        if udIndex = Config.pDataMapConfig^.udSubscribeElements - 1 then
          Config.pDataMapConfig^.udSubscribeElements -= 1;
        else
          
          SigCLib.MemCpy( dst0  :=  (Config.pDataMapConfig^.Elements.pSubscribeEntries$UDINT + sizeof(t_s_DataMap_ElementEntry_Subscribe)*udIndex)$^void, 
                          src0  :=  (Config.pDataMapConfig^.Elements.pSubscribeEntries$UDINT + sizeof(t_s_DataMap_ElementEntry_Subscribe)*(udIndex+1))$^void, 
                          len0  :=  ((Config.pDataMapConfig^.udSubscribeElements-1) - udIndex)*sizeof(t_s_DataMap_ElementEntry_Subscribe));
          
          Config.pDataMapConfig^.udSubscribeElements -= 1;
          
        end_if;
        
        bOK := TRUE;
        return;
        
      else
      
        //Create Log: Tried removing an Entry from the DataMap with invalid Index.
        
        tmpPara := to_dint(udIndex);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_REMOVE_FAILED_INDEX_INV_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_REMOVE_FAILED_INDEX_INV_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_REMOVE_FAILED_INDEX_INV_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
      
      end_if;
      
    
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_ResetStates
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  VAR
  	udCount : UDINT;
    pSubElement : ^t_s_DataMap_ElementEntry_Subscribe;
    pPubElement : ^t_s_DataMap_ElementEntry_Publish;
  END_VAR
  
  //Assume Fail
  bOK := FALSE;
  
  //Reset Registered DataMap States
  if Config.pDataMapConfig then
  
    if Config.pDataMapConfig^.udSubscribeElements > 0 then
      pSubElement := Config.pDataMapConfig^.Elements.pSubscribeEntries;
      for udCount := 0 to Config.pDataMapConfig^.udSubscribeElements - 1 do
        pSubElement^.State := 0;
        pSubElement$UDINT += sizeof(t_s_DataMap_ElementEntry_Subscribe);
      end_for;
    end_if;
    
    if Config.pDataMapConfig^.udPublishElements > 0 then
      pPubElement:= Config.pDataMapConfig^.Elements.pPublishEntries;
      for udCount := 0 to Config.pDataMapConfig^.udPublishElements - 1 do
        pPubElement^.State := 0;
        pPubElement$UDINT += sizeof(t_s_DataMap_ElementEntry_Publish);
      end_for;
    end_if;
    
    bOK := TRUE;
  
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_Return_Callback
	VAR_INPUT
		pThis 	: ^void;
		MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes;
		iMid 	: INT;
		iGrantedQoS 	: INT;
		pMessage 	: ^MQTTClient::t_s_MQTTMessage;
	END_VAR
  
  //Call Internal Method
  pThis$^MQTTClient_Interface^.DataMap_Return(MsgType     :=  MsgType, 
                                              iMid        :=  iMid, 
                                              iGrantedQoS :=  iGrantedQoS,
                                              pMessage    :=  pMessage);
  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_Clear
  
  if Config.pDataMapConfig                             &
     Config.pDataMapConfig^.Elements.pPublishEntries   &
     Config.pDataMapConfig^.Elements.pSubscribeEntries then
    
    Config.pDataMapConfig^.udPublishElements := 0;
    Config.pDataMapConfig^.udSubscribeElements := 0;
    
    sigclib_memset( dst :=  Config.pDataMapConfig^.Elements.pPublishEntries, 
                    c   :=  0x00, 
                    len :=  sizeof(t_s_DataMap_ElementEntry_Publish)*Config.pDataMapConfig^.udEntries);
    
    sigclib_memset( dst :=  Config.pDataMapConfig^.Elements.pSubscribeEntries, 
                    c   :=  0x00, 
                    len :=  sizeof(t_s_DataMap_ElementEntry_Subscribe)*Config.pDataMapConfig^.udEntries);
                    
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::DataMap_Return
	VAR_INPUT
		MsgType 	: MQTTClient_Interface::t_e_PubSubRetCodes;
		iMid 	: INT;
		iGrantedQoS 	: INT;
		pMessage 	: ^MQTTClient::t_s_MQTTMessage;
	END_VAR
  VAR
  	udCount         : UDINT;
  	pArray          : ^void;
    pArrEntry       : ^void;
    udNumSubEntries : UDINT;
    pSubEntry       : ^t_s_DataMap_ElementEntry_Subscribe;
    pPubEntry       : ^t_s_DataMap_ElementEntry_Publish;
    bFound          : BOOL;
    udCopyLen       : UDINT;
    tmpPara1        : DINT;
    tmpPara2        : DINT;
    tmpPara3        : DINT;
    tmpPara4        : DINT;
    tmpData         : DINT; //Variable to contain the received 4 byte values temporarily, this avoids writing rubbish on the server
  END_VAR
  
  //Clear pSubEntries Pointer, Memory is malloc'd and set to this pointer if MsgType = PSRC_PublishReceived,
  //All exit paths must be observed to avoid a memory leak here.
  pArray := NIL;
  
  if Config.pDataMapConfig = NIL then
    //Create Log: Received Datamap Callback for DataMap Whilst DataMap is not Inited.
    
    tmpPara1 := to_dint(iMid);
    
    if pMessage <> NIL then
      tmpPara2 := to_dint(pMessage^.mid);
    else
      tmpPara2 := 16#FFFF;
    end_if;
        
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_CALLBACK_MAP_NOTINIT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_CALLBACK_MAP_NOTINIT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_CALLBACK_MAP_NOTINIT_TEXT, 
                      pPara1      :=  #tmpPara1, 
                      pPara2      :=  #tmpPara2, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
                      
    return;
  end_if;
  
  bFound := FALSE;
  
  //======================================
  //Find the DataMap Entry with this Mid
  //======================================
  case MsgType of
  
    //------------------------------------------------
    //Disconnected
    //------------------------------------------------
  	PSRC_Disconnected:
    
      //Reset all the DataMap Entries

      return;
      
    //---------------------------------------------------------------------------
    //Subscribe Related, can only be: one entry (Mid Tracked) or all (Mid = -1)
    //---------------------------------------------------------------------------
  	PSRC_Subscribed, PSRC_Unsubscribed:
    
      pSubEntry := Config.pDataMapConfig^.Elements.pSubscribeEntries;
      if Config.pDataMapConfig^.udSubscribeElements > 0 then
      
        //If this is an unsubscribe all (iMid=-1), then simply unsubscribe all and return,
        //else find the entry to unsubscribe
        if iMid = -1 then
        
          for udCount := 0 to Config.pDataMapConfig^.udSubscribeElements - 1 do
            pSubEntry^.State := DMSS_Unsubscribed;
            pSubEntry$UDINT += sizeof(t_s_DataMap_ElementEntry_Subscribe);
          end_for;
          return;
        
        //This is a specific entry, step over all entries to find the matching entry.
        else
        
          for udCount := 0 to Config.pDataMapConfig^.udSubscribeElements - 1 do
            if pSubEntry^.iMid = iMid then
              bFound := TRUE;
              exit;
            end_if;
            pSubEntry$UDINT += sizeof(t_s_DataMap_ElementEntry_Subscribe);
          end_for;
          
        end_if;
      end_if;
      
    //----------------------------------------------------
    //Publish Related, Mid tracked, can only be one entry
    //----------------------------------------------------
  	PSRC_Published:
      
      pPubEntry := Config.pDataMapConfig^.Elements.pPublishEntries;
      for udCount := 0 to Config.pDataMapConfig^.udEntries - 1 do
        if pPubEntry^.iMid = iMid then
          pPubEntry^.iMid := -1;
          bFound := TRUE;
          exit;
        end_if;
        pPubEntry$UDINT += sizeof(t_s_DataMap_ElementEntry_Publish);
      end_for;
      
    //-------------------------------------------------------------------
    //Subscribe Related, Use Topic for relation, can be multiple entries
    //-------------------------------------------------------------------
    PSRC_PublishReceived:
      
      pArray := MQTTClient.MallocV1(size0 :=  sizeof(^void) * Config.pPubSubConfig^.PubSubList.udMaxEntries, 
                                    mark0 :=  MQTTCLIENTINTERFACE_DEFAULT_MALLOC_MARK);
                                 
      //If the Malloc succeeded
      if pArray <> NIL then
      
        SigCLib.MemSet( dst :=  pArray, 
                        c   :=  0x00, 
                        len :=  sizeof(^void) * Config.pPubSubConfig^.PubSubList.udMaxEntries);
                        
        udNumSubEntries := 0;
        pSubEntry := Config.pDataMapConfig^.Elements.pSubscribeEntries;
        pArrEntry := pArray;
        
        for udCount := 0 to Config.pDataMapConfig^.udSubscribeElements - 1 do
        
          //If this is not a stale entry and the topic matches, add to the list.
          if PubSub_TopicCompare(pStr:=pMessage^.topic, pWCString:=#pSubEntry^.aTopic[0]) then
          
            bFound := TRUE;
            pArrEntry^$UDINT := pSubEntry$UDINT;
            pArrEntry$UDINT += sizeof(^void);
            udNumSubEntries += 1;
            
          end_if;
          
          pSubEntry$UDINT += sizeof(t_s_DataMap_ElementEntry_Subscribe);
          
        end_for;
        
      //Malloc failed, we won't be able to deliver the message to the Application, report error.
      else
        
        tmpPara1 := to_dint(iMid);
    
        if pMessage <> NIL then
          tmpPara2 := to_dint(pMessage^.mid);
        else
          tmpPara2 := 16#FFFF;
        end_if;
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_RETURN_NOMEM_ARRAY_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_RETURN_NOMEM_ARRAY_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_RETURN_NOMEM_ARRAY_TEXT, 
                          pPara1      :=  #tmpPara1, 
                          pPara2      :=  #tmpPara2, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        
        return;
        
      end_if;

  end_case;

  if bFound = FALSE then
    //Create Log: Received DataMap Callback but did not find corresponding entry.
    
    tmpPara1 := to_dint(iMid);
    
    if pMessage <> NIL then
      tmpPara2 := to_dint(pMessage^.mid);
    else
      tmpPara2 := 16#FFFF;
    end_if;
        
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_CALLBACK_ENTRY_NOTFOUND_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_CALLBACK_ENTRY_NOTFOUND_MSG, 
                      pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_CALLBACK_ENTRY_NOTFOUND_TEXT, 
                      pPara1      :=  #tmpPara1, 
                      pPara2      :=  #tmpPara2, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    
    //If the pSubEntries Pointer is set, free
    if pArray then
      MQTTClient.Free(mptr:=pArray);
      pArray := NIL;
    end_if;
                          
    return;
  end_if;

  //=====================================================
  //Based on the type of message, edit the DataMap
  //=====================================================
  case MsgType of
    
    //------------------------------------------------
    //Subscribe completed, check and advance
    //------------------------------------------------
    t_e_PubSubRetCodes::PSRC_Subscribed:        

      //if the QoS is invalid, set state and log
      if iGrantedQoS < MQTT_PROT_QOS_MIN |
         iGrantedQoS > MQTT_PROT_QOS_MAX then
        //Create Log: DataMap Element Failed to Subscribe, Returned QoS Invalid, Element=XXXX Granted=XX, Requested=XX
        
        tmpPara1 := to_dint(iMid);
        
        if pMessage <> NIL then
          tmpPara2 := to_dint(pMessage^.mid);
        else
          tmpPara2 := 16#FFFF;
        end_if;
        
        tmpPara3 := to_dint(iGrantedQoS);
        
        if pSubEntry <> NIL then
          tmpPara4 := to_dint(pSubEntry^.iQoS);
        else
          tmpPara4 := 16#FFFF;
        end_if;
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_DATAMAP_SUB_CONF_WRONG_QOS_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_DATAMAP_SUB_CONF_WRONG_QOS_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_DATAMAP_SUB_CONF_WRONG_QOS_TEXT, 
                          pPara1      :=  #tmpPara1, 
                          pPara2      :=  #tmpPara2, 
                          pPara3      :=  #tmpPara3, 
                          pPara4      :=  #tmpPara4);
                          
        pSubEntry^.State := DMSS_Error;
        return;
      end_if;
      
      //If the Entry is not in the correct state
      if pSubEntry^.State <> DMSS_WaitForSubscribe then
        //Create Log: DataMap Element failed to Subscribe, Subscription returned valid but the Element State was invalid, Element=XXXX, Granted QoS=XX
        
        tmpPara1 := to_dint(iMid);
        
        if pMessage <> NIL then
          tmpPara2 := to_dint(pMessage^.mid);
        else
          tmpPara2 := 16#FFFF;
        end_if;
        
        tmpPara3 := to_dint(pSubEntry^.State);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_SUB_CONFD_WRONG_STATE_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_SUB_CONFD_WRONG_STATE_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_SUB_CONFD_WRONG_STATE_TEXT, 
                          pPara1      :=  #tmpPara1, 
                          pPara2      :=  #tmpPara2, 
                          pPara3      :=  #tmpPara3, 
                          pPara4      :=  NIL);
                          
        pSubEntry^.State := DMSS_Error;
        return;
        
      end_if;

      //If QoS does not match then log the difference and update
      if iGrantedQoS <> pSubEntry^.iQoS then
        //Create Log: DataMap Element Granted QoS differs from Requested, Element=XXXX Granted=XX, Requested=XX
        
        tmpPara1 := to_dint(iMid);
        
        if pMessage <> NIL then
          tmpPara2 := to_dint(pMessage^.mid);
        else
          tmpPara2 := 16#FFFF;
        end_if;
              
        tmpPara3 := to_dint(iGrantedQoS);
        
        if pSubEntry <> NIL then
          tmpPara4 := to_dint(pSubEntry^.iQoS);
        else
          tmpPara4 := 16#FFFF;
        end_if;
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                          dMsgGroup   :=  MQCLIINF_LOG_INFO_DATAMAP_SUB_CONFD_QOS_DIFFERS_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_INFO_DATAMAP_SUB_CONFD_QOS_DIFFERS_MSG, 
                          pMsg        :=  MQCLIINF_LOG_INFO_DATAMAP_SUB_CONFD_QOS_DIFFERS_TEXT, 
                          pPara1      :=  #tmpPara1, 
                          pPara2      :=  #tmpPara2, 
                          pPara3      :=  #tmpPara3, 
                          pPara4      :=  #tmpPara4);
                        
                        
        pSubEntry^.iQoS := iGrantedQoS;
      end_if;
      
      pSubEntry^.State := DMSS_Subscribed;

    //------------------------------------------------
    //Unsubscribe completed, check and advance
    //------------------------------------------------
    t_e_PubSubRetCodes::PSRC_Unsubscribed:
    
      //Create Log: DataMap Element Unsubscribed, Element=XXXX
      
      tmpPara1 := to_dint(iMid);
      
      if pMessage <> NIL then
        tmpPara2 := to_dint(pMessage^.mid);
      else
        tmpPara2 := 16#FFFF;
      end_if;

      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                        dMsgGroup   :=  MQCLIINF_LOG_INFO_DATAMAP_UNSUB_CONFD_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_INFO_DATAMAP_UNSUB_CONFD_MSG, 
                        pMsg        :=  MQCLIINF_LOG_INFO_DATAMAP_UNSUB_CONFD_TEXT, 
                        pPara1      :=  #tmpPara1, 
                        pPara2      :=  #tmpPara2, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                                
      pSubEntry^.State := DMSS_Unsubscribed;
    
    //------------------------------------------------
    //Publish Received, Set Data
    //------------------------------------------------
    t_e_PubSubRetCodes::PSRC_PublishReceived:
      
      if pMessage then
        
        //Step over all the entries found and process the message
        if udNumSubEntries > 0 then
          
          for udCount := 0 to udNumSubEntries - 1 do
            
            //pSubEntry := aSubEntries[udCount];
            pSubEntry$UDINT := (pArray$UDINT + sizeof(^void)*udCount);
            pSubEntry := pSubEntry^$^t_s_DataMap_ElementEntry_Subscribe;
            
            //======================================
            //Set the data based on the type
            //======================================
            case pSubEntry^.DataType of
              //----------------------
              //4 Bytes
              //----------------------
              t_e_DataMap_DataTypes::DD_UDINT:
                                
                udCopyLen := pMessage^.payloadlen;
                
                if udCopyLen > sizeof(UDINT) then
                  //Create Log: More data received than is able to be fit into Datamap element, data truncated
                  
                  tmpPara1 := to_dint(iMid);
                  
                  if pMessage <> NIL then
                    tmpPara2 := to_dint(pMessage^.mid);
                  else
                    tmpPara2 := 16#FFFF;
                  end_if;
                  
            
                  Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                    dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_UDINT_GRP, 
                                    dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_UDINT_MSG, 
                                    pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_UDINT_TEXT, 
                                    pPara1      :=  #tmpPara1, 
                                    pPara2      :=  #tmpPara2, 
                                    pPara3      :=  #udCopyLen$DINT, 
                                    pPara4      :=  NIL);
                  
                  udCopyLen := sizeof(UDINT);
                  
                end_if;
                
                tmpData := 0;
                SigCLib.MemCpy( dst0  :=  #tmpData, 
                                src0  :=  pMessage^.payload, 
                                len0  :=  pMessage^.payloadlen);
                
                WR( pt    :=  pSubEntry^.pData, 
                    dData :=  tmpData$DINT);
                
              //----------------------
              //4 Bytes
              //----------------------
              t_e_DataMap_DataTypes::DD_DINT:
                
                udCopyLen := pMessage^.payloadlen;
                
                if udCopyLen > sizeof(DINT) then
                  //Create Log: More data received than is able to be fit into Datamap element, data truncated
                  
                  tmpPara1 := to_dint(iMid);
                  
                  if pMessage <> NIL then
                    tmpPara2 := to_dint(pMessage^.mid);
                  else
                    tmpPara2 := 16#FFFF;
                  end_if;
            
                  Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                    dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_DINT_GRP, 
                                    dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_DINT_MSG, 
                                    pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_DINT_TEXT, 
                                    pPara1      :=  #tmpPara1, 
                                    pPara2      :=  #tmpPara2, 
                                    pPara3      :=  #udCopyLen$DINT, 
                                    pPara4      :=  NIL);
                                    
                  udCopyLen := sizeof(UDINT);
                  
                end_if;
                
                tmpData := 0;
                SigCLib.MemCpy( dst0  :=  #tmpData, 
                                src0  :=  pMessage^.payload, 
                                len0  :=  pMessage^.payloadlen);
                
                WR( pt    :=  pSubEntry^.pData, 
                    dData :=  tmpData$DINT);
                              
              //----------------------
              //4 Bytes
              //----------------------
              t_e_DataMap_DataTypes::DD_REAL:
                
                udCopyLen := pMessage^.payloadlen;
                
                if udCopyLen > sizeof(REAL) then
                  //Create Log: More data received than is able to be fit into Datamap element, data truncated
                  
                  tmpPara1 := to_dint(iMid);
                  
                  if pMessage <> NIL then
                    tmpPara2 := to_dint(pMessage^.mid);
                  else
                    tmpPara2 := 16#FFFF;
                  end_if;
            
                  Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                                    dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_REAL_GRP, 
                                    dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_REAL_MSG, 
                                    pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_TRUNCATED_REAL_TEXT, 
                                    pPara1      :=  #tmpPara1, 
                                    pPara2      :=  #tmpPara2, 
                                    pPara3      :=  #udCopyLen$DINT, 
                                    pPara4      :=  NIL);
                                    
                  udCopyLen := sizeof(UDINT);
                  
                end_if;
                
                tmpData := 0;
                SigCLib.MemCpy( dst0  :=  #tmpData, 
                                src0  :=  pMessage^.payload, 
                                len0  :=  pMessage^.payloadlen);
                
                WR( pt    :=  pSubEntry^.pData, 
                    dData :=  tmpData$DINT);
              
              //----------------------
              //Dynamic Size
              //----------------------
              t_e_DataMap_DataTypes::DD_String:
              
                pSubEntry^.pData$^StringInternal^.WriteDataOff(udLen :=  pMessage^.payloadlen, 
                                                               udOff :=  0, 
                                                               pData :=  pMessage^.payload$^USINT);
                
            end_case;
                        
          end_for;

        end_if;

        
      
      else
        
        //Create Log: DataMap Received PublishReceived Callback from MQTTClientInterface but no message was set
        
        tmpPara1 := to_dint(iMid);
        
        if pMessage <> NIL then
          tmpPara2 := to_dint(pMessage^.mid);
        else
          tmpPara2 := 16#FFFF;
        end_if;
          
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_EMPTY_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_EMPTY_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_DATAMAP_DATA_EMPTY_TEXT, 
                          pPara1      :=  #tmpPara1, 
                          pPara2      :=  #tmpPara2, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        
      end_if;

      //If the pSubEntries Pointer is set, free
      if pArray then
        MQTTClient.Free(mptr:=pArray);
        pArray := NIL;
      end_if;
      
    //------------------------------------------------
    //Publish Complete
    //------------------------------------------------
    t_e_PubSubRetCodes::PSRC_Published:  
      
      pPubEntry^.bPublishComplete := TRUE;
      
      return;
        
  end_case;


  
END_FUNCTION

//================================================================================================================================================================
//-------------------------------------------------------------------END OF DATAMAP METHODS-----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//------------------------------------------------------------------------CALLBACK METHODS------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient_Interface::Callback_OnConnectWithFlags
	VAR_INPUT
		pThis 	: ^void;
		retCode 	: INT;
    flags   : BYTE;
	END_VAR
  
  if pThis then
    pThis$^MQTTClient_Interface^.OnConnectWithFlags(retCode:=retCode,flags:=flags);
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnDisconnect
	VAR_INPUT
		pThis 	: ^void;
		retCode 	: INT;
	END_VAR
  
  if pThis then
    pThis$^MQTTClient_Interface^.OnDisconnect(retCode:=retCode);
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnPublish
	VAR_INPUT
		pThis 	: ^void;
		mid 	: INT;
	END_VAR
  
  if pThis then
    pThis$^MQTTClient_Interface^.OnPublish(mid:=mid);
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnMessage
	VAR_INPUT
		pThis 	: ^void;
		pMessage 	: ^MQTTClient::t_s_MQTTMessage;
	END_VAR
  
  if pThis then
    pThis$^MQTTClient_Interface^.OnMessage(pMessage:=pMessage);
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnSubscribe
	VAR_INPUT
		pThis 	: ^void;
		mid 	: INT;
		qos_count 	: INT;
		granted_qos 	: ^INT;
	END_VAR
  
  if pThis then
    pThis$^MQTTClient_Interface^.OnSubscribe( mid         :=  mid,
                                              qos_count   := qos_count,
                                              granted_qos := granted_qos);
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnUnsubscribe
	VAR_INPUT
		pThis 	: ^void;
		mid 	: INT;
	END_VAR

  if pThis then
    pThis$^MQTTClient_Interface^.OnUnsubscribe(mid:=mid);
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnLog
	VAR_INPUT
		pThis 	: ^void;
		level 	: INT;
		pStr 	: ^CHAR;
	END_VAR

  if pThis then
    pThis$^MQTTClient_Interface^.OnLog( level :=  level,
                                        pStr  :=  pStr);
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::Callback_OnLog_WithDetail
	VAR_INPUT
		pThis 	    : ^void;
		usLevel 	  : USINT;
		dMsgGroup 	: DINT;
		dMsgNbr 	  : DINT;
		pMsg 	      : ^CHAR;
		pPara1 	    : ^DINT;
		pPara2 	    : ^DINT;
		pPara3 	    : ^DINT;
		pPara4 	    : ^DINT;
	END_VAR

  if pThis then
  
    pThis$^MQTTClient_Interface^.OnLog_WithDetail(usLevel   := usLevel,
                                                  dMsgGroup := dMsgGroup,
                                                  dMsgNbr   := dMsgNbr,
                                                  pMsg      := pMsg,
                                                  pPara1    := pPara1,
                                                  pPara2    := pPara2,
                                                  pPara3    := pPara3,
                                                  pPara4    := pPara4);
                                                  
  end_if;

END_FUNCTION

FUNCTION MQTTClient_Interface::OnConnectWithFlags
	VAR_INPUT
		retCode 	: INT;
		flags 	  : BYTE;
	END_VAR
  VAR
  	tmpPara, tmpPara2 : DINT;
  END_VAR

    
  //=================================
  //Internal Actions
  
  //If in the correct state, process the Connect message, else log
  if InterfaceState = MCIS_WaitForConnection |
     InterfaceState = MCIS_Reconnecting      then
    
    if retCode = MQTT_PROT_CONNACK_RET_CONNACCEPTED then
      
      InterfaceState := MCIS_Connected;
      
      //Handle Flags
      
        //Tell the Subscribed entities that they have been unsubscribed.
        if  SessionPresent.Read() = 0 then
          MQTT_SetCleanSession();
        end_if;
            
      //Create Log: Connected
      
      tmpPara := to_dint(retCode);
      tmpPara2 := to_dint(flags);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                        dMsgGroup   :=  MQCLIINF_LOG_INFO_CONNECTION_CONNECTED_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_INFO_CONNECTION_CONNECTED_MSG, 
                        pMsg        :=  MQCLIINF_LOG_INFO_CONNECTION_CONNECTED_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  #tmpPara2, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      Diagnostic_Event( Event   :=  DL_Connect, 
                        udValue :=  0);
      
    elsif retCode = MQTT_PROT_CONNACK_RET_PROTVERSION then
    
      //Create Log: Connection Failed, Protocol Versions Mismatch
      
      tmpPara := to_dint(retCode);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_VER_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_VER_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_VER_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      InterfaceState := MCIS_Error;
    
    elsif retCode = MQTT_PROT_CONNACK_RET_ID_REJECTED then
    
      //Create Log: Connection Failed, ClientID Rejected
      
      tmpPara := to_dint(retCode);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_CLIENTID_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_CLIENTID_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_CLIENTID_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      InterfaceState := MCIS_Error;
    
    elsif retCode = MQTT_PROT_CONNACK_RET_SERVER_UNAVAIL then
    
      //Create Log: Connection Failed, Server unavailable
      
      tmpPara := to_dint(retCode);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_SERV_UNAV_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_SERV_UNAV_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_SERV_UNAV_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      InterfaceState := MCIS_Error;
    
    elsif retCode = MQTT_PROT_CONNACK_RET_USN_PASS then
    
      //Create Log: Connection Failed, Username and/or Password incorrect
      
      tmpPara := to_dint(retCode);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_USNPWD_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_USNPWD_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_USNPWD_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      InterfaceState := MCIS_Error;
    
    elsif retCode = MQTT_PROT_CONNACK_RET_NOT_AUTHD then
    
      //Create Log: Connection Failed, Not authorised
      
      tmpPara := to_dint(retCode);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_NOT_AUTH_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_NOT_AUTH_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_CONN_FAIL_NOT_AUTH_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      InterfaceState := MCIS_Error;
    
    end_if;

  //Not expecting callback  
  else
  
    //Create Log: Unexpected Connect Callback Received
    
    tmpPara := to_dint(retCode);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_CONNECTION_CONN_CALLBACK_UNEXP_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_CONNECTION_CONN_CALLBACK_UNEXP_MSG, 
                      pMsg        :=  MQCLIINF_LOG_WARNING_CONNECTION_CONN_CALLBACK_UNEXP_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
  
  end_if;
  
  //=================================
  //Signed in Objects
  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnDisconnect
	VAR_INPUT
		retCode 	: INT;
	END_VAR
  VAR
  	udCount : UDINT;
    tmpPara : DINT;
    pEntry  : ^t_s_PubSubEntry;
  END_VAR

  
  //=================================
  //Internal Actions
  
  //=============================================
  //Handle Disconnect Message according to state
  //=============================================
  case InterfaceState of
    
    //------------------------------------------------------------------
    //Was Connected and then Disconnected, advance State
    //------------------------------------------------------------------
  	MQTTClient_Interface::t_e_MQTTClientStates::MCIS_Connected:
      
      //User Request, Go to ready
      if retCode = MQTTCLIENT_DISCONNECT_RETCODE_USER then
        
        InterfaceState := MCIS_Ready;
        //Create Log: MQTT Interface Successfully Disconnected due to user request
        
        tmpPara := to_dint(retcode);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                          dMsgGroup   :=  MQCLIINF_LOG_INFO_CONNECTION_DISCONNECTED_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_INFO_CONNECTION_DISCONNECTED_MSG, 
                          pMsg        :=  MQCLIINF_LOG_INFO_CONNECTION_DISCONNECTED_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        
      //Unexpected, wait for connection
      elsif retCode = MQTTCLIENT_DISCONNECT_RETCODE_UNEXP then
      
        InterfaceState := MCIS_Reconnecting;
        //Diagnostic Info:
        Diagnostic_Event( Event   :=  DL_ConnectRetry, 
                          udValue :=  0);
        
        //Create Log: MQTT Interface Disconnected Unexpectedly, Waiting for reconnection.
        
        tmpPara := to_dint(retcode);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_DISCONN_UNEXP_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_DISCONN_UNEXP_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_DISCONN_UNEXP_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
      
      //Undefined RetCode, Log, Error
      else
        
        //Create Log: MQTT Client Diconnected with undefined disconnect code.
        
        tmpPara := to_dint(retcode);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                          dMsgGroup   :=  MQCLIINF_LOG_ERROR_CONNECTION_DISCONN_UNKNOWN_CODE_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_ERROR_CONNECTION_DISCONN_UNKNOWN_CODE_MSG, 
                          pMsg        :=  MQCLIINF_LOG_ERROR_CONNECTION_DISCONN_UNKNOWN_CODE_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
                        
        InterfaceState := MCIS_Error;
      
      end_if;
    
    //------------------------------------------------------------------
    //Unexpected callback
    //------------------------------------------------------------------
    else
      
      //Create Log: Unexpected Disconnect Message Received from MQTT Client
      
      tmpPara := to_dint(retcode);
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                        dMsgGroup   :=  MQCLIINF_LOG_WARNING_CONNECTION_DISCONN_CALLBACK_UNEXP_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_WARNING_CONNECTION_DISCONN_CALLBACK_UNEXP_MSG, 
                        pMsg        :=  MQCLIINF_LOG_WARNING_CONNECTION_DISCONN_CALLBACK_UNEXP_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
                        
      InterfaceState := MCIS_Error;
      
  end_case;
  
  //Perform the disconnect callbacks for the items in the pubsub list
  if Config.pPubSubConfig &
     Config.pPubSubConfig^.PubSubList.udNumEntries > 0 then
     
    for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries -1 do
      
      pEntry := (Config.pPubSubConfig^.PubSubList.pEntries$UDINT + sizeof(t_s_PubSubEntry)*udCount)$^t_s_PubSubEntry;
      
      if pEntry^.Callback.pThis    & 
         pEntry^.Callback.pMethod  then
        
        pEntry^.Callback.pMethod$PubSub_Callback( pThis       :=  pEntry^.Callback.pThis, 
                                                  MsgType     :=  PSRC_Disconnected, 
                                                  iMid        :=  -1, 
                                                  iGrantedQoS :=  -1, 
                                                  pMessage    :=  NIL);
      
       //If this is the MQTTTopic Class
      elsif pEntry^.Callback.pThis          &
            pEntry^.Callback.pMethod = NIL  then
        
        pEntry^.Callback.pThis$^MQTTTopic^.PubSubData(MsgType     :=  PSRC_Disconnected, 
                                                      iMid        :=  -1, 
                                                      iGrantedQoS :=  -1, 
                                                      pMessage    :=  NIL);
      
      end_if;

      
    end_for;
  
  end_if;


  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnPublish
	VAR_INPUT
		mid 	: INT;
	END_VAR
  VAR
  	udCount : UDINT;
    pEntry : ^t_s_PubSubEntry;
    tmpPara : DINT;
  END_VAR
  
  //If there aren't any Subscribe elements in the Subscribe List | Mem not OK
  if Config.pPubSubConfig^.PubSubList.udNumEntries = 0 then
    //Create Log: Received Publish confirm from MQTTClient without having any elements in the subscription list, ignored.
    
    tmpPara := to_dint(mid);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_PUBLISH_UNEXPECTED_PUB_CONF_NOTINIT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_PUBLISH_UNEXPECTED_PUB_CONF_NOTINIT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_PUBLISH_UNEXPECTED_PUB_CONF_NOTINIT_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
  end_if;
  
  //Step over the entries to find the responsible one
  pEntry := Config.pPubSubConfig^.PubSubList.pEntries;
  
  for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
    
    if pEntry^.iMid = mid & 
       pEntry^.EntryType = PSE_Publish then
      
//      if pEntry^.EntryType <> PSE_Publish then
//        //Create Log: Received a Publish confirmation for a non publish item in the pubsub list, ignored.
//        
//        tmpPara := to_dint(mid);
//        
//        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
//                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_PUBLISH_UNEXP_PUB_CONF_NOT_FOUND_GRP, 
//                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_PUBLISH_UNEXP_PUB_CONF_NOT_FOUND_MSG, 
//                          pMsg        :=  MQCLIINF_LOG_WARNING_PUBLISH_UNEXP_PUB_CONF_NOT_FOUND_TEXT, 
//                          pPara1      :=  #tmpPara, 
//                          pPara2      :=  NIL, 
//                          pPara3      :=  NIL, 
//                          pPara4      :=  NIL);
//        
//        //Remove this entry from the PubSub list
//        if Config.pPubSubConfig^.PubSubList.udNumEntries - 1 > udCount then
//          
//          SigCLib.MemCpy( dst0  :=  pEntry, 
//                          src0  :=  (pEntry$UDINT + sizeof(t_s_PubSubEntry))$^void, 
//                          len0  :=  (sizeof(t_s_PubSubEntry) * (Config.pPubSubConfig^.PubSubList.udNumEntries - 1 - udCount)));
//          
//        end_if;
//        
//        Config.pPubSubConfig^.PubSubList.udNumEntries -= 1;
//        
//        return;
//      end_if;
      
      //If this is a user class
      if pEntry^.Callback.pThis   &
         pEntry^.Callback.pMethod then
        
        //Call the responsible party.
        pEntry^.Callback.pMethod$PubSub_Callback(pThis        :=  pEntry^.Callback.pThis, 
                                                 MsgType      :=  PSRC_Published,
                                                 iMid         :=  mid, 
                                                 iGrantedQoS  :=  0,
                                                 pMessage     :=  NIL);
      //If this is the MQTTTopic Class
      elsif pEntry^.Callback.pThis          &
            pEntry^.Callback.pMethod = NIL  then
        
        pEntry^.Callback.pThis$^MQTTTopic^.PubSubData(MsgType     :=  PSRC_Published, 
                                                      iMid        :=  mid, 
                                                      iGrantedQoS :=  0, 
                                                      pMessage    :=  NIL);
        
      else
        //Create Log: Received a publish confirmation but could not call back as the Callback parameters weren't OK.
        
        tmpPara := to_dint(mid);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_PUBLISH_PUB_CALLBACK_NOTSET_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_PUBLISH_PUB_CALLBACK_NOTSET_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_PUBLISH_PUB_CALLBACK_NOTSET_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        return;
      end_if;
      
      //Remove this entry from the PubSub list
      if Config.pPubSubConfig^.PubSubList.udNumEntries - 1 > udCount then
        
        SigCLib.MemCpy( dst0  :=  pEntry, 
                        src0  :=  (pEntry$UDINT + sizeof(t_s_PubSubEntry))$^void, 
                        len0  :=  (sizeof(t_s_PubSubEntry) * (Config.pPubSubConfig^.PubSubList.udNumEntries - 1 - udCount)));
        
      end_if;
      Config.pPubSubConfig^.PubSubList.udNumEntries -= 1;
      
      return;
      
    end_if;
    
    pEntry$UDINT += sizeof(t_s_PubSubEntry);
    
  end_for;
  
  //Create Log: Received publication confirm from MQTTClient and did not find the element in the pubsub list, ignored.
  
  tmpPara := to_dint(mid);
  
  Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                    dMsgGroup   :=  MQCLIINF_LOG_INFO_PUBLISH_PUBLISHED_GRP, 
                    dMsgNbr     :=  MQCLIINF_LOG_INFO_PUBLISH_PUBLISHED_MSG, 
                    pMsg        :=  MQCLIINF_LOG_INFO_PUBLISH_PUBLISHED_TEXT, 
                    pPara1      :=  #tmpPara, 
                    pPara2      :=  NIL, 
                    pPara3      :=  NIL, 
                    pPara4      :=  NIL);
  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnMessage
	VAR_INPUT
		pMessage 	: ^MQTTClient::t_s_MQTTMessage;
	END_VAR
  VAR
  	udCount : UDINT;
    pSubEntry : ^t_s_PubSubEntry;
    tmpPara : DINT;
  END_VAR

  //Find the Message in the PubSub List and call the responsible party.  
  if pMessage then
    
    //Set the Diagnostic Data
    Diagnostic_Event( Event   :=  DL_RXBytes, 
                      udValue :=  pMessage^.payloadlen);
    
    if Config.pPubSubConfig = NIL then
      //Create Log: Received a published message callback but the pubsublist is not initialised.
      
      if pMessage <> NIL then
        tmpPara := to_dint(pMessage^.mid);
      else
        tmpPara := 16#FFFF;
      end_if;
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR,
                        dMsgGroup   :=  MQCLIINF_LOG_ERROR_MESSAGE_UNEXPECTED_PUB_CONF_NOTINIT_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_ERROR_MESSAGE_UNEXPECTED_PUB_CONF_NOTINIT_MSG, 
                        pMsg        :=  MQCLIINF_LOG_ERROR_MESSAGE_UNEXPECTED_PUB_CONF_NOTINIT_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
      return;
    end_if;
    
    if Config.pPubSubConfig^.PubSubList.udNumEntries = 0 then
      //Create Log: Received a published message callback but the pubsublist is empty.
      
      if pMessage <> NIL then
        tmpPara := to_dint(pMessage^.mid);
      else
        tmpPara := 16#FFFF;
      end_if;
      
      Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                        dMsgGroup   :=  MQCLIINF_LOG_WARNING_MESSAGE_UNEXP_LIST_EMPTY_GRP, 
                        dMsgNbr     :=  MQCLIINF_LOG_WARNING_MESSAGE_UNEXP_LIST_EMPTY_MSG, 
                        pMsg        :=  MQCLIINF_LOG_WARNING_MESSAGE_UNEXP_LIST_EMPTY_TEXT, 
                        pPara1      :=  #tmpPara, 
                        pPara2      :=  NIL, 
                        pPara3      :=  NIL, 
                        pPara4      :=  NIL);
      return;
    end_if;
    
    pSubEntry := Config.pPubSubConfig^.PubSubList.pEntries;
    
    for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
      
      if PubSub_TopicCompare(pStr:=pMessage^.topic, pWCString:=#pSubEntry^.aTopic[0])   &
         (pSubEntry^.EntryType = PSE_Subscribe)                                         then
        
        //If the callback is set call the standard callback
        if pSubEntry^.Callback.pThis    &
           pSubEntry^.Callback.pMethod  then
          
          pSubEntry^.Callback.pMethod$PubSub_Callback(pThis       :=  pSubEntry^.Callback.pThis,
                                                      MsgType     :=  PSRC_PublishReceived, 
                                                      iMid        :=  pMessage^.mid, 
                                                      iGrantedQoS :=  0, 
                                                      pMessage    :=  pMessage);
                                                      
        //If this is the MQTTTopic Class, use the class type definition (Allows for Download on the fly)
        elsif pSubEntry^.Callback.pThis          &
              pSubEntry^.Callback.pMethod = NIL  then
          
          pSubEntry^.Callback.pThis$^MQTTTopic^.PubSubData( MsgType     :=  PSRC_PublishReceived, 
                                                            iMid        :=  pMessage^.mid, 
                                                            iGrantedQoS :=  0, 
                                                            pMessage    :=  pMessage);
        
        //No Callback is set, this message cannot be delivered
        else
        
          //Create Log: Received a Published Message Callback but could not call the responsible party as no callback was set
          
          if pMessage <> NIL then
            tmpPara := to_dint(pMessage^.mid);
          else
            tmpPara := 16#FFFF;
          end_if;
          
          Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                            dMsgGroup   :=  MQCLIINF_LOG_WARNING_MESSAGE_CALLBACK_NOTSET_GRP, 
                            dMsgNbr     :=  MQCLIINF_LOG_WARNING_MESSAGE_CALLBACK_NOTSET_MSG, 
                            pMsg        :=  MQCLIINF_LOG_WARNING_MESSAGE_CALLBACK_NOTSET_TEXT, 
                            pPara1      :=  #tmpPara, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
        
        end_if;
        
      end_if;
      
      pSubEntry$UDINT += sizeof(t_s_PubSubEntry);
      
    end_for;
    
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnSubscribe
	VAR_INPUT
		mid 	: INT;
		qos_count 	: INT;
		granted_qos 	: ^INT;
	END_VAR
  VAR
  	udCount : UDINT;
    pEntry : ^t_s_PubSubEntry;
    tmpPara : DINT;
  END_VAR
    
  //If there aren't any Subscribe elements in the Subscribe List | Mem not OK
  if  Config.pPubSubConfig = NIL                        |
      Config.pPubSubConfig^.PubSubList.udNumEntries = 0 then
    //Create Log: Received Subscription confirm from MQTTClient without having any elements in the subscription list, ignored.
    
    tmpPara := to_dint(mid);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_UNEXP_SUB_CONF_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_UNEXP_SUB_CONF_MSG, 
                      pMsg        :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_UNEXP_SUB_CONF_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  #Config.pPubSubConfig^.PubSubList.udNumEntries$DINT, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
  end_if;
  
  //Step over the entries to find the responsible one
  pEntry := Config.pPubSubConfig^.PubSubList.pEntries;
  
  for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
    
    if pEntry^.iMid = mid &
       pEntry^.EntryType = PSE_Subscribe then
      
//      if pEntry^.EntryType <> PSE_Subscribe then
//        //Create Log: Received a subscription confirmation for a non subscribe item in the subscription list, ignored.
//        
//        tmpPara := to_dint(mid);
//        
//        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
//                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_SUB_CONF_PUB_ENTRY_GRP, 
//                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_SUB_CONF_PUB_ENTRY_MSG, 
//                          pMsg        :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_SUB_CONF_PUB_ENTRY_TEXT, 
//                          pPara1      :=  #tmpPara, 
//                          pPara2      :=  NIL, 
//                          pPara3      :=  NIL, 
//                          pPara4      :=  NIL);
//        return;
//      end_if;
      
      if pEntry^.Callback.pThis &
         pEntry^.Callback.pMethod then
        
        //Call the responsible party.
        pEntry^.Callback.pMethod$PubSub_Callback(pThis        :=  pEntry^.Callback.pThis, 
                                                 MsgType      :=  PSRC_Subscribed,
                                                 iMid         :=  mid, 
                                                 iGrantedQoS  :=  granted_qos^,
                                                 pMessage     :=  NIL);
      
      //If this is the MQTTTopic Class
      elsif pEntry^.Callback.pThis          &
            pEntry^.Callback.pMethod = NIL  then
        
        pEntry^.Callback.pThis$^MQTTTopic^.PubSubData(MsgType     :=  PSRC_Subscribed, 
                                                      iMid        :=  mid, 
                                                      iGrantedQoS :=  granted_qos^, 
                                                      pMessage    :=  NIL);
      
      else
        //Create Log: Received a subscription confirmation but could not call back as the Callback parameters weren't OK.
        
        tmpPara := to_dint(mid);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_CALLBACK_NOTSET_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_CALLBACK_NOTSET_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_CALLBACK_NOTSET_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
        return;
      end_if;
      
      //Stop as we found the element we were interested in.
      return;
      
    end_if;
    
    pEntry$UDINT += sizeof(t_s_PubSubEntry);
    
  end_for;
  
  //Create Log: Received Subscription confirm from MQTTClient and did not find the element in the subscription list, ignored.
  
  tmpPara := to_dint(mid);
  
  Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                    dMsgGroup   :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_UNEXP_SUB_CONF_NOT_FOUND_GRP, 
                    dMsgNbr     :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_UNEXP_SUB_CONF_NOT_FOUND_MSG, 
                    pMsg        :=  MQCLIINF_LOG_WARNING_SUBSCRIBE_UNEXP_SUB_CONF_NOT_FOUND_TEXT, 
                    pPara1      :=  #tmpPara, 
                    pPara2      :=  NIL, 
                    pPara3      :=  NIL, 
                    pPara4      :=  NIL);
  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnUnsubscribe
	VAR_INPUT
		mid 	: INT;
	END_VAR
  VAR
  	udCount : UDINT;
    pEntry : ^t_s_PubSubEntry;
    tmpPara : DINT;
  END_VAR
  
  //If there aren't any Subscribe elements in the Subscribe List | Mem not OK
  if  Config.pPubSubConfig = NIL                        |
      Config.pPubSubConfig^.PubSubList.udNumEntries = 0 then
    //Create Log: Received UNSUBACK from MQTTClient without having any elements in the subscription list, ignored.
    
    tmpPara := to_dint(mid);
    
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                      dMsgGroup   :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_UNEXP_LIST_EMPTY_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_UNEXP_LIST_EMPTY_MSG, 
                      pMsg        :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_UNEXP_LIST_EMPTY_TEXT, 
                      pPara1      :=  #tmpPara, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
  end_if;
  
  //Step over the entries to find the responsible one
  pEntry := Config.pPubSubConfig^.PubSubList.pEntries;
  
  for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
    
    if pEntry^.iUnsubMid = mid &
       pEntry^.EntryType = PSE_Subscribe then
      
//      if pEntry^.EntryType <> PSE_Subscribe then
//        //Create Log: Received a subscription confirmation for a non subscribe item in the subscription list, ignored.
//        
//        tmpPara := to_dint(mid);
//        
//        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
//                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_WRONG_ENTRY_GRP, 
//                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_WRONG_ENTRY_MSG, 
//                          pMsg        :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_WRONG_ENTRY_TEXT, 
//                          pPara1      :=  #tmpPara, 
//                          pPara2      :=  NIL, 
//                          pPara3      :=  NIL, 
//                          pPara4      :=  NIL);
//        return;
//      end_if;
      
      if pEntry^.Callback.pThis &
         pEntry^.Callback.pMethod then
        
        //Call the responsible party.
        pEntry^.Callback.pMethod$PubSub_Callback(pThis        :=  pEntry^.Callback.pThis, 
                                                 MsgType      :=  PSRC_Unsubscribed,
                                                 iMid         :=  mid, 
                                                 iGrantedQoS  :=  -1,
                                                 pMessage     :=  NIL);
      
       //If this is the MQTTTopic Class
        elsif pEntry^.Callback.pThis          &
              pEntry^.Callback.pMethod = NIL  then
          
          pEntry^.Callback.pThis$^MQTTTopic^.PubSubData(MsgType     :=  PSRC_Unsubscribed, 
                                                        iMid        :=  mid, 
                                                        iGrantedQoS :=  -1, 
                                                        pMessage    :=  NIL);
      
      else
        //Create Log: Received an unsubscription confirmation but could not call back as the Callback parameters weren't OK.
        
        tmpPara := to_dint(mid);
        
        Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING,
                          dMsgGroup   :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_CALLBACK_NOTSET_GRP, 
                          dMsgNbr     :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_CALLBACK_NOTSET_MSG, 
                          pMsg        :=  MQCLIINF_LOG_WARNING_UNSUBSCRIBE_CALLBACK_NOTSET_TEXT, 
                          pPara1      :=  #tmpPara, 
                          pPara2      :=  NIL, 
                          pPara3      :=  NIL, 
                          pPara4      :=  NIL);
      end_if;
      
      //Remove this entry from the PubSub list
      if Config.pPubSubConfig^.PubSubList.udNumEntries - 1 > udCount then
        
        SigCLib.MemCpy( dst0  :=  pEntry, 
                          src0  :=  (pEntry$UDINT + sizeof(t_s_PubSubEntry))$^void, 
                          len0  :=  (sizeof(t_s_PubSubEntry) * (Config.pPubSubConfig^.PubSubList.udNumEntries - 1 - udCount)));
        
      end_if;
      
      Config.pPubSubConfig^.PubSubList.udNumEntries -= 1;
      
      return;
      
    end_if;
    
    pEntry$UDINT += sizeof(t_s_PubSubEntry);
    
  end_for;
  
  //Create Log: Received Subscription confirm from MQTTClient and did not find the element in the subscription list, ignored.
  
  tmpPara := to_dint(mid);
  
  Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO,
                    dMsgGroup   :=  MQCLIINF_LOG_INFO_UNSUBSCRIBE_UNSUBSCRIBED_GRP, 
                    dMsgNbr     :=  MQCLIINF_LOG_INFO_UNSUBSCRIBE_UNSUBSCRIBED_MSG, 
                    pMsg        :=  MQCLIINF_LOG_INFO_UNSUBSCRIBE_UNSUBSCRIBED_TEXT, 
                    pPara1      :=  #tmpPara, 
                    pPara2      :=  NIL, 
                    pPara3      :=  NIL, 
                    pPara4      :=  NIL);
  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnLog
	VAR_INPUT
		level 	: INT;
		pStr 	: ^CHAR;
	END_VAR
  VAR
  	dLogLevel : DINT;
  END_VAR
  
  //If the string pointer is not OK, Log and stop
  if pStr = NIL then
    
    dLogLevel := to_dint(level);
    
    //Log Failure
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_LOGGING_NO_TEXT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_LOGGING_NO_TEXT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_LOGGING_NO_TEXT_TEXT, 
                      pPara1      :=  #dLogLevel, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
    
  end_if;

  //Diagnostic info
  Diagnostic_Event( Event   :=  DL_Log, 
                    udValue :=  0);
  
  //====================================================
  //Decide the Application Log Level based on MQTT Level
  //====================================================
  case level of
    //-------------------
    //Info -> Info
    //-------------------
    MQTT_LOG_INFO:
      dLogLevel := MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO;
    //-------------------
    //Notice -> Info
    //-------------------
    MQTT_LOG_NOTICE:
      dLogLevel := MQTTCLIENTINTERFACE_LOGGING_LEVEL_INFO;
    //-------------------
    //Warning -> Warning
    //-------------------
    MQTT_LOG_WARNING:
      dLogLevel := MQTTCLIENTINTERFACE_LOGGING_LEVEL_WARNING;
    //-------------------
    //Error -> Error
    //-------------------
    MQTT_LOG_ERR:
      dLogLevel := MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR;
    //-------------------
    //Debug -> Debug
    //-------------------
    MQTT_LOG_DEBUG:
      dLogLevel := MQTTCLIENTINTERFACE_LOGGING_LEVEL_DEBUG;
  
  else
    
    dLogLevel := to_dint(level);
    
    //Log Failure
    Logging_InterfLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_LOGGING_UNKNOWN_LEVEL_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_LOGGING_UNKNOWN_LEVEL_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_LOGGING_UNKNOWN_LEVEL_TEXT, 
                      pPara1      :=  #dLogLevel, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
    
  end_case;

  //Log Message from MQTTClient
  Logging_InterfLog(usLevel     :=  to_usint(dLogLevel), 
                    dMsgGroup   :=  MQTTCLIENTINTERFACE_LOG_MQTTCLIENT_MSGGRP, 
                    dMsgNbr     :=  MQTTCLIENTINTERFACE_LOG_MQTTCLIENT_MSGNBR, 
                    pMsg        :=  pStr, 
                    pPara1      :=  NIL, 
                    pPara2      :=  NIL, 
                    pPara3      :=  NIL, 
                    pPara4      :=  NIL);
  
END_FUNCTION

FUNCTION MQTTClient_Interface::OnLog_WithDetail
	VAR_INPUT
		usLevel 	  : USINT;
		dMsgGroup 	: DINT;
		dMsgNbr 	  : DINT;
		pMsg 	      : ^CHAR;
		pPara1 	    : ^DINT;
		pPara2 	    : ^DINT;
		pPara3 	    : ^DINT;
		pPara4 	    : ^DINT;
	END_VAR
  VAR
  	dLogLevel : DINT;
  END_VAR
  
  //===================================
  //Set the Last Log Details
  //===================================
  case usLevel of
    
    //-----------------
    //Error
    //-----------------
    MQTT_LOG_ERR:
      
      DiagnosticData.LogEvents.Level_Error.dLastClientGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Error.dLastClientMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Error.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Error.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Info
    //-----------------
    MQTT_LOG_INFO:
      
      DiagnosticData.LogEvents.Level_Info.dLastClientGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Info.dLastClientMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Info.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Info.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Debug
    //-----------------
    MQTT_LOG_DEBUG:
      
      DiagnosticData.LogEvents.Level_Debug.dLastClientGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Debug.dLastClientMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Debug.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Debug.dLastGlobalMessage := dMsgNbr;
    
    //-----------------
    //Warning
    //-----------------
    MQTT_LOG_WARNING:
      
      DiagnosticData.LogEvents.Level_Warning.dLastClientGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Warning.dLastClientMessage := dMsgNbr;
      
      DiagnosticData.LogEvents.Level_Warning.dLastGlobalGroup   := dMsgGroup;
      DiagnosticData.LogEvents.Level_Warning.dLastGlobalMessage := dMsgNbr;
      
  end_case;
  
  //If the string pointer is not OK, Log and stop
  if pMsg = NIL then
    
    dLogLevel := to_dint(uslevel);
     
    //Log Failure
    Logging_InternLog(usLevel     :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                      dMsgGroup   :=  MQCLIINF_LOG_ERROR_LOGGING_NO_TEXT_GRP, 
                      dMsgNbr     :=  MQCLIINF_LOG_ERROR_LOGGING_NO_TEXT_MSG, 
                      pMsg        :=  MQCLIINF_LOG_ERROR_LOGGING_NO_TEXT_TEXT, 
                      pPara1      :=  #dLogLevel, 
                      pPara2      :=  NIL, 
                      pPara3      :=  NIL, 
                      pPara4      :=  NIL);
    return;
    
  end_if;

  //Diagnostic info
  Diagnostic_Event( Event   :=  DL_Log, 
                    udValue :=  0);
  
  //Log Message from MQTTClient
  Logging_InternLog(usLevel     :=  usLevel, 
                    dMsgGroup   :=  dMsgGroup, 
                    dMsgNbr     :=  dMsgNbr, 
                    pMsg        :=  pMsg, 
                    pPara1      :=  pPara1, 
                    pPara2      :=  pPara2, 
                    pPara3      :=  pPara3, 
                    pPara4      :=  pPara4, 1);
  
END_FUNCTION

//================================================================================================================================================================
//-------------------------------------------------------------------END OF CALLBACK METHODS----------------------------------------------------------------------
//================================================================================================================================================================

//================================================================================================================================================================
//-------------------------------------------------------------------------COUNTER METHODS------------------------------------------------------------------------
//================================================================================================================================================================
FUNCTION MQTTClient_Interface::Counters_IncSubMID
	VAR_OUTPUT
		iMid 	: INT;
	END_VAR
  
  Config.iNextSubMID += 1;
  
  if Config.iNextSubMID >= MQTTCLIENTINTERFACE_SUB_MID_ROLLOVER then
    Config.iNextSubMID := MQTTCLIENTINTERFACE_SUB_MID_INITVAL;
  end_if;
  
  iMid := Config.iNextSubMID;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Counters_GetSubMID
	VAR_OUTPUT
		iMID 	: INT;
	END_VAR
  
  iMID := Config.iNextSubMID;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Counters_IncPubMID
	VAR_OUTPUT
		iMid 	: INT;
	END_VAR
  
  Config.iNextPubMID += 1;
  
  if Config.iNextPubMID >= MQTTCLIENTINTERFACE_PUB_MID_ROLLOVER then
    Config.iNextPubMID := MQTTCLIENTINTERFACE_PUB_MID_INITVAL;
  end_if;
  
  iMid := Config.iNextPubMID;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Counters_GetPubMID
	VAR_OUTPUT
		iMID 	: INT;
	END_VAR
  
  iMID := Config.iNextPubMID;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Counters_IncApplID
	VAR_OUTPUT
		udApplID 	: UDINT;
	END_VAR
  
  udApplID := 0;
  
  if Config.pPubSubConfig = NIL then
    return;
  end_if;
  
  Config.pPubSubConfig^.udNextAppliID += 1;
  
  if Config.pPubSubConfig^.udNextAppliID > MQTTCLIENTINTERFACE_APPLID_ROLLOVER then
    Config.pPubSubConfig^.udNextAppliID := MQTTCLIENTINTERFACE_APPLID_INITVAL;
  end_if;
  
  udApplID := Config.pPubSubConfig^.udNextAppliID;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Counters_GetApplID
	VAR_OUTPUT
		udApplID 	: UDINT;
	END_VAR
  
  udApplID := 0;
  
  if Config.pPubSubConfig then
    udApplID := Config.pPubSubConfig^.udNextAppliID;
  end_if;

END_FUNCTION

//================================================================================================================================================================
//---------------------------------------------------------------------END OF COUNTER METHODS---------------------------------------------------------------------
//================================================================================================================================================================

FUNCTION GLOBAL MQTTClient_Interface::MQTT_ReadLogConfig
	VAR_OUTPUT
		bUpdated 	: BOOL;
	END_VAR
  
  bUpdated := FALSE;
  
  if Config.IsConn.LogConfig then
    cLogConfig := cLogConfig.Read();
    bUpdated := TRUE;
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::CleanSession::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	CleanSession := MQTTClient.CleanSession.Read();
	output := CleanSession;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::CleanSession::Write
	VAR_INPUT
		input (EAX) 	: DINT;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: DINT;
	END_VAR

	CleanSession := input;
	result := (MQTTClient.CleanSession.Write(CleanSession))$DINT;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::SessionPresent::Read
	VAR_OUTPUT
		output (EAX) 	: DINT;
	END_VAR

	SessionPresent := MQTTClient.SessionPresent.Read();
	output := SessionPresent;

END_FUNCTION

FUNCTION MQTTClient_Interface::PubSub_TopicCompare
	VAR_INPUT
		pStr 	: ^UINT;
		pWCString 	: ^UINT;
	END_VAR
	VAR_OUTPUT
		bEqual 	: BOOL;
	END_VAR
  VAR
  	pTopic, pWCTopic : ^UINT;
  END_VAR

  //Assume that the strings are not equal
  bEqual := FALSE;
  
  //If the input is OK, continue the comparison
  if pStr      &
     pWCString then
    
    pTopic    := pStr;
    pWCTopic  := pWCString;
    
    //Special case: The Wildcard string starts with the Multi-Layer Wildcard -> Immediately matches.
    if pWCTopic^ = MQTTCLIENTINTERFACE_TOPIC_WC_MULTI then
      bEqual := TRUE;
      return;
    end_if;
    
    while (pWCTopic^ = pTopic^)                             |
          (pWCTopic^ = MQTTCLIENTINTERFACE_TOPIC_WC_MULTI)  |
          (pWCTopic^ = MQTTCLIENTINTERFACE_TOPIC_WC_SINGLE) do
      
      //Found a Multi-layer Wildcard - The topics are equal (We don't confirm that nothing follows the #).
      if pWCTopic^ = MQTTCLIENTINTERFACE_TOPIC_WC_MULTI then
        
        bEqual := TRUE;
        return;
      
      //Found a single layer wildcard - Skip this Topic Layer
      elsif pWCTopic^ = MQTTCLIENTINTERFACE_TOPIC_WC_SINGLE then
        
        while pTopic^ <> MQTTCLIENTINTERFACE_TOPIC_SEPARATOR  &
              pTopic^ <> 0$UINT                               do
          pTopic$UDINT += sizeof(UINT);
        end_while;
        
        pWCTopic$UDINT += sizeof(UINT);
        
        //Special Case: WC-String ended on a + -> (text/+ = text/topic)
        if pWCTopic^ = 0$UINT then
          
          if pTopic^ = MQTTCLIENTINTERFACE_TOPIC_SEPARATOR then
            pTopic$UDINT += sizeof(UINT);
          end_if;
          
          if pTopic^ = pWCTopic^ then
            bEqual := TRUE;
          end_if;
          
          return;
          
        end_if;

      //If we have reached the end of the string, stop
      elsif pWCTopic^ = 0$UINT then
        
        bEqual := TRUE;
        return;

      end_if;

      //Advance the String pointers
      pTopic$UDINT    += sizeof(UINT);
      pWCTopic$UDINT  += sizeof(UINT);

      //If either String ends but the other continues, the topics aren't equal
      if (pTopic^ = 0$UINT &
          pWCTopic^ <> 0$UINT)  | 
         (pWCTopic^ = 0$UINT &
          pTopic^ <> 0$UINT)    then
        return;
      end_if;

      //Jump over Separators
      if pTopic^ = MQTTCLIENTINTERFACE_TOPIC_SEPARATOR then
        pTopic$UDINT    += sizeof(UINT);
      end_if;

      if pWCTopic^ = MQTTCLIENTINTERFACE_TOPIC_SEPARATOR then
        pWCTopic$UDINT    += sizeof(UINT);
      end_if;
      
      
    end_while;
        
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::PubSub_Reset
  VAR
  	udCount : UDINT;
    pEntry : ^t_s_PubSubEntry;
  END_VAR

  //Step through the Subscribed entites and send the Unsubscribed callback
  if Config.pPubSubConfig &
     Config.pPubSubConfig^.PubSubList.udNumEntries > 0 then
    
    for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
      
      pEntry := (Config.pPubSubConfig^.PubSubList.pEntries$UDINT + sizeof(t_s_PubSubEntry)*udCount)$^t_s_PubSubEntry;
      
      if pEntry^.EntryType = PSE_Subscribe then
        
        //If the callback method is set call the method
        if pEntry^.Callback.pThis    & 
           pEntry^.Callback.pMethod  then
          
          pEntry^.Callback.pMethod$PubSub_Callback( pThis       :=  pEntry^.Callback.pThis, 
                                                    MsgType     :=  PSRC_Unsubscribed, 
                                                    iMid        :=  -1, 
                                                    iGrantedQoS :=  -1, 
                                                    pMessage    :=  NIL);
        //If this is the MQTTTopic Class
        elsif pEntry^.Callback.pThis          &
              pEntry^.Callback.pMethod = NIL  then
          
          pEntry^.Callback.pThis$^MQTTTopic^.PubSubData(MsgType     :=  PSRC_Unsubscribed, 
                                                        iMid        :=  -1, 
                                                        iGrantedQoS :=  -1, 
                                                        pMessage    :=  NIL);
        
        end_if;
        
      end_if;
    end_for;
    
    Config.pPubSubConfig^.PubSubList.udNumEntries := 0;
    sigclib_memset( dst :=  Config.pPubSubConfig^.PubSubList.pEntries, 
                    c   :=  0x00, 
                    len :=  Config.pPubSubConfig^.PubSubList.udMaxEntries * sizeof(t_s_PubSubEntry));
  
  end_if;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::PubSub_CheckSubscription
	VAR_INPUT
		pTopic 	: ^UINT;
		pThis 	: ^void;
		pCallback 	: ^void;
	END_VAR
	VAR_OUTPUT
		udAppliID 	: UDINT;
	END_VAR
  VAR
  	udCount : UDINT;
    pEntry : ^t_s_PubSubEntry;
  END_VAR

  udAppliID := 0;
  
  if Config.pPubSubConfig &
     Config.pPubSubConfig^.PubSubList.udNumEntries > 0 then
  
    for udCount := 0 to Config.pPubSubConfig^.PubSubList.udNumEntries - 1 do
    
      pEntry := (Config.pPubSubConfig^.PubSubList.pEntries$UDINT + udCount*sizeof(t_s_PubSubEntry))$^t_s_PubSubEntry;
      
      if pEntry^.Callback.pMethod = pCallback           &
         pEntry^.Callback.pThis   = pThis               &
         sigclib_strcmp16(src1  :=  #pEntry^.aTopic[0], 
                          src2  :=  pTopic) = 0         then
        
        udAppliID := pEntry^.udAppliID;
        return;
        
      end_if;

    
    end_for;
  
  end_if;
   
  return;
  
END_FUNCTION

FUNCTION MQTTClient_Interface::Diagnostic_Calculate
  VAR
    udCount : UDINT;
  END_VAR
  
  //If the Calculation Interval has passed, update the diagnostic information
  if ops.tAbsolute - DiagnosticData.udLastCalcTimestamp >= MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALCINTERVAL then
    
    //=======================================================
    //Transfer Rate Calc
    //=======================================================
    
      //Input current Transfer Rates
      DiagnosticData.TransferRateCalc.aTxEntries[DiagnosticData.TransferRateCalc.udIndex] := DiagnosticData.ComDiagnosis.udTotalBytesTx - DiagnosticData.TransferRateCalc.udLastTotalBytesTx;
      DiagnosticData.TransferRateCalc.aRxEntries[DiagnosticData.TransferRateCalc.udIndex] := DiagnosticData.ComDiagnosis.udTotalBytesRx - DiagnosticData.TransferRateCalc.udLastTotalBytesRx;
      
      DiagnosticData.TransferRateCalc.udLastTotalBytesTx := DiagnosticData.ComDiagnosis.udTotalBytesTx;
      DiagnosticData.TransferRateCalc.udLastTotalBytesRx := DiagnosticData.ComDiagnosis.udTotalBytesRx;
      
      //Adjust index
      DiagnosticData.TransferRateCalc.udIndex   += 1;
      if DiagnosticData.TransferRateCalc.udIndex = MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG then
        DiagnosticData.TransferRateCalc.udIndex := 0;
      end_if;
      
      //Calculate current average
      DiagnosticData.ComDiagnosis.udTxRate := DiagnosticData.ComDiagnosis.udRxRate := 0;
      
      for udCount := 0 to MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG - 1 do
        DiagnosticData.ComDiagnosis.udTxRate += DiagnosticData.TransferRateCalc.aTxEntries[udCount];
        DiagnosticData.ComDiagnosis.udRxRate += DiagnosticData.TransferRateCalc.aRxEntries[udCount];
      end_for;
      
      //Set the rate values
      Diagnostic_Event( Event   :=  DL_TXRate, 
                        udValue :=  to_udint(to_real(DiagnosticData.ComDiagnosis.udTxRate)/to_real(MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG)));
      Diagnostic_Event( Event   :=  DL_RXRate, 
                        udValue :=  to_udint(to_real(DiagnosticData.ComDiagnosis.udRxRate)/to_real(MQTTCLIENTINTERFACE_DIAGNOSTIC_TX_RATE_CALC_AVG)));
    
    //=======================================================
    //PubSub List Counts
    //=======================================================
      
      //PubsUbList Entries
      if Config.pPubSubConfig then
        Diagnostic_Event( Event   :=  DL_PubSubEntries, 
                          udValue :=  Config.pPubSubConfig^.PubSubList.udNumEntries);    
      else
        Diagnostic_Event( Event   :=  DL_PubSubEntries, 
                          udValue :=  0);    
      end_if;
    
    //=======================================================
    //DataMap List Counts
    //=======================================================
      
      //DataMap Entries
      if Config.pDataMapConfig then
        
        Diagnostic_Event( Event   :=  DL_DataMapEntries, 
                          udValue :=  Config.pDataMapConfig^.udPublishElements + Config.pDataMapConfig^.udSubscribeElements);
        
      else
        
        Diagnostic_Event( Event   :=  DL_DataMapEntries, 
                          udValue :=  0);
        
      end_if;

  
    DiagnosticData.udLastCalcTimestamp := ops.tAbsolute;
    
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MQTTClient_Interface::ComDiagnosis::NewInst
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^Results;
	END_VAR
	VAR_OUTPUT
		ret_code 	: IprStates;
	END_VAR
  
  if  pPara = NIL |
      pResult = NIL then
    ret_code := ERROR;
    return;
  end_if;
  
	CASE pPara^.uiCmd OF
		MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_COMDIAG_ID : Diagnostic_GetData( pPara   :=  pPara, 
                                                                            pResult :=  pResult);
	END_CASE;

	ret_code := READY;

END_FUNCTION

FUNCTION MQTTClient_Interface::Diagnostic_GetData
	VAR_INPUT
		pPara 	: ^CmdStruct;
		pResult 	: ^results;
	END_VAR
  
  //==============================================================
  //Based on the diagnostic command, perform the required task
  //==============================================================
  case pPara^.aPara[1] of
    //-------------------------------------------------------------
    //Reset All Values
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_COMDIAG_RESET:
      
      Diagnostic_Event( Event   :=  DL_Reset, 
                        udValue :=  0);
    
    //-------------------------------------------------------------
    //Number of Connection Attempts
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_CONNECTCOUNT:
    
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udConnect;
    
    //-------------------------------------------------------------
    //Number of Failed Connections
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_CONNECTFAILCNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udConnectFail;
    
    //-------------------------------------------------------------
    //Number of Connection Retries
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_RETRYCOUNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udConnectRetry;
    
    //-------------------------------------------------------------
    //Number of Connection Watchdog Timeouts
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_WATCHDOGCOUNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udWDTimeout;
    
    //-------------------------------------------------------------
    //Not Used
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_ACTERRORCODE:
      
      pResult^.aData[0]$UDINT := 0;    
    
    //-------------------------------------------------------------
    //Last Non Successful Return Value from MQTTClient
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_LASTERRORCODE:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udLastRet;
    
    //-------------------------------------------------------------
    //Number of non successful returns from MQTTClient
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_ERRORCNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udFailRet;
    
    //-------------------------------------------------------------
    //Number of Subscribe Requests
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_READCNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udSubReqs;
    
    //-------------------------------------------------------------
    //Number of Subscribe Failures
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_READERRORCNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udSubFail;
    
    //-------------------------------------------------------------
    //Number of Publish Requests
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_WRITECNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPubReq;
    
    //-------------------------------------------------------------
    //Number of Publish Failures
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_WRITEERRORCNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPubFail;
    
    //-------------------------------------------------------------
    //Number of Unsubscribe Requests
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_UNSUBSCRIBES:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udUnsubReq;
    
    //-------------------------------------------------------------
    //Number of Unsubscribe Failures
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_UNSUBFAILS:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udUnsubFail;
    
    //-------------------------------------------------------------
    //Number of PubSub List Entries
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_PUBSUBENTRIES:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPubSubEntries;
    
    //-------------------------------------------------------------
    //Number of Logs Made
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_LOGCOUNT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udLogs;
    
    //-------------------------------------------------------------
    //Number of PINGREQ Sent
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_PINGREQSENT:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPingReq;
    
    //-------------------------------------------------------------
    //Number of PINGRESP Received
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_PINGRESPREC:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPingResp;
    
    //-------------------------------------------------------------
    //Number of QOS0 Publish Messages
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS0_PUB:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPubQOS0;
    
    //-------------------------------------------------------------
    //Number of QOS1 Publish Messages
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS1_PUB:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPubQOS1;
    
    //-------------------------------------------------------------
    //Number of QOS2 Publish Messages
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS2_PUB:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udPubQOS2;
    
    //-------------------------------------------------------------
    //Number of QOS0 Subscribe Messages
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS0_SUB:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udSubQOS0;
    
    //-------------------------------------------------------------
    //Number of QOS1 Subscribe Messages
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS1_SUB:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udSubQOS1;
    
    //-------------------------------------------------------------
    //Number of QOS2 Subscribe Messages
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_QOS2_SUB:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udSubQOS2;
    
    //-------------------------------------------------------------
    //Number of Datamap Entries
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_DM_ELEMENTS:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udDMEntries;
    
    //-------------------------------------------------------------
    //TX Rate
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_TX_RATE:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udTxRate;
    
    //-------------------------------------------------------------
    //RX Rate
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_RX_RATE:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udRxRate;
    
    //-------------------------------------------------------------
    //Total RX Bytes
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_RX_BYTES:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udTotalBytesRx;
    
    //-------------------------------------------------------------
    //Total TX Bytes
    //-------------------------------------------------------------
    MQTTCLIENTINTERFACE_DIAGNOSTIC_NEWINST_GET_TX_BYTES:
      
      pResult^.aData[0]$UDINT := DiagnosticData.ComDiagnosis.udTotalBytesTx;
      
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::Diagnostic_Event
	VAR_INPUT
		Event 	: t_e_DiagnosticLogTypes;
		udValue 	: UDINT;
	END_VAR

  //==============================================================
  //Based on the event that occurred, change the diagnostic data
  //==============================================================
  case Event of
    //----------------------------------------------------------
    //Reset the Diagnostic Values
    //----------------------------------------------------------
    DL_Reset:
    
      //Reset the timestamp
      DiagnosticData.udLastCalcTimestamp := ops.tAbsolute;
    
      //Clear Values
      SigCLib.MemSet( dst :=  #DiagnosticData.ComDiagnosis, 
                      c   :=  0x00, 
                      len :=  sizeof(DiagnosticData.ComDiagnosis));
                      
      SigCLib.MemSet( dst :=  #DiagnosticData.TransferRateCalc, 
                      c   :=  0x00, 
                      len :=  sizeof(DiagnosticData.TransferRateCalc));
    
    //----------------------------------------------------------
    //Increment Connection Count
    //----------------------------------------------------------
    DL_Connect:
    
      DiagnosticData.ComDiagnosis.udConnect += 1;
    
    //----------------------------------------------------------
    //Connection Failed
    //----------------------------------------------------------
    DL_ConnectFail:
    
      DiagnosticData.ComDiagnosis.udConnectFail += 1;
    
    //----------------------------------------------------------
    //Connection Retried
    //----------------------------------------------------------
    DL_ConnectRetry:
    
      DiagnosticData.ComDiagnosis.udConnectRetry += 1;
    
    //----------------------------------------------------------
    //Connection Watchdog Timed out
    //----------------------------------------------------------
    DL_WatchdogTimeout:
    
      DiagnosticData.ComDiagnosis.udWDTimeout += 1;
    
    //----------------------------------------------------------
    //NotUsed
    //----------------------------------------------------------
    DL_NotUsed:
    
      
    
    //----------------------------------------------------------
    //Last Error Code Returned from MQTTClient
    //----------------------------------------------------------
    DL_LastErrorCode:
    
      DiagnosticData.ComDiagnosis.udLastRet := udValue;
    
    //----------------------------------------------------------
    //Number of errors returned from MQTTClient
    //----------------------------------------------------------
    DL_Error:
    
      DiagnosticData.ComDiagnosis.udFailRet += 1;
    
    //----------------------------------------------------------
    //Number of subscribe requests
    //----------------------------------------------------------
    DL_SubRequest:
    
      DiagnosticData.ComDiagnosis.udSubReqs += 1;
    
    //----------------------------------------------------------
    //Number of failed subscribe requests
    //----------------------------------------------------------
    DL_SubFail:
    
      DiagnosticData.ComDiagnosis.udSubFail += 1;
    
    //----------------------------------------------------------
    //Number of Publish Requests
    //----------------------------------------------------------
    DL_PubRequest:
    
      DiagnosticData.ComDiagnosis.udPubReq += 1;
    
    //----------------------------------------------------------
    //Number of failed Publishes
    //----------------------------------------------------------
    DL_PubFail:
    
      DiagnosticData.ComDiagnosis.udPubFail += 1;
    
    //----------------------------------------------------------
    //Number of Unsubscribe requests
    //----------------------------------------------------------
    DL_UnsubRequest:
    
      DiagnosticData.ComDiagnosis.udUnsubReq += 1;
    
    //----------------------------------------------------------
    //Unsubscribe Failed
    //----------------------------------------------------------
    DL_UnsubFail:
    
      DiagnosticData.ComDiagnosis.udUnsubFail += 1;
    
    //----------------------------------------------------------
    //Set PubSubEntries
    //----------------------------------------------------------
    DL_PubSubEntries:
    
      DiagnosticData.ComDiagnosis.udPubSubEntries := udValue;
    
    //----------------------------------------------------------
    //Add Log
    //----------------------------------------------------------
    DL_Log:
    
      DiagnosticData.ComDiagnosis.udLogs += 1;
    
    //----------------------------------------------------------
    //Ping Request Sent
    //----------------------------------------------------------
    DL_PingReq:
    
      DiagnosticData.ComDiagnosis.udPingReq += 1;
    
    //----------------------------------------------------------
    //Ping Response Received
    //----------------------------------------------------------
    DL_PingResp:
    
      DiagnosticData.ComDiagnosis.udPingResp += 1;
    
    //----------------------------------------------------------
    //QOS 0 Publish made
    //----------------------------------------------------------
    DL_Pub0:
    
      DiagnosticData.ComDiagnosis.udPubQOS0 += 1;
    
    //----------------------------------------------------------
    //QOS1 Publish Made
    //----------------------------------------------------------
    DL_Pub1:
    
      DiagnosticData.ComDiagnosis.udPubQOS1 += 1;
    
    //----------------------------------------------------------
    //QOS2 Publish Made
    //----------------------------------------------------------
    DL_Pub2:
    
      DiagnosticData.ComDiagnosis.udPubQOS2 += 1;
    
    //----------------------------------------------------------
    //QOS0 Subscribe Made
    //----------------------------------------------------------
    DL_Sub0:
    
      DiagnosticData.ComDiagnosis.udSubQOS0 += 1;
    
    //----------------------------------------------------------
    //QOS1 Subscribe Made
    //----------------------------------------------------------
    DL_Sub1:
    
      DiagnosticData.ComDiagnosis.udSubQOS1 += 1;
    
    //----------------------------------------------------------
    //QOS2 Subscribe Made
    //----------------------------------------------------------
    DL_Sub2:
    
      DiagnosticData.ComDiagnosis.udSubQOS2 += 1;
    
    //----------------------------------------------------------
    //Set DataMap Entries
    //----------------------------------------------------------
    DL_DataMapEntries:
    
      DiagnosticData.ComDiagnosis.udDMEntries := udValue;
    
    //----------------------------------------------------------
    //Set TX Rate
    //----------------------------------------------------------
    DL_TXRate:
    
      DiagnosticData.ComDiagnosis.udTxRate := udValue;
    
    //----------------------------------------------------------
    //Set RX Rate
    //----------------------------------------------------------
    DL_RXRate:
    
      DiagnosticData.ComDiagnosis.udRxRate := udValue;
    
    //----------------------------------------------------------
    //Set RX Bytes
    //----------------------------------------------------------
    DL_RXBytes:
    
      DiagnosticData.ComDiagnosis.udTotalBytesRx += udValue;
    
    //----------------------------------------------------------
    //Set TX Bytes
    //----------------------------------------------------------
    DL_TXBytes:   
    
      DiagnosticData.ComDiagnosis.udTotalBytesTx += udValue;
    
  end_case;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::ConfigObject_Process
	VAR_OUTPUT
		eRet 	: t_e_TaskRet;
	END_VAR
  VAR
  	ClientIDConfig          : MQTTClient_Interface_ConfigBase::t_s_ClientID;
    ConnectionDetailsConfig : MQTTClient_Interface_ConfigBase::t_s_ConnectionParameters;
    MIMConfig               : MQTTClient_Interface_ConfigBase::t_s_MaxInflightMessages;
    AuthenticationConfig    : MQTTClient_Interface_ConfigBase::t_s_Authentication;
    WillConfig              : MQTTClient_Interface_ConfigBase::t_s_Will;
    ReconnectionConfig      : MQTTClient_Interface_ConfigBase::t_s_ReconnectionParameters;
    TLSConfig               : MQTTClient_Interface_ConfigBase::t_s_TLS;
    tmpPara1                : DINT;
  END_VAR

  //Assume Busy
  eRet := TR_Busy;
  
  //======================================
  //Proccess the Config Object
  //======================================
  case Config.ConfigObject.State of
    //----------------------------
    //Client ID
    //----------------------------
    CO_ClientID:
      
      //Call the Config Method
      ClientIDConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.ClientID();
      
      //Check if the config has been made, set the values
      if ClientIDConfig.ClientID <> ACCESS_DENIED then
        
        //If the input is OK, set the parameters
        if ClientIDConfig.ClientID                                                             &
           SigCLib.StrLen16(str0:=ClientIDConfig.ClientID) < MQTT_PROT_MAX_CLIENTID_NAME_LEN   then
          
          SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.aClientID[0], 
                          c     :=  0x00, 
                          len   :=  sizeof(MQTTClientConfigData.Config.aClientID));
          SigCLib.StrCpy16(dst0 :=  #MQTTClientConfigData.Config.aClientID[0],
                           src0 :=  ClientIDConfig.ClientID);
          
          MQTTClientConfigData.Config.bClientIDSet := TRUE;
        
        //Input Not OK, Log
        else
                    
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_CLIENTID_STRING_LEN_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_CLIENTID_STRING_LEN_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_CLIENTID_STRING_LEN_TEXT, 
                            pPara1    :=  NIL, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
      end_if;
      
      Config.ConfigObject.State := CO_ConnectionDetails;
      
    //----------------------------
    //Connection Details
    //----------------------------
    CO_ConnectionDetails:
      
      //Call the Config Method
      ConnectionDetailsConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.ConnectionParameters();
      
      //Check if the config has been made
      if ConnectionDetailsConfig.hostname <> ACCESS_DENIED then
        
        //If the input is OK, set the parameters
        if ConnectionDetailsConfig.hostname                                                        &
           SigCLib.StrLen16(str0:=ConnectionDetailsConfig.hostname) < MQTTCLIENT_HOSTNAME_MAX_LEN  then
          
          SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.Connect.aHostname[0], 
                          c     :=  0x00, 
                          len   :=  sizeof(MQTTClientConfigData.Config.Connect.aHostname));
          SigCLib.StrCpy16( dst0  :=  #MQTTClientConfigData.Config.Connect.aHostname[0], 
                            src0  :=  ConnectionDetailsConfig.hostname);
          
          MQTTClientConfigData.Config.Connect.ValuesSet.Hostname := TRUE;
        
        //Input Not OK, Log
        else
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_HOSTNAME_STR_LEN_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_HOSTNAME_STR_LEN_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_HOSTNAME_STR_LEN_TEXT, 
                            pPara1    :=  NIL, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //If the input is OK, set the parameters
        if ConnectionDetailsConfig.port > 0       &
           ConnectionDetailsConfig.port <= 65536  then
          
          MQTTClientConfigData.Config.Connect.iPort := ConnectionDetailsConfig.port;
          MQTTClientConfigData.Config.Connect.ValuesSet.Port := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := to_dint(ConnectionDetailsConfig.port);
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_PORT_INVALID_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_PORT_INVALID_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_PORT_INVALID_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //If the input is OK, set the parameters
        if ConnectionDetailsConfig.keepalive > 0       &
           ConnectionDetailsConfig.keepalive <= 65536  then
          
          MQTTClientConfigData.Config.Connect.iKeepalive := ConnectionDetailsConfig.keepalive;
          MQTTClientConfigData.Config.Connect.ValuesSet.Keepalive := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := to_dint(ConnectionDetailsConfig.keepalive);
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_KEEPALIVE_INVALID_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_KEEPALIVE_INVALID_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_KEEPALIVE_INVALID_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
      end_if;
      
      Config.ConfigObject.State := CO_MaxInflightMessages;
    
    //----------------------------
    //Max Inflight Messages
    //----------------------------
    CO_MaxInflightMessages:
    
      //Call the Config Method
      MIMConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.MaxInflightMessages();
      
      //Check if the config has been made
      if MIMConfig.max_inflight_messages <> -1 then
        
        //If the input is OK, set the parameters
        if MIMConfig.max_inflight_messages >= MQTTCLIENT_MIN_INFLIGHT_MSGS then
          
          MQTTClientConfigData.Config.Connect.iMaxInflightMessages  := MIMConfig.max_inflight_messages;
          MQTTClientConfigData.Config.Connect.ValuesSet.MaxInflight := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := MQTTCLIENT_MIN_INFLIGHT_MSGS;
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_MAX_INF_MSGS_LOW_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_MAX_INF_MSGS_LOW_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_MAX_INF_MSGS_LOW_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
      end_if;
      
      Config.ConfigObject.State := CO_Authentication;
      
    //----------------------------
    //Authentication
    //----------------------------
    CO_Authentication:
      
      //Call the Config Method
      AuthenticationConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.AuthenticationParameters();
      
      //Check if the config has been made
      if AuthenticationConfig.username <> ACCESS_DENIED then
        
        //If the input is OK, set the parameters
        if AuthenticationConfig.username                                                                         &
           SigCLib.StrLen16(str0:=AuthenticationConfig.username) < MQTTCLIENTINTERFACE_CONNECT_USERNAME_MAX_LEN  then
          
          SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.Connect.aUsername[0], 
                          c     :=  0x00, 
                          len   :=  sizeof(MQTTClientConfigData.Config.Connect.aUsername));
          SigCLib.StrCpy16( dst0  :=  #MQTTClientConfigData.Config.Connect.aUsername[0], 
                            src0  :=  AuthenticationConfig.username);
          
          MQTTClientConfigData.Config.Connect.ValuesSet.Username := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := MQTTCLIENTINTERFACE_CONNECT_USERNAME_MAX_LEN;
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_AUTH_USN_STR_LEN_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_AUTH_USN_STR_LEN_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_AUTH_USN_STR_LEN_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
                            
          MQTTClientConfigData.Config.Connect.ValuesSet.Username := FALSE;
          
        end_if;
        
        //If the input is OK, set the parameters
        if AuthenticationConfig.password                                                                         &
           SigCLib.StrLen16(str0:=AuthenticationConfig.password) < MQTTCLIENTINTERFACE_CONNECT_PASSWORD_MAX_LEN  then
          
          SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.Connect.aPassword[0], 
                          c     :=  0x00, 
                          len   :=  sizeof(MQTTClientConfigData.Config.Connect.aPassword));
          SigCLib.StrCpy16( dst0  :=  #MQTTClientConfigData.Config.Connect.aPassword[0], 
                            src0  :=  AuthenticationConfig.password);
          
          MQTTClientConfigData.Config.Connect.ValuesSet.Password := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := MQTTCLIENTINTERFACE_CONNECT_PASSWORD_MAX_LEN;
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_AUTH_PASS_STR_LEN_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_AUTH_PASS_STR_LEN_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_AUTH_PASS_STR_LEN_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
                            
          MQTTClientConfigData.Config.Connect.ValuesSet.Password := FALSE;
          
        end_if;
        
      end_if;
      
      Config.ConfigObject.State := CO_Will;
    
    //----------------------------
    //Will Config
    //----------------------------
    CO_Will:
    
      //Call the Config Method
      WillConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.Will();
      
      //Check if the config has been made
      if WillConfig.topic <> ACCESS_DENIED then
        
        //If the input is OK, set the parameters
        if WillConfig.topic                                                                   &
           SigCLib.StrLen16(str0:=WillConfig.topic) < MQTTCLIENTINTERFACE_WILL_TOPIC_MAX_LEN  then
          
          SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.Will.aTopic[0], 
                          c     :=  0x00, 
                          len   :=  sizeof(MQTTClientConfigData.Config.Will.aTopic));
          SigCLib.StrCpy16( dst0  :=  #MQTTClientConfigData.Config.Will.aTopic[0], 
                            src0  :=  WillConfig.topic);
          
          MQTTClientConfigData.Config.Will.ValuesSet.Topic := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := MQTTCLIENTINTERFACE_WILL_TOPIC_MAX_LEN;
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_TOPIC_STR_LEN_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_TOPIC_STR_LEN_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_TOPIC_STR_LEN_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //If the input is OK, set the parameters
        if WillConfig.payloadtext                                                                  &
           SigCLib.StrLen(str:=WillConfig.payloadtext) < MQTTCLIENTINTERFACE_WILL_PAYLOAD_MAX_LEN  then
          
          SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.Will.aPayload[0], 
                          c     :=  0x00, 
                          len   :=  sizeof(MQTTClientConfigData.Config.Will.aPayload));
          SigCLib.StrCpy( dst0  :=  #MQTTClientConfigData.Config.Will.aPayload[0], 
                          src0  :=  WillConfig.payloadtext);
          
          MQTTClientConfigData.Config.Will.ValuesSet.Payload := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := MQTTCLIENTINTERFACE_WILL_PAYLOAD_MAX_LEN;
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_PAYLOAD_STR_LEN_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_PAYLOAD_STR_LEN_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_PAYLOAD_STR_LEN_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //If the input is OK, set the parameters
        if WillConfig.qos >= MQTT_PROT_QOS_MIN  &
           WillConfig.qos <= MQTT_PROT_QOS_MAX  then
          
          MQTTClientConfigData.Config.Will.iQoS := WillConfig.qos;
          MQTTClientConfigData.Config.Will.ValuesSet.QoS := TRUE;
        
        //Input Not OK, Log
        else
          
          tmpPara1 := to_dint(WillConfig.qos);
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_QOS_INVALID_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_QOS_INVALID_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_WILL_QOS_INVALID_TEXT, 
                            pPara1    :=  #tmpPara1, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //Retain has an exclusive state choice.
        MQTTClientConfigData.Config.Will.bRetain := WillConfig.bRetain;
        MQTTClientConfigData.Config.Will.ValuesSet.RetainWill := TRUE;
        
      end_if;
      
      Config.ConfigObject.State := CO_Reconnection;
      
    //----------------------------
    //Reconnection Parameters
    //----------------------------
    CO_Reconnection:
    
      //Call the Config Method
      ReconnectionConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.ReconnectionParameters();
      
      //Check if the config has been made
      if ReconnectionConfig.min_interval <> -1 then
        
        //If the input is OK, set the parameters
        if ReconnectionConfig.min_interval >= 0                               &
           ReconnectionConfig.min_interval < ReconnectionConfig.max_interval  then
          
          MQTTClientConfigData.Config.Reconnect.iMinInterval          := ReconnectionConfig.min_interval;
          MQTTClientConfigData.Config.Reconnect.ValuesSet.MinInterval := TRUE;
        
        //Input Not OK, Log
        else
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_RECONN_MIN_TIME_INVALID_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_RECONN_MIN_TIME_INVALID_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_RECONN_MIN_TIME_INVALID_TEXT, 
                            pPara1    :=  NIL, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //If the input is OK, set the parameters
        if ReconnectionConfig.max_interval >= 0                               &
           ReconnectionConfig.max_interval > ReconnectionConfig.min_interval  then
          
          MQTTClientConfigData.Config.Reconnect.iMaxInterval := ReconnectionConfig.max_interval;
          MQTTClientConfigData.Config.Reconnect.ValuesSet.MaxInterval := TRUE;
        
        //Input Not OK, Log
        else
          
          Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                            dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_RECONN_MAX_TIME_INVALID_GRP, 
                            dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_RECONN_MAX_TIME_INVALID_MSG, 
                            pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_RECONN_MAX_TIME_INVALID_TEXT, 
                            pPara1    :=  NIL, 
                            pPara2    :=  NIL, 
                            pPara3    :=  NIL, 
                            pPara4    :=  NIL);
          
        end_if;
        
        //Scale has an exclusive state choice.
        MQTTClientConfigData.Config.Reconnect.bExponential                := ReconnectionConfig.exponential_scale;
        MQTTClientConfigData.Config.Reconnect.ValuesSet.ExponentialScale  := TRUE;
        
      end_if;
      
      Config.ConfigObject.State := CO_TLS;
      
    //----------------------------
    //TLS Config
    //----------------------------
    CO_TLS:
      
      //Call the Config Method
      TLSConfig := Config.ConfigObject.pThis$^MQTTClient_Interface_ConfigBase^.TLS();
      
      //Check if the config has been made
      if TLSConfig.cafile <> ACCESS_DENIED then
        
        //Se the TLS ValuesSet Flag
        MQTTClientConfigData.Config.TLS.ValuesSet.TLS := TRUE;
        
        //If the input is OK, set the parameters
        if TLSConfig.cafile then
           
          if SigCLib.StrLen(str:=TLSConfig.cafile) < MQTTCLIENTINTERFACE_TLS_CAFILE_MAX_LEN  then
          
            SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.TLS.aCAFile[0], 
                            c     :=  0x00, 
                            len   :=  sizeof(MQTTClientConfigData.Config.TLS.aCAFile));
            SigCLib.StrCpy( dst0   :=  #MQTTClientConfigData.Config.TLS.aCAFile[0], 
                            src0   :=  TLSConfig.cafile);
            
            MQTTClientConfigData.Config.TLS.ValuesSet.CAFile := TRUE;
          
          //Input Not OK, Log
          else
          
            tmpPara1 := MQTTCLIENTINTERFACE_TLS_CAFILE_MAX_LEN;
            
            Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                              dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_CAFILE_STR_LEN_GRP, 
                              dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_CAFILE_STR_LEN_MSG, 
                              pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_CAFILE_STR_LEN_TEXT, 
                              pPara1    :=  #tmpPara1, 
                              pPara2    :=  NIL, 
                              pPara3    :=  NIL, 
                              pPara4    :=  NIL);
            
          end_if;
        
        end_if;
        
        //If the input is OK, set the parameters
        if TLSConfig.certfile then
           
          if SigCLib.StrLen(str:=TLSConfig.certfile) < MQTTCLIENTINTERFACE_TLS_CERTFILE_MAX_LEN then
          
            SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.TLS.aCertFile[0], 
                            c     :=  0x00, 
                            len   :=  sizeof(MQTTClientConfigData.Config.TLS.aCertFile));
            SigCLib.StrCpy( dst0   :=  #MQTTClientConfigData.Config.TLS.aCertFile[0], 
                            src0   :=  TLSConfig.certfile);
            
            MQTTClientConfigData.Config.TLS.ValuesSet.CertFile := TRUE;
          
          //Input Not OK, Log
          else
          
            tmpPara1 := MQTTCLIENTINTERFACE_TLS_CERTFILE_MAX_LEN;
            
            Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                              dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_CERTFILE_STR_LEN_GRP, 
                              dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_CERTFILE_STR_LEN_MSG, 
                              pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_CERTFILE_STR_LEN_TEXT, 
                              pPara1    :=  #tmpPara1, 
                              pPara2    :=  NIL, 
                              pPara3    :=  NIL, 
                              pPara4    :=  NIL);
            
          end_if;
        
        end_if;
        
        //If the input is OK, set the parameters
        if TLSConfig.keyfile then
           
          if SigCLib.StrLen(str:=TLSConfig.keyfile) < MQTTCLIENTINTERFACE_TLS_KEYFILE_MAX_LEN then
          
            SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.TLS.aKeyFile[0], 
                            c     :=  0x00, 
                            len   :=  sizeof(MQTTClientConfigData.Config.TLS.aKeyFile));
            SigCLib.StrCpy(dst0    :=  #MQTTClientConfigData.Config.TLS.aKeyFile[0], 
                           src0    :=  TLSConfig.keyfile);
            
            MQTTClientConfigData.Config.TLS.ValuesSet.KeyFile := TRUE;
          
          //Input Not OK, Log
          else
          
            tmpPara1 := MQTTCLIENTINTERFACE_TLS_KEYFILE_MAX_LEN;
            
            Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                              dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_KEYFILE_STR_LEN_GRP, 
                              dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_KEYFILE_STR_LEN_MSG, 
                              pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_KEYFILE_STR_LEN_TEXT, 
                              pPara1    :=  #tmpPara1, 
                              pPara2    :=  NIL, 
                              pPara3    :=  NIL, 
                              pPara4    :=  NIL);
            
          end_if;
        
        end_if;
        
        //If the input is OK, set the parameters
        if TLSConfig.pw then
           
          if SigCLib.StrLen(str:=TLSConfig.pw) < MQTTCLIENTINTERFACE_TLS_PASSWORD_MAX_LEN then
          
            SigCLib.MemSet( dst   :=  #MQTTClientConfigData.Config.TLS.aPassword[0], 
                            c     :=  0x00, 
                            len   :=  sizeof(MQTTClientConfigData.Config.TLS.aPassword));
            SigCLib.StrCpy( dst0   :=  #MQTTClientConfigData.Config.TLS.aPassword[0], 
                            src0   :=  TLSConfig.pw);
            
            MQTTClientConfigData.Config.TLS.ValuesSet.Password := TRUE;
          
          //Input Not OK, Log
          else
          
            tmpPara1 := MQTTCLIENTINTERFACE_TLS_PASSWORD_MAX_LEN;
            
            Logging_InterfLog(usLevel   :=  MQTTCLIENTINTERFACE_LOGGING_LEVEL_ERR, 
                              dMsgGroup :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_PASS_STR_LEN_GRP, 
                              dMsgNbr   :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_PASS_STR_LEN_MSG, 
                              pMsg      :=  MQCLIINF_LOG_ERROR_CONFIG_OBJ_TLS_PASS_STR_LEN_TEXT, 
                              pPara1    :=  #tmpPara1, 
                              pPara2    :=  NIL, 
                              pPara3    :=  NIL, 
                              pPara4    :=  NIL);
            
          end_if;
        
        end_if;
        
      end_if;
      
      Config.ConfigObject.State := CO_ClientID;
      eRet := TR_Done;
      
  end_case;

  
END_FUNCTION

FUNCTION GLOBAL MQTTClient_Interface::Config_Login
	VAR_INPUT
		pThis 	: ^void;
	END_VAR
	VAR_OUTPUT
		bOK 	: BOOL;
	END_VAR
  
  //If the pointer is not OK, stop
  if pThis = NIL then
    bOK := FALSE;
    return;
  end_if;

  //If the Login has been set before, fail, else accept
  if Config.ConfigObject.pThis then
    bOK := FALSE;
  else
    bOK := TRUE;
    Config.ConfigObject.pThis := pThis;
  end_if;

  
END_FUNCTION

FUNCTION MQTTClient_Interface::Diagnostic_ReadErrors
  VAR
  	udErr : UDINT;
    pErrStr : ^CHAR;
  END_VAR

  
  //If a sufficient amount of time has passed, check for errors
  if ops.tAbsolute - DiagnosticData.udLastErrorCheck >= MQTTCLIENTINTERFACE_DIAGNOSTIC_ERROR_CHECK_INTERVAL then
    
    //Update timestamp
    DiagnosticData.udLastErrorCheck := ops.tAbsolute;
    
    //If SSL is activated, check the interface for errors
    if MQTTClientConfigData.Config.TLS.ValuesSet.TLS then
      
      udErr := OpenSSL.ERR_get_error();
      
      if udErr <> 0 then
                
        pErrStr := OpenSSL.ERR_error_string(e   :=  udErr, 
                                            buf :=  NIL);
        
        if pErrStr then
          
          Logging_InterfLog(usLevel     :=  MQTT_LOG_ERR, 
                            dMsgGroup   :=  MQTTCLIENT_INTERFACE_LOG_ERROR_OPENSSL_MSGGROUP, 
                            dMsgNbr     :=  to_dint(udErr), 
                            pMsg        :=  pErrStr, 
                            pPara1      :=  NIL, 
                            pPara2      :=  NIL, 
                            pPara3      :=  NIL, 
                            pPara4      :=  NIL);
          
        end_if;

        
      end_if;

      
    end_if;

    
  end_if;

  
END_FUNCTION


FUNCTION GLOBAL MQTTClient_Interface::Config_SetParameter
	VAR_INPUT
		Parameter 	: t_e_ConfigParameters;
		Value 	: DINT;
	END_VAR
	VAR_OUTPUT
		retCode 	: INT;
	END_VAR
  
  //Assume OK
  retCode := 0;
  
  //===============================================================
  //Based on the selected Parameter, attempt to change the setting
  //===============================================================
  case Parameter of
  
    //-------------------------------------------
    //Sets whether the DataMap publishes OnChange
    //values when added or waits for first change
    //-------------------------------------------
  	t_e_ConfigParameters::CP_DataMap_SendOnAdd:
    
      //Valid
      if Value = 0 | Value = 1 then
        
        if Config.pDataMapConfig <> NIL then
          Config.pDataMapConfig^.Config.bSendOnAdd := (Value = 1);
        end_if;
        
      //Invalid
      else
        
        retCode := MQTTClient::MQTT_ERR_INVAL;
        
      end_if;
    
  end_case;
  
END_FUNCTION
