//This file was generated by the LASAL2 CodeGenerator  -- 
//Please, do not edit this file (it might be overwritten by the next generator run)
//{{LSL_DECLARATION

(*!
<Class
	Name               = "MainHardwareCntrl"
	Revision           = "0.0"
	GUID               = "{7DABEAA7-EA7F-479C-860F-43821CC3B15F}"
	RealtimeTask       = "false"
	CyclicTask         = "true"
	BackgroundTask     = "false"
	Sigmatek           = "false"
	OSInterface        = "false"
	HighPriority       = "false"
	Automatic          = "false"
	UpdateMode         = "Prescan"
	SharedCommandTable = "true"
	Objectsize         = "(810,180)">
	<Channels>
		<Server Name="HardwareControl" GUID="{4758B78B-6525-410A-BF81-C052271CDB1A}" Visualized="false" Initialize="false" WriteProtected="false" Retentive="false"/>
	</Channels>
	<Network Name="MainHardwareCntrl">
		<!-- List of Components in this network -->
		<Components>
			<Object
				Name       = "_base"
				GUID       = "{2A4A34C4-FC23-4BB6-A1D5-6EF16A2D4074}"
				Class      = "LinkedListControlBase"
				Position   = "(218,120)"
				Visualized = "false">
				<Channels>
					<Server Name="HardwareInterfaces"/>
					<Server Name="ToObject"/>
					<Client Name="op_LogData"/>
					<Client Name="p_FirstObject"/>
				</Channels>
			</Object>
		</Components>
		<Comments>
		</Comments>
		<!-- List of Connections in this network -->
		<Connections>
			<Connection Source="this.ToObject" Destination="_base.ToObject" Vertices="(1216,210),(1044,210),"/>
			<Connection Source="this.HardwareInterfaces" Destination="_base.HardwareInterfaces" Vertices="(1216,270),(1044,270),"/>
			<Connection Source="_base.p_FirstObject" Destination="this.p_FirstObject" Vertices="(218,270),(90,270),(38,270),"/>
			<Connection Source="_base.op_LogData" Destination="this.op_LogData" Vertices="(218,210),(38,210),"/>
		</Connections>
		<!-- Headerfiles -->
		<Options>
		</Options>
	</Network>
</Class>
*)
#pragma using LinkedListControlBase

MainHardwareCntrl : CLASS
: LinkedListControlBase
	TYPE
	  tAuxMainStatus : BDINT  //! <Type Public="true" Name="tAuxMainStatus"/>
	  [
	    1 Configuration_loaded,
	    2 bit2,
	    3 AuxReady,
	    4 AgvOnpostion,
	    5 Bit5,
	    6 Bit6,
	    7 Bit7,
	    8 Bit8,
	    9 RestartRequest,
	    10 Bit10,
	    11 Bit11,
	    12 Bit12,
	    13 Bit13,
	    14 Bit14,
	    15 Bit15,
	    16 Bit16,
	    17 Bit17,
	    18 Bit18,
	    19 Bit19,
	    20 Bit20,
	    21 Bit21,
	    22 Bit22,
	    23 Bit23,
	    24 Bit24,
	    25 Bit25,
	    26 Bit26,
	    27 Bit27,
	    28 Bit28,
	    29 Bit29,
	    30 Bit30,
	    31 AuxError,
	    32 CmdError,
	  ];
	  tAuxStateHandeling :
	  (
	    StartState,
	    Runstate,
	    CleanupState,
	    ExitState
	  )$UDINT;
	END_TYPE
  //Servers:
	HardwareControl 	: SvrCh_gt_AgvMainHardware;
  //Clients:
  //Variables:
		ReqAuxMainControl 	: gt_AgvMainHardware;
		ActualState 	: gt_AgvHandleState;
		CurAuxMainControl 	: gt_AgvMainHardware;
  //Functions:
	
	FUNCTION VIRTUAL GLOBAL Init;
	
	FUNCTION VIRTUAL GLOBAL CyWork
		VAR_INPUT
			EAX 	: UDINT;
		END_VAR
		VAR_OUTPUT
			state (EAX) 	: UDINT := READY;
		END_VAR;
	
	FUNCTION HandleMainConfiguration;
	
	FUNCTION HandleMainSettings;
	
	FUNCTION HandleMainStartUp;
	
	FUNCTION HandleMainOperational;
	
	FUNCTION GLOBAL HandleMainState
		VAR_OUTPUT
			RetValue 	: BOOL;
		END_VAR;
	
	FUNCTION ProcessMainError
		VAR_INPUT
			ErrorNumber 	: UDINT;
		END_VAR;
	
	FUNCTION MainHardwareLoop;
	
	FUNCTION GetMainError
		VAR_OUTPUT
			Retvalue 	: BOOL;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HardwareControl::Read
		VAR_OUTPUT
			output (EAX) 	: gt_AgvMainHardware;
		END_VAR;
	
	FUNCTION VIRTUAL GLOBAL HardwareControl::Write
		VAR_INPUT
			input (EAX) 	: gt_AgvMainHardware;
		END_VAR
		VAR_OUTPUT
			result (EAX) 	: gt_AgvMainHardware;
		END_VAR;
  //Tables:
	FUNCTION @STD
		VAR_OUTPUT
			ret_code	: CONFSTATES;
		END_VAR;
	FUNCTION GLOBAL TAB @CT_;
END_CLASS;

//}}LSL_DECLARATION


FUNCTION GLOBAL TAB MainHardwareCntrl::@CT_
0$UINT,
2#0100000000000010$UINT, //TY_MAINHARDWARECNTRL
0$UINT, 0$UINT, (SIZEOF(::MainHardwareCntrl))$UINT, 
1$UINT, 0$UINT, 0$UINT, 
TO_UDINT(728813614), "MainHardwareCntrl", //Class
TO_UDINT(2398870984), "LinkedListControlBase", 0$UINT, 11$UINT, //Baseclass
//Servers:
(::MainHardwareCntrl.HardwareControl.pMeth)$UINT, _CH_SVR$UINT, 2#0000000000000000$UINT, TO_UDINT(108175424), "HardwareControl", 
//Clients:
END_FUNCTION


#define USER_CNT_MainHardwareCntrl 12

TYPE
	_LSL_STD_VMETH	: STRUCT
			CmdTable	: CMDMETH;
			UserFcts	: ARRAY[0..USER_CNT_MainHardwareCntrl] OF ^Void;
	END_STRUCT;
END_TYPE

FUNCTION MainHardwareCntrl::@STD
	VAR_OUTPUT
		ret_code	: CONFSTATES;
	END_VAR
	VAR
		vmt	: _LSL_STD_VMETH;
		nCmdSize	: UINT;
	END_VAR

	ret_code	:= LinkedListControlBase::@STD();
	IF ret_code <> C_OK THEN
		RETURN;
	END_IF;
	nCmdSize		:= WewoBase::ToObject.pMeth^.nCmds$UINT*SIZEOF(pVoid) + CMDMETH.Init;

	_memcpy((#vmt.CmdTable)$^USINT, WewoBase::ToObject.pMeth, nCmdSize);
	vmt.CmdTable.nCmds		:= nSTDCMD + USER_CNT_MainHardwareCntrl;
	vmt.CmdTable.Init		:= #Init();
	vmt.CmdTable.CyWork		:= #CyWork();
	WewoBase::ToObject.pMeth		:= StoreCmd (pCmd := #vmt.CmdTable, SHARED);

	IF WewoBase::ToObject.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;
	HardwareControl.pMeth			:= StoreMethod( #HardwareControl::Read(), #HardwareControl::Write() );
	IF HardwareControl.pMeth THEN
		ret_code	:= C_OK;
	ELSE
		ret_code	:= C_OUTOF_NEAR;
		RETURN;
	END_IF;

END_FUNCTION

//{{LSL_IMPLEMENTATION
#pragma using LinkedObjectBase
#pragma using AuxBase

FUNCTION VIRTUAL GLOBAL MainHardwareCntrl::Init

   LinkedListControlBase::Init();
   p_FirstObject:=p_FirstObject.Read();
   
    
   if (initCnt >= 12) then
    
  end_if;

END_FUNCTION

FUNCTION VIRTUAL GLOBAL MainHardwareCntrl::CyWork
	VAR_INPUT
		EAX 	: UDINT;
	END_VAR
	VAR_OUTPUT
		state (EAX) 	: UDINT;(* := READY *)
	END_VAR
    
    
    MainHardwareLoop();
    
  
END_FUNCTION




FUNCTION VIRTUAL GLOBAL MainHardwareCntrl::HardwareControl::Write
	VAR_INPUT
		input (EAX) 	: gt_AgvMainHardware;
	END_VAR
	VAR_OUTPUT
		result (EAX) 	: gt_AgvMainHardware;
	END_VAR

	HardwareControl := input;
    ReqAuxMainControl := HardwareControl;
	result := HardwareControl;

END_FUNCTION


FUNCTION VIRTUAL GLOBAL MainHardwareCntrl::HardwareControl::Read
	VAR_OUTPUT
		output (EAX) 	: gt_AgvMainHardware;
	END_VAR

	output := HardwareControl;

END_FUNCTION


FUNCTION GLOBAL MainHardwareCntrl::HandleMainState
	VAR_OUTPUT
		RetValue 	: BOOL;
	END_VAR
 VAR
  	    p_object          : pVoid;             // pointer to AuxBase
        ReadyCounter : dint;
        Objcounter      : dint;
    END_VAR
    
    ReadyCounter := 0;
    objcounter      := 0;
    p_object          := GetFirstObject();
    
    while (p_object <> NIL) do
        Objcounter +=1 ;
        // pre action
        case ActualState of
            gt_AgvHandleState::HandleOperational:
                if  p_object^$AuxBase.configStatus() = 1 then
                    p_object^$AuxBase.HandleOperational();
                else
                    p_object^$AuxBase.HandleDisabled(); 
                end_if;
                
            gt_AgvHandleState::HandleStartUp:
               if p_object^$AuxBase.HandleStartUp() = true then
                    ReadyCounter += 1;
                end_if;
        
            gt_AgvHandleState::HandleConfiguration:
               if  p_object^$AuxBase.Handleconfiguration() = true then
                    ReadyCounter += 1;
                end_if;

         end_case;   
     
        // Post action
     
       ProcessMainError(p_object^$AuxBase.GetActuelErrorWarning());
        
     p_object := p_object^$AuxBase.GetNextObjectPtr();
  end_while;
 
 if objcounter = Readycounter then
    RetValue := true;
    else
    RetValue := false;
  end_if;
 
END_FUNCTION


FUNCTION MainHardwareCntrl::ProcessMainError
	VAR_INPUT
		ErrorNumber 	: UDINT;
	END_VAR

END_FUNCTION


FUNCTION MainHardwareCntrl::MainHardwareLoop
  // Check if step change is posible.
   
    if (ReqAuxMainControl <> CurAuxMainControl)  then
      CurAuxMainControl := ReqAuxMainControl;    
    end_if;
    
    
    Case CurAuxMainControl of
        
       gt_AgvMainHardware::HardwareConfig:
            ActualState := HandleConfiguration;
            if  HandleMainState() = true then
                if GetMainError() = false then
                    HardwareControl := HardwareIdle;
                    else
                    HardwareControl := HardwareError;
                end_if;
            end_if;
        
       gt_AgvMainHardware::HardwareStartup:
            ActualState :=HandleStartUp;
             if  HandleMainState() = true then
                if GetMainError() = false then
                    HardwareControl := HardwareIdle;
                    else
                    HardwareControl := HardwareError;
                end_if;
            end_if;
        
        HardwareOperational:
            ActualState := HandleOperational;
            HandleMainState();
        
        HardwareIdle:
        
        
        HardwareError:
        
        
        
    end_case;

   
    
   
END_FUNCTION


FUNCTION MainHardwareCntrl::GetMainError
	VAR_OUTPUT
		Retvalue 	: BOOL;
	END_VAR
    
    Retvalue := false;

END_FUNCTION
